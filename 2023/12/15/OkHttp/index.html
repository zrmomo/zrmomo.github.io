<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>okhttp详解 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OkHttp创建12OkHttpClient:val client &#x3D; OkHttpClient.Builder().xxx.build()  创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。 示例12345678910111213141516171819202122232425异步：	   val client &#x3D; Ok">
<meta property="og:type" content="article">
<meta property="og:title" content="okhttp详解">
<meta property="og:url" content="https://zrmomo.github.io/2023/12/15/OkHttp/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="OkHttp创建12OkHttpClient:val client &#x3D; OkHttpClient.Builder().xxx.build()  创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。 示例12345678910111213141516171819202122232425异步：	   val client &#x3D; Ok">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2023-12-15T09:14:57.000Z">
<meta property="article:modified_time" content="2024-03-15T06:45:14.472Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2023/12/15/OkHttp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'okhttp详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-15 14:45:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">okhttp详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-15T09:14:57.000Z" title="发表于 2023-12-15 17:14:57">2023-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-15T06:45:14.472Z" title="更新于 2024-03-15 14:45:14">2024-03-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="okhttp详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient:</span><br><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().xxx.build()</span><br></pre></td></tr></table></figure>

<p>创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">异步：</span><br><span class="line">	   <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">       <span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">        LogCat.e( Thread.currentThread())</span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 这里还是在子线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">同步：</span><br><span class="line">		thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                loge(response)</span><br><span class="line">                <span class="comment">// 在这里处理同步响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>同步请求：</strong><ul>
<li><strong>同步请求是在当前线程上执行的。</strong>这意味着，如果在主线程上执行同步请求，它会阻塞主线程，直到请求完成。</li>
<li>同步请求通常用于后台线程或不涉及用户界面的操作，因为它们可能会导致应用界面冻结，用户体验差。</li>
<li>在同步请求中，您在代码中直接等待响应，只有在请求完成后才能继续执行后续代码。</li>
</ul>
</li>
<li><strong>异步请求：</strong><ul>
<li><strong>异步请求是在后台线程上执行的，不会阻塞当前线程。</strong>这允许在请求完成之前继续执行其他操作，包括更新用户界面。</li>
<li>异步请求通常用于与用户界面交互的操作，以确保用户界面保持响应性。</li>
<li>在异步请求中，通常提供一个回调函数，该回调函数将在请求完成时执行，允许处理响应数据。</li>
</ul>
</li>
</ol>
<h2 id="请求生成"><a href="#请求生成" class="headerlink" title="请求生成"></a>请求生成</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">client?.newCall(request)?.execute()</span><br><span class="line"></span><br><span class="line">#OkHttpClient::newCall:最终生成一个RealCall对象</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">#RealCall::execute()：开启同步请求</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">	<span class="comment">// 检查是否已经被执行</span></span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 将当前realcall加入到OkHttpClient的调度器中  因为是同步 不需要线程池开启子线程 所以直接return getResponseWithInterceptorChain()</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#Dispatcher::enqueue()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 call 是否为 WebSocket 请求</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">		<span class="comment">// 查找具有相同主机的已经存在的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 将符合条件的调用从readyAsyncCalls提升到runningAsyncCalls</span></span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 确保在多线程环境下，异步调用的执行数量不会超过预定的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#Dispatcher::promoteAndExecute():</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变列表用于存储将要执行的异步调用</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个标志变量用于表示是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 块，确保以下操作在互斥锁的保护下进行</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 readyAsyncCalls 队列的迭代器</span></span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 readyAsyncCalls 队列中的异步调用</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 runningAsyncCalls 中的异步调用数已经达到了最大请求数（maxRequests），则停止添加新的异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 asyncCall.callsPerHost（每个主机的并发请求数）已经达到了最大请求数（maxRequestsPerHost），则继续下一个异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 readyAsyncCalls 队列中移除该异步调用</span></span><br><span class="line">            i.remove()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加该异步调用所在主机的并发请求数</span></span><br><span class="line">            asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 executableCalls 列表中，准备执行</span></span><br><span class="line">            executableCalls.add(asyncCall)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 runningAsyncCalls 列表中，表示正在执行</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有异步调用正在执行，更新 isRunning 变量</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 executableCalls 列表，执行每个异步调用</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">			<span class="comment">// 这里开启了线程池调用</span></span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealCall::AsyncCall:: executeOn()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span> <span class="comment">// 用于跟踪执行是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用传入的 executorService 来执行当前异步调用（实际上是执行该异步任务）</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果执行成功，设置 success 为 true</span></span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="comment">// 如果执行被拒绝，创建一个 InterruptedIOException 异常，并将原始异常作为其原因</span></span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 noMoreExchanges 方法，通知没有更多的交换操作，同时调用 responseCallback 的 onFailure 方法传递异常</span></span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：无论执行是否成功，都会执行的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 如果执行不成功，调用 client.dispatcher.finished(this) 来表示该调用不再运行</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncCall::<span class="keyword">class</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AsyncCall继承了Runnable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 给当前线程命名，通常用于日志记录和调试</span></span><br><span class="line">    threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span> <span class="comment">// 用于标记回调是否已经触发</span></span><br><span class="line">        timeout.enter() <span class="comment">// 进入超时状态，启动计时器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 getResponseWithInterceptorChain() 获取响应对象</span></span><br><span class="line">            <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记回调已经触发</span></span><br><span class="line">            signalledCallback = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 responseCallback 的 onResponse() 方法，将响应传递给回调函数</span></span><br><span class="line">            responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 不要触发回调两次！如果回调已经触发，记录日志</span></span><br><span class="line">                Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 responseCallback 的 onFailure() 方法，将异常传递给回调函数</span></span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">            cancel() <span class="comment">// 取消当前调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 如果回调尚未触发，创建一个异常，将其作为取消原因传递给回调函数</span></span><br><span class="line">                <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">                canceledException.addSuppressed(t)</span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抛出异常以终止线程</span></span><br><span class="line">            <span class="keyword">throw</span> t</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何，都要通知客户端调度程序当前调用已完成</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器的通过责任链模式挨个执行每个拦截器的任务，最后将请求的response返回给最上层</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最后的具体网络请求实现还是得看 getResponseWithInterceptorChain()</span></span><br><span class="line"></span><br><span class="line">RealCall:: getResponseWithInterceptorChain()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 构建拦截器链，创建一个拦截器列表</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加用户自定义的普通拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 重试、重定向拦截器</span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</span></span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 读取、写入缓存的拦截器</span></span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 与服务器建立连接的拦截器</span></span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 WebSocket 请求，添加用户自定义的网络拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最终真正执行网络请求的拦截器</span></span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有拦截器合并为链，并调用其proceed()开始处理本次请求</span></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用拦截器链的 proceed 方法，处理请求并获取响应</span></span><br><span class="line">				<span class="comment">// 主要还是得看这个方法</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求被取消，关闭响应并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 捕获 IOException 异常，标记已经调用 noMoreExchanges 方法，并重新抛出异常</span></span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：如果没有调用过 noMoreExchanges 方法，则调用它来释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealInterceptorChain:: proceed()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 检查当前拦截器索引是否小于拦截器列表的大小</span></span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加调用计数</span></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查新请求的 URL 是否与当前请求的 URL 主机和端口相同</span></span><br><span class="line">        check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器链中的下一个拦截器</span></span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">		<span class="comment">// 获取当前index的拦截器对象</span></span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器的 intercept 方法，获取响应对象，如果为 null，则抛出异常</span></span><br><span class="line">		<span class="comment">// 这里的intercept方法传入的是下一个拦截器，</span></span><br><span class="line">		<span class="comment">// 在当中回调用下一个拦截器的proceed方法response = realChain.proceed(request)</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查下一个拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应对象是否有响应体</span></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>对OKHttp有了解吗，拦截器这一块有了解吗？</li>
<li>有没有用到过，或则自定义拦截器，怎么用的</li>
<li>拦截器一定会被执行吗</li>
<li>责任链模式和策略模式有什么区别</li>
</ol>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/RetryAndFollowUpInterceptor%EF%BC%9A%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%20d608e513720d4f7e85d2a65cb9df191a.md"><strong>RetryAndFollowUpInterceptor：</strong>重试、重定向拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/BridgeInterceptor%EF%BC%9A%E5%B0%86%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%94%A8%E6%88%B7%E5%93%8D%E5%BA%94%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20536849dff4944c349e970fdc8ae1619b.md">BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%209e0ba47ba1524aafb889cf0008e1b86e.md">CacheInterceptor：读取、写入缓存的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/ConnectInterceptor%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20bd971853d1ed4038ba3426d485bf6af5.md">ConnectInterceptor 建立连接的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CallServerInterceptor%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20b4e0c43b2b424fa686714b168d39b7e1.md"><strong>CallServerInterceptor：</strong>最终真正执行网络请求的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%20a209e906006a4e67a7e39c2b1bebec7b.md">自定义拦截器</a></p>
<h2 id="RetryAndFollowUpInterceptor：重试、重定向拦截器"><a href="#RetryAndFollowUpInterceptor：重试、重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor：重试、重定向拦截器"></a>RetryAndFollowUpInterceptor：重试、重定向拦截器</h2><p>重定向:</p>
<p>重定向简单理解则是客户端请求服务端时，服务端让客户端请求别的网站，服务端会在响应中添加新的请求地址，客户端去请求这个新的地址。</p>
<p>问题一：重试的判断条件</p>
<p>问题二：怎么主动控制禁止网络请求重试</p>
<p>问题三：循环重试会不会走入死循环</p>
<p>问题四：重定向怎么实现的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 将传入的 Interceptor.Chain 强制转换为 RealInterceptorChain</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request <span class="comment">// 获取请求</span></span><br><span class="line">    <span class="keyword">val</span> call = realChain.call <span class="comment">// 获取调用</span></span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span> <span class="comment">// 跟随请求计数</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span> <span class="comment">// 之前的响应</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span> <span class="comment">// 是否是新的交换</span></span><br><span class="line">    <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;() <span class="comment">// 已恢复的失败列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 创建ExchangeFinder，此类用于创建和寻找Exchange，Exchange主要处理此次请求中的IO的连接管理和事件请，会在后续的拦截器中进行分析</span></span><br><span class="line">        call.enterNetworkInterceptorExchange(request, newExchangeFinder) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response: Response</span><br><span class="line">        <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 此处调用下一个拦截器获取respnse</span></span><br><span class="line">				<span class="comment">// 将Request交给给下个节点，此处的下个节点为BridgeInterceptor，若下层节点处理过程中扔出错误会被下面的catch捕获</span></span><br><span class="line">                response = realChain.proceed(request) </span><br><span class="line">                newExchangeFinder = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">                <span class="comment">// 尝试通过路由连接失败，请求尚未发送</span></span><br><span class="line">			   <span class="comment">// 重点方法，决定能否重试的关键方法，此方法返回为true才可重试，看重试小节中的分析</span></span><br><span class="line">                <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">                <span class="comment">// 通过recover方法检测路由异常是否能重新连接</span></span><br><span class="line">                <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e.firstConnectException</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 走到这里，则一定拿到了服务器的响应</span></span><br><span class="line">		   <span class="comment">// 若循环中的代码完整执行过，则priorResponse不为空，也就意味着需要重定向（不太严谨的说法），类似链表的结构保存下来整个响应路径</span></span><br><span class="line">            <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">					          response = response.newBuilder()</span><br><span class="line">								              .priorResponse(priorResponse.newBuilder()</span><br><span class="line">						                  .body(<span class="literal">null</span>)</span><br><span class="line">						                  .build())</span><br><span class="line">								              .build()</span><br><span class="line">				        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exchange为Exchange类，主要处理此次网络连接的IO操作</span></span><br><span class="line">            <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">            <span class="comment">// 处理重定向的重点方法，此方法会根据返回的response和连接管理器判断是否需要重定向，看下重定向小节</span></span><br><span class="line">            <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">                    call.timeoutEarlyExit()</span><br><span class="line">                &#125;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 没有跟随请求，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">            <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 跟随请求有请求体，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.body?.closeQuietly() <span class="comment">// 关闭响应体</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp <span class="comment">// 使用跟随请求作为新的请求</span></span><br><span class="line">            priorResponse = response</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题一：</p>
<p>首先确认代码体主要是一个while true 死循环，然后看下面这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果recover返回了false 则直接抛出异常 中断了重试</span></span><br><span class="line"><span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">          <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recoveredFailures += e.firstConnectException</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>出现异常的大部分情况都会返回false  从而抛出异常，如果命中了可以重试的异常则会走continue 停止当前循环开启下一次循环从而开启下一次的请求。</p>
<p>然后看看recover的具体实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">	**RetryAndFollowUpInterceptor::**recover()</span><br><span class="line"><span class="comment">// 定义一个名为recover的私有函数，用于处理异常情况并决定是否需要进行错误恢复。</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    e: <span class="type">IOException</span>,                 <span class="comment">// 传入的异常对象，通常是与网络请求相关的IOException。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">RealCall</span>,                 <span class="comment">// RealCall对象，用于执行HTTP请求的实际调用。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    userRequest: <span class="type">Request</span>,           <span class="comment">// 用户发起的请求对象。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    requestSendStarted: <span class="type">Boolean</span>     <span class="comment">// 标志位，表示请求是否已经开始发送。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 如果客户端配置禁止在连接失败时重试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经开始发送，并且该请求是一次性的（不能重新发送），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果异常是不可恢复的（例如，连接超时等），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有更多的路由可以尝试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于错误恢复，使用相同的路由选择器创建一个新的连接。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// 返回true表示需要进行错误恢复操作。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">**RetryAndFollowUpInterceptor::**requestIsOneShot</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestIsOneShot</span><span class="params">(e: <span class="type">IOException</span>, userRequest: <span class="type">Request</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBody = userRequest.body</span><br><span class="line">  <span class="keyword">return</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) ||  <span class="comment">//isOneShot()是需要程序员重写RequestBody的方法，不重写的情况下默认返回为false</span></span><br><span class="line">      e <span class="keyword">is</span> FileNotFoundException  <span class="comment">//若下层节点处理过程中抛出FileNotFoundException也不允许重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**RetryAndFollowUpInterceptor::**isRecoverable</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isRecoverable</span><span class="params">(e: <span class="type">IOException</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 协议异常则不许重试，举一个协议异常的例子，没有使用代理却返回响应码407需要代理验证，此类与协议规范冲突的错误大多数为ProtocolException</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 若产生中断异常，Socket超时或者在非IO异常（路由异常）时可能可以重试（requestSendStarted是catch中捕获的最初的异常决定的）</span></span><br><span class="line">    <span class="comment">// 若捕获异常为RouteException，requestSendStarted为false</span></span><br><span class="line">    <span class="comment">// 若捕获异常为IOException，且异常的具体类型为ConnectionShutdownException时，requestSendStarted也为false</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">is</span> SocketTimeoutException &amp;&amp; !requestSendStarted</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ssl握手异常，且具体错误属于是证书异常，则不允许重试，因为重试也肯定失败</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.cause <span class="keyword">is</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//证书校验失败 不匹配 也不允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="comment">// 翻译：如果产生连接代理出现问题，且是抛出IO异常，此时要返回true，尝试新的路由路线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上述中不可重试的情况，分为两种情况一种是<strong>程序员不希望重试</strong>一种是<strong>下层抛出异常</strong>。</p>
<p>问题二：</p>
<ul>
<li>配置<code>OkhttpClient</code>时设置<code>retryOnConnectionFailure</code>为<code>false</code>，所有请求将不可重试。</li>
<li>使用请求体请求时，<code>Body</code>继承自<code>RequestBody</code>并重写<code>isOneShot()</code>返回为<code>true</code>，可以做到过滤某些请求。</li>
</ul>
<p>问题三：</p>
<p>不会，首先重试的条件是苛刻的，绝大多数重试情况都只是网络波动，且在判断是否可重试时，有非常关键的一个条件，有没有可以重试的路线，一直重试必然会导致路线全部使用完，此时也一定会跳出循环。</p>
<p>问题四：</p>
<p>需要重定向说明之前的请求完成了然后需要再请求别的网址，看下面这段代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里将followup 赋值给了request 然后在下一个循环开启对应请求。		</span></span><br><span class="line">request = followUp</span><br><span class="line">priorResponse = response</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将之前的请求响应内容保存下来。 priorResponse是上次循环上面代码保存下来的</span></span><br><span class="line"><span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">		response = response.newBuilder()</span><br><span class="line">							.priorResponse(priorResponse.newBuilder()</span><br><span class="line">						  .body(<span class="literal">null</span>)</span><br><span class="line">						  .build())</span><br><span class="line">						.build()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"><a href="#BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器" class="headerlink" title="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"></a>BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取用户发起的请求</span></span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="comment">// 创建一个请求构建器，用于修改请求头信息</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求体</span></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取请求体的内容类型</span></span><br><span class="line">        <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Type字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体的内容长度</span></span><br><span class="line">        <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Length字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">            <span class="comment">// 移除Transfer-Encoding字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果内容长度为-1，设置Transfer-Encoding为chunked</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">            <span class="comment">// 移除Content-Length字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Host字段，添加Host字段，使用请求URL的主机名</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Connection字段，添加Connection字段为Keep-Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Accept-Encoding字段，并且没有Range字段，添加Accept-Encoding字段为gzip</span></span><br><span class="line">		<span class="comment">// Accept-Encoding用于提供客户端支持的压缩方式，与响应头的Content-Encoding对应</span></span><br><span class="line">    <span class="comment">// Range表示客户端想要此次请求资源的某一部分如：Range: bytes=0-50, 100-150，表示只要0-50和100-150字节两个部分</span></span><br><span class="line">    <span class="comment">// 若没有指定上述两个请求头属性，则压缩方式指定为gzip</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="literal">true</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CookieJar中加载Cookies，并添加到请求头中的Cookie字段</span></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有User-Agent字段，添加User-Agent字段为指定的userAgent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行网络请求，获取网络响应</span></span><br><span class="line">		<span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将网络响应的头部信息传递给CookieJar，以便处理和存储Cookies</span></span><br><span class="line">		cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个响应构建器，用于修改网络响应</span></span><br><span class="line">		<span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">	    .request(userRequest)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果需要进行透明的gzip解压缩，并且响应头中包含Content-Encoding字段为gzip，且响应允许有响应体</span></span><br><span class="line">		<span class="comment">// 若上述使用gzip，则需要进行解压</span></span><br><span class="line">    <span class="comment">// Content-Encoding代表此次响应体的编码</span></span><br><span class="line">		<span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">		    <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">		    networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="comment">// 获取网络响应体</span></span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个GzipSource，用于解压gzip压缩的响应体</span></span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="comment">// 移除响应头中的Content-Encoding和Content-Length字段</span></span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        <span class="comment">// 设置响应构建器的头部信息</span></span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="comment">// 获取响应体的Content-Type</span></span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置响应体为解压后的内容</span></span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回修改后的响应</span></span><br><span class="line">		<span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说这个拦截器并不复杂主要也就是封装请求头。重要的还是涉及计网的部分，这部分有关http的知识在<a target="_blank" rel="noopener" href="https://www.notion.so/bbcad4bff70d4beb8269b08602dd95e8?pvs=21">计网</a>查询。</p>
<h2 id="CacheInterceptor：读取、写入缓存的拦截器"><a href="#CacheInterceptor：读取、写入缓存的拦截器" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h2><h3 id="CacheInterceptor：读取、写入缓存的拦截器-1"><a href="#CacheInterceptor：读取、写入缓存的拦截器-1" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h3><p>先来个图总结cache的路径：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled.png" alt="Untitled"></p>
<p>主要看下面这个博客的内容。</p>
<p>总结下一些主要的东西：</p>
<ol>
<li>cache默认是null如果需要缓存需要在构建的时候添加。</li>
<li>走缓存还是走网络请求是通过<code>CacheStrategy</code> 类来判断的，判断公式为：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%2055.png" alt="Untitled 1"></p>
<p>具体代码体现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">      <span class="comment">// 若该请求没有对应的缓存响应，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若该请求为HTTPS请求，但是缓存响应中没有保存TLS握手相关信息，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过cacheResponse的响应码来判断响应是否允许被缓存，若不允许则忽略缓存响应，需要网络请求 </span></span><br><span class="line">      <span class="comment">// (其实参与判断的还有noStore指令的值) </span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CacheControl类：包含来自服务端或客户端的缓存指令，这些指令表明了什么响应可以被存储，</span></span><br><span class="line">      <span class="comment">// 这些存储的响应可以满足哪些需求。</span></span><br><span class="line">      <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">      <span class="comment">// noCache指令说明：noCache指令可以出现在请求、响应当中。若出现在响应的位置，它表明在发布</span></span><br><span class="line">      <span class="comment">// 缓存副本之前，必须向源服务器验证缓存的有效性；若出现在请求中，它表明不要使用一个缓存来回应</span></span><br><span class="line">      <span class="comment">// 该需求。  </span></span><br><span class="line">      <span class="comment">// hasConditions方法：若Request包含If-Modified-Since或If-None-Match其中一个Header，</span></span><br><span class="line">      <span class="comment">// 则该方法返回true。</span></span><br><span class="line">      <span class="comment">// 这里If语句的意思：若请求不允许使用缓存响应，或者请求头有If-Modified-Since/If-None-Match，  	  // 则忽略缓存响应，需要网络请求。(客户端发送的请求自己就带有If-Modified-Since或If-None-Match</span></span><br><span class="line">      <span class="comment">// ，缓存响应也是不会被使用的，OkHttp在下面的代码中是有为请求添加If-Modified-Since或</span></span><br><span class="line">      <span class="comment">// If-None-Match的Header的逻辑的) </span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">      <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果cacheResponse没有noCache指令(发布缓存前不用向源服务器验证)，并且cacheResponse</span></span><br><span class="line">      <span class="comment">// 仍然在存活时间内，则不需要进行网络请求，直接使用缓存响应  </span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加 If-None-Match/If-Modified-Since 的Header到请求头中，服务器通过验证这些Header，</span></span><br><span class="line">      <span class="comment">// 来判断客户端的缓存是否还有效，若缓存仍然有效，则返回304，响应中不会包含Response Body  </span></span><br><span class="line">      <span class="keyword">val</span> conditionName: String</span><br><span class="line">      <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">          conditionValue = etag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = lastModifiedString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = servedDateString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 If-None-Match/If-Modified-Since 的Header可以添加，则忽略缓存响应，需要网络请求   </span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在原来的Request上面添加包含If-None-Match/If-Modified-Since的Header  </span></span><br><span class="line">      <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="comment">// 返回一个包含网络请求和缓存响应的策略  </span></span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码总结看下面的博客。这段代码是真正控制缓存的关键。</p>
<ol>
<li>cache类的主要作用是在本地对<code>Response</code>进行<code>CRUD</code>（增删改查四种数据库操作）的操作。</li>
<li>CacheStrategy类具体判断networkRequest、cacheResponse是在computeCandidate方法实现的。具体看下面的博客。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/giagor/p/15706508.html">探索OkHttp系列 (四) 缓存机制 - Giagor - 博客园</a></p>
<p>首先这个缓存器只会缓存GET请求，其次如果需要缓存的话需要在构建Request的时候添加cache</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient.Builder().cache(Cache(File(<span class="keyword">this</span>.externalCacheDir, <span class="string">&quot;okhttpcache&quot;</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)).build()</span><br><span class="line"><span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">object</span> : Callback)</span><br></pre></td></tr></table></figure>

<p>其次在Request的构造中有一个cacheControl方法这个方法会传入<code>CacheControl</code> 类，这个类可以在request中定制缓存策略。在Cache的官方头注释中有对这个类各种策略的使用示例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheControl = CacheControl.Builder()</span><br><span class="line">    .maxAge(<span class="number">1</span>, TimeUnit.HOURS) <span class="comment">// 缓存有效期为1小时</span></span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://example.com/api/data&quot;</span>)</span><br><span class="line">    .cacheControl(cacheControl)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Cache类解析</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">  directory: File,</span><br><span class="line">  maxSize: <span class="built_in">Long</span>,</span><br><span class="line">  fileSystem: FileSystem</span><br><span class="line">) : Closeable, Flushable &#123;</span><br><span class="line">	 <span class="comment">// 这里使用的是磁盘缓存</span></span><br><span class="line">  <span class="comment">// 缓存最最重要的属性，看名字也知道缓存策略为硬盘LRU缓存，下述分析DiskLruCache</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cache = DiskLruCache(</span><br><span class="line">        fileSystem = fileSystem,	      <span class="comment">// 主机的本地文件系统，内部使用OKIO实现IO操作</span></span><br><span class="line">        directory = directory,            <span class="comment">// 缓存目录</span></span><br><span class="line">        appVersion = VERSION,			  <span class="comment">// 版本</span></span><br><span class="line">        valueCount = ENTRY_COUNT,         <span class="comment">// 缓存文件的类型，此处是2，因为一条缓存映射两个实体文件头和体</span></span><br><span class="line">        maxSize = maxSize,				  <span class="comment">// 缓存大小</span></span><br><span class="line">        taskRunner = TaskRunner.INSTANCE  <span class="comment">// 日志追踪线程池</span></span><br><span class="line">    )</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存使用的是磁盘缓存，缓存目录是添加cache时加的目录。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%202.png" alt="Untitled 2"></p>
<p>先来看看cache缓存数据的时候</p>
<p>Cache::put()缓存的只是响应头数据</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Cache::put()</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(response: <span class="type">Response</span>)</span></span>: CacheRequest? &#123;</span><br><span class="line">    <span class="keyword">val</span> requestMethod = response.request.method</span><br><span class="line">	<span class="comment">// 如果请求方法为POST,PATCH,PUT,DELETE,MOVE,则移除此缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remove(response.request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只允许get方法缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestMethod != <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some</span></span><br><span class="line">        <span class="comment">// POST requests, but the complexity of doing so is high and the benefit is low.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果 Vary 响应头中包含星号，也无法缓存此响应</span></span><br><span class="line">    <span class="comment">// vary 详情请看https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary</span></span><br><span class="line">    <span class="comment">// vary简单理解则是记录下来需要缓存的响应头的值</span></span><br><span class="line">    <span class="keyword">if</span> (response.hasVaryAll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry是Cache.Entry 非 DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">val</span> entry = Entry(response)</span><br><span class="line">    <span class="keyword">var</span> editor: DiskLruCache.Editor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用DiskLruCache的edit(), 此方法则会根据传入的参数获取DiskLruCache.Entry, 看下述2.DiskLruCache#edit中的解析</span></span><br><span class="line">        editor = cache.edit(key(response.request.url)) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 执行写入操作,看下Cache.Entry#writeTo</span></span><br><span class="line">        entry.writeTo(editor)</span><br><span class="line">        <span class="comment">// 返回RealCacheRequest,此时会创建响应体文件, 看下RealCacheRequest</span></span><br><span class="line">        <span class="keyword">return</span> RealCacheRequest(editor)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        abortQuietly(editor)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面都是对这个方法中所调用方法的解析</strong></p>
<p>DiskLruCache::edit() 中的解析</p>
<p>这个方法主要是在journal文件中写入DIRTY 然后返回val editor &#x3D; Editor(entry)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">edit</span><span class="params">(key: <span class="type">String</span>, expectedSequenceNumber: <span class="type">Long</span> = ANY_SEQUENCE_NUMBER)</span></span>: Editor? &#123;</span><br><span class="line">	<span class="comment">// 初始化DiskLruCache</span></span><br><span class="line">    initialize()</span><br><span class="line">	<span class="comment">// 检测缓存有没有关闭,若关闭则抛出异常</span></span><br><span class="line">    checkNotClosed()</span><br><span class="line">    <span class="comment">// 判断key是否有效</span></span><br><span class="line">    validateKey(key)</span><br><span class="line">    <span class="comment">// 获取lruEntries中key的value, 第一次则一定为null</span></span><br><span class="line">    <span class="keyword">var</span> entry: Entry? = lruEntries[key]</span><br><span class="line">    <span class="comment">// 若是添加操作则expectedSequenceNumber使用默认值ANY_SEQUENCE_NUMBER,if不会命中</span></span><br><span class="line">    <span class="comment">// 若是更新操作才有可能命中此if</span></span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">        (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Snapshot is stale.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 若entry绑定了Editor则也返回null</span></span><br><span class="line">    <span class="keyword">if</span> (entry?.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Another edit is in progress.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次添加不会命中,因为entry为null, lockingSourceCount是当前正在打开的输入流的总数</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.lockingSourceCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 无法写入此文件，因为读者仍在阅读它</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在清理过程中, 超过设置的缓存大小且移除Entry失败时会使mostRecentTrimFailed = true, 若需要重建journal, 日志文件创建失败会使mostRecentRebuildFailed = true, 这两种情况下会命中if</span></span><br><span class="line">    <span class="keyword">if</span> (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">        <span class="comment">// The OS has become our enemy! If the trim job failed, it means we are storing more data than</span></span><br><span class="line">        <span class="comment">// requested by the user. Do not allow edits so we do not go over that limit any further. If</span></span><br><span class="line">        <span class="comment">// the journal rebuild failed, the journal writer will not be active, meaning we will not be</span></span><br><span class="line">        <span class="comment">// able to record the edit, causing file leaks. In both cases, we want to retry the clean up</span></span><br><span class="line">        <span class="comment">// so we can get out of this state!</span></span><br><span class="line">        <span class="comment">// 翻译如下: 操作系统已成为我们的敌人！如果修剪作业失败，则意味着我们存储的数据多于用户请求的数据。不允许编辑，因此我们不会进一步超出该限制。如果日志重建失败，日志写入器将不会处于活动状态，这意味着我们将无法记录编辑，从而导致文件泄漏。在这两种情况下，我们都想重试清理，以便摆脱这种状态！</span></span><br><span class="line">        cleanupQueue.schedule(cleanupTask)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">    <span class="comment">// 翻译:在创建文件之前刷新日志以防止文件泄漏</span></span><br><span class="line">    <span class="comment">// 先在journal文件中写入DIRTY</span></span><br><span class="line">    <span class="keyword">val</span> journalWriter = <span class="keyword">this</span>.journalWriter!!</span><br><span class="line">    journalWriter.writeUtf8(DIRTY)</span><br><span class="line">    .writeByte(<span class="string">&#x27; &#x27;</span>.toInt())</span><br><span class="line">    .writeUtf8(key)</span><br><span class="line">    .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    journalWriter.flush()</span><br><span class="line">	<span class="comment">// 若写入journal文件失败则hasJournalErrors = true</span></span><br><span class="line">    <span class="keyword">if</span> (hasJournalErrors) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Don&#x27;t edit; the journal can&#x27;t be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry为DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123; </span><br><span class="line">        entry = Entry(key)</span><br><span class="line">        lruEntries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Editor、作用就是具体的输入流和输出流的操作者</span></span><br><span class="line">    <span class="keyword">val</span> editor = Editor(entry)</span><br><span class="line">    entry.currentEditor = editor</span><br><span class="line">    <span class="keyword">return</span> editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DiskLruCache.Entry 的解析</strong></p>
<p><code>DiskLruCache</code>中存储的缓存实体对象，一个<code>Entry</code>对象代表一条缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> key: String</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度数组，下标0代表头文件大小，下标1代表响应体内容文件大小</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> lengths: LongArray = LongArray(valueCount) </span><br><span class="line">    <span class="comment">// 像日志一样，分为tmp和正式文件，真正的缓存也是如此</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cleanFiles = mutableListOf&lt;File&gt;() <span class="comment">//正式缓存文件集合</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> dirtyFiles = mutableListOf&lt;File&gt;()	<span class="comment">//脏缓存文件集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前缓存是否可用</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readable: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前编辑或读取完成时必须删除此条目，则为真。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> zombie: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在进行的编辑，如果此条目未被编辑，则为 null。将此设置为 null 时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> currentEditor: Editor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此条缓存打开的输入流的总数。当将此值递减为零时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> lockingSourceCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sequenceNumber: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">   		<span class="comment">// 以key为文件名创建File对象</span></span><br><span class="line">        <span class="keyword">val</span> fileBuilder = StringBuilder(key).append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">val</span> truncateTo = fileBuilder.length</span><br><span class="line">        <span class="comment">// valueCount为2 循环两次</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until valueCount) &#123;</span><br><span class="line">            fileBuilder.append(i)</span><br><span class="line">            cleanFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            fileBuilder.append(<span class="string">&quot;.tmp&quot;</span>)</span><br><span class="line">            dirtyFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            <span class="comment">// 删除后缀</span></span><br><span class="line">            fileBuilder.setLength(truncateTo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache.Entry#writeTo</p>
<p>这个方法就是将请求头信息写入文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeTo</span><span class="params">(editor: <span class="type">DiskLruCache</span>.<span class="type">Editor</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 按照响应头的报文格式写入文件</span></span><br><span class="line">  editor.newSink(ENTRY_METADATA).buffer().use &#123; sink -&gt;</span><br><span class="line">    sink.writeUtf8(url).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(requestMethod).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="comment">// 写入Vary</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until varyHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(varyHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong((responseHeaders.size + <span class="number">2</span>).toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until responseHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(responseHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(responseHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    sink.writeUtf8(SENT_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(sentRequestMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(RECEIVED_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(receivedResponseMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isHttps) &#123;</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      sink.writeUtf8(handshake!!.cipherSuite.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      writeCertList(sink, handshake.peerCertificates)</span><br><span class="line">      writeCertList(sink, handshake.localCertificates)</span><br><span class="line">      sink.writeUtf8(handshake.tlsVersion.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheInterceptor</span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取当前的HTTP请求</span></span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取之前的缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前时间、请求和缓存响应计算缓存策略</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存策略中的网络请求和缓存响应</span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪缓存策略的结果</span></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HTTP请求的事件监听器</span></span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存候选项存在但不适用于当前请求，则关闭它。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果禁止使用网络且缓存不足，则返回一个响应表示无法满足请求</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.satisfactionFailure(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不需要网络请求，则直接返回缓存响应</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.cacheHit(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有缓存响应，通知监听器</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发起网络请求并获取网络响应</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果出现I/O错误或其他异常，确保不会泄漏缓存响应的主体（body）</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果同时有缓存响应和网络响应，表示进行条件获取（conditional get）操作</span></span><br><span class="line">		<span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 状态码给了304 说明服务器的Last-Modified字段对比一致 资源未修改可以使用缓存</span></span><br><span class="line">		    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应状态码为304（未修改），则合并两个响应</span></span><br><span class="line">		        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 关闭网络响应的主体</span></span><br><span class="line">		        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 更新缓存，将合并后的响应存储到缓存中</span></span><br><span class="line">		        cache!!.trackConditionalCacheHit()</span><br><span class="line">		        cache.update(cacheResponse, response)</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 返回合并后的响应，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">	        &#125;</span><br><span class="line">			    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应不是304，关闭缓存响应的主体</span></span><br><span class="line">			        cacheResponse.body?.closeQuietly()</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">// 走到这里说明缓存失效需要处理返回的数据</span></span><br><span class="line">			<span class="comment">// 创建网络响应对象，同时处理缓存响应和网络响应的主体</span></span><br><span class="line">			<span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">				    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">				    .networkResponse(stripBody(networkResponse))</span><br><span class="line">				    .build()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">		        <span class="comment">// 如果响应需要缓存并且满足缓存条件，将请求提供给缓存</span></span><br><span class="line">		        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        </span><br><span class="line">		        <span class="comment">// 返回一个响应，同时执行缓存写入操作，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">		            <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这会记录条件缓存未命中</span></span><br><span class="line">                listener.cacheMiss(call)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的HTTP方法会使缓存无效，尝试从缓存中删除相应的项</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// 缓存无法删除，忽略异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终的响应</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheWritingResponse</span><span class="params">(cacheRequest: <span class="type">CacheRequest</span>?, response: <span class="type">Response</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 如果缓存请求为空，或者响应的主体为空，则直接返回响应</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="literal">null</span> || response.body == <span class="literal">null</span>) <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存请求的未缓冲主体</span></span><br><span class="line">    <span class="keyword">val</span> cacheBodyUnbuffered = cacheRequest.body()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的主体源</span></span><br><span class="line">    <span class="keyword">val</span> source = response.body!!.source()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建缓存主体，使用缓冲</span></span><br><span class="line">    <span class="keyword">val</span> cacheBody = cacheBodyUnbuffered.buffer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于写入缓存的主体源</span></span><br><span class="line">    <span class="keyword">val</span> cacheWritingSource = <span class="keyword">object</span> : Source &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cacheRequestClosed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> bytesRead: <span class="built_in">Long</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bytesRead = source.read(sink, byteCount)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheRequest.abort() <span class="comment">// 写入缓存响应失败，中止缓存请求。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheBody.close() <span class="comment">// 缓存响应已完整写入！</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据写入缓存主体</span></span><br><span class="line">            sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)</span><br><span class="line">            cacheBody.emitCompleteSegments()</span><br><span class="line">            <span class="keyword">return</span> bytesRead</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span> = source.timeout()</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheRequestClosed &amp;&amp;</span><br><span class="line">                !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                cacheRequest.abort()</span><br><span class="line">            &#125;</span><br><span class="line">            source.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的Content-Type和Content-Length</span></span><br><span class="line">    <span class="keyword">val</span> contentType = response.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> contentLength = response.body.contentLength()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的响应，使用缓存写入的主体</span></span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OKHttp的缓存设计"><a href="#OKHttp的缓存设计" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h3><p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制。它允许客户端缓存请求的响应数据，减少不必要的网络请求，从而提高应用的性能和响应速度。下面是OkHttp缓存设计的关键点：</p>
<ol>
<li><p><strong>缓存存储</strong>：</p>
<ul>
<li>OkHttp使用<code>Cache</code>类管理缓存。该类负责存储、检索和清除缓存响应。</li>
</ul>
</li>
<li><p><strong>可缓存性</strong>：</p>
<ul>
<li>OkHttp中决定一个响应是否可以被缓存是基于HTTP头部信息，如<code>Cache-Control</code>、<code>Last-Modified</code>和<code>ETag</code>。</li>
</ul>
</li>
<li><p><strong>缓存策略</strong>：</p>
<ul>
<li>通过<code>CacheStrategy</code>类确定是返回缓存的响应还是发起网络请求。该策略考虑请求头中的缓存指令和响应头中的验证器（如ETag或者Last-Modified）。</li>
</ul>
</li>
<li><p><strong>缓存验证</strong>：</p>
<ul>
<li>当缓存的响应被认为是过时的，OkHttp会在新的请求中添加条件头部（例如<code>If-None-Match</code>或<code>If-Modified-Since</code>）去验证缓存。如果服务器返回304（Not Modified），表明缓存仍然有效，客户端可以继续使用缓存的数据。否则，使用新的响应数据。</li>
</ul>
</li>
<li><p><strong>缓存拦截器</strong>：</p>
<ul>
<li><code>CacheInterceptor</code>是OkHttp中管理缓存逻辑的拦截器。它会检查请求的缓存指令，根据现有的缓存响应和请求条件，选择是从缓存返回数据还是发起新的网络请求。</li>
</ul>
</li>
<li><p><strong>新鲜度和过期</strong>：</p>
<ul>
<li>缓存的响应要在一定时间内被认定为新鲜的，基于<code>Cache-Control</code>的<code>max-age</code>指令、<code>Expires</code>头部或者启发式的计算。如果响应不再新鲜，OkHttp将尝试重新验证缓存。</li>
</ul>
</li>
<li><p><strong>同步和异步请求</strong>：</p>
<ul>
<li>OkHttp的缓存策略对于同步和异步请求都适用。但它会确保在异步请求中，缓存操作和网络调用都是在后台线程中执行，不会阻塞主线程。</li>
</ul>
</li>
<li><p><strong>透明处理</strong>：</p>
<ul>
<li>对于OkHttp的使用者来说，缓存大部分时间是透明的，只需要配置好<code>Cache</code>对象，并附着到OkHttp客户端即可。实际的缓存逻辑由库内部管理。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>OkHttp的缓存策略和逻辑遵循HTTP协议，但它也提供了一定程度的自定义，应用开发者可以通过设置请求头部来影响缓存的行为。</li>
</ul>
</li>
<li><p><strong>缓存持久性</strong>：</p>
<ul>
<li>OkHttp的缓存把响应数据存储在文件系统中，即使应用被杀死，这些缓存数据仍然可以在下次应用启动时被访问。</li>
</ul>
</li>
</ol>
<p>​		OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p><code>Http</code>的缓存规则分为两大类：<strong>强制缓存，对比缓存</strong>，与缓存规则相关的信息，均包含在报文的<code>Header</code>中。</p>
<p><strong>强制缓存</strong></p>
<p>​		强制缓存的实现依靠于<code>Expires</code>和<code>Cache-Control</code>这两个字段。<code>Expires</code> 通过这个 Header ，服务端可以告诉客户端缓存的过期时间，表示在过期时间内该资源都不会被更改，可以不用再向自己请求了。但因为客户端时间和服务器时间的差异，在在 HTTP&#x2F;1.1 协议中引入了 <code>Cache-Control</code> 机制，通过这个 Header 可以在服务端与客户端之间沟通缓存信息。常见的缓存指令如下</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center"><strong>客户端</strong>可以缓存</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center"><strong>客户端</strong>和<strong>代理服务器</strong>都可以缓存</td>
</tr>
<tr>
<td align="center">max-age&#x3D;xxx</td>
<td align="center">缓存数据在xxx秒后过期</td>
</tr>
<tr>
<td align="center">no-cache</td>
<td align="center">需要使用对比缓存来验证缓存数据</td>
</tr>
</tbody></table>
<p><strong>对比缓存</strong></p>
<p>​		浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若缓存资源仍有效，服务器会返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>通过Last-Modified &#x2F; If-Modified-Since与Cache-Control配合判断，<code>Last-Modified</code> 位于响应头，<code>If-Modified-Since</code> 位于请求头。</p>
<ul>
<li><p><code>Last-Modified</code>：该响应资源最后的修改时间，服务器在响应请求的时候可以填入该字段。</p>
</li>
<li><p>If-Modified-Since：客户端缓存过期时（<code>max-age</code> 到达），发现该资源具有 <code>Last-Modified</code> 字段，可以在 Header 中填入 <code>If-Modified-Since</code> 字段，并填入<code>Last-Modified</code>记录的时间。服务端收到该时间后会与该资源的最后修改时间进行比较。</p>
<ul>
<li><p>若该资源已经被修改 ，则会返回状态码200，并对整个资源响应。</p>
</li>
<li><p>否则说明该资源在访问时未被修改，则会响应状态码 304，告知客户端可以使用缓存的资源</p>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>​		强制缓存和对比缓存可以同时存在，<strong>强制缓存优先级高于对比缓存</strong>，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p>当强制缓存和对比缓存同时存在时：</p>
<ol>
<li>对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。</li>
<li>对于比较缓存，客户端将缓存信息中的<code>Etag</code>和<code>Last-Modified</code>通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。否则返回200并对整个资源响应。</li>
</ol>
<h2 id="ConnectInterceptor-建立连接的拦截器"><a href="#ConnectInterceptor-建立连接的拦截器" class="headerlink" title="ConnectInterceptor 建立连接的拦截器"></a>ConnectInterceptor 建立连接的拦截器</h2><p>该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/giagor/p/15706524.html">探索OkHttp系列 (五) 连接建立与复用 - Giagor - 博客园</a></p>
<h3 id="HTTP中的连接复用机制"><a href="#HTTP中的连接复用机制" class="headerlink" title="HTTP中的连接复用机制"></a><strong><strong>HTTP中的连接复用机制</strong></strong></h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Http协议需要首先建立Socket连接（即TCP&#x2F;IP连接），同时我们了解到TCP&#x2F;IP连接需要进行三次握手，断开连接需要完成四次挥手。在完成了对某一域名的Socket连接之后，借助此Socket来进行Http数据的交互。那么第一次交互完成之后，如果需要进行与此域名的第二次交互，就可以利用前一次的Socket连接进行。因此OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。</p>
<h3 id="okHttp如何复用TCP连接？"><a href="#okHttp如何复用TCP连接？" class="headerlink" title="okHttp如何复用TCP连接？"></a><strong>okHttp如何复用TCP连接？</strong></h3><p>这个其实主要说的是 <code>ConnectInterceptor</code> 拦截器中初始化 <code>Exchange</code> 时内部做的事，具体如下：</p>
<p><code>OkHttp</code> 使用连接池 <code>RealConnectionPool</code> 管理所有连接，连接池将所有活动的连接存储在池中，并维护了一个空闲的链接列表(<code>TaskQueue</code>)，当需要新的连接时，<strong>优先尝试从这个池中找</strong>，如果没找到，则 <strong>重新创建</strong> 一个 <code>RealConnection</code> 连接对象，并将其添加到连接池中。在具体的寻找连接的过程中，一共进行了下面5次尝试：</p>
<ol>
<li>尝试重连 <code>RealCall</code> 中的 <code>connection</code>，此时不需要重新获取连接；</li>
<li>尝试从连接池中获取一个连接，不带路由与多路复用；</li>
<li>再次尝试从连接池中获取一个连接，带路由，不带多路复用；</li>
<li>手动创建一个新连接；</li>
<li>再次尝试从连接池中获取一个连接，带路由与多路复用；</li>
</ol>
<p>当然 <code>OkHttp</code> 也支持自定义连接池，具体如下：</p>
<p><img src="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png" alt="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png"></p>
<p>上述代码中，创建了一个新的连接池，并设置其保留最多 <code>maxIdleConnections</code> 个空闲连接，并且连接的存活期为 <code>keepAliveDuration</code> 分钟。</p>
<h3 id="okhttp连接池使用流程"><a href="#okhttp连接池使用流程" class="headerlink" title="okhttp连接池使用流程"></a>okhttp连接池使用流程</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20211209161223068.png" alt="image-20211209161223068"></p>
<h3 id="从连接池中获取可用连接部分代码分析"><a href="#从连接池中获取可用连接部分代码分析" class="headerlink" title="从连接池中获取可用连接部分代码分析"></a>从连接池中获取可用连接部分代码分析</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个连接去承载新的流，优先使用现有连接，接着是连接池中的连接，最后是创建一个新的连接</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 检查取消事件  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.尝试去重用call的连接  </span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="comment">// 检查这个连接是否可用和可复用  </span></span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        <span class="comment">// 连接不可用，在call中移除该连接，并返回该连接对应的Socket，随后要关闭它  </span></span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="comment">// 如果连接可以使用，那么就返回该连接  </span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    <span class="comment">// 关闭Socket  </span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need a new connection. Give it fresh stats.</span></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.尝试从连接池中获取连接(第一次)</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="comment">// 连接池里没有东西，计算下一条要尝试的路由  </span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 从现有的routeSelection中获取一个路由  </span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算一个新的routeSelector，这是一个阻塞操作  </span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="comment">// 如果routeSelector为null，那么就先创建一个RouteSelector  </span></span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从routeSelector中获取一个新的routeSelection  </span></span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    <span class="comment">// 获取routeSelection中的路由列表  </span></span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">    <span class="comment">// the pool. We have a better chance of matching thanks to connection coalescing.</span></span><br><span class="line">    <span class="comment">// 3.现在我们有了一组IP地址，再次尝试从连接池中获取连接，由于连接合并，这次我们有更大的希望</span></span><br><span class="line">    <span class="comment">// 从连接池里获取一个连接(第二次)  </span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="comment">// 返回连接</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从routeSelection中获取一个路由，用于新连接的创建  </span></span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="comment">// 4.创建新连接  </span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行TCP+TLS握手(Https请求才会做TLS握手)，这是一个阻塞的操作    </span></span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we raced another call connecting to this host, coalesce the connections. This makes for 3</span></span><br><span class="line">  <span class="comment">// different lookups in the connection pool!</span></span><br><span class="line">  <span class="comment">// 5.如果有另一个调用也是连接到相同的主机，并且该调用已经创建了新连接，将连接放到了连接池里，</span></span><br><span class="line">  <span class="comment">// 那么就使用连接池里的连接(第三次)  </span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    <span class="comment">// 保存路由  </span></span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    <span class="comment">// 将前面新创建的连接的Socket关闭  </span></span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接池中的连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三次在连接池中获取连接，依然没找到，意味着要使用新创建的连接 */</span>  </span><br><span class="line">      </span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    <span class="comment">// 6.将先创建的连接放进连接池里面</span></span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="comment">// 返回新创建的连接  </span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CallServerInterceptor：执行网络请求的拦截器"><a href="#CallServerInterceptor：执行网络请求的拦截器" class="headerlink" title="CallServerInterceptor：执行网络请求的拦截器"></a>CallServerInterceptor：执行网络请求的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="comment">// 以Request作为Key，获取候选缓存  </span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据「当前时间、请求、候选缓存」，创建缓存策略  </span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="comment">// 如果该请求不需要使用网络，那么networkRequest就为null  </span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="comment">// 如果不存在该请求对应的缓存，那么cacheResponse为null  </span></span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且没有对应的缓存，那么直接报错，返回状态码504  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.satisfactionFailure(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且有对应的缓存，那么就进入If语句，返回缓存</span></span><br><span class="line">    <span class="comment">// (代码执行到这里，说明networkRequest和cacheResponse不能同时为null)  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 经过上面的两个If语句，代码执行到这里，说明networkRequest不为null，也就是该请求要使用网络 */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示网络请求的响应  </span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 进行网络请求，获取下一个拦截器返回的Response  </span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="comment">// 释放资源  </span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 之前已经获取到请求对应的缓存  </span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若网络请求返回的响应中，包含状态码304，说明之前的缓存数据有效，返回cacheResponse对应</span></span><br><span class="line">      <span class="comment">// 的缓存结果（HTTP_NOT_MODIFIED对应状态码304）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">  			<span class="comment">// 混合 缓存Response的Header 和 网络获取的Response的Header        </span></span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存过期，收回资源  </span></span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 在上面的一大段If语句中，若响应码为304，则缓存资源有效，返回缓存资源，若响应码不为304， */</span>  </span><br><span class="line">	<span class="comment">/* 则表示缓存资源过期，关闭缓存资源 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取网络请求的结果  </span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对网络请求获取的Response进行缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果请求方法不需要缓存，则移除缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回网络的请求结果  </span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>自定义拦截器有两种应用拦截器和网络拦截器分别在两个位置，一个是在拦截器链头部，一个是在<strong>CallServerInterceptor和</strong>ConnectInterceptor中间。</p>
<p>他俩的区别：</p>
<ul>
<li>添加方式</li>
</ul>
<p>头：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>尾：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h4 id="对OKHttp有了解吗，拦截器这一块有了解吗？"><a href="#对OKHttp有了解吗，拦截器这一块有了解吗？" class="headerlink" title="对OKHttp有了解吗，拦截器这一块有了解吗？"></a>对OKHttp有了解吗，拦截器这一块有了解吗？</h4><p>OKHttp有五种自己的拦截器：</p>
<ol>
<li><p><code>RetryAndFollowUpInterceptor</code>：负责失败的网络重试和 URL 重定向。</p>
</li>
<li><p><code>BridgeInterceptor</code>：将应用程序原始的请求转换为可以通过网络发送的请求，同样也将来自服务器的响应转换为可以给应用程序使用的响应。如：添加 Content-Length ， Gzip 等编解码， cookies 的处理都在这。</p>
</li>
<li><p><code>CacheInterceptor</code>：这是 OkHttp 实现缓存的关键， CacheInterceptor 将查看服务器响应头中的缓存指令并尝试从应用程序配置的 Cache 中获取潜在的缓存响应。</p>
</li>
<li><p><code>ConnectInterceptor</code>：它通过向服务器建立实际的网络连接来开始网络请求的链。</p>
</li>
<li><p><code>CallServerInterceptor</code>：这是网络链的最后一个拦截器，它会将请求数据发送给服务器并从服务器获取响应数据。</p>
<p>还有两种自定义的拦截器：</p>
<ul>
<li><p>这两种拦截器的区别在于添加方法不同，所以添加后的位置也不一样。</p>
<ul>
<li>添加方式</li>
</ul>
<p>应用拦截器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>网络拦截器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
</li>
</ul>
</li>
</ol>
<h4 id="有没有用到过自定义拦截器，怎么用的"><a href="#有没有用到过自定义拦截器，怎么用的" class="headerlink" title="有没有用到过自定义拦截器，怎么用的"></a>有没有用到过自定义拦截器，怎么用的</h4><p>实现 <code>Interceptor</code> 接口并重写 <code>intercept</code> 方法。可以在 <code>intercept</code> 方法中对 <code>request</code> 和 <code>response</code> 进行监控或者修改。</p>
<p>以下是一个简单的打印请求日志的自定义拦截器：</p>
<p>kotlin</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印请求信息</span></span><br><span class="line">        println(<span class="string">&quot;Sending request to <span class="subst">$&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求并获取响应</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印响应信息</span></span><br><span class="line">        println(<span class="string">&quot;Received response from <span class="subst">$&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>OkHttpClient</code> 配置中添加自定义的拦截器：</p>
<p>kotlin</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(LoggingInterceptor())</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>以上示例的拦截器会打印每个请求的发送和响应接收信息。同时注意到添加拦截器的方法以 <code>.addInterceptor()</code> 的形式插入到了 OkHttpClient 的构建过程中。这样，新建的 OkHttpClient 实例就具备了我们自定义处理逻辑的能力。</p>
<h4 id="拦截器一定会被执行吗"><a href="#拦截器一定会被执行吗" class="headerlink" title="拦截器一定会被执行吗"></a>拦截器一定会被执行吗</h4><p>​		在OkHttp中，拦截器是否会被执行取决于多个因素。首先，应用拦截器（通过<code>addInterceptor()</code>方法添加的拦截器）一定会被执行一次。</p>
<p>然而，网络拦截器（通过<code>addNetworkInterceptor()</code>方法添加的拦截器）可能不会被执行，或者可能会被执行多次。例如，当发生错误重试或网络重定向时，网络拦截器可能会被执行多次。</p>
<p>另外，如果在拦截器链中的某个拦截器返回了<code>null</code>，那么后面的拦截器将不会被执行。</p>
<h4 id="简单说下OKHttp一个网络请求的流程"><a href="#简单说下OKHttp一个网络请求的流程" class="headerlink" title="简单说下OKHttp一个网络请求的流程"></a>简单说下OKHttp一个网络请求的流程</h4><p>​		<strong>先创建OkHttpClient</strong><code>val client = OkHttpClient.Builder().xxx.build()</code>,<strong>然后创建请求体</strong><code>request = Request.Builder().url(&quot;http://www.baidu.com&quot;).build()</code> 这里定义了请求地址。<strong>然后使用enqueue或者execute开启请求</strong> <code>client?.newCall(request)?.execute()</code>。 </p>
<p>​		其中newCall(request)会将请求封装成一个reallCall对象。然后调用reallCall的enqueue方法开启请求。这个方法的入参是一个callback 接口对象，这是用来返回请求结果的，然后最终会回调 <code>getResponseWithInterceptorChain()</code>方法的结果。这个就是通过拦截器链处理请求的方法。这个后面再说。</p>
<p>​		execute方法里会先将当前请求放入调度器的任务队列中，然后再适当的时机将他添加到线程池中启动。reallCall继承自Runnable真正的任务内容再run方法中。这里还是使用getResponseWithInterceptorChain返回结果</p>
<p>​		getResponseWithInterceptorChain中定义了拦截器链其中包括五个自带的拦截器和两个自定义的拦截器，其中的拦截器按照顺序来看依次是，应用拦截器、重试重定向拦截器、请求响应转换拦截器、缓存拦截器、链接建立拦截器、自定义的网络拦截器、然后是最后读写拦截器 。开启拦截器链进行请求</p>
<p>​		先是重试重定向拦截器，先说重试，在方法中有一个while (true)的死循环循环中有个try catch用来捕获请求过程中出现的异常，如果命中了可以重试的异常就不会抛出而是继续下一次的循环，开启新的请求。重定向的话会根据响应的code （30x）判断是否需要重定向，是的话重新赋值request进行新的请求。如果重试和重定向都没命中会直接返回response </p>
<p>​		请求响应转换拦截器，主要是对请求头和相应头的处理</p>
<p>​		缓存拦截器，这个拦截器默认是null，如果需要的话需要在构造的时候手动添加且只会缓存get请求。假设添加了话，它会根据后面拦截器返回的网络请求结果networkRequest和cacheResponse来进行一个策略判断，两个都是null直接504，networkRequest为null，cacheResponse不为null则直接返回cacheResponse，networkRequest不为null，cacheResponse为null则返回networkRequest满足条件的话缓存networkRequest。两个都不为null，网络Response状态码若为304，则混合请求头后更新缓存，并返回缓存；若状态码为200,返回网络Response,满足缓存条件则缓存Response。 然后cacheResponse的存储使用的是磁盘缓存。</p>
<p>​		建立连接的拦截器，该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。没有的话就会新创建一个连接。</p>
<p>​		网络请求的拦截器，间接调用编码器的一些方法对数据进行接收和输出以及对一些状态码的处理。</p>
<h4 id="OKHttp的缓存设计-1"><a href="#OKHttp的缓存设计-1" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h4><p>​		OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。</p>
<p>​		CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h4 id="OKHttp设计的精髓在哪里"><a href="#OKHttp设计的精髓在哪里" class="headerlink" title="OKHttp设计的精髓在哪里"></a>OKHttp设计的精髓在哪里</h4><p>​		责任链模式的设计</p>
<h4 id="OKHttp连接池作用是什么"><a href="#OKHttp连接池作用是什么" class="headerlink" title="OKHttp连接池作用是什么"></a>OKHttp连接池作用是什么</h4><p>​		复用 TCP 连接，减少三次握手的次数。</p>
<h4 id="假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗"><a href="#假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗" class="headerlink" title="假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗"></a>假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗</h4><p>​		复用时会通过<strong>主机名和端口号</strong>判断是否可用。</p>
<h4 id="连接池怎么复用"><a href="#连接池怎么复用" class="headerlink" title="连接池怎么复用"></a>连接池怎么复用</h4><p>​		OkHttp中的连接池最大空闲连接的数量为5，并且最大的空闲时间为5分钟，这里的最大空闲连接数量是相对于一个地址而言。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/15/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" title="Recyclerview缓存机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Recyclerview缓存机制</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/15/kotlin%E5%8D%8F%E7%A8%8B/" title="kotlin协程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kotlin协程</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OkHttp"><span class="toc-number">1.</span> <span class="toc-text">OkHttp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E7%94%9F%E6%88%90"><span class="toc-number">1.2.</span> <span class="toc-text">请求生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RetryAndFollowUpInterceptor%EF%BC%9A%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">RetryAndFollowUpInterceptor：重试、重定向拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BridgeInterceptor%EF%BC%9A%E5%B0%86%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%94%A8%E6%88%B7%E5%93%8D%E5%BA%94%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">CacheInterceptor：读取、写入缓存的拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">CacheInterceptor：读取、写入缓存的拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OKHttp%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.2.</span> <span class="toc-text">OKHttp的缓存设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">HTTP缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConnectInterceptor-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">ConnectInterceptor 建立连接的拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">HTTP中的连接复用机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">1.7.2.</span> <span class="toc-text">连接池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#okHttp%E5%A6%82%E4%BD%95%E5%A4%8D%E7%94%A8TCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">okHttp如何复用TCP连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#okhttp%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.4.</span> <span class="toc-text">okhttp连接池使用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8F%AF%E7%94%A8%E8%BF%9E%E6%8E%A5%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.7.5.</span> <span class="toc-text">从连接池中获取可用连接部分代码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CallServerInterceptor%EF%BC%9A%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">CallServerInterceptor：执行网络请求的拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">自定义拦截器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9OKHttp%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E8%BF%99%E4%B8%80%E5%9D%97%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">对OKHttp有了解吗，拦截器这一块有了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E5%88%B0%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">有没有用到过自定义拦截器，怎么用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">拦截器一定会被执行吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8BOKHttp%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">简单说下OKHttp一个网络请求的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OKHttp%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">OKHttp的缓存设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OKHttp%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%B2%BE%E9%AB%93%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">OKHttp设计的精髓在哪里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OKHttp%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.0.0.7.</span> <span class="toc-text">OKHttp连接池作用是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%99%BE%E5%BA%A6API%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E8%85%BE%E8%AE%AFAPi%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8F%AF%E4%BB%A5%E5%A4%8D%E7%94%A8%E5%90%97"><span class="toc-number">2.0.0.8.</span> <span class="toc-text">假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%8E%E4%B9%88%E5%A4%8D%E7%94%A8"><span class="toc-number">2.0.0.9.</span> <span class="toc-text">连接池怎么复用</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>