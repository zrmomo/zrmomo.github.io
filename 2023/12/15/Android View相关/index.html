<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android View | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android view 绘制流程布局加载过程我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585">
<meta property="og:type" content="article">
<meta property="og:title" content="Android View">
<meta property="og:url" content="https://zrmomo.github.io/2023/12/15/Android%20View%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="Android view 绘制流程布局加载过程我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2023-12-15T09:14:57.000Z">
<meta property="article:modified_time" content="2024-04-23T11:26:14.076Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2023/12/15/Android%20View%E7%9B%B8%E5%85%B3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android View',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-23 19:26:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android View</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-15T09:14:57.000Z" title="发表于 2023-12-15 17:14:57">2023-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-23T11:26:14.076Z" title="更新于 2024-04-23 19:26:14">2024-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android View"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Android-view-绘制流程"><a href="#Android-view-绘制流程" class="headerlink" title="Android view 绘制流程"></a>Android view 绘制流程</h1><h2 id="布局加载过程"><a href="#布局加载过程" class="headerlink" title="布局加载过程"></a>布局加载过程</h2><p>我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">  	  <span class="comment">// 这里调用了PhoneWindow的setContentView方法</span></span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  	<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 创建一个DecorView</span></span><br><span class="line">                mDecor = generateDecor();  </span><br><span class="line">                mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">                mDecor.setIsRootNamespace(<span class="literal">true</span>);  </span><br><span class="line">                <span class="comment">//...  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;  </span><br><span class="line">              	<span class="comment">// 这里引入R.layout.screen_simple add到了DecorView上 并将R.id.content传递给mContentParent 可以看下面的源码部分</span></span><br><span class="line">                mContentParent = generateLayout(mDecor);  </span><br><span class="line">                mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">                <span class="keyword">if</span> (mTitleView != <span class="literal">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//根据FEATURE_NO_TITLE隐藏，或者设置mTitleView的值  </span></span><br><span class="line">                    <span class="comment">//...  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);  </span><br><span class="line">                    <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">//设置ActionBar标题、图标神马的；根据FEATURE初始化Actionbar的一些显示  </span></span><br><span class="line">                        <span class="comment">//...  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 先是一系列的属性设置贴了一些平时常用的</span></span><br><span class="line">    <span class="comment">// 取消标题栏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="literal">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置全屏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="literal">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    <span class="comment">// 一系列的窗口属性设置</span></span><br><span class="line">    <span class="comment">// 如：SDK 31 新增的高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowBlurBehindEnabled, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getForcedWindowFlags() &amp; WindowManager.LayoutParams.FLAG_BLUR_BEHIND) == <span class="number">0</span>) &#123;</span><br><span class="line">            params.flags |= WindowManager.LayoutParams.FLAG_BLUR_BEHIND;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        params.setBlurBehindRadius(a.getDimensionPixelSize(</span><br><span class="line">                android.R.styleable.Window_windowBlurBehindRadius, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 整体布局文件</span></span><br><span class="line">    <span class="type">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据一系列判断选择 SDK 中的布局一般默认是 R.layout.screen_simple</span></span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载到DecorView上</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到 screen_simple.xml 布局的内容部分 （R.id.content）</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">DecorView:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="type">int</span> layoutResource)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 通过 LayoutInflater 将 screen_simple.xml 解析成 View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 addView 将 root 添加到 DecorView 上</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前最终的布局层次</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>此时只是完成了基础的activity的DecirView的初始化 我们实现的布局还没有解析到布局上</p>
<p>回头看setContentView()方法，目前上面的部分实现了installDecor()，也就是初始化完成了DecorView 并解析了R.layout.screen_simple到上面，并将里面的FrameLayout（R.id.content）的引用传递出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>下面就是解析自己的布局过程，就是下面这行代码开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br></pre></td></tr></table></figure>

<p>往下挖源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater:	</span><br><span class="line">	<span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">    <span class="comment">// 如果开启了调试模式，打印日志，显示正在从哪个资源文件加载视图</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">              + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line">    <span class="comment">// 尝试从预编译的资源中加载视图，如果成功则返回视图 </span></span><br><span class="line">    <span class="comment">// 目前这个方法被禁用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取XML资源解析器</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用解析器，根据root和attachToRoot参数来加载视图</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后关闭解析器</span></span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用同步块，确保多线程环境下的安全性</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// 开始性能追踪，用于调试和性能优化</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上下文和属性集</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root; <span class="comment">// root 赋值给 result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果根视图不为空并且根视图的 ViewRootImpl 不为空，通知渲染器进行昂贵帧的处理</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将解析器推进到第一个START_TAG 也就是根View</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 拿到根 View 名字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点是 &lt;merge&gt;，则需要合并布局</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果根视图为空或者不需要附加到根视图，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行合并布局</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 根据标签创建视图</span></span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图为空且 temp 不为空 且 temp 的 ViewRootImpl 不为空，通知渲染器处理昂贵帧</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span> &amp;&amp; temp.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 布局参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图不为空，则生成根视图的布局参数</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Creating params from root: &quot;</span> + root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初始化布局参数</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要附加到根视图，则设置布局参数给 temp</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; start inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; done inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将创建的根 View 添加到 root 也就是 mContentParent 中</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回传入的根视图还是在 XML 中找到的顶层视图</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="comment">// XML 解析异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                    getParserStateDescription(inflaterContext, attrs)</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要保留对上下文的静态引用</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束性能追踪</span></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果标签名为 &quot;view&quot;，则尝试获取 &quot;class&quot; 属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不忽略主题属性，则尝试应用主题包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="comment">// 从属性中获取主题信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果主题资源 ID 不为 0，则使用 ContextThemeWrapper 包装上下文</span></span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试直接创建视图  </span></span><br><span class="line">      	<span class="comment">// 这里是使用Factory2创建view </span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">				</span><br><span class="line">       <span class="comment">// 如果创建失败进入 if</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果直接创建失败，则尝试通过其他方式创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 表示 sdk 中的 View (Text、Button...)</span></span><br><span class="line">                    view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 表示自定义 View 或者 support 包中的 View (androidx.appcompat.widget.AppCompatButton...)</span></span><br><span class="line">                    view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 InflateException，则直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ClassNotFoundException，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果是其他异常，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结上述源码：</p>
<p>​		LayoutInflater::inflate 开启了布局解析，<code>XmlResourceParser parser = res.getLayout(resource);</code>获取了布局解析器，然后<code>inflate(parser, root, attachToRoot);</code> 进入了具体的解析流程。从<code>final View temp = createViewFromTag(root, name, inflaterContext, attrs);</code>进入createViewFromTag方法，然后走下如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                        view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<p>tryCreateView是尝试创建view，看看具体代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很简单就是通过mFactory2&#x2F;mFactory来创建view。</p>
<p>其中Activity的父类AppCompatActivity中的构造方法中会执行一个initDelegate()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 添加上下文可用监听器</span></span><br><span class="line">    addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AppCompatDelegate 实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">            <span class="comment">// 安装视图工厂 这里开启了Factory</span></span><br><span class="line">            delegate.installViewFactory();</span><br><span class="line">            <span class="comment">// 调用 AppCompatDelegate 的 onCreate 方法，并传入从 SavedStateRegistry 恢复的状态</span></span><br><span class="line">            delegate.onCreate(getSavedStateRegistry()</span><br><span class="line">                    .consumeRestoredStateForKey(DELEGATE_TAG));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDelegateImpl:</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 这里setFactory2 将this也就是AppCompatDelegateImpl</span></span><br><span class="line">            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                        + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码走完又可以回到这部分了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">View view;</span><br><span class="line">      <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">          view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">          view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          view = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用的onCreateView方法的实现应该是在AppCompatDelegateImpl中，看下具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 AppCompatViewInflater 为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mAppCompatViewInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewInflaterClassName</span> <span class="operator">=</span></span><br><span class="line">                a.getString(R.styleable.AppCompatTheme_viewInflaterClass);</span><br><span class="line">        <span class="keyword">if</span> (viewInflaterClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未指定自定义的 ViewInflater 类名，使用默认的 AppCompatViewInflater</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用反射加载自定义的 ViewInflater 类</span></span><br><span class="line">                Class&lt;?&gt; viewInflaterClass =</span><br><span class="line">                        mContext.getClassLoader().loadClass(viewInflaterClassName);</span><br><span class="line">                mAppCompatViewInflater =</span><br><span class="line">                        (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor()</span><br><span class="line">                                .newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 加载失败时，使用默认的 AppCompatViewInflater，并打印错误日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Failed to instantiate custom view inflater &quot;</span></span><br><span class="line">                        + viewInflaterClassName + <span class="string">&quot;. Falling back to default.&quot;</span>, t);</span><br><span class="line">                mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承上下文，用于处理 &lt;include&gt; 标签的情况</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inheritContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (IS_PRE_LOLLIPOP) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 5.0 之前的版本，处理 &lt;include&gt; 标签的继承上下文情况</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector == <span class="literal">null</span>) &#123;</span><br><span class="line">            mLayoutIncludeDetector = <span class="keyword">new</span> <span class="title class_">LayoutIncludeDetector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector.detect(attrs)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前视图是 &lt;include&gt; 的根视图，则继承上下文</span></span><br><span class="line">            inheritContext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 &lt;include&gt; 标签，根据深度或者使用旧的启发式方法来判断是否继承上下文</span></span><br><span class="line">            inheritContext = (attrs <span class="keyword">instanceof</span> XmlPullParser)</span><br><span class="line">                    ? ((XmlPullParser) attrs).getDepth() &gt; <span class="number">1</span></span><br><span class="line">                    : shouldInheritContext((ViewParent) parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AppCompatViewInflater 的 createView 方法创建视图</span></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* 只在 Android 5.0 之前读取 android:theme 属性 */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* 无论何时都读取 app:theme 属性作为后备，基于传统原因 */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* 只有在启用时对上下文进行着色处理 */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又走到了createView方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"># AppCompatViewInflater </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">originalContext</span> <span class="operator">=</span> context;</span><br><span class="line">        <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            context = parent.getContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">            context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">            context = TintContextWrapper.wrap(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">                view = createTextView(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">                view = createImageView(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">                view = createButton(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">                view = createEditText(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">                view = createSpinner(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">                view = createImageButton(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">                view = createCheckBox(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">                view = createRadioButton(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">                view = createCheckedTextView(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">                view = createAutoCompleteTextView(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">                view = createMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">                view = createRatingBar(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">                view = createSeekBar(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;ToggleButton&quot;</span>:</span><br><span class="line">                view = createToggleButton(context, attrs);</span><br><span class="line">                verifyNotNull(view, name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">                <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">                <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">                <span class="comment">// later in this method.</span></span><br><span class="line">                view = createView(context, name, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">            <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">            <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">            view = createViewFromTag(context, name, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">            checkOnClickListener(view, attrs);</span><br><span class="line">            backportAccessibilityAttributes(context, view, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结上面：AppCompatActivity 默认设置了 Factory2，并且其实现创建 View 是直接通过 new 的方式，并没有使用反射。</p>
<p>上面一节有个方法需要注意下，就是布局的子view是如果添加到根view的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/LayoutInflater.java</span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    				...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">								</span><br><span class="line">						...</span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数的深度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 逐个 View 解析</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:focusable=&quot;true&quot;, 获取View的焦点</span></span><br><span class="line">            pendingRequestFocus = <span class="literal">true</span>;</span><br><span class="line">            consumeChildElements(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:tag标签</span></span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析include标签，include标签不能作为根布局</span></span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;include /&gt; cannot be the root element&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, context, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// merge标签必须作为根布局</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; must be the root element&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据元素名解析，生成View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 添加解析的View</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果finishInflate为true，则调用onFinishInflate方法</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为AppCompatActivity 默认设置了 Factory2，且Factory2只能设置一次，如果activity集成了AppCompatActivity那么只能通过反射设置Factory2了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory2</span><span class="params">(Factory2 factory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Given factory can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> <span class="title class_">FactoryMerger</span>(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射将mFactorySet重新设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//上面提到过：Android布局加载器使用mFactorySet标记是否设置过Factory，如设置过抛出一次</span></span><br><span class="line">  <span class="comment">//所以需要通过反射设置mFactorySet为false</span></span><br><span class="line">  <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LayoutInflater.class.getDeclaredField(<span class="string">&quot;mFactorySet&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用factory2设置布局加载工厂</span></span><br><span class="line"><span class="type">SkinLayoutInflaterFactory</span> <span class="variable">skinLayoutInflaterFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkinLayoutInflaterFactory</span></span><br><span class="line">  (activity);</span><br><span class="line">LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>

<p><strong>setContentView总结：</strong></p>
<p>​		在<code>Activity</code>实例创建好并且执行<code>attach()</code>方法的时候，会为<code>Activity</code>创建一个<code>PhoneWindow</code>，接下来就到了<code>onCreate()</code>的生命周期，在调用<code>setContentView()</code>的时候，如果还没有初始化<code>ContentParent</code>，说明是第一次进行<code>setContentView()</code>，那么就会初始化<code>DecorView</code>，还会给<code>DecorView</code>添加一个系统页面样式的<code>子View(R.layout.screen_simple)</code>，那么在系统样式的<code>ViewGroup</code>中，就可以通过<code>id</code>找到用来加载自定义布局的<code>ContentParent</code>，再通过<code>inflate</code>就可以将我们自己写的<code>xml</code>文件<code>(R.layout.main)</code>转化为一颗<code>ViewTree</code>了，这颗<code>ViewTree</code>就在<code>ContentParent</code>里面。</p>
<p>所以<code>setContentView()</code>的作用最终可以总结为：</p>
<ul>
<li><strong>创建<code>DecorView</code></strong></li>
<li><strong>创建<code>ContentParent</code></strong></li>
<li><strong>自定义布局转化为<code>ViewTree</code>，放在<code>ContentParent</code>中</strong></li>
</ul>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA">Android 资源加载源码分析一</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5a71014e7b1b">Android View的绘制流程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11">Android 干货分享：插件化换肤原理（1）—— 布局加载过程、View创建流程、Resources 浅析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff">LayoutInflater源码分析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e554406bd15">插件化换肤</a></p>
<p><a target="_blank" rel="noopener" href="https://yummylau.com/2018/01/30/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2018-01-30_xml%E5%B8%83%E5%B1%80%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90view/">源码解析 之 xml布局时如何生成view</a></p>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>上面布局解析完之后还不可见，在Activity处于<code>onResume()</code>生命周期时才会展示布局。</p>
<p>​		<code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中回调的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<h3 id="onResume"><a href="#onResume" class="headerlink" title="**onResume **"></a>**onResume **</h3><p>​		在<code>onResume()</code>中会调用<code>WindowManager</code>中的<code>addView()</code>添加<code>DecorView</code>，当<code>WindowManager</code>管理<code>ViewTree</code>的时候会给<code>ViewTree</code>分配一个<code>ViewRootImpl</code>，<code>ViewRootImpl</code>的第一个作用就是管理<code>ViewTree</code>的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个<code>Activity</code>的情况下，每个<code>Activity</code>都有自己的<code>PhoneWindow</code>、<code>DecorView</code>以及<code>WindowManagerImpl</code>，<code>WindowManagerGlobal</code>持有每个<code>Activity</code>的<code>RootView</code>，<code>mWindowSession</code>和<code>mWindow</code>是用来和<code>WMS</code>进行双向通信的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isForward, <span class="type">boolean</span> shouldSendCompatFakeFocus, String reason)</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="comment">// 这里的decor就是上面setContentView加载的DecorView</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">      	<span class="comment">// 每一个Activity都会对应一个WindowManager对象（Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象）</span></span><br><span class="line">        <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">        WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将DecorView add进WindowManager中</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">		。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上面的<code>wm.addView</code>最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法。这个方法中会调用<code>requestLayout()</code>。</p>
<h3 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout()"></a>requestLayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 将布局请求安排到消息队列中，以便在下一个消息循环中执行。</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 获取 Looper 并创建同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">          	<span class="comment">// 调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即在下一个VSync到来时会执行TraversalRunnable--&gt;doTraversal()---&gt;performTraversals()--&gt;绘制流程。</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的mTraversalRunnable是个Runnable对象</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">		  <span class="comment">// 到这里终于看到了绘制的起点了</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要有以下逻辑：</p>
<ol>
<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>
<li>然后把当前线程的消息队列Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>
<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>
</ol>
<blockquote>
<p>vsync信号是由底层发出的。上层有个类监听vsync的信号，当接收到信号时，就会通过Choreographer向消息队列发送异步消息，这个消息的作用之一就是通知ViewRootImpl去执行测量，布局，绘制操作。</p>
</blockquote>
<h3 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Choreographer 扮演 Android 渲染链路中承上启下的角色</p>
<ol>
<li><strong>承上</strong>：负责接收和处理 App 的各种更新消息和回调，等到 Vsync 到来的时候统一处理。比如集中处理 Input(主要是 Input 事件的处理) 、Animation(动画相关)、Traversal(包括 measure、layout、draw 等操作) ，判断卡顿掉帧情况，记录 CallBack 耗时等</li>
<li><strong>启下</strong>：负责请求和接收 Vsync 信号。接收 Vsync 事件回调(通过 FrameDisplayEventReceiver.onVsync )；请求 Vsync(FrameDisplayEventReceiver.scheduleVsync)</li>
</ol>
<h4 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.handleResumeActivity(IBinder, <span class="type">boolean</span>, <span class="type">boolean</span>, String) (android.app) </span><br><span class="line">--&gt;WindowManagerImpl.addView(View, LayoutParams) (android.view) </span><br><span class="line">  --&gt;WindowManagerGlobal.addView(View, LayoutParams, Display, Window) (android.view) </span><br><span class="line">    --&gt;ViewRootImpl.ViewRootImpl(Context, Display) (android.view) </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>看看Choreographer 的代码，Choreographer和Looper一样 是线程单例的。接着看看Choreographer构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        <span class="comment">//使用当前线程looper创建 mHandler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">        <span class="comment">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">                : <span class="literal">null</span>;</span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class="line">        mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建5个Callback队列，</span></span><br><span class="line">		<span class="comment">// 也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。</p>
<p>回到原来的调用流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requestLayout()</span><br><span class="line">	scheduleTraversals()</span><br><span class="line">		 mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br></pre></td></tr></table></figure>

<p>​		postCallback最终调用到postCallbackDelayedInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    	<span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 加上延迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">// 取对应类型的CallbackQueue添加任务</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">        	<span class="comment">//立即执行</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>。</p>
<p>​		没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。</p>
<p>看下mHandler的对这个消息的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                	<span class="comment">// 执行doFrame,即绘制过程</span></span><br><span class="line">                    doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                	<span class="comment">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class="line">                    doScheduleVsync();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                	<span class="comment">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class="line">                    doScheduleCallback(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>直接使用doScheduleCallback方法，看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                    scheduleFrameLocked(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//开启了VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">                <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                	<span class="comment">// 主动申请 VSYNC 信号</span></span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                    msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">                    mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">                mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#scheduleVsyncLocked&quot;</span>);</span><br><span class="line">            mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>
<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>
<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>
</ol>
<p>​		到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>
<p>看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。</p>
<p>有一个叫做FrameDisplayEventReceiver的类，它是专门用来接收vsync信号的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiver</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     	* 接收到VSync脉冲时 回调</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> frame 帧号码，自增</span></span><br><span class="line"><span class="comment">     	*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            mTimestampNanos = timestampNanos;</span><br><span class="line">            mFrame = frame;</span><br><span class="line">            <span class="comment">//  将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// run方法中直接调用了 doFrame 开始一帧的逻辑处理</span></span><br><span class="line">            doFrame(mTimestampNanos, mFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		**onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如果MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()**。这里的mHandler还是上面的FrameHandler。</p>
<p>​		接收到信号之后就走到了doFrame方法</p>
<p>doFrame()：真正执行一帧逻辑的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">			<span class="comment">// 预期执行时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            	<span class="comment">// 计算掉帧数</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                	<span class="comment">// 掉帧超过30帧打印Log提示</span></span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class="line">                ...</span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">            <span class="comment">// Frame标志位恢复</span></span><br><span class="line">            mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录最后一帧时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 按类型顺序 执行任务</span></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markInputHandlingStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markAnimationsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            AnimationUtils.unlockAnimationClock();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        CallbackRecord callbacks;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 根据指定的类型Callback Queue中查找到达执行时间的CallbackRecord</span></span><br><span class="line">            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">            <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交任务类型</span></span><br><span class="line">            <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">                <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class="line">                            + mFrameIntervalNanos;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                                + <span class="string">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class="line">                                + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                                + <span class="string">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                                + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                        mDebugPrintNextFrameTimeDelta = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                    mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 迭代执行队列所有任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">                <span class="comment">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class="line">                c.run(frameTimeNanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                    <span class="comment">//回收CallbackRecord</span></span><br><span class="line">                    recycleCallbackLocked(callbacks);</span><br><span class="line">                    callbacks = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">        <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">        <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            	<span class="comment">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class="line">                ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//取出Runnable执行run()</span></span><br><span class="line">                ((Runnable)action).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>
<p>​		在编舞者创建的时候会创建五个任务队列来排队要处理的任务，当我们向编舞者post一个任务后会触发编舞者对绘制帧的申请，绘制帧的申请通过FrameDisplayEventReceiver实现的，它的父类实现了对VSync的监听，当收到信号后将自身封装成了一个Runnable然后通过Handler发送到任务队列中，这个Runnable的run方法中执行的就是doFrame方法。doFrame方法里会遍历前面提到的五个队列然后依次执行他们注册的callback。</p>
<p>大致总结一下：</p>
<ol>
<li>ViewRootImpl的<strong>requestLayout</strong>方法中会执行<code>ViewRootImpl.scheduleTraversals()</code> 方法，这个方法建立同步屏障，优先处理异步消息。通过 <code>Choreographer.postCallback()</code> 方法提交了任务 <code>mTraversalRunnable</code>，这个任务就是负责 View 的测量，布局，绘制。</li>
<li><code>Choreographer.postCallback()</code> 方法通过 <code>DisplayEventReceiver.nativeScheduleVsync()</code> 方法向系统底层注册了下一次 <code>vsync</code> 信号的监听。当下一次 <code>vsync</code> 来临时，系统会回调其 <code>dispatchVsync()</code> 方法，最终回调 <code>FrameDisplayEventReceiver.onVsync()</code> 方法。</li>
<li><code>FrameDisplayEventReceiver.onVsync()</code> 方法中取出之前提交的 <code>mTraversalRunnable</code> 并执行。这样就完成了一次绘制流程。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6895735092438630407?searchId=20240409145813D97E60FCD44F8F0C87AA#heading-2">View 在什么时间点被测量？</a></p>
<h3 id="performTraversals"><a href="#performTraversals" class="headerlink" title="performTraversals"></a>performTraversals</h3><p>看一下performTraversals的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># ViewRootImpl </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DecorView 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">layoutRequested</span> <span class="operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">// 此处可能会调用 performMeasure 方法</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != <span class="literal">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="comment">// 如果 lp.horizontalWeight 或 lp.verticalWeight 大于 0 则重新调用 performMeasure 测量</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            layoutRequested = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">didLayout</span> <span class="operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performMeasure</span><span class="params">(<span class="type">int</span> childWidthMeasureSpec, <span class="type">int</span> childHeightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="type">int</span> desiredWindowWidth,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> desiredWindowHeight)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">     	 <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="type">int</span> xoff, <span class="type">int</span> yoff,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DecorView是一个FrameLayout下面会直接进入FrameLayout的measure方法，参数就是上面生成的childWidthMeasureSpec和childHeightMeasureSpec。</p>
<p>​		<strong>DecorView 的测量规格由窗口的尺寸和其 LayoutParams 共同确定，而普通 View 的测量规格由父 View 的 MeasureSpec 和自身的 LayoutParams 决定，就是measureChildWithMargins方法，MeasureSpec 确定后，就可以在 onMeasure() 方法中确定 View 的测量宽高。</strong></p>
<p>​		<strong>对于 ViewGroup，除了要完成自己的测量，还要遍历调用子元素的 measure() 方法之后才能确定自己的值，而 View 只需要通过 measure() 方法就能确定测量规格。</strong></p>
<p>​		View 的测量过程由 View 的 measure() 方法完成，measure() 方法是一个 final 类型的方法，子类不能重写。</p>
<p>mView.measure -&gt; View::measure -&gt; FrameLayout.onMeasure</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">	<span class="comment">// 处理子view的measure</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth = Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight = Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                        mMatchParentChildren.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置在测量完子View后结合子View的情况设置自身的measure值</span></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6904192359253147661#heading-5">https://juejin.cn/post/6904192359253147661#heading-5</a></p>
<h4 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h4><h5 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="**MeasureSpec **"></a>**MeasureSpec **</h5><p>MeasureSpec是一个32位的int值，用于描述View的大小和模式。它的高2位表示模式（mode），低30位表示大小（size）MeasureSpec有三种模式：</p>
<ol>
<li><p>精确模式（<strong>MeasureSpec.EXACTLY</strong>）：在这种模式下，View的大小已经确定，为SpecSize所指定的值。例如，当我们将控件的layout_width或layout_height指定为具体数值或者为<strong>MATCH_PARENT</strong>时，都是控件大小已经确定的情况，都是精确尺寸</p>
</li>
<li><p>最大模式（<strong>MeasureSpec.AT_MOST</strong>）：在这种模式下，父控件给出的是最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。例如，当控件的layout_width或layout_height指定为<strong>WRAP_CONTENT</strong>时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。</p>
</li>
<li><p>未指定模式（<strong>MeasureSpec.UNSPECIFIED</strong>）：在这种模式下，父控件不会干涉子View想要多大的尺寸，子View可以随意使用空间，不受限制。例如，在ScrollView或NestedScrollView中，子View的测量模式可能会被设置为MeasureSpec.UNSPECIFIED，这样子View就可以根据自己的内容来决定自己的大小。</p>
</li>
</ol>
<p><strong>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求</strong></p>
<ul>
<li><p><strong>mode的值</strong></p>
<p>-<strong>2147483648</strong>   对应的二进制表示是 <code>0b10000000000000000000000000011000</code>。在这个二进制中，最低的两位 <code>00</code> 表示测量模式为 <code>AT_MOST</code>。 </p>
<p><strong>1073742099</strong> 对应的二进制表示是 <code>0b10000000000000000000000100100011</code>。在这个二进制中，最低的两位 <code>11</code> 表示测量模式为 <code>EXACTLY</code>。</p>
</li>
<li><p><strong>ViewGroup独有的measureChildWithMargins</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed, <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>以LinearLayout为例 解析Measure过程</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先分析下Android View 的结构：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>我们写的布局最终会add到上面图片的FrameLayout中。</p>
<p>然后开始FrameLayout的measure方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;  </span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>measureChildWithMargins的源码就是上面的ViewGroup的Measure的代码。</p>
<p>上面的performTraversals方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br></pre></td></tr></table></figure>

<p>再结合view视图层次DecorView的下一级是ViewRoot这是个LinearLayout。ViewRoot 是系统的View，它的LayoutParams默认都是match_parent。</p>
<p>根据上面的计算规则：</p>
<p>ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size。</p>
<p><strong>目前ViewRoot的measure方法的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。</strong></p>
<p>measure方法会调用onMeasure方法开启计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout：</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewRoot的子view有两个ViewStub和id.content.</p>
<p>调用ViewRoot.measure后会调用，LinearLayout 的onMeasure 方法开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用。</p>
<p>根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿<strong>ViewRoot 的MeasureSpec</strong> 和 <strong>android.R.id.content的LayoutParams</strong> 做计算了，计算过程就是调用getChildMeasureSpec的方法。</p>
<p>来看下计算过程，首先ViewRoot.measure的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。content的width和height都是matchparent。那么看下getChildMeasureSpec方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 只看这个分支</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// 根据条件走到这个分支</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 后传递给content的Measure方法</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>id&#x2F;content是个FrameLayout然后又开启了新的计算流程。</p>
<p>这个计算流程就开始计算我们自己写的布局了，再看下原布局。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先应该是先计算最外面的LinearLayout，根据规则LinearLayout的measure(int widthMeasureSpec, int heightMeasureSpec)的两个MeasureSpec的mode都应该是<strong>EXACTLY</strong></p>
<p>然后开启LinearLayout的onMeasure方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后根据LinearLayout的measure结合TextView的LayoutParams计算得到传递给TextView的MeasureSpaec。</p>
<p>这里看看LinearLayout的measure的源码，因为orientation&#x3D;”vertical”所以会走measureVertical(widthMeasureSpec, heightMeasureSpec);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>; <span class="comment">// 总高度，子控件累加总高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大子控件的宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子view测量状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">alternativeMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 没有设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weightedMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allFillParent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 子控件全设置match_parent</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子控件累加总权重（子控件设置了layout_weight）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();<span class="comment">// 子控件总数量</span></span><br><span class="line"><span class="comment">// 这里获取了LinearLayout的Mode</span></span><br><span class="line">  	<span class="comment">// 根据上面分析widthMode都是EXACTLY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matchWidth</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 有子View宽度设置为match_parent</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skippedMeasure</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否跳过重新测量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">baselineChildIndex</span> <span class="operator">=</span> mBaselineAlignedChildIndex; <span class="comment">// 基线子view</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 跟setMeasureWithLargestChildEnabled()有关</span></span><br><span class="line">		<span class="comment">// 当设定为true，所有有设定了weight的子View的最小高度是：最大的View的高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useLargestChild</span> <span class="operator">=</span> mUseLargestChild;</span><br><span class="line"><span class="comment">// 最大子控件的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestChildHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">consumedExcessSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 需要测量的子View总数，不需要测量指的是设定了weight</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nonSkippedChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子view数量开启循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 测量view为null占据的高度，默认返回0</span></span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonSkippedChildCount++;</span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取当前子view的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 处理 weight</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 判断当前子view的height == 0 且 weight &gt; 0  </span></span><br><span class="line">      	<span class="comment">// 根据布局来看 useExcessSpace应该为false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useExcessSpace</span> <span class="operator">=</span> lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 子View的高度是具体的，可以这直接算出来，不需算子View的高度</span></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="literal">true</span>; <span class="comment">// 该子View直接忽略二次计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// useExcessSpace 为false  无法精确计算子View</span></span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">              <span class="comment">// 假设为true的话 让子view的height为WRAP_CONTENT</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">				<span class="comment">// 判断Weight的值，为0则usedHeight为mTotalLength  mTotalLength表示目前为止已经测量过的子视图的总高度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">usedHeight</span> <span class="operator">=</span> totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">          	<span class="comment">// 开始走getChildMeasureSpec流程。 这里是获取TextView的MeasureSpec 然后走它的onMeasure方法</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line">				<span class="comment">// 获取child的高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">          	<span class="comment">// 获取总共的长度 </span></span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                    + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                    + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="literal">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span> lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 底部是否有分割线，计算最高高度</span></span><br><span class="line">    <span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置了 measureWithLargestChild 且 总高度无法确定，需要重新计算 mToatalLength</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 添加padding</span></span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查最小高度</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据heightMeasureSpec计算最后结果，heightSizeAndState存储最终的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSizeAndState</span> <span class="operator">=</span> resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingExcess</span> <span class="operator">=</span> heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 简单来说就是 skippedMeasure为true说明之前的测量被跳过了需要重新测量</span></span><br><span class="line">  	<span class="comment">// 或者使用了Weight属性 要启动二次测量</span></span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">            || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">      	<span class="comment">// 计算总的weight，mWidgetSum是外部设定，totalWeight是首次计算出来的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">remainingWeightSum</span> <span class="operator">=</span> mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">childWeight</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 计算分配的值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> (<span class="type">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">              	<span class="comment">// 剩余分配高度</span></span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">              	<span class="comment">// 剩余比重总和</span></span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                  	<span class="comment">// 子View直接是largestChildHeight</span></span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// 子view是没有height，直接为分配高度</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子View有height，另外还要加上分配的高度</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">              	<span class="comment">// 重新测量子View</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span>  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">          	<span class="comment">// 计算子View的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span></span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">childExtra</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LinearLayout的onMeasure中的child.measure启动了TextView的onMeasure():</p>
<p>源码就不展示了，大概就是根据传入的获取MeasureSpec计算自己的宽度和高度，然后通过setMeasuredDimension方法将获取的值赋值给mMeasuredWidth和mMeasuredHeight。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个值就是layout进行定位的值。</p>
<h4 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h4><p>回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>

<p>measure执行完之后就该执行layout了，mView.getMeasuredWidth()和mView.getMeasuredHeight()就是上个阶段计算得到的值。</p>
<p>还是先看FrameLayout的layout干了啥</p>
<p>FrameLayout没有自己实现layout函数，得看ViewGroup里的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没啥东西，还是得看super.layout(l, t, r, b);的实现，也就是View中的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      .....</span><br><span class="line">     <span class="comment">//设置View位于父视图的坐标轴  主要是初始化了四个值  mLeft  mTop  mRight mBottom</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> setFrame(l, t, r, b); </span><br><span class="line">      <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">              ViewDebug.trace(<span class="built_in">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line">          mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">      mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在View中onLayout是空实现，所以回到FrameLayout中看具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> childLeft;</span><br><span class="line">                <span class="type">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                        <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// layout(int l, int t, int r, int b)</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是根据规则获取了child的childLeft和childTop,然后启动child的layout函数。</p>
<p>这里看一下view的坐标系</p>
<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/cc5c57e82f5346e0ad194f914edd0e5d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png" style="zoom: 50%;" />

<p>left和top坐标确定了view左上角的位置，right和bottom坐标确定了右下角的位置。</p>
<p>right - left 为view的宽(width)  bottom - top 为view的高(height)。</p>
<p>Layout流程就这些没啥好说的。</p>
<h4 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h4><p>再回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br></pre></td></tr></table></figure>

<p>FrameLayout和ViewGroup都没有重写draw方法，所以我们看下View中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         *      7. If necessary, draw the default focus highlight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="type">int</span> saveCount;</span><br><span class="line">				<span class="comment">// 绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShowingLayoutBounds()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;re done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程用这张图片概括一下，循环的入口是draw方法。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/webp-20231215160503207" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>View 绘制主要包含 3 大流程：</p>
<ul>
<li><strong>measure（测量）</strong>：主要用于确定 View 的测量宽&#x2F;高。</li>
<li><strong>layout（布局）</strong>：主要用于确定 View 在父容器中的放置位置。</li>
<li><strong>draw（绘制）</strong>：结合前面两步结果，将 View 真正绘制到屏幕上。</li>
</ul>
<p>Android 中，主要有两种视图：<code>View</code>和<code>ViewGroup</code>，其中：</p>
<ul>
<li>**<code>View</code>**：就是一个独立的视图</li>
<li>**<code>ViewGroup</code>**：一个容器组件，该容器可容纳多个子视图，即<code>ViewGroup</code>可容纳多个<code>View</code>或<code>ViewGroup</code>，且支持嵌套。</li>
</ul>
<p>虽然<code>ViewGroup</code>继承于<code>View</code>，但是在 View 绘制三大流程中，某些流程需要区分<code>View</code>和<code>ViewGroup</code>，它们之间的操作并不完全相同，比如：</p>
<ul>
<li><code>View</code>和<code>ViewGroup</code>都需要进行 measure，确定各自的测量宽&#x2F;高。<code>View</code>只需直接测量自身即可，而<code>ViewGroup</code>通常都必须先测量所有子View，最后才能测量自己</li>
<li>通常<code>ViewGroup</code>先定位自己的位置（<code>layout</code>），然后再定位其子View 位置（<code>onLayout</code>）</li>
<li><code>View</code>需要进行 draw 过程，而<code>ViewGroup</code>通常不需要（当然也可以进行绘制），因为<code>ViewGroup</code>更多作为容器存在，起存储放置功能</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404101505151.webp" alt="img"></p>
<p>​		View的绘制流程从performTraversals方法开始，首先调用的是performMeasure()方法，开启测量的流程。performMeasure() 方法会调用 DecorView 的 measure() 方法，在 measure() 方法中又会调用自己的 onMeasure() 方法。DecorView 的 onMeasure() 方法会调用父类 FrameLayout 的 onMeasure() 方法，在 FrameLayout 的 onMeasure() 方法中，会调用子元素的 onMeasure() 方法测量子元素的宽高，接着子元素会重复父容器的 measure 过程，如此反复完成整个 View 树的遍历。</p>
<p>​		要知道当前View的MeasureSpec 由上一级的MeasureSpec 和自己的LayoutParams 决定的。最顶层的DecorView 在执行performMeasure方法时获取的MeasureSpec 是由屏幕的宽高和自己的LayoutParams 一起来决定的。</p>
<p><strong>measure（测量）:</strong> ViewGroup会先根据上级View传入的MeasureSpec 来使用getChildMeasureSpec方法获取子View的MeasureSpec ，然后调用子View的onMeasure方法将MeasureSpec 传递给子View。在这之后ViewGroup会根据测量的子View的结果和自己和MeasureSpec 来计算自己实际的大小。普通的View就可以直接根据自己的MeasureSpec 来计算自己的大小。</p>
<p><strong>layout（布局）：</strong>从performLayout到FrameLayout 的onLayout方法，传入的坐标是（0，0，屏幕的宽度，屏幕的高度）。首先通过layout方法确定自己的坐标，然后调用layoutChildren方法计算子View的坐标。调用子View的onLayout方法传递过去。</p>
<p><strong>draw（绘制）：</strong></p>
<p>View 绘制分为下面 6 步：</p>
<ol>
<li>绘制背景</li>
<li>保存 Canvas 图层为后续淡出做准备（可选）</li>
<li>绘制 View 的内容</li>
<li>绘制子 View (dispatchDraw)</li>
<li>绘制淡出边缘并恢复 Canvas 图层（可选）</li>
<li>绘制装饰（比如 foreground 和 scrollbar）</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ee5d3bb5ab90">Android - View 绘制流程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6952624592514973732">requestLayout竟然涉及到这么多知识点</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6863756420380196877">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7017452765672636446#heading-8">Android invalidate&#x2F;postInvalidate&#x2F;requestLayout 彻底厘清</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6904518722564653070?searchId=202403061612369260ECC8F072D9103CB2#heading-2">比较一下requestLayout和invalidate方法</a></p>
<h1 id="Android输入系统"><a href="#Android输入系统" class="headerlink" title="Android输入系统"></a>Android输入系统</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fanglongxiang/p/14091511.html">Android10_原理机制系列_事件传递机制 </a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7203989318271221816">[Android输入系统] Socket连接的建立</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7171130176158302245#heading-3">Android图形系统（五）番外篇：触摸事件详解</a></p>
<h2 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h2><p><code>InputManagerService</code> 是 Android 系统中负责管理输入事件（如触摸、按键、轨迹球等）的服务。作为系统服务的一部分，它是 Android 输入系统的核心组件之一，主要职责包括输入设备管理、事件处理和分发、焦点管理、手势识别和安全性等。<code>InputManagerService</code> 确保用户与设备的交互能够顺畅且安全地进行。system_server的逻辑属于system_server进程不属于应用进程。</p>
<p><code>InputManagerService</code> 的创建过程如下：</p>
<ol>
<li><strong>系统启动</strong>：Android 设备启动时，<code>Zygote</code> 进程先启动，并创建 <code>SystemServer</code> 进程。</li>
<li><strong>启动系统服务</strong>：<code>SystemServer</code> 进程启动后，按预定顺序启动各种系统服务，包括 <code>InputManagerService</code>。</li>
<li><strong>创建 InputManagerService</strong>：<code>SystemServer</code> 创建 <code>InputManagerService</code> 实例，并将其注册到系统服务管理器（<code>ServiceManager</code>）中，使其他组件可以访问。</li>
<li><strong>初始化输入设备</strong>：<code>InputManagerService</code> 启动后，初始化系统中的输入设备，并开始监听输入事件。</li>
<li><strong>准备就绪</strong>：完成初始化后，<code>InputManagerService</code> 为系统和应用程序提供输入管理服务。</li>
</ol>
<h2 id="InputManagerService创建"><a href="#InputManagerService创建" class="headerlink" title="InputManagerService创建"></a>InputManagerService创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WindowManagerService</span> <span class="variable">wm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputManagerService</span> <span class="variable">inputManager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建IMS对象</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> <span class="title class_">InputManagerService</span>(context);</span><br><span class="line">        wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">        <span class="comment">//注册服务：&quot;input&quot;</span></span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">                <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        inputManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">InputManagerService</span> <span class="variable">inputManagerF</span> <span class="operator">=</span> inputManager;</span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputManagerF != <span class="literal">null</span>) &#123;</span><br><span class="line">                inputManagerF.systemRunning();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, BOOT_TIMINGS_TRACE_LOG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SystemServer中 关于IMS主要看3个内容：</p>
<ul>
<li>new InputManagerService()，最后进入native 最终创建了InputManager及一系列相关内容</li>
<li>inputManager.setWindowManagerCallbacks(），设置了回调，这里说明了 最终如何回调到PhoneWindowManager。</li>
<li>inputManager.start()，主要是IntputManager中两个线程运行起来。InputReaderThread读取和处理，InputDispatcherThread派发。</li>
</ul>
<p>下面是流程中几个重要的对象：</p>
<ul>
<li><p>EventHub：创建InputReader时 可以看到先创建了EventHub作为参数。</p>
<p>EventHub 通过Linux内核的INotify与Epoll机制 监听设备，可直接访问 设备节点。通过 getEvents() 方法 读取设备节点的原始输入事件 数据。</p>
<p>关于 EventHub的创建 这里不讨论了，这里只需简单了解它上面一点就可以了。它涉及内核和一些机制，暂时我也还不熟悉，哈哈。</p>
</li>
<li><p>InputReader：负责输入事件的获取。在独立线程（InputReaderThread）中 循环执行，有以下几个功能：</p>
<p>功能1-通过 EventHub 不断 <strong>获取设备节点的 原始输入数据</strong> 。</p>
<p>功能2-然后 <strong>进行加工处理后 交由 InputDispatcher分派</strong> 。</p>
<p>功能3-它还有 <strong>管理 输入设备列表和配置</strong> 。</p>
</li>
<li><p>InputDispatcher：负责输入事件的派发。在独立线程（InputDispatcherThread）中运行，其保存有WMS的所有窗口信息。</p>
<p>在接收到 InputReader 的输入事件后，会在窗口信息中找到合适的窗口并派发消息。同时还会监控ANR的产生。</p>
</li>
<li><p>InputReaderThread、InputDispatcherThread：因为InputReader 和 InputDispatcher都是耗时操作，因此创建 单独线程 来运行他们。这就是他们运行的线程。</p>
</li>
</ul>
<h2 id="输入事件中的模块"><a href="#输入事件中的模块" class="headerlink" title="输入事件中的模块"></a>输入事件中的模块</h2><p>Android输入系统，主要包含以下几个模块：</p>
<p>发送端：运行在system_server进程，主要运行在<code>InputReaderThread</code>和<code>InputDispatcherThread</code>。</p>
<ul>
<li><code>InputReader</code>：这个模块主要负责从硬件获取输入，转换成事件<code>Event</code>，传给<code>InputDispatcher</code>。</li>
<li><code>InputDispatcher</code>：将<code>InputReader</code>传递过来的事件分发给相应的窗口，并且监控ANR。</li>
</ul>
<p>接收端：运行在应用程序进程，运行在UI线程。</p>
<ul>
<li><code>InputEventReceiver</code>：在App端接收按键，并进行分发。</li>
<li><code>View</code>和<code>Activity</code>：接收按键并进行处理。</li>
</ul>
<p>基础服务：</p>
<ul>
<li><code>InputManagerService</code>：负责<code>InputReader</code>和<code>InputDispatcher</code>的创建。</li>
<li><code>WindowManagerService</code>：管理<code>InputManager</code>与<code>Window</code>及<code>AMS</code>之间的通信。</li>
</ul>
<p>通信机制：<code>socket</code>：发送端和接收端跨进程，采用的是socket的通信机制。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/wms_ims.png" alt="wms_ims"></p>
<p><strong>说明：</strong></p>
<ul>
<li>图中<strong>3个红色虚线框：</strong> 即下面输入事件传递 介绍的3部分内容。IMS中事件的读取和派发；WMS中Window获取事件和传递；View中事件的传递和处理。</li>
<li>图中<strong>2种颜色区域：</strong> 标识2个进程。system_server 和 应用进程。</li>
<li>图中<strong>红色实线箭头：</strong> 文章介绍的 事件传递的 主要过程。</li>
<li>图中<strong>2个红色虚线箭头：</strong> 列出了 两个比较常见的policy拦截的大致阶段 (当然不止这两个)，说明了最终如何回调到PhoneWindowManager的同名方法。</li>
</ul>
<h2 id="事件流程跟踪"><a href="#事件流程跟踪" class="headerlink" title="事件流程跟踪"></a>事件流程跟踪</h2><p>在 startOtherServices()中，创建IMS后，设置了回调，最后有 <code>inputManager.start();</code> ，这个就是 两个线程运行起来 并执行了 threadLoop() 的起点。threadLoop() 会循环执行，InputReaderThread的threadLoop()方法里面执行的就是InputReader，他的作用2就是对获取的事件进行加工处理后 交由 InputDispatcher分派。</p>
<p>具体的处理先不看，<strong>输入事件 由InputReader 获取处理后，传递到InputDispatcher，封装成EventEntry并加入mInboundQueue 队列。</strong>之后就到了InputDispatcherThread线程的逻辑。根据先进先出原则依次处理入队的事件。</p>
<p>取出事件后进行类型判断然后进行一系列的处理，<strong>最终是将事件等信息封装为InputMessage， 通过InputChannel将这个消息发送出去。</strong></p>
<p>上面只是大概总结了一下IMS段做的一些事情，最后消息通过InputChannel发送到目标窗口的进程了。</p>
<blockquote>
<p>在 Android 的输入系统中，<code>InputChannel</code> 是一个用于在不同进程或线程之间传递输入事件的通道。它是一个底层组件，用于在应用程序和系统服务（如 <code>InputManagerService</code>）之间进行输入事件的传输。</p>
</blockquote>
<p>下面到了WMS接收事件，此时WMS所在的进程就是当前的应用进程。</p>
<p>在ViewRootImpl的setView() 方法中会创建一个WindowInputEventReceiver对象， 创建的过程中重要做了这么几件事情：1.在native层创建NativeInputEventReceiver，创建的过程中会将inputChannel封装到mInputConsumer。2.执行initialize()方法，在里面会在主线程的<strong>Looper</strong>中注册输入事件的监听，<strong>当Looper监听到有输入事件时，会回调 NativeInputEventReceiver的handleEvent()方法。</strong>handleEvent()方法会从InputChannel读取信息，并处理保存事件到inputEvent然后回调java层的 InputEventReceiver.dispatchInputEvent。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> consumeBatches, <span class="type">nsecs_t</span> frameTime, <span class="type">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> skipCallbacks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">//从InputChannel读取信息，并处理保存事件到inputEvent，参考2.4.1</span></span><br><span class="line">        <span class="type">status_t</span> status = mInputConsumer.<span class="built_in">consume</span>(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//回调java层的 InputEventReceiver.dispatchInputEvent，参考2.4.2</span></span><br><span class="line">                env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>ViewRootImpl</code> 是 Android 中负责将视图（<code>View</code>）层次结构附加到窗口并进行布局、绘制等操作的内部类。</p>
<p><code>setView()</code> 方法是 <code>ViewRootImpl</code> 中的一个关键方法，它用于设置视图层次结构的根视图，并启动视图的布局和绘制过程。</p>
<p><code>WindowInputEventReceiver</code> 是 Android 系统中用于接收输入事件的类。</p>
<p><code>NativeInputEventReceiver</code> 是 Android 输入系统的一部分，用于在原生代码层接收来自输入设备的事件。</p>
</blockquote>
<p>WindowInputEventReceiver是继承自InputEventReceiver的也就是回调了WindowInputEventReceiver的dispatchInputEvent方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">InputEventReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInputEvent</span><span class="params">(InputEvent event)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (processedEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//输入事件 加入队列，插到队列尾部</span></span><br><span class="line">            enqueueInputEvent(event, <span class="built_in">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队之后就是在ViewRootImpl::enqueueInputEvent函数中依次处理队列中的事件具体的代码就不贴了，也就是层层函数传递。最终传递到下面这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># ViewRootImpl</span><br><span class="line"><span class="comment">// 这是按键触发的事件 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">KeyEvent</span> <span class="variable">event</span> <span class="operator">=</span> (KeyEvent)q.mEvent;</span><br><span class="line">        ...</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触屏触发的事件</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">MotionEvent</span> <span class="variable">event</span> <span class="operator">=</span> (MotionEvent)q.mEvent;</span><br><span class="line">       <span class="comment">// 处理手写事件</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> mHandwritingInitiator.onTouchEvent(event);</span><br><span class="line">		   ...</span><br><span class="line">        handled = handled || mView.dispatchPointerEvent(event);</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的mView就是DecorView，然后看下DecorView的dispatchKeyEvent实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">keyCode</span> <span class="operator">=</span> event.getKeyCode();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isDown</span> <span class="operator">=</span> action == KeyEvent.ACTION_DOWN;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mWindow.isDestroyed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> cb != <span class="literal">null</span> &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchKeyEvent(event)</span><br><span class="line">                : <span class="built_in">super</span>.dispatchKeyEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isDown ? mWindow.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">            : mWindow.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是Activity的窗口，cb获取到的是Activity，mFeatureId是-1。这里的mWindow是PhoneWindow，即Activity在attach()时 创建的PhoneWindow，在setContentView()过程 通过mDecor.setWindow()传入到DecorView中的。</p>
<p>这个mWindow.getCallback()获取的是Activity本身，即Activity在attach()时setCallback() 传入的this本身。</p>
<p>DecorView没有自己实现dispatchPointerEvent方法，dispatchPointerEvent的具体实现在View类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    	<span class="comment">// 判断是否是触摸事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后这里会调用DecorView的dispatchTouchEvent(event)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">      <span class="keyword">return</span> cb != <span class="literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">              ? cb.dispatchTouchEvent(ev) : <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	这里的cb就是activity然后调用了它的dispatchTouchEvent方法。</p>
<p><strong>总结：</strong></p>
<p>内核将原始事件写入到设备文件中，InputReader 不断地通过 EventHub 将原始事件取出来，解析加工成 KeyEvent、MotionEvent 事件，然后交给 InputDispatcher</p>
<p>InputDispatcher 根据 WMS 提供的窗口信息将事件交给合适的窗口</p>
<p>接着，窗口的 ViewRootImpl 对象再沿着控件树将事件派发给感兴趣的控件，控件对其收到的事件作出响应，更新自己的画面、执行特定的动作</p>
<h1 id="Android-View事件分发"><a href="#Android-View事件分发" class="headerlink" title="Android View事件分发"></a>Android View事件分发</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38015afcdb58">https://www.jianshu.com/p/38015afcdb58</a></p>
<h2 id="分发的事件是什么"><a href="#分发的事件是什么" class="headerlink" title="分发的事件是什么"></a>分发的事件是什么</h2><p>我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的。根据不同动作，主要有以下三种事件类型：<br>1.ACTION_DOWN：<strong>手指刚接触屏幕，按下去的那一瞬间产生该事件</strong><br>2.ACTION_MOVE：<strong>手指在屏幕上移动时候产生该事件</strong><br>3.ACTION_UP：<strong>手指从屏幕上松开的瞬间产生该事件</strong></p>
<p><strong>从ACTION_DOWN开始到ACTION_UP结束我们称为一个事件序列</strong></p>
<p>正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在MotionEvent上来讲无外乎下面两种。<br><strong>1.点击后抬起，也就是单击操作：ACTION_DOWN -&gt; ACTION_UP<br>2.点击后再风骚的滑动一段距离，再抬起：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP</strong></p>
<h2 id="MotionEvent事件分发的三个方法"><a href="#MotionEvent事件分发的三个方法" class="headerlink" title="MotionEvent事件分发的三个方法"></a>MotionEvent事件分发的三个方法</h2><ul>
<li><p><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong><br>通过方法名我们不难猜测，它就是事件分发的重要方法。那么很明显，如果一个MotionEvent传递给了View，那么dispatchTouchEvent方法一定会被调用！<br>返回值：表示是否消费了当前事件。可能是View本身的onTouchEvent方法消费，也可能是子View的dispatchTouchEvent方法中消费。返回true表示事件被消费，本次的事件终止。返回false表示View以及子View均没有消费事件，将调用父View的onTouchEvent方法</p>
</li>
<li><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong><br>事件拦截，当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。特别注意，这是ViewGroup特有的方法，View并没有拦截方法<br>返回值：是否拦截事件传递，返回true表示拦截了事件，那么事件将不再向下分发而是调用View本身的onTouchEvent方法。返回false表示不做拦截，事件将向下分发到子View的dispatchTouchEvent方法。</p>
</li>
<li><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong><br>真正对MotionEvent进行处理或者说消费的方法。在dispatchTouchEvent进行调用。<br>返回值：返回true表示事件被消费，本次的事件终止。返回false表示事件没有被消费，将调用父View的onTouchEvent方法</p>
</li>
</ul>
<p>上面的三个方法可以用以下的伪代码来表示其之间的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//事件是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev))&#123;<span class="comment">//调用onInterceptTouchEvent判断是否拦截事件</span></span><br><span class="line">        consume = onTouchEvent(ev);<span class="comment">//如果拦截则调用自身的onTouchEvent方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);<span class="comment">//不拦截调用子View的dispatchTouchEvent方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;<span class="comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件分发的具体流程"><a href="#事件分发的具体流程" class="headerlink" title="事件分发的具体流程"></a>事件分发的具体流程</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。那么很明显我们先看Activity的dispatchTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Activity：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getWindow().superDispatchTouchEvent(ev)方法发现是Window类当中的一个抽象方法，Window的唯一实现类是PhoneWindow。那么去看PhoneWindow对应的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneWindow</span></span><br><span class="line">    <span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line">    <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个DecorView就是Window的顶级View，我们通过setContentView设置的View是它的子View，</strong>到这里事件已经被传递到我们的顶级View中，一般是ViewGroup。</p>
<p>看看ViewGroup的dispatchTouchEvent方法实现，代码比较多先看下判断是否拦截事件的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// 在开始新的触摸手势时，丢弃所有以前的状态。由于应用切换、ANR 或其他一些状态更改，框架可能已删除上一个手势的 up 或 cancel 事件。</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里会执行 mFirstTouchTarget = null;  mFirstTouchTarget是用来承载处理事件的子View对象，这个对象非常重要，它决定了ViewGroup是否拦截事件</span></span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否拦截事件的标志位</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">    	   <span class="comment">// 判断是否是ACTION_DOWN事件和mFirstTouchTarget是否为null，如果是ACTION_DOWN事件说明是一个新的事件或者mFirstTouchTarget不为null说明有处理事件的子View，会然后会判断子view是否调用了requestDisallowInterceptTouchEvent方法来禁止ViewGroup拦截，判断通过后会调用onInterceptTouchEvent方法来判断最终是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查触摸事件是否来自鼠标设备</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            <span class="comment">// 检查触摸事件的动作是否为按下（ACTION_DOWN）</span></span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            <span class="comment">// 检查是否按下了主要的鼠标按钮</span></span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            <span class="comment">// 调用isOnScrollbarThumb方法检查是否在滚动条拇指上</span></span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getXDispatchLocation(<span class="number">0</span>), ev.getYDispatchLocation(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">// 如果上述条件都为真，表示需要拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件有一个为假，表示不需要拦截该事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码，通过判断actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN和 mFirstTouchTarget !&#x3D; null判断是否拦截，这里有一点要注意的是，根据逻辑 <strong>如果ViewGroup没有拦截ACTION_DOWN事件的话说明这组事件会有子view处理，所以mFirstTouchTarget 不会为null。否则的话mFirstTouchTarget 为null且不是ACTION_DOWN事件说明之前拦截了ACTION_DOWN事件，则后面的事件直接拦截。</strong></p>
<p><strong>mFirstTouchTarget 是否有值决定了ViewGroup是否拦截ACTION_DOWN以外的事件</strong></p>
<p>假设这里不拦截的话，看后续的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="comment">//对子View进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断1，View可见并且没有播放动画。2，点击事件的坐标落在View的范围内</span></span><br><span class="line">            <span class="comment">//如果上述两个条件有一项不满足则continue继续循环下一个View</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 走到这里说明找到了满足的子View了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里会判断mFirstTouchTarget，因为目前还未将事件传递给子view所以还是null 返回的也会是null</span></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="comment">//如果有子View处理即newTouchTarget 不为null则跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">//dispatchTransformedTouchEvent第三个参数child这里不为null，实际调用的是child的dispatchTouchEvent方法，具体实现可以看下面。 重点方法</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX = ev.getX();</span><br><span class="line">                mLastTouchDownY = ev.getY();</span><br><span class="line">                <span class="comment">//当child处理了点击事件，那么会设置mFirstTouchTarget 在addTouchTarget被赋值，具体实现看下面</span></span><br><span class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//子View处理了事件，然后就跳出了for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     ......</span><br><span class="line">         <span class="comment">// 如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false） </span></span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true，子View为GroupView的话会重复上面的逻辑，不是的话会直接走View的dispatchTouchEvent方法。</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">     	<span class="comment">// 这里给mFirstTouchTarget赋值了，也就是上面说的是否处理了事件看mFirstTouchTarget是否为null</span></span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示ViewGroup进行事件传递的逻辑，在dispatchTransformedTouchEvent中会判断子View是否消费了事件，如果消费了会给mFirstTouchTarget赋值否则mFirstTouchTarget仍为null。</p>
<p>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）。会再次调用dispatchTransformedTouchEvent方法，且传入得child为null。</p>
<p>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">           handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">           handled = child.dispatchTouchEvent(event);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>目前为止ViewGroup的事件处理逻辑分析完了。</p>
<p><strong>结论</strong>：</p>
<blockquote>
<p><strong>ViewGroup会遍历所有子View去寻找能够处理点击事件的子View（可见，没有播放动画，点击事件坐标落在子View内部）最终调用子View的dispatchTouchEvent方法处理事件</strong></p>
</blockquote>
<blockquote>
<p><strong>当子View处理了事件则mFirstTouchTarget 被赋值，并终止子View的遍历。</strong></p>
</blockquote>
<blockquote>
<p><strong>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）那么ViewGroup会去处理这个事件（本质调用View的dispatchTouchEvent去处理）</strong></p>
</blockquote>
<p>如果ViewGrop处理这个事件的话会调用View的dispatchTouchEvent。如果不是ViewGroup处理事件，而是普通的View处理事件的话会直接调用View的dispatchTouchEvent方法。</p>
<p>所以最终都会走到View的dispatchTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">//如果窗口没有被遮盖</span></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            <span class="comment">//当前监听事件</span></span><br><span class="line">            <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">            <span class="comment">//需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件,如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//result为false调用自己的onTouchEvent方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		View会先判断是否设置了OnTouchListener，<strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong> <strong>且当前View的dispatchTouchEvent方法就会返回false。</strong>当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法</p>
<p>​		执行顺序：ViewGroup&#x2F;View的onTouch() -&gt; onTouchEvent() -&gt; performClick（） -&gt; onClick()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    ... </span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span></span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p><strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>加一个知识点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">            setLongClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>View的setOnClickListener会默认将View的clickable设置成true。<br>View的setOnLongClickListener同样会将View的longClickable设置成true。</strong></p>
<p><strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong>这里的View的dispatchTouchEvent就会返回false，也就是dispatchTransformedTouchEvent方法会返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的<strong>dispatchTouchEvent是View嵌套调用的</strong>，所以最终的结果会由View层回调到Window层中，看一下原来的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值又会返回到Activity中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个事件循环结束了循环</p>
<p>面试回答的时候为了逻辑清晰，可以定义一个只有一个ViewGroup和View的传递链</p>
<p>Activity - GroupView - View</p>
<p>事件由Activity 开始传递，然后到了GroupView 再到View，事件传递主要的逻辑就是GroupView层和 View层，</p>
<p>​		首先事件会走到Activity 的dispatchTouchEvent方法，里面会调用Window的superDispatchTouchEvent方法去处理事件。</p>
<blockquote>
<p>Window类是抽象类，其唯一实现类PhoneWindow类，superDispatchTouchEvent方法中会调用DecorView的superDispatchTouchEvent方法，而superDispatchTouchEvent方法中会调用ViewGroup的dispatchTouchEvent()方法。</p>
</blockquote>
<p>​		回到原来的逻辑，目前事件传递到了ViewGroup层，Window的superDispatchTouchEvent方法中会调用DecorView的事件分发方法。DecorView就是个FrameLayout，所以事件到了Viewgroup层。</p>
<p>​		Viewgroup的dispatchTouchEvent方法的逻辑，首先逻辑开始会判断要不要拦截当前事件，判断是否拦截会有两个判断条件。一个是当前的action事件是否为down事件，还有一个就是子View是否处理了事件的标志位。如果是down事件或者标志位不等于null会进行第二次判断，判断子view是否禁止当前父view拦截事件。默认是false，然后会调用onInterceptTouchEvent方法判断是否拦截默认是不拦截的。</p>
<p>​		如果既不是ACTION_DOWN事件，mFirstTouchTarget&#x3D;&#x3D;null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定后面move和up事件都会被拦截，因为如果没拦截的话mFirstTouchTarget不会为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    			<span class="comment">// 判断子view是否禁止当前父view拦截事件</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​		如果判断不拦截的话就会遍历所有的子view寻找目标的view，判断条件有两个：View可见并且没有播放动画、点击事件的坐标落在View的范围内。</p>
<p>​		如果寻找不到的话就会调用ViewGroup的父类，也就是View的dispatchTouchEvent方法。因此会执行ViewGroup的onTouch() -&gt; onTouchEvent() -&gt; performClick（） -&gt; onClick()，即自己处理该事件，事件不会往下传递。</p>
<p>​		如果找到了目标View的话调用子View的dispatchTouchEvent方法，实现了事件的传递，然后最终也是调用了View的dispatchTouchEvent方法。</p>
<p>​		这个方法首先会判断当前View是否设置了OnTouchListener监听，如果设置了监听且onTouch方法返回了true，那么onTouchEvent不会被调用，且当前的dispatchTouchEvent方法直接返回true。如果返回false的话会接着调用onTouchEvent方法。</p>
<p>​		这个方法会判断clickable和longClickable，只要有一个是true就会消费事件，然后会通过switch case判断事件的类型，再up case中会调用当前view设置的点击事件。</p>
<p>​		目前一整个事件传递从activity到view消费的这么一个逻辑，其实主要还是再Viewgroup和View传递的逻辑。之前说了View 消费的情况，我下面说一下View不消费的情况。</p>
<p>​		View不消费的话ViewGroup同样会走View类的dispatchTouchEvent方法的逻辑，然后调用onTouchEvent方法。如果onTouchEvent方法返回false的话事件会返回到Window层然后再返回到Activity层，也就是一开始说的逻辑，会调用activity的onTouchEvent方法。</p>
<p>​		只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p>​		<strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>View的setOnClickListener会默认将View的clickable设置成true。</p>
<p>View的setOnLongClickListener同样会将View的longClickable设置成true。</p>
<h2 id="事件分发native层"><a href="#事件分发native层" class="headerlink" title="事件分发native层"></a>事件分发native层</h2><p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fanglongxiang/p/14091511.html">https://www.cnblogs.com/fanglongxiang/p/14091511.html</a></strong></p>
<h2 id="事件分发处理嵌套Recyclerview的嵌套滑动冲突"><a href="#事件分发处理嵌套Recyclerview的嵌套滑动冲突" class="headerlink" title="事件分发处理嵌套Recyclerview的嵌套滑动冲突"></a>事件分发处理嵌套Recyclerview的嵌套滑动冲突</h2><p>冲突原因：</p>
<p>​		嵌套滑动机制，<code>ViewGroup</code>（如 <code>RecyclerView</code>、<code>NestedScrollView</code> 等）可以作为嵌套滑动的父视图或子视图。在嵌套滑动的上下文中，父视图可以在不直接拦截触摸事件的情况下参与子视图的滑动处理，通过嵌套滑动的回调方法如 <code>onStartNestedScroll</code>、<code>onNestedScroll</code> 等来实现。但是，如果父视图决定处理嵌套滑动，它可能会通过这些机制间接“拦截”子视图的事件。</p>
<p>解决方式：</p>
<p>​		默认让父视图不要拦截触摸事件，然后在子View滑动到底部之后再允许拦截事件。</p>
<p>思路：</p>
<p>​		当用户开始触摸时（即 <code>ACTION_DOWN</code> 事件发生），记录初始触摸点的 <code>Y</code> 坐标。此外，通过调用 <code>requestDisallowInterceptTouchEvent(true)</code> 通知父视图不要拦截后续的触摸事件，这样可以确保子 <code>RecyclerView</code> 能够接收到完整的滑动事件序列（例如，连续的 <code>ACTION_MOVE</code> 事件）。</p>
<p>​		而当子 <code>RecyclerView</code> 滚动到顶部或底部时，后续的滑动操作能够传递给父 <code>RecyclerView</code>，从而允许父 <code>RecyclerView</code> 进行滑动。</p>
<p>给子View设置OnTouchListener</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildScrollTouchListener</span>(<span class="keyword">private</span> <span class="keyword">val</span> childRecyclerView: RecyclerView) : View.OnTouchListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialY = <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouch</span><span class="params">(v: <span class="type">View</span>, event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                initialY = event.y</span><br><span class="line">                <span class="comment">// 明确地请求父视图不要拦截触摸事件</span></span><br><span class="line">                v.parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">               <span class="comment">// 检查子 RecyclerView 是否能够向上滚动。如果返回 false，表示已经滚动到顶部</span></span><br><span class="line">			  <span class="keyword">val</span> canScrollUp = childRecyclerView.canScrollVertically(-<span class="number">1</span>)</span><br><span class="line">			  <span class="comment">// 检查子 RecyclerView 是否能够向下滚动。如果返回 false，表示已经滚动到底部</span></span><br><span class="line">               <span class="keyword">val</span> canScrollDown = childRecyclerView.canScrollVertically(<span class="number">1</span>)</span><br><span class="line">		      <span class="comment">// 比较当前触摸点的 Y 坐标和初始触摸点的 Y 坐标，如果当前的 Y 大于初始的 Y，说明是向上滚动的手势</span></span><br><span class="line">			 <span class="keyword">val</span> isScrollingUp = event.y &gt; initialY</span><br><span class="line">			 <span class="comment">// 同理，如果当前的 Y 小于初始的 Y，说明是向下滚动的手势</span></span><br><span class="line">   			 <span class="keyword">val</span> isScrollingDown = event.y &lt; initialY</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((isScrollingUp &amp;&amp; !canScrollUp) || (isScrollingDown &amp;&amp; !canScrollDown)) &#123;</span><br><span class="line">                    <span class="comment">// 如果子 RecyclerView 滑动到顶部并且继续向上滑，或者滑动到底部并继续向下滑</span></span><br><span class="line">                    <span class="comment">// 则允许父 RecyclerView 捕获滑动事件</span></span><br><span class="line">                    v.parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不消耗事件，让子 RecyclerView 正常处理滑动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置给子Recyclerview</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">holder.childRecyclerView.apply &#123; setOnTouchListener(ChildScrollTouchListener(<span class="keyword">this</span>)) &#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在事件传递到ViewGroup之后会有这么个判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取子View是否禁止拦截</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">      <span class="comment">// onInterceptTouchEvent默认是不拦截的</span></span><br><span class="line">      intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">      ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 不拦截</span></span><br><span class="line">         intercepted = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h1><h2 id="自定义-View实现方式"><a href="#自定义-View实现方式" class="headerlink" title="自定义 View实现方式"></a>自定义 View实现方式</h2><p>总结下来有三种：</p>
<ul>
<li>继承某个控件，然后对它的一些功能进行修改，或者删除添加</li>
<li>将多个控件组合在一起形成一个新的View</li>
<li>继承 View &#x2F; ViewGroup 类，重写 <strong><code>onMeasure()</code><strong>、</strong><code>onLayout()</code><strong>、</strong><code>onDraw()</code></strong> 三大方法，从 0 到 1 创造一个新的控件。</li>
</ul>
<p>代码示例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaterialEdit</span>(context: Context,attrs:AttributeSet) :</span><br><span class="line">    AppCompatEditText(context,attrs) &#123; <span class="comment">// 定义一个名为 MaterialEdit 的类，继承自 AppCompatEditText</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量和变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_SIZE = <span class="number">12.</span>dp  <span class="comment">// 文本大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_MARGIN = <span class="number">8.</span>dp <span class="comment">// 文本边距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> HORIZONTAL_OFFSET = <span class="number">5.</span>dp <span class="comment">// 水平偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> VERTICAL_OFFSET = <span class="number">23.</span>dp <span class="comment">// 垂直偏移量  浮动标签距离view顶部的向下偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> EXTRA_VERTICAL_OFFSET = <span class="number">16.</span>dp <span class="comment">// 便签动画时的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG) <span class="comment">// 创建一个 Paint 对象，用于绘制文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> floatingLabelShown = <span class="literal">false</span> <span class="comment">// 一个标志，表示浮动标签是否正在显示</span></span><br><span class="line">    <span class="keyword">var</span> useFloatingLabel = <span class="literal">false</span> <span class="comment">// 一个标志，表示是否使用浮动标签</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field != value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                <span class="keyword">if</span> (field) &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop + TEXT_SIZE + TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop - TEXT_SIZE - TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">            <span class="keyword">by</span> lazy &#123;</span><br><span class="line">                ObjectAnimator.ofFloat(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.textSize = TEXT_SIZE <span class="comment">// 设置 Paint 的文本大小</span></span><br><span class="line">        <span class="comment">// 获取自定义属性 useFloatingLabel 的值  会触发 set 方法</span></span><br><span class="line">        <span class="keyword">val</span> typeArray = context.obtainStyledAttributes(attrs,R.styleable.MaterialEdit)</span><br><span class="line">        useFloatingLabel = typeArray.getBoolean(R.styleable.MaterialEdit_useFloatingLabel,<span class="literal">true</span>)</span><br><span class="line">        typeArray.recycle() <span class="comment">// 回收 typeArray</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 EditText 中的文本改变时，执行这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        text: <span class="type">CharSequence</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        start: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthBefore: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthAfter: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮动标签正在显示，且文本变为空，那么隐藏浮动标签</span></span><br><span class="line">        <span class="keyword">if</span> (floatingLabelShown &amp;&amp; text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">false</span></span><br><span class="line">            animator.reverse() <span class="comment">// 执行动画的逆向操作，即隐藏浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果浮动标签没有显示，且文本不为空，那么显示浮动标签</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!floatingLabelShown &amp;&amp; !text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">true</span></span><br><span class="line">            animator.start() <span class="comment">// 开始执行动画，即显示浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个方法中绘制 EditText 的界面</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas) <span class="comment">// 调用父类的 onDraw 方法，绘制 EditText 的主体</span></span><br><span class="line">        paint.alpha = (floatingLabelFraction * <span class="number">0xff</span>).toInt() <span class="comment">// 根据动画的进度，设置 Paint 的透明度</span></span><br><span class="line">        <span class="comment">// 计算当前的垂直位置</span></span><br><span class="line">        <span class="keyword">val</span> currentVerticalValue =</span><br><span class="line">            VERTICAL_OFFSET + EXTRA_VERTICAL_OFFSET * (<span class="number">1</span> - floatingLabelFraction)</span><br><span class="line">        <span class="comment">// 在计算出的位置绘制提示文本</span></span><br><span class="line">        hint?.toString()?.let &#123;</span><br><span class="line">            canvas.drawText(</span><br><span class="line">                it,</span><br><span class="line">                HORIZONTAL_OFFSET,</span><br><span class="line">                currentVerticalValue,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义-View-Demo"><a href="#自定义-View-Demo" class="headerlink" title="自定义 View Demo"></a>自定义 View Demo</h1><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的FlowLayout，继承自ViewGroup以管理子视图的布局</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlowLayout</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) : ViewGroup(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水平间距和垂直间距，用于定义子视图之间的间隙</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> horizontalSpacing = <span class="number">20</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> verticalSpacing = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量FlowLayout的尺寸以及其子视图的尺寸</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从MeasureSpec获取宽度的模式和大小</span></span><br><span class="line">        <span class="keyword">val</span> widthMode = MeasureSpec.getMode(widthMeasureSpec)</span><br><span class="line">        <span class="keyword">val</span> widthSize = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化FlowLayout的高度，当前行的宽度和高度</span></span><br><span class="line">        <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> lineWidth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> lineHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子视图进行测量</span></span><br><span class="line">        <span class="keyword">val</span> childCount = childCount</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec)</span><br><span class="line">            <span class="keyword">val</span> childWidth = child.measuredWidth</span><br><span class="line">            <span class="keyword">val</span> childHeight = child.measuredHeight</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前行是否可以继续添加子视图，或者需要换行</span></span><br><span class="line">            <span class="keyword">if</span> (lineWidth + childWidth &gt; widthSize) &#123;</span><br><span class="line">                <span class="comment">// 换行：增加总高度，并重置行宽和行高</span></span><br><span class="line">                height += lineHeight + verticalSpacing</span><br><span class="line">                lineWidth = childWidth</span><br><span class="line">                lineHeight = childHeight</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不换行：更新当前行的宽度和高度</span></span><br><span class="line">                lineWidth += <span class="keyword">if</span> (lineWidth &gt; <span class="number">0</span>) horizontalSpacing + childWidth <span class="keyword">else</span> childWidth</span><br><span class="line">                lineHeight = max(lineHeight, childHeight)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加上最后一行的高度，设置FlowLayout的测量尺寸</span></span><br><span class="line">        height += lineHeight</span><br><span class="line">        setMeasuredDimension(widthSize, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据测量的结果放置子视图的位置</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayout</span><span class="params">(changed: <span class="type">Boolean</span>, l: <span class="type">Int</span>, t: <span class="type">Int</span>, r: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> width = r - l  <span class="comment">// 计算FlowLayout的实际宽度</span></span><br><span class="line">        <span class="keyword">var</span> xPos = paddingLeft  <span class="comment">// 初始化子视图的起始x坐标</span></span><br><span class="line">        <span class="keyword">var</span> yPos = paddingTop  <span class="comment">// 初始化子视图的起始y坐标</span></span><br><span class="line">        <span class="keyword">var</span> lineHeight = <span class="number">0</span>  <span class="comment">// 初始化行高</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有子视图，根据测量结果放置每个子视图的位置</span></span><br><span class="line">        <span class="keyword">val</span> childCount = childCount</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            <span class="keyword">val</span> childWidth = child.measuredWidth</span><br><span class="line">            <span class="keyword">val</span> childHeight = child.measuredHeight</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否需要换行</span></span><br><span class="line">            <span class="keyword">if</span> (xPos + childWidth &gt; width) &#123;</span><br><span class="line">                <span class="comment">// 换行：重置x坐标，更新y坐标，重置行高</span></span><br><span class="line">                xPos = paddingLeft</span><br><span class="line">                yPos += lineHeight + verticalSpacing</span><br><span class="line">                lineHeight = childHeight</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新行高</span></span><br><span class="line">                lineHeight = max(lineHeight, childHeight)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 放置子视图</span></span><br><span class="line">            child.layout(xPos, yPos, xPos + childWidth, yPos + childHeight)</span><br><span class="line">            <span class="comment">// 更新x坐标为下一个子视图的起始位置</span></span><br><span class="line">            xPos += childWidth + horizontalSpacing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="onDraw方法直接绘制元素"><a href="#onDraw方法直接绘制元素" class="headerlink" title="onDraw方法直接绘制元素"></a>onDraw方法直接绘制元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>(context: Context, attrs: AttributeSet?) : View(context, attrs) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">paint</span> <span class="operator">=</span> Paint().apply &#123;</span><br><span class="line">        color = Color.<span class="type">RED</span></span><br><span class="line">        <span class="variable">style</span> <span class="operator">=</span> Paint.Style.<span class="type">FILL</span></span><br><span class="line">        <span class="variable">textSize</span> <span class="operator">=</span> <span class="number">40f</span></span><br><span class="line">        textAlign = Paint.Align.CENTER</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDraw</span><span class="params">(canvas: Canvas)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDraw(canvas)</span><br><span class="line"></span><br><span class="line">        <span class="type">val</span> <span class="variable">width</span> <span class="operator">=</span> width.toFloat()</span><br><span class="line">        <span class="type">val</span> <span class="variable">height</span> <span class="operator">=</span> height.toFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行五个元素均匀排列</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">itemWidth</span> <span class="operator">=</span> width / <span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> (i in <span class="number">0</span> until <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">x</span> <span class="operator">=</span> itemWidth / <span class="number">2</span> + i * itemWidth</span><br><span class="line">            <span class="type">val</span> <span class="variable">y</span> <span class="operator">=</span> height / <span class="number">4</span></span><br><span class="line">            canvas.drawText(<span class="string">&quot;Item$&#123;i + 1&#125;&quot;</span>, x, y, paint)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二行 上面三个元素 下面两个元素</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">itemHeight</span> <span class="operator">=</span> height / <span class="number">4</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">itemPadding</span> <span class="operator">=</span> <span class="number">20f</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">secondRowY</span> <span class="operator">=</span> height * <span class="number">3</span> / <span class="number">4</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">secondRowItemWidth</span> <span class="operator">=</span> width / <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> (i in <span class="number">0</span> until <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">x</span> <span class="operator">=</span> secondRowItemWidth / <span class="number">2</span> + i * secondRowItemWidth</span><br><span class="line">            <span class="type">val</span> <span class="variable">y</span> <span class="operator">=</span> secondRowY - itemPadding - itemHeight / <span class="number">2</span></span><br><span class="line">            canvas.drawText(<span class="string">&quot;Item$&#123;i + 6&#125;&quot;</span>, x, y, paint)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">x1</span> <span class="operator">=</span> secondRowItemWidth / <span class="number">2</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">y1</span> <span class="operator">=</span> secondRowY + itemPadding + itemHeight / <span class="number">2</span></span><br><span class="line">        canvas.drawText(<span class="string">&quot;Item5&quot;</span>, x1, y1, paint)</span><br><span class="line">        <span class="type">val</span> <span class="variable">x2</span> <span class="operator">=</span> secondRowItemWidth * <span class="number">2</span> + secondRowItemWidth / <span class="number">2</span></span><br><span class="line">        canvas.drawText(<span class="string">&quot;Item6&quot;</span>, x2, y1, paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="歌词控件"><a href="#歌词控件" class="headerlink" title="歌词控件"></a>歌词控件</h2><p>思路：</p>
<p>​		歌词显示的思路就是将歌词一行行的画出来，我们首先假设屏幕足够大，那么只需要定位第一行歌词的位置，画出来第一行歌词，然后逐行下移一个固定的距离，再画出下一行歌词，依次类推，整个歌词内容就会全部画在画布上了。</p>
<p>实际实现：</p>
<p>​		首先从屏幕的中间开始，然后纵坐标每次增加文字的高度与到顶部距离之和，依次画出来每行文字。这样，假如屏幕足够大的话，那么所有的歌词就会从屏幕中间开始，依次向下一行行的显示出来。</p>
<p>​		因为使用 StaticLayout 后，一行文字的高度不再固定，所以 y 坐标不再累加固定的文字高度，而是上一行和下一行文字之和的一半+文字间距</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LrcView2</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mLrcPaint = TextPaint() <span class="comment">// 字体画笔</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCurrentTextColor = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mDefaultLabel: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLrcPadding = <span class="number">0f</span> <span class="comment">// 歌词宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mLrcEntryList = mutableListOf&lt;LrcEntry&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mFlag: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mOffset = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mTextGravity = <span class="number">0</span> <span class="comment">// 歌词显示位置，靠左/居中/靠右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mDividerHeight = <span class="number">0f</span> <span class="comment">// 歌词分割线高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCurrentLine = <span class="number">0</span> <span class="comment">// 当前行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mCurrentTextSize = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mAnimationDuration: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mAnimator: ValueAnimator? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> isShowTimeline = <span class="literal">false</span> <span class="comment">// 显示歌词时间线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> ta = getContext().obtainStyledAttributes(attrs, R.styleable.LrcView)</span><br><span class="line">        mCurrentTextSize = ta.getDimension(</span><br><span class="line">            R.styleable.LrcView_lrcTextSize, resources.getDimension(R.dimen.lrc_text_size)</span><br><span class="line">        )</span><br><span class="line">        mCurrentTextColor = ta.getColor(</span><br><span class="line">            R.styleable.LrcView_lrcCurrentTextColor, getResources().getColor(</span><br><span class="line">                R.color.lrc_current_text_color</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        mDefaultLabel = ta.getString(R.styleable.LrcView_lrcLabel)</span><br><span class="line">        mLrcPadding = ta.getDimension(R.styleable.LrcView_lrcPadding, <span class="number">0f</span>)</span><br><span class="line">        mLrcPaint.textSize = <span class="number">60</span> * resources.displayMetrics.scaledDensity</span><br><span class="line">        mTextGravity = ta.getInteger(R.styleable.LrcView_lrcTextGravity, LrcEntry.GRAVITY_CENTER)</span><br><span class="line">        mDividerHeight = ta.getDimension(</span><br><span class="line">            R.styleable.LrcView_lrcDividerHeight, resources.getDimension(</span><br><span class="line">                R.dimen.lrc_divider_height</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        mLrcPaint.isAntiAlias = <span class="literal">true</span></span><br><span class="line">        mLrcPaint.textSize = mCurrentTextSize</span><br><span class="line">        mLrcPaint.textAlign = Paint.Align.LEFT</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> defDuration = resources.getInteger(R.integer.lrc_animation_duration)</span><br><span class="line">        mAnimationDuration =</span><br><span class="line">            ta.getInt(R.styleable.LrcView_lrcAnimationDuration, defDuration).toLong()</span><br><span class="line">        mAnimationDuration =</span><br><span class="line">            <span class="keyword">if</span> (mAnimationDuration &lt; <span class="number">0</span>) defDuration.toLong() <span class="keyword">else</span> mAnimationDuration</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLrcWidth</span><span class="params">()</span></span>: <span class="built_in">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width - mLrcPadding * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">        <span class="keyword">val</span> centerY = height / <span class="number">2</span></span><br><span class="line">        <span class="comment">// 如果歌词为空 则绘制默认提示</span></span><br><span class="line">        <span class="keyword">if</span> (lrcIsEmpty()) &#123;</span><br><span class="line">            mLrcPaint.setColor(mCurrentTextColor)</span><br><span class="line">            <span class="keyword">val</span> staticLayout = StaticLayout.Builder.obtain(</span><br><span class="line">                mDefaultLabel ?: <span class="string">&quot;默认提示为空&quot;</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                (mDefaultLabel ?: <span class="string">&quot;默认提示为空&quot;</span>).length,</span><br><span class="line">                mLrcPaint,</span><br><span class="line">                getLrcWidth().toInt()</span><br><span class="line">            ).setAlignment(Layout.Alignment.ALIGN_CENTER).setLineSpacing(<span class="number">0f</span>, <span class="number">1f</span>)</span><br><span class="line">                .setIncludePad(<span class="literal">false</span>).build()</span><br><span class="line">            drawText(canvas, staticLayout, centerY.toFloat())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> centerLine = getCenterLine()</span><br><span class="line">        <span class="comment">// 将画布原点设置为高度一半的位置</span></span><br><span class="line">        canvas.translate(<span class="number">0f</span>, mOffset)</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">0f</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> mLrcEntryList.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为使用 StaticLayout 后，一行文字的高度不再固定，所以 y 坐标不再累加固定的文字高度，而是上一行和下一行文字之和的一半+文字间距</span></span><br><span class="line">                y += (mLrcEntryList[i - <span class="number">1</span>].height + mLrcEntryList[i].height shr <span class="number">1</span>) + mDividerHeight</span><br><span class="line">            &#125;</span><br><span class="line">            drawText(canvas, mLrcEntryList[i].staticLayout!!, y)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画一行歌词，因为歌词是从上往下绘制的，所以再绘制的过程中需要不断的移动画布原点，但是y是累加的所以需要回到最	  * 开始的位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 歌词中心 Y 坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawText</span><span class="params">(canvas: <span class="type">Canvas</span>, staticLayout: <span class="type">StaticLayout</span>, y: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 保存画布状态</span></span><br><span class="line">        canvas.save()</span><br><span class="line">        <span class="comment">// 将坐标原点移动到垂直居中位置</span></span><br><span class="line">        canvas.translate(mLrcPadding, y - (staticLayout.height shr <span class="number">1</span>))</span><br><span class="line">        staticLayout.draw(canvas)</span><br><span class="line">        <span class="comment">// 回复画布状态</span></span><br><span class="line">        canvas.restore()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载单个歌词文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadLrc</span><span class="params">(lrcFile: <span class="type">File</span>?)</span></span> &#123;</span><br><span class="line">        loadLrc(lrcFile, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载主歌词文件和副歌词文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadLrc</span><span class="params">(mainLrcFile: <span class="type">File</span>?, secondLrcFile: <span class="type">File</span>?)</span></span> &#123;</span><br><span class="line">        runOnUi &#123;</span><br><span class="line">            reset() <span class="comment">// 重置歌词显示</span></span><br><span class="line">            <span class="keyword">val</span> flag = <span class="string">&quot;file://<span class="subst">$&#123;mainLrcFile?.path&#125;</span><span class="subst">$&#123;secondLrcFile?.let &#123; <span class="string">&quot;#<span class="subst">$&#123;it.path&#125;</span>&quot;</span> &#125;</span> ?: &quot;</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line">            setFlag(flag) <span class="comment">// 设置当前加载的歌词标识</span></span><br><span class="line">            <span class="comment">// 使用协程进行异步操作</span></span><br><span class="line">            CoroutineScope(Dispatchers.IO).launch &#123;</span><br><span class="line">                <span class="keyword">val</span> lrcEntries = LrcUtils.parseLrc(</span><br><span class="line">                    arrayOf(mainLrcFile, secondLrcFile).filterNotNull().toTypedArray()</span><br><span class="line">                )</span><br><span class="line">                withContext(Dispatchers.Main) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getFlag() == flag) &#123;</span><br><span class="line">                        onLrcLoaded(lrcEntries) <span class="comment">// 歌词加载完成后的处理</span></span><br><span class="line">                        setFlag(<span class="literal">null</span>) <span class="comment">// 清除歌词标识</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当歌词加载完成后的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLrcLoaded</span><span class="params">(entryList: <span class="type">List</span>&lt;<span class="type">LrcEntry</span>&gt;?)</span></span> &#123;</span><br><span class="line">        entryList?.let &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.isNotEmpty()) &#123;</span><br><span class="line">                mLrcEntryList.addAll(it)</span><br><span class="line">                mLrcEntryList.sort() <span class="comment">// 对歌词条目进行排序</span></span><br><span class="line">                initEntryList() <span class="comment">// 初始化歌词条目</span></span><br><span class="line">                invalidate() <span class="comment">// 重新绘制视图</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化歌词条目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initEntryList</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lrcIsEmpty() || width == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (lrcEntry <span class="keyword">in</span> mLrcEntryList) &#123;</span><br><span class="line">            lrcEntry.<span class="keyword">init</span>(mLrcPaint, getLrcWidth().toInt(), mTextGravity) <span class="comment">// 初始化每个歌词条目</span></span><br><span class="line">        &#125;</span><br><span class="line">        mOffset = (height / <span class="number">2</span>).toFloat() <span class="comment">// 设置垂直偏移量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断歌词是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lrcIsEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mLrcEntryList.isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前加载的歌词标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setFlag</span><span class="params">(flag: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mFlag = flag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前加载的歌词标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFlag</span><span class="params">()</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> mFlag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在主线程上运行指定的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runOnUi</span><span class="params">(runnable: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</span><br><span class="line">            runnable.run()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            post(runnable)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mLrcEntryList.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前在视图中央的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCenterLine</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> centerLine = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> minDistance = <span class="built_in">Float</span>.MAX_VALUE</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> mLrcEntryList.indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abs((mOffset - getOffset(i)).toDouble()) &lt; minDistance) &#123;</span><br><span class="line">                minDistance = abs((mOffset - getOffset(i)).toDouble()).toFloat()</span><br><span class="line">                centerLine = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> centerLine</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取歌词距离视图顶部的距离</span></span><br><span class="line"><span class="comment">     * 采用懒加载方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOffset</span><span class="params">(line: <span class="type">Int</span>)</span></span>: <span class="built_in">Float</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLrcEntryList[line].offset == <span class="built_in">Float</span>.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">var</span> offset = (height / <span class="number">2</span>).toFloat()</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.line) &#123;</span><br><span class="line">                offset -= (mLrcEntryList[i - <span class="number">1</span>].height + mLrcEntryList[i].height shr <span class="number">1</span>) + mDividerHeight</span><br><span class="line">            &#125;</span><br><span class="line">            mLrcEntryList[line].offset = offset</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLrcEntryList[line].offset</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新歌词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 当前播放时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateTime</span><span class="params">(time: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        runOnUi &#123;</span><br><span class="line">            <span class="keyword">if</span> (lrcIsEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@runOnUi</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> line: <span class="built_in">Int</span> = findShowLine(time)</span><br><span class="line">            <span class="keyword">if</span> (line != mCurrentLine) &#123;</span><br><span class="line">                mCurrentLine = line</span><br><span class="line">                <span class="keyword">if</span> (!isShowTimeline) &#123;</span><br><span class="line">                    smoothScrollTo(line)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    invalidate()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分法查找当前时间应该显示的行数（最后一个 &lt;= time 的行数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findShowLine</span><span class="params">(time: <span class="type">Long</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> right = mLrcEntryList.size</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">val</span> middle = (left + right) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> middleTime = mLrcEntryList[middle].time</span><br><span class="line">            <span class="keyword">if</span> (time &lt; middleTime) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (middle + <span class="number">1</span> &gt;= mLrcEntryList.size || time &lt; mLrcEntryList[middle + <span class="number">1</span>].time) &#123;</span><br><span class="line">                    <span class="keyword">return</span> middle</span><br><span class="line">                &#125;</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动到某一行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">smoothScrollTo</span><span class="params">(line: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        smoothScrollTo(line, mAnimationDuration)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束滚动动画</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">endAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAnimator != <span class="literal">null</span> &amp;&amp; mAnimator?.isRunning == <span class="literal">true</span>) &#123;</span><br><span class="line">            mAnimator?.end()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滚动到某一行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">smoothScrollTo</span><span class="params">(line: <span class="type">Int</span>, duration: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> offset = getOffset(line)</span><br><span class="line">        endAnimation()</span><br><span class="line">        mAnimator = ValueAnimator.ofFloat(mOffset, offset)</span><br><span class="line">        mAnimator?.setDuration(duration)</span><br><span class="line">        mAnimator?.interpolator = LinearInterpolator()</span><br><span class="line">        mAnimator?.addUpdateListener &#123; animation: ValueAnimator -&gt;</span><br><span class="line">            mOffset = animation.getAnimatedValue() <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">            invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">        LrcUtils.resetDurationScale()</span><br><span class="line">        mAnimator?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setLabel</span><span class="params">(label: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        runOnUi &#123;</span><br><span class="line">            mDefaultLabel = label</span><br><span class="line">            <span class="keyword">this</span>.invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不涉及到画布的移动就不需要保存状态，直接往上面画就行，只需要计算每个元素的坐标。</p>
<h2 id="圆角的ImageView"><a href="#圆角的ImageView" class="headerlink" title="圆角的ImageView"></a>圆角的ImageView</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义圆角 ImageView 类，继承自 AppCompatImageView</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundImageView</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) :</span><br><span class="line">    androidx.appcompat.widget.AppCompatImageView(context, attrs) &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Path 对象用于绘制圆角矩形路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path: Path = Path()</span><br><span class="line">    <span class="comment">// 定义一个变量用于存储圆角半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cornerRadius: <span class="built_in">Float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 从布局属性中获取自定义属性</span></span><br><span class="line">        <span class="keyword">val</span> typedArray =</span><br><span class="line">            context.theme.obtainStyledAttributes(attrs, R.styleable.RoundedImageView, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取自定义属性的值，如果没有设置，则使用默认值 20f</span></span><br><span class="line">            cornerRadius = typedArray.getDimension(R.styleable.RoundedImageView_cornerRadius, <span class="number">20f</span>)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 回收 TypedArray 对象</span></span><br><span class="line">            typedArray.recycle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 onDraw 方法以实现自定义绘制逻辑</span></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;DrawAllocation&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个矩形，大小与 ImageView 相同</span></span><br><span class="line">        <span class="keyword">val</span> rect = RectF(<span class="number">0f</span>, <span class="number">0f</span>, width.toFloat(), height.toFloat())</span><br><span class="line">        <span class="comment">// 重置路径对象</span></span><br><span class="line">        path.reset()</span><br><span class="line">        <span class="comment">// 向路径中添加一个圆角矩形</span></span><br><span class="line">        path.addRoundRect(rect, cornerRadius, cornerRadius, Path.Direction.CCW)</span><br><span class="line">        <span class="comment">// 使用路径裁剪画布</span></span><br><span class="line">        canvas.clipPath(path)</span><br><span class="line">        <span class="comment">// 调用父类的 onDraw 方法绘制图像</span></span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Android-动画"><a href="#Android-动画" class="headerlink" title="Android 动画"></a>Android 动画</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p><strong>帧动画（Frame Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">val frameAnimation = imageView.background as AnimationDrawable</span><br><span class="line">frameAnimation.start()</span><br></pre></td></tr></table></figure>

<p><strong>补间动画（Tween Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">val rotateAnimation = AnimationUtils.loadAnimation(context, R.anim.rotate)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p><strong>属性动画（Property Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">2000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure>

<p><strong>过渡动画（Transition Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup = findViewById(R.id.scene_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> scene1: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene1, context)</span><br><span class="line"><span class="keyword">val</span> scene2: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene2, context)</span><br><span class="line"></span><br><span class="line">TransitionManager.go(scene2, TransitionInflater.from(context).inflateTransition(R.transition.example_transition))</span><br></pre></td></tr></table></figure>

<p><strong>触摸反馈动画（Touch Feedback Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义触摸反馈动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;?android:attr/colorControlHighlight&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/button_normal&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br><span class="line">button.background = ContextCompat.getDrawable(context, R.drawable.ripple)</span><br></pre></td></tr></table></figure>

<p><strong>物理动画（Physics-based Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> springAnimation = SpringAnimation(imageView, DynamicAnimation.ROTATION, <span class="number">0f</span>)</span><br><span class="line">springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW</span><br><span class="line">springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY</span><br><span class="line">springAnimation.start()</span><br></pre></td></tr></table></figure>

<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">   imageView.setBackgroundResource(R.drawable.animation)</span><br><span class="line">   <span class="keyword">val</span> animationDrawable = imageView.background <span class="keyword">as</span> AnimationDrawable</span><br><span class="line">   animationDrawable.start()</span><br></pre></td></tr></table></figure>

<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.ani)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p>补间动画的属性</p>
<p>补间动画（Tween Animation）在 Android 中主要包括四种类型：AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation，它们分别对应透明度、缩放、位移和旋转四种动画效果。</p>
<p>以下是这四种补间动画的主要属性：</p>
<ol>
<li><strong>AlphaAnimation（透明度动画）</strong>：<ul>
<li>fromAlpha：动画开始时视图的透明度（0.0 - 1.0）</li>
<li>toAlpha：动画结束时视图的透明度（0.0 - 1.0）</li>
</ul>
</li>
<li><strong>ScaleAnimation（缩放动画）</strong>：<ul>
<li>fromXScale：动画开始时视图的X轴缩放比例</li>
<li>toXScale：动画结束时视图的X轴缩放比例</li>
<li>fromYScale：动画开始时视图的Y轴缩放比例</li>
<li>toYScale：动画结束时视图的Y轴缩放比例</li>
<li>pivotX：X轴的缩放中心点</li>
<li>pivotY：Y轴的缩放中心点</li>
</ul>
</li>
<li><strong>TranslateAnimation（位移动画）</strong>：<ul>
<li>fromXDelta：动画开始时视图在X轴的位置</li>
<li>toXDelta：动画结束时视图在X轴的位置</li>
<li>fromYDelta：动画开始时视图在Y轴的位置</li>
<li>toYDelta：动画结束时视图在Y轴的位置</li>
</ul>
</li>
<li><strong>RotateAnimation（旋转动画）</strong>：<ul>
<li>fromDegrees：动画开始时视图的旋转角度</li>
<li>toDegrees：动画结束时视图的旋转角度</li>
<li>pivotX：旋转的中心点X坐标</li>
<li>pivotY：旋转的中心点Y坐标</li>
</ul>
</li>
</ol>
<p>以上每种动画类型的属性都可以在 XML 中定义，也可以在代码中动态设置。除了这些特定的属性外，所有的补间动画还有一些共同的属性，例如：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>fillAfter：动画结束后，视图是否保持动画结束时的状态</li>
<li>fillBefore：动画开始前，视图是否保持动画开始时的状态</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatMode：动画的重复模式（重新开始或反向执行）</li>
<li>interpolator：动画的插值器（用于控制动画的速度变化）</li>
</ul>
<p>区域问题</p>
<p>补间动画虽然能对控件做动画 ，但是并没有改变控件内 部 的属性值 。也就是说只是做了动画，它的位置属性啥的都没有变。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>​		补间动画和逐帧动画统称为视图动画 ，从字面意思中可以看 出，这两个动画只能对派生自 View 类的控件实例起作用； 而属性动画则不同，从名字 中可以看出它应该是作用于控件属性的 。<strong>正因为属性动画 能够只针对控件的某一个属性来做动画，所以造就了它能单独改变控件某一个属性的值 ，比如颜色 。</strong></p>
<p>属性动画分为ValueAnimator 和 ObjectAnimator 。</p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a><strong>ValueAnimator</strong></h3><p>简单使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">   animator.setDuration(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 在这里监听</span></span><br><span class="line">   animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">       <span class="comment">// 可以在这里根据value值对View进行操作</span></span><br><span class="line">       <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">       loge(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   animator.start()</span><br></pre></td></tr></table></figure>

<p>比如用来移动View</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">		<span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(value, value, value + imageView.width, value + imageView.height)</span><br><span class="line">        &#125;</span><br><span class="line">	    animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationStart&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationEnd&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationRepeat&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        animator.start()</span><br><span class="line">	    <span class="comment">//无限次重复的动画必须得在合适的时机cancel</span></span><br><span class="line">        animator.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View就会沿着从左上角到右下角的对角线进行移动。1秒钟完成动画，然后无限次的重复动画。</p>
<h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">animator.interpolator = AccelerateDecelerateInterpolator()</span><br></pre></td></tr></table></figure>

<p>Android SDK 提供了多种内置的插值器：</p>
<ol>
<li><code>LinearInterpolator</code>: 时间和动画进度之间是线性关系，也就是匀速运动。</li>
<li><code>AccelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐加快。</li>
<li><code>DecelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐减慢。</li>
<li><code>AccelerateDecelerateInterpolator</code>: 动画开始时速度逐渐加快，然后在结束时速度逐渐减慢。</li>
<li><code>AnticipateInterpolator</code>: 开始时，先向相反方向改变一段距离，然后再沿正常方向开始动画。</li>
<li><code>OvershootInterpolator</code>: 动画结束时，会超出目标值一些，然后再弹回来。</li>
<li><code>AnticipateOvershootInterpolator</code>: 开始时向相反方向改变，结束时超出目标值，然后再弹回。</li>
<li><code>BounceInterpolator</code>: 动画结束时，会像弹球一样多次弹跳。</li>
<li><code>CycleInterpolator</code>: 动画会循环指定的次数，每次循环都包括一个正向和一个反向的动画。</li>
<li><code>FastOutSlowInInterpolator</code>: 开始时快速，然后慢慢减速。</li>
</ol>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">100</span>, <span class="number">400</span>)</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">        loge(currentValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里currentValue的计算公式为，比如都到了全程的百分二十</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentValue = 100 + (400 -100)x 0.2</span><br></pre></td></tr></table></figure>

<p>这个0.2也就是进度值时插值器里的getinterpolatio方法返回的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getInterpolation</span><span class="params">(<span class="type">float</span> input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>input 参数与任何我们设定的值没有关系，只与时间有关 ，随着时间的推移，动画的进度也自然地增加，input 参数就代表了当前动画的进度，而返回值则表示动画的当前数值进度。</p>
<p>Linearlnterpolator插值器中就直接返回了input</p>
<p>所以自定义插值器只需要实现TimeInterpolator 接口然后自定义getInterpolation方法的返回值就可以了。</p>
<h3 id="Evaluator估值器"><a href="#Evaluator估值器" class="headerlink" title="Evaluator估值器"></a>Evaluator估值器</h3><p>作用：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1705668341835.jpg" alt="1705668341835"></p>
<p>​		我们通过监昕器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值 。 那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator 。</p>
<p><strong>Evaluator 用 于将从插值器返回的数值进度转换成对应的数值。</strong></p>
<p>oflnt（）和ofFloat（）都是系统直接提供的函数 ，所以会有默认的插值器和 Evaluator 可供使用 。</p>
<p>以IntEvaluator为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startInt</span> <span class="operator">=</span> startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>(int)(startInt + fraction * (endValue - startInt))</code>就等价于上面的<code>currentValue = 100 + (400 -100)×进度值</code></p>
<p>自定义Evaluator</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEvaluator</span> : <span class="type">android.animation.TypeEvaluator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Int</span>, endValue: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.setEvaluator(ReverseEvaluator())</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(imageView.left, currentValue, imageView.right, currentValue + imageView.height)</span><br><span class="line">            loge(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br></pre></td></tr></table></figure>

<p>最终实现了View从下到上也就是从终点到起点的运动。</p>
<h3 id="插值器和估值器的关系"><a href="#插值器和估值器的关系" class="headerlink" title="插值器和估值器的关系"></a>插值器和估值器的关系</h3><ol>
<li><strong>插值器（Interpolator）</strong>：<ul>
<li><strong>插值器用于计算动画的进度</strong>。它根据动画的时间流逝比例来确定动画的当前进度比例。不同的插值器会产生不同的动画速度变化效果，如线性（LinearInterpolator）、加速（AccelerateInterpolator）、减速（DecelerateInterpolator）、弹跳（BounceInterpolator）等。</li>
<li>插值器的输出是一个介于 0 和 1 之间的浮点数，表示动画的进度。</li>
</ul>
</li>
<li><strong>估值器（TypeEvaluator）</strong>：<ul>
<li><strong>估值器用于根据插值器计算出的进度比例来确定动画的具体数值。</strong>它将进度比例映射到动画的起始值和结束值之间的某个具体值。</li>
<li>Android 提供了几种默认的估值器，如 <code>IntEvaluator</code>、<code>FloatEvaluator</code> 和 <code>ArgbEvaluator</code>，分别用于整数、浮点数和颜色值的动画。你也可以自定义估值器来实现特定的数值计算逻辑。</li>
</ul>
</li>
</ol>
<p><strong>关系</strong>：</p>
<ul>
<li>插值器和估值器共同工作来确定动画在任意给定时间点的具体状态。</li>
<li>插值器首先计算出动画的进度比例，然后这个比例被传递给估值器，估值器根据这个比例计算出对应的动画数值。</li>
<li>换句话说，插值器定义了动画的速度曲线，而估值器定义了动画的数值变化方式。</li>
</ul>
<p>​		例如，如果想要一个视图在 300 毫秒内从透明度 0 变化到透明度 1，并且希望这个变化过程是先加速后减速的，可以使用 <code>AccelerateDecelerateInterpolator</code> 作为插值器，<code>FloatEvaluator</code> 作为估值器来实现这个动画。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p>​		<strong>ValueAnimator 有一个缺点 ，就是只能对动画中的数值进行计算 。</strong> 如果想对那个个控件执行操作，就需要监听 ValueAnimator 的动画过程，相比于补间动画要烦琐得多 。所以在 ValueAnimator 的基础上派生了 一个类 ObjectAnimator 。ObjectAnimator 是直接针对属性进行改变。 </p>
<p><strong>简单使用</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">    <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView,<span class="string">&quot;alpha&quot;</span>,<span class="number">0f</span>,<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// 一次的动画时常为2000毫秒</span></span><br><span class="line">    animator.setDuration(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">    animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">    animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">    animator.start()</span><br></pre></td></tr></table></figure>

<p>代码设置了imageView的透明度的从0到1的变化动画，ObjectAnimator 做动画，并不是根据控件XML 中的属性来改变的，而是通过指定属性所对应的 set 函数来改变的。View类中定义了alpha的set函数。</p>
<h3 id="ObjectAnimator动画原理"><a href="#ObjectAnimator动画原理" class="headerlink" title="ObjectAnimator动画原理"></a>ObjectAnimator动画原理</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122162025356.png" alt="image-20240122162025356"></p>
<p>​		在 ObjectAnimator 的动画流程中，先通过插值器产生当前进度的百分比，然后再经过 Evaluator 生成对应百分比所对应的数字值 。 这两步与 ValueAnimator 的动画流程是完全一样的，唯一不同的是最后一步，在 ValueAnimator 中，需要通过添加监昕器来监昕当前的数值；而在 ObjectAnimator 中，则先根据属性值拼装成对应的 set 函数的名 字（ 比如这里的scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，得到 setScaleY ），然后<strong>通过反射找到对应控件的setScaleY (float scale Y）函数，井将当前的数值作为setScaleY (floatscaleY）函数的参数传入 。</strong></p>
<p>​		第一，拼接 set 函数的方法。<strong>首先强制将属性的第一个字母大写 ，然后与 set 拼接</strong>，就得到对应的 set 函数的名字。注意，只是强制将属性的第一个字母大写 ，后面的部分是保持不变的 。反过来， 如果我们的函数名为 setScalePointX（），那么在写属性时可以写成 scalePointX 或者 ScalePointX，<strong>即第一个字母大小写随意，但是后面的部分必须与set 函数后面部分的大小写保持一致 。找函数这一步是通过反射来实现的。</strong></p>
<p>​		第二，如何确定函数的参数类型？我们知道了如何找到对应的函数名，那么对应方法中的参数类型如何确定呢？我们在介绍 ValueAnimator 的时候说过，动画过程中产生的数值与构造时传入的值类型是一样的。由于 ObjectAnimator 与 ValueAnimator 在插值器和 Evaluator 这两步是完全一样的，而当前的动画数值是在 Evaluator 这一步产生的，所以 ObjectAnimator 的动画中产生的数值类型与构造时传入的值类型也是一样的。</p>
<p>​		第三，调用set 函数以后怎么办 ？从ObjectAnimator 的动画流程中可以看到，ObjectAnimator 只负责把动画过程中的数值传到对应属性的 s et 函数中就结束了。注意，传给set 函数以后就结束了！set 函数就相当于我们在ValueAnimator 中添加的监听器，set 函数中对控件的操作还是需要由我们自己来写的。</p>
<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>​		ValueAnimator 和 ObjecAnimator 除可以通过 oflnt（） 、ofFloat（）、ofObject（） 函数创建实例外，还都有一个 ofPropertyValuesHoIder（）函数来创建实例。</p>
<p>原理：</p>
<p>​		PropertyValuesHolder 类 的含义就是 ，它其中保存了动画过程 中所需要操作的属性和对应的值。 我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态的。</p>
<p>​		在封装成 Prope向NaluesHolder 实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。所以，ObjectAnimator 通过暴露 PropertyValuesHolder 的方法 ，向我们提供 了一个 口子 ，让我们可以通过 PropertyValuesHo ld er 来构造动画 。</p>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 dp 单位转换为 px 单位，并创建一个平移动画的 PropertyValuesHolder，</span></span><br><span class="line"><span class="comment">// 使得视图从 37dp 的位置平移到 228dp 的位置</span></span><br><span class="line"><span class="keyword">val</span> translateInHolder =</span><br><span class="line">    PropertyValuesHolder.ofFloat(<span class="string">&quot;translationX&quot;</span>, dp2px(<span class="number">37f</span>), dp2px(<span class="number">228f</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个淡出动画的 PropertyValuesHolder，使得视图的透明度从 1 (完全不透明) 减少到 0 (完全透明)</span></span><br><span class="line"><span class="keyword">val</span> alphaOutHolder = PropertyValuesHolder.ofFloat(<span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 PropertyValuesHolder 创建一个 ObjectAnimator，对 imageView 应用平移和淡出动画</span></span><br><span class="line"><span class="keyword">val</span> animator: ObjectAnimator = ObjectAnimator.ofPropertyValuesHolder(</span><br><span class="line">    binding.imageView, translateInHolder, alphaOutHolder</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里定义了两个PropertyValuesHolder对象，分别是对位置和透明这两个属性进行操作。</p>
<h3 id="自定义-ObjectAnimator-属性"><a href="#自定义-ObjectAnimator-属性" class="headerlink" title="自定义 ObjectAnimator 属性"></a>自定义 ObjectAnimator 属性</h3><p>在自定义View的时候，可以来自定义一个属性来实现动画的载体。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">       <span class="keyword">set</span>(value) &#123;</span><br><span class="line">           field = value</span><br><span class="line">           invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">           <span class="keyword">by</span> lazy &#123;</span><br><span class="line">               ObjectAnimator.ofFloat(</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                   <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中floatingLabelFraction就是自定义的属性，然后再ofFloat方法中的target设置为this。</p>
<p>当且仅当动画只有一个过渡值时，系统才会调用对应属性的 get 函数来得到动画的初始值。如下面</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">&quot;floatingLabelFraction&quot;</span>, <span class="number">1f</span> )</span><br></pre></td></tr></table></figure>

<p>当不存在 get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h3 id="组合动画AnimatorSet"><a href="#组合动画AnimatorSet" class="headerlink" title="组合动画AnimatorSet"></a>组合动画AnimatorSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translation</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  <span class="comment">// 平移动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);  <span class="comment">// 旋转动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 透明度动画 // 创建组合动画的对象 </span></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();  <span class="comment">// 根据需求组合动画 </span></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  <span class="comment">//启动动画 </span></span><br><span class="line">animSet.start()</span><br></pre></td></tr></table></figure>

<p>常用的组合方法</p>
<ul>
<li>AnimatorSet.play(Animator anim)   ：播放当前动画</li>
<li>AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行</li>
<li>AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行</li>
<li>AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行</li>
<li>AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行</li>
</ul>
<h3 id="PropertyValuesHolder-1"><a href="#PropertyValuesHolder-1" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>PropertyValuesHolder 类的含义就是 ，它其 中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内 部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态 的 。在封装成Prope向NaluesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframeO</span> <span class="operator">=</span> Keyframe . ofFloat(Of , <span class="number">1</span>);</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframel</span> <span class="operator">=</span> Keyframe.ofFloat(O.lf , <span class="number">1.</span>lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframe9</span> <span class="operator">=</span> Keyframe .ofFloat(<span class="number">0</span> . <span class="number">9f</span> , l . lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframelO</span> <span class="operator">=</span> Keyframe . ofFloat(l , <span class="number">1</span>) ;</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">frameHolder2</span> <span class="operator">=</span> PropertyValuesHolder . ofKeyframe (” ScaleX”,</span><br><span class="line">scaleXframeO , scaleXframel, scaleXframe9 , scaleXframelO) ;</span><br><span class="line"> <span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(mimage,frameHolderl,frameHolder2,frameHolder3);</span><br><span class="line">        animator.setDuration(lOOO);</span><br><span class="line">        animator.start();</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator 中唯一一个能实现多动画同时播放的方法。</p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>为 View 的动画操作提供一种更加便捷的用法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tvText.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> animator = tvText.animate()</span><br><span class="line">    animator.duration=<span class="number">1000</span></span><br><span class="line">    animator.translationX(<span class="number">100f</span>)<span class="comment">//点击一次会向右偏移，再点击没效果</span></span><br><span class="line">    animator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h4 id="为什么要减少布局的嵌套层次？"><a href="#为什么要减少布局的嵌套层次？" class="headerlink" title="为什么要减少布局的嵌套层次？"></a>为什么要减少布局的嵌套层次？</h4><p><a target="_blank" rel="noopener" href="https://rengwuxian.com/compose-intrinsic-measurement/">https://rengwuxian.com/compose-intrinsic-measurement/</a></p>
<h4 id="Android中常用布局的性能对比"><a href="#Android中常用布局的性能对比" class="headerlink" title="Android中常用布局的性能对比"></a>Android中常用布局的性能对比</h4><p>​		同层级下RelativeLayout会对子View做两次measure，而LinearLayout则只需一次measure过程，但是如果LinearLayout中有weight属性，则也需要进行两次measure。在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</p>
<p>ConstraintLayout存在的最大目的是减少布局层级和过度绘制，为了实现这个目的，它在绘制的时候会有很多的计算，对于简单布局来说，得不偿失。</p>
<h4 id="requestLayout-会触发draw吗"><a href="#requestLayout-会触发draw吗" class="headerlink" title="requestLayout 会触发draw吗"></a>requestLayout 会触发draw吗</h4><p>不一定</p>
<p>​		requestLayout最终会走到ViewRootImpl的performTraversals方法，然后会触发Measure、Layout 过程。由于没有设置重绘区域，因此Draw 过程将不会触发。</p>
<p>​		但是如果View的尺寸改变了，变大了，那么调用了requestLayout后因为走了Measure、Layout 过程，测量、摆放倒是重新设置了，但是不调用Draw出不来效果。</p>
<p>​		在layout方法里进行判读尺寸是否改变，改变了的话调用invalidate。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#View.java</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setFrame</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldWidth</span> <span class="operator">=</span> mRight - mLeft;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldHeight</span> <span class="operator">=</span> mBottom - mTop;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newWidth</span> <span class="operator">=</span> right - left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newHeight</span> <span class="operator">=</span> bottom - top;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sizeChanged</span> <span class="operator">=</span> (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line">            <span class="comment">//尺寸发生改变 调用invalidate 传入true，否则传入false</span></span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="invalidate会触发layout吗"><a href="#invalidate会触发layout吗" class="headerlink" title="invalidate会触发layout吗"></a>invalidate会触发layout吗</h4><p>​		invalidate最终会走到ViewRootImpl的performTraversals方法，在ViewRootImpl中mLayoutRequested 的默认值为false，且在invalidate的流程中未对其赋值，所以不会调用layout和measure。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DecorView 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">layoutRequested</span> <span class="operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">// 此处可能会调用 performMeasure 方法</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != <span class="literal">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="comment">// 如果 lp.horizontalWeight 或 lp.verticalWeight 大于 0 则重新调用 performMeasure 测量</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            layoutRequested = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">didLayout</span> <span class="operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="invalidate和requestLayout的区别"><a href="#invalidate和requestLayout的区别" class="headerlink" title="invalidate和requestLayout的区别"></a>invalidate和requestLayout的区别</h4><ol>
<li>**invalidate()**：<ul>
<li>作用：用于请求重绘当前视图。当视图的内容（如颜色、文本、背景等）发生变化，需要更新显示时，可以调用此方法。</li>
<li>触发过程：<code>invalidate()</code> 会导致视图的 <code>draw()</code> 方法被调用，以便重新绘制视图的外观。</li>
<li>使用场景：当你需要更新视图的显示内容，但视图的大小和位置不变时，使用 <code>invalidate()</code>。</li>
</ul>
</li>
<li>**requestLayout()**：<ul>
<li>作用：用于请求重新测量和布局当前视图及其子视图。当视图的大小或位置需要改变时，可以调用此方法。</li>
<li>触发过程：<code>requestLayout()</code> 会导致视图的 <code>measure()</code> 方法和 <code>layout()</code> 方法被调用，以便重新确定视图及其子视图的大小和位置。</li>
<li>使用场景：当你动态地改变了视图的大小、边距、填充等属性，或者添加、移除子视图时，需要调用 <code>requestLayout()</code> 来通知系统重新布局。</li>
</ul>
</li>
</ol>
<p>​		其实<code>requestLayout</code>和<code>invalidate</code>均会发起<code>scheduleTraversals</code>之后的三大流程，但对于是否分发深入下去，其中的标记位起到了决定性作用。</p>
<p>​		<code>requestLayout</code>必然会进行measure、layout、draw（会根据size是否change在layout时发起invalidate，如果不确定是否change且需要重绘，可以再手动调用invalidate()）</p>
<p>​		<code>invalidate</code>仅会进行draw，当然如果在期间环节，<code>某个view.layoutParams发生变化</code>，导致measure时判断<code>needsLayout</code>为true，那也会进行measure、layout</p>
<h4 id="为什么view-post可以获取到控件高度"><a href="#为什么view-post可以获取到控件高度" class="headerlink" title="为什么view.post可以获取到控件高度"></a>为什么view.post可以获取到控件高度</h4><p>​		post即把action放在view的等待队列<code>mRunQueue</code>中，在<code>performTraversals&gt;&gt;view.dispatchAttachedToWindow</code>会取出所有的<code>handler action</code>推送到ViewRootHandler，由于performTraversals自身就是个<code>handler Runnable</code>，所以view.post内容一定会等到performTraversals完成后才会等到消息队列执行。</p>
<h4 id="怎么实现圆角的ImageView？"><a href="#怎么实现圆角的ImageView？" class="headerlink" title="怎么实现圆角的ImageView？"></a>怎么实现圆角的ImageView？</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义圆角 ImageView 类，继承自 AppCompatImageView</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundImageView</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) :</span><br><span class="line">    androidx.appcompat.widget.AppCompatImageView(context, attrs) &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Path 对象用于绘制圆角矩形路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path: Path = Path()</span><br><span class="line">    <span class="comment">// 定义一个变量用于存储圆角半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cornerRadius: <span class="built_in">Float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 从布局属性中获取自定义属性</span></span><br><span class="line">        <span class="keyword">val</span> typedArray =</span><br><span class="line">            context.theme.obtainStyledAttributes(attrs, R.styleable.RoundedImageView, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取自定义属性的值，如果没有设置，则使用默认值 20f</span></span><br><span class="line">            cornerRadius = typedArray.getDimension(R.styleable.RoundedImageView_cornerRadius, <span class="number">20f</span>)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 回收 TypedArray 对象</span></span><br><span class="line">            typedArray.recycle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 onDraw 方法以实现自定义绘制逻辑</span></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;DrawAllocation&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个矩形，大小与 ImageView 相同</span></span><br><span class="line">        <span class="keyword">val</span> rect = RectF(<span class="number">0f</span>, <span class="number">0f</span>, width.toFloat(), height.toFloat())</span><br><span class="line">        <span class="comment">// 重置路径对象</span></span><br><span class="line">        path.reset()</span><br><span class="line">        <span class="comment">// 向路径中添加一个圆角矩形</span></span><br><span class="line">        path.addRoundRect(rect, cornerRadius, cornerRadius, Path.Direction.CCW)</span><br><span class="line">        <span class="comment">// 使用路径裁剪画布</span></span><br><span class="line">        canvas.clipPath(path)</span><br><span class="line">        <span class="comment">// 调用父类的 onDraw 方法绘制图像</span></span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他好几种方式：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7095200146761187336#heading-3">Android ImageView 圆角实现</a></p>
<h4 id="View-post-为何能够获取到-View-的宽高值？"><a href="#View-post-为何能够获取到-View-的宽高值？" class="headerlink" title="View.post() 为何能够获取到 View 的宽高值？"></a>View.post() 为何能够获取到 View 的宽高值？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; View.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AttachInfo</span> <span class="variable">attachInfo</span> <span class="operator">=</span> mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. attachInfo 不为空，通过 mHandler 发送</span></span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. attachInfo 为空，放入队列中</span></span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键是 <code>attachInfo</code> 是否为空。</p>
<ul>
<li><code>attachInfo</code> 是在 <code>ViewRootImpl</code> 的构造函数中初始化的，</li>
<li><code>ViewRootImpl</code> 是在 <code>WindowManagerGlobal.addView()</code> 创建的</li>
<li><code>WindowManagerGlobal.addView()</code> 是在 ActivityThread 的 <code>handleResumeActivity()</code> 中调用的，但是是在 <code>Activity.onResume()</code> 回调之后</li>
</ul>
<p>​		所以，如果 <code>attachInfo</code> 不为空的话，至少已经处在进行视图绘制的这次消息处理当中。把 <code>post()</code> 方法要执行的 Runnable 利用 Handler 发送出去，当包含这个 Runnable 的 Message 被执行时，是一定可以获取到 View 的宽高的。</p>
<p>​		在 <code>onCreate()</code> 和 <code>onResume()</code> 这两个回调中，<code>attachInfo</code> 肯定是空的，这时候就要依赖 <code>getRunQueue().post(action)</code> 。原理也很简单，<strong>把 <code>post()</code> 方法要执行的 Runnable 存储在一个队列中，在合适的时机（View 已被测量）拿出来执行</strong>。</p>
<p>​		队列 <code>HandlerActionQueue</code> 是一个初始容量是 4 的 <code>HandlerAction</code> 数组。HandlerAction 有两个成员变量，要执行的 Runnable 和延迟执行的时间。</p>
<p>​		队列的执行逻辑在 <code>executeActions(handler)</code> 方法中，通过传入的 handler 进行任务分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="type">int</span> visibility)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 分发任务</span></span><br><span class="line">            mRunQueue.executeActions(info.mHandler);</span><br><span class="line">            mRunQueue = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 回调 onAttachedToWindow()</span></span><br><span class="line">    onAttachedToWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>根据 ViewRootImpl 是否已经创建，View.post() 会执行不同的逻辑。如果 ViewRootImpl 已经创建，即 mAttachInfo 已经初始化，直接通过 Handler 发送消息来执行任务。如果 ViewRootImpl 未创建，即 View 尚未开始绘制，会将任务保存为 HandlerAction，暂存在队列 HandlerActionQueue 中，等到 View 开始绘制，执行 performTraversal() 方法时，在 dispatchAttachedToWindow() 方法中通过 Handler 分发 HandlerActionQueue 中暂存的任务。</strong></p>
<p>​		<strong>另外要注意，View 绘制是发生在一次 Meesage 处理过程中的，View.post() 执行的任务也是发生在一次 Message 处理过程中的，它们一定是有先后顺序的。</strong></p>
<h4 id="还可以怎么获取视图宽高？"><a href="#还可以怎么获取视图宽高？" class="headerlink" title="还可以怎么获取视图宽高？"></a>还可以怎么获取视图宽高？</h4><p>除了通过 <code>View.post()</code> 获取视图宽高之外，还有两种比较推荐的方式。</p>
<p>第一种，<code>onWindowFocusChanged()</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun <span class="title function_">onWindowFocusChanged</span><span class="params">(hasFocus: Boolean)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.onWindowFocusChanged(hasFocus)</span><br><span class="line">    <span class="keyword">if</span> (hasFocus)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，<code>OnGlobalLayoutListener</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">binding.dialog.viewTreeObserver.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener&#123;</span><br><span class="line">    override fun <span class="title function_">onGlobalLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        binding.dialog.viewTreeObserver.removeOnGlobalLayoutListener(<span class="built_in">this</span>)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​		这两种方法都可能被调用多次。当 Activity 获取和失去焦点的时候，<code>onWindowFocusChanged</code> 都会调用。当 View 树发生状态变化时，<code>OnGlobalLayoutListener</code> 也会调用多次，可以根据需要移除监听。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6895735092438630407?searchId=20240409145813D97E60FCD44F8F0C87AA#heading-2">View 在什么时间点被测量？</a></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/15/Android%E8%99%9A%E6%8B%9F%E6%9C%BAmin/" title="Android 虚拟机min"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android 虚拟机min</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/15/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" title="Recyclerview缓存机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Recyclerview缓存机制</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-view-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Android view 绘制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">布局加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">View的绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#onResume"><span class="toc-number">1.2.1.</span> <span class="toc-text">**onResume **</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestLayout"><span class="toc-number">1.2.2.</span> <span class="toc-text">requestLayout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choreographer"><span class="toc-number">1.2.3.</span> <span class="toc-text">Choreographer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">调用链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#performTraversals"><span class="toc-number">1.2.4.</span> <span class="toc-text">performTraversals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Measure%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Measure过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MeasureSpec"><span class="toc-number">1.2.4.1.1.</span> <span class="toc-text">**MeasureSpec **</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Layout过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Draw%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">Draw过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">Android输入系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InputManagerService"><span class="toc-number">2.1.</span> <span class="toc-text">InputManagerService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InputManagerService%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">InputManagerService创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">输入事件中的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B%E8%B7%9F%E8%B8%AA"><span class="toc-number">2.4.</span> <span class="toc-text">事件流程跟踪</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">Android View事件分发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">分发的事件是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MotionEvent%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">MotionEvent事件分发的三个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">事件分发的具体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91native%E5%B1%82"><span class="toc-number">3.4.</span> <span class="toc-text">事件分发native层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%A4%84%E7%90%86%E5%B5%8C%E5%A5%97Recyclerview%E7%9A%84%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81"><span class="toc-number">3.5.</span> <span class="toc-text">事件分发处理嵌套Recyclerview的嵌套滑动冲突</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E8%87%AA%E5%AE%9A%E4%B9%89View"><span class="toc-number">4.</span> <span class="toc-text">Android自定义View</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-View%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">自定义 View实现方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-View-Demo"><span class="toc-number">5.</span> <span class="toc-text">自定义 View Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">流式布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#onDraw%E6%96%B9%E6%B3%95%E7%9B%B4%E6%8E%A5%E7%BB%98%E5%88%B6%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">onDraw方法直接绘制元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%8C%E8%AF%8D%E6%8E%A7%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">歌词控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%86%E8%A7%92%E7%9A%84ImageView"><span class="toc-number">5.4.</span> <span class="toc-text">圆角的ImageView</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-%E5%8A%A8%E7%94%BB"><span class="toc-number">6.</span> <span class="toc-text">Android 动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">6.2.</span> <span class="toc-text">帧动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB"><span class="toc-number">6.3.</span> <span class="toc-text">补间动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">6.4.</span> <span class="toc-text">属性动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ValueAnimator"><span class="toc-number">6.4.1.</span> <span class="toc-text">ValueAnimator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E5%99%A8"><span class="toc-number">6.4.2.</span> <span class="toc-text">插值器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E5%80%BC%E5%99%A8"><span class="toc-number">6.4.3.</span> <span class="toc-text">自定义插值器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluator%E4%BC%B0%E5%80%BC%E5%99%A8"><span class="toc-number">6.4.4.</span> <span class="toc-text">Evaluator估值器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E5%99%A8%E5%92%8C%E4%BC%B0%E5%80%BC%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">6.4.5.</span> <span class="toc-text">插值器和估值器的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectAnimator"><span class="toc-number">6.4.6.</span> <span class="toc-text">ObjectAnimator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObjectAnimator%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.7.</span> <span class="toc-text">ObjectAnimator动画原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PropertyValuesHolder"><span class="toc-number">6.4.8.</span> <span class="toc-text">PropertyValuesHolder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ObjectAnimator-%E5%B1%9E%E6%80%A7"><span class="toc-number">6.4.9.</span> <span class="toc-text">自定义 ObjectAnimator 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8A%A8%E7%94%BBAnimatorSet"><span class="toc-number">6.4.10.</span> <span class="toc-text">组合动画AnimatorSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PropertyValuesHolder-1"><span class="toc-number">6.4.11.</span> <span class="toc-text">PropertyValuesHolder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewPropertyAnimator"><span class="toc-number">6.4.12.</span> <span class="toc-text">ViewPropertyAnimator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%87%8F%E5%B0%91%E5%B8%83%E5%B1%80%E7%9A%84%E5%B5%8C%E5%A5%97%E5%B1%82%E6%AC%A1%EF%BC%9F"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">为什么要减少布局的嵌套层次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">Android中常用布局的性能对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#requestLayout-%E4%BC%9A%E8%A7%A6%E5%8F%91draw%E5%90%97"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">requestLayout 会触发draw吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invalidate%E4%BC%9A%E8%A7%A6%E5%8F%91layout%E5%90%97"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">invalidate会触发layout吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invalidate%E5%92%8CrequestLayout%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.0.0.5.</span> <span class="toc-text">invalidate和requestLayout的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88view-post%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0%E6%8E%A7%E4%BB%B6%E9%AB%98%E5%BA%A6"><span class="toc-number">7.0.0.6.</span> <span class="toc-text">为什么view.post可以获取到控件高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%9C%86%E8%A7%92%E7%9A%84ImageView%EF%BC%9F"><span class="toc-number">7.0.0.7.</span> <span class="toc-text">怎么实现圆角的ImageView？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-post-%E4%B8%BA%E4%BD%95%E8%83%BD%E5%A4%9F%E8%8E%B7%E5%8F%96%E5%88%B0-View-%E7%9A%84%E5%AE%BD%E9%AB%98%E5%80%BC%EF%BC%9F"><span class="toc-number">7.0.0.8.</span> <span class="toc-text">View.post() 为何能够获取到 View 的宽高值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E8%A7%86%E5%9B%BE%E5%AE%BD%E9%AB%98%EF%BC%9F"><span class="toc-number">7.0.0.9.</span> <span class="toc-text">还可以怎么获取视图宽高？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.0.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>