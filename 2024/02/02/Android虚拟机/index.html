<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android 虚拟机 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android 虚拟机在Android系统中，Java虚拟机是借由大名鼎鼎的Zygote进程来创建的。Zygote是Java世界的创造者——即Android中所有Java进程都由Zygote进程fork而来，而Zygote进程自己又是Linux系统上的init进程通过解析配置脚本来启动的。 Dalvik DVM与JVM对比 基于栈的虚拟机（如 Java 虚拟机 - JVM）： 基于栈的虚拟机每一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 虚拟机">
<meta property="og:url" content="https://zrmomo.github.io/2024/02/02/Android%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="Android 虚拟机在Android系统中，Java虚拟机是借由大名鼎鼎的Zygote进程来创建的。Zygote是Java世界的创造者——即Android中所有Java进程都由Zygote进程fork而来，而Zygote进程自己又是Linux系统上的init进程通过解析配置脚本来启动的。 Dalvik DVM与JVM对比 基于栈的虚拟机（如 Java 虚拟机 - JVM）： 基于栈的虚拟机每一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-02-02T13:10:51.118Z">
<meta property="article:modified_time" content="2024-02-02T13:09:47.063Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/02/02/Android%E8%99%9A%E6%8B%9F%E6%9C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android 虚拟机',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-02 21:09:47'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android 虚拟机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-02T13:10:51.118Z" title="发表于 2024-02-02 21:10:51">2024-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-02T13:09:47.063Z" title="更新于 2024-02-02 21:09:47">2024-02-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android 虚拟机"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Android-虚拟机"><a href="#Android-虚拟机" class="headerlink" title="Android 虚拟机"></a>Android 虚拟机</h1><p>在Android系统中，Java虚拟机是借由大名鼎鼎的Zygote进程来创建的。Zygote是Java世界的创造者——即Android中所有Java进程都由Zygote进程fork而来，而Zygote进程自己又是Linux系统上的init进程通过解析配置脚本来启动的。</p>
<h2 id="Dalvik-DVM"><a href="#Dalvik-DVM" class="headerlink" title="Dalvik DVM"></a>Dalvik DVM</h2><h3 id="与JVM对比"><a href="#与JVM对比" class="headerlink" title="与JVM对比"></a>与JVM对比</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-93cda252f04eaa29f9e0a3cd27ba2470_1440w.webp" alt="img"></p>
<p><strong>基于栈的虚拟机（如 Java 虚拟机 - JVM）：</strong></p>
<p>基于栈的虚拟机每一个运行的线程，都有一个独立的栈，栈中记录了方法调用的历史，每一个方法的调用，都对应一个栈帧，并且将栈帧压入栈中，最顶部的栈帧为当前栈帧，既 当前执行的方法，基于栈帧与操作数栈进行所有操作。</p>
<p>执行流程：</p>
<ul>
<li><strong>将栈顶某类型值存入局部变量某处</strong>：这是说，我们从栈（一种数据结构，可以想象成一摞盘子）的顶部取出一个值（就像取走最上面的盘子），然后把这个值放到我们的”局部变量”中。你可以把”局部变量”想象成一种存储区域，我们可以在那里放东西，以便稍后使用。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要暂时保存一些数据以便稍后使用时发生。例如，你可能正在计算一个复杂的表达式，需要将中间结果暂时保存下来，以便在稍后的计算中使用。这时，你就可以将这个中间结果（即栈顶的值）保存到局部变量中。</p>
</blockquote>
<ul>
<li><strong>将局部变量中某处某类型常量压入操作数栈</strong>：这是说，我们从”局部变量”中取出一个值（就像从抽屉里取出一件衣服），然后把这个值放到栈的顶部（就像把一个新盘子放到盘子堆的顶部）。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要使用之前保存的数据时发生。例如，你可能需要使用之前保存的中间结果来完成表达式的计算。这时，你就可以将这个中间结果（即局部变量中的值）压入栈中，以便进行接下来的计算。</p>
</blockquote>
<ul>
<li><strong>执行相关指令</strong>：这是说，我们要执行一些操作，这些操作可能会使用栈顶的值，也可能会改变栈顶的值，或者做其他的事情。这些操作是由虚拟机的指令集定义的，每一种指令都有特定的功能，例如加法、减法、乘法等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-404079569b9204d0783c7a324e201fcb_1440w.webp" alt="img"></p>
<p><strong>基于寄存器的虚拟机（如 Dalvik 虚拟机 - DVM）</strong>：</p>
<p>基于寄存器的虚拟机中没有操作数栈，不过有很多虚拟寄存器，类似操作数栈，这些寄存器也存放在运行时栈中，本质上就是一个数组，与JVM相似，在Dalvik 虚拟机中每个线程都有自己的程序计数器 和 调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p>
<blockquote>
<p>寄存器 CPU的组成部分，寄存器是有限存储容量的高速存储容器（计算机中各级存储速度 寄存器-&gt; 一级缓存-&gt;二级缓存 -&gt; 内存 -&gt; 硬盘），可以用来管理指令、数据的地址。</p>
</blockquote>
<p>执行流程：</p>
<p>直接依据指令，将某类型值存入虚拟寄存器中，相关的操作也依据指令在虚拟寄存器中通过CPU处理，将处理结果返回虚拟寄存器（省掉了基于栈的流程中局部变量与操作数栈中数据的流动）</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-f7c8576e5446b47136b6836b83c8caac_1440w.webp" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20207106">借鉴文章</a></p>
<h3 id="DVM本身的优化"><a href="#DVM本身的优化" class="headerlink" title="DVM本身的优化"></a>DVM本身的优化</h3><ol>
<li>将多个类文件收集到同一个dex文件中，以便节省空间；</li>
<li>使用只读的内存映射方式加载dex文件，以便可以多进程共享dex文件，节省程序加载时间；</li>
<li>提前调整好字节序（byte order）和字对齐（word alignment）方式，使得它们更适合于本地机器，以便提高指令执行速度；</li>
<li>尽量提前进行字节码验证（bytecode verification），提高程序的加载速度；</li>
<li>需要重写字节码的优化要提前进行。</li>
</ol>
<h3 id="DVM内存管理"><a href="#DVM内存管理" class="headerlink" title="DVM内存管理"></a>DVM内存管理</h3><p>Dalvik虚拟机的内存大体上可以分为Java Object Heap、Bitmap Memory和Native Heap三种。</p>
<p><strong>Java Object Heap：</strong>用来分配Java对象的，也就是我们在代码new出来的对象都是位于Java Object Heap上的。</p>
<p><strong>Bitmap Memory：</strong>在Android 3.0之前，Bitmap Memory是在Native Heap中分配的，但是这部分内存同样计入Java Object Heap中，也就是说，Bitmap占用的内存和Java Object占用的内存加起来不能超过Java Object Heap的最大值。在Android 3.0以及更高的版本中，<strong>Bitmap Memory就直接是在Java Object Heap中分配了，这样就可以直接接受GC的管理。</strong>Native Heap就是在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<p><strong>Native Heap：</strong>在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<h3 id="简述GC"><a href="#简述GC" class="headerlink" title="简述GC"></a>简述GC</h3><p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h3 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译(JIT)"></a>即时编译(JIT)</h3><p>JIT是相对AOT而言的，即JIT是在程序运行的过程中进行编译的，而AOT是在程序运行前进行编译的</p>
<h3 id="DVM进程和线程管理特点"><a href="#DVM进程和线程管理特点" class="headerlink" title="DVM进程和线程管理特点"></a>DVM进程和线程管理特点</h3><ol>
<li>每一个Android应用程序进程都有一个Dalvik虚拟机实例。这样做的好处是Android应用程序进程之间不会相互影响，也就是说，一个Android应用程序进程的意外中止，不会影响到其它的Android应用程序进程的正常运行。</li>
<li>每一个Android应用程序进程都是由一种称为Zygote的进程fork出来的。Zygote进程是由init进程启动起来的，也就是在系统启动的时候启动的。Zygote进程在启动的时候，会创建一个虚拟机实例，并且在这个虚拟机实例将所有的Java核心库都加载起来。每当Zygote进程需要创建一个Android应用程序进程的时候，它就通过复制自身来实现，也就是通过fork系统调用来实现。这些被fork出来的Android应用程序进程，一方面是复制了Zygote进程中的虚拟机实例，另一方面是与Zygote进程共享了同一套Java核心库。这样不仅Android应用程序进程的创建过程很快，而且由于所有的Android应用程序进程都共享同一套Java核心库而节省了内存空间。</li>
</ol>
<h3 id="DVM启动分析"><a href="#DVM启动分析" class="headerlink" title="DVM启动分析"></a>DVM启动分析</h3><p>启动过程主要就是完成了以下四个事情：</p>
<ol>
<li>创建了一个Dalvik虚拟机实例；</li>
<li>加载了Java核心类及其JNI方法；</li>
<li>为主线程的设置了一个JNI环境；</li>
<li>注册了Android核心类的JNI方法。</li>
</ol>
<p>​		Zygote进程为Android系统准备好了一个Dalvik虚拟机实例，以后Zygote进程在创建Android应用程序进程的时候，就可以将它自身的Dalvik虚拟机实例复制到新创建Android应用程序进程中去，从而加快了Android应用程序进程的启动过程。此外，Java核心类和Android核心类（位于dex文件中），以及它们的JNI方法（位于so文件中），都是以内存映射的方式来读取的，因此，<strong>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。</strong></p>
<h3 id="DVM下的GC"><a href="#DVM下的GC" class="headerlink" title="DVM下的GC"></a>DVM下的GC</h3><p><a target="_blank" rel="noopener" href="https://jasonzhong.github.io/2017/09/28/Android-%E6%B5%85%E6%9E%90-GC-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">Android-浅析-GC-基础原理</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/41822747">Dalvik虚拟机垃圾收集（GC）过程分析</a></p>
<p>Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做Active Heap，另一部分叫做Zygote Heap。<strong>Zygote堆用来管理Zygote进程在启动过程中预加载和创建的各种对象</strong>，而Active堆是在Zygote进程fork第一个子进程之前创建的。之后无论是Zygote进程还是其子进程，都在Active堆上进行对象分配和释放。这样做的目的是使得Zygote进程和其子进程最大限度地共享Zygote堆所占用的内存。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240127151630567.png" alt="image-20240127151630567"></p>
<p>Dalvik虚拟机需要一些辅助数据结构，包括一个Card Table、两个Heap Bitmap和一个Mark Stack。</p>
<p>Card Table：记录在垃圾收集过程中对象的引用情况的，以便可以实现Concurrent G。</p>
<p>Live Heap Bitmap：用来记录上次GC之后，还存活的对象</p>
<p>Mark Heap Bitmap：用来记录当前GC中还存活的对象。</p>
<p>上次GC后存活的但是当前GC不存活的对象，就是需要释放的对象。<strong>Davlk虚拟机使用标记-清除（Mark-Sweep）算法进行GC。</strong>在标记阶段，通过一个<strong>Mark Stack来实现递归检查被引用的对象</strong>，即在当前GC中存活的对象。有了这个Mark Stack，就可以通过循环来模拟函数递归调用。Mark阶段从根集（Root Set）开始，递归地<strong>标记出当前所有被引用的对象</strong>，而Sweep阶段负责回收那些没有被引用的对象。</p>
<p>在分析Dalvik虚拟机使用的Mark-Sweep算法之前，我们先来了解一下什么情况下会触发GC。Dalvik虚拟机在三种情况下会触发四种类型的GC。</p>
<p>jvm将GC抽象成了一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GcSpec</span> &#123;    </span><br><span class="line">  <span class="type">bool</span> isPartial;  <span class="comment">// 为true时，表示仅仅回收Active堆的垃圾；为false时，表示同时回收Active堆和Zygote堆的垃圾。</span></span><br><span class="line">  <span class="type">bool</span> isConcurrent; <span class="comment">// 为true时，表示执行并行GC；为false时，表示执行非并行GC。</span></span><br><span class="line">  <span class="type">bool</span> doPreserve;  <span class="comment">// 为true时，表示在执行GC的过程中，不回收软引用引用的对象；为false时，表示在执行GC的过程中，回收软引用引用的对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *reason;  <span class="comment">// 描述</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>然后产生了四种GC</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_FOR_MALLOC;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_CONCURRENT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_EXPLICIT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_BEFORE_OOM;  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GC_FOR_MALLOC</strong>: 表示是在堆上分配对象时内存不足触发的GC。</li>
<li><strong>GC_CONCURRENT</strong>: 表示是在已分配内存达到一定量之后触发的GC。</li>
<li><strong>GC_EXPLICIT</strong>: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。</li>
<li><strong>GC_BEFORE_OOM</strong>: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</li>
</ul>
<p>GC_FOR_MALLOC、GC_CONCURRENT和GC_BEFORE_OOM三种类型的GC都是在分配对象的过程触发的</p>
<p>Dalvik虚拟机支持非并行和并行两种GC,它们的总体流程是相似的，主要差别在于前者在执行的过程中一直是挂起非GC线程的，而后者是有条件地挂起非GC线程。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20Dalvik%20GC.png" alt="Android Dalvik GC"></p>
<p>以上就是并行和非并行GC的执行总体流程，它们的主要区别在于，<strong>前者在GC过程中，有条件地挂起和唤醒非GC线程，而后者在执行GC的过程中，一直都是挂起非GC线程的。</strong>并行GC通过有条件地挂起和唤醒非GC线程，就可以使得应用程序获得更好的响应性。但是我们也应该看到，并行GC需要多执行一次标记根集对象以及递归标记那些在GC过程被访问了的对象的操作。也就是说，并行GC在使用得应用程序获得更好的响应性的同时，也需要花费更多的CPU资源。</p>
<p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>下面都是基于Android4.4</p>
<h3 id="ART替换DVM"><a href="#ART替换DVM" class="headerlink" title="ART替换DVM"></a>ART替换DVM</h3><p>ART虚拟机，它和Dalvik虚拟机、Java虚拟机的关系如图1所示：<br><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/d3c3b501eff5f127d1227631137b4c81_653x445.png" alt="d3c3b501eff5f127d1227631137b4c81_653x445">Dalvik虚拟机和ART虚拟机都实现了三个用来抽象Java虚拟机的接口：</p>
<ol>
<li>JNI_GetDefaultJavaVMInitArgs – 获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM – 在进程中创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs – 获取进程中创建的虚拟机实例</li>
</ol>
<p>在Android系统中，Davik虚拟机实现在libdvm.so中，ART虚拟机实现在libart.so中。也就是说，libdvm.so和libart.so导出了JNI_GetDefaultJavaVMInitArgs、JNI_CreateJavaVM和JNI_GetCreatedJavaVMs这三个接口，供外界调用。</p>
<p>此外，Android系统还提供了一个系统属性persist.sys.dalvik.vm.lib，它的值要么等于libdvm.so，要么等于libart.so。当等于libdvm.so时，就表示当前用的是Dalvik虚拟机，而当等于libart.so时，就表示当前用的是ART虚拟机。</p>
<p>以上描述的Dalvik虚拟机和ART虚拟机的共同之处，当然它们之间最显著还是不同之处。不同的地方就在于，<strong>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。</strong>这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码，具体可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/luoshengyang/article/details/8852432">Dalvik虚拟机简要介绍和学习计划</a>这个系列的文章。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，<strong>将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。</strong>因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>
<p>DVM在应用在安装的过程，其实也会执行一次“翻译”的过程。只不过这个“翻译”的过程是将dex字节码进行优化，也就是由dex文件生成odex文件。而ART将这个过程换成了直接翻译成机器码，从流程的角度来说没什么改变。</p>
<p>应用程序的安装发生在两个时机，<strong>第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。</strong>在第一个时机中，系统除了会对&#x2F;system&#x2F;app和&#x2F;data&#x2F;app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对&#x2F;system&#x2F;framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。</p>
<h3 id="ART简要介绍"><a href="#ART简要介绍" class="headerlink" title="ART简要介绍"></a>ART简要介绍</h3><p>在APK运行之前，就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了。这种技术不但使得我们可以不对原有的APK作任何修改，还可以使得这些APK只需要在安装时翻译一次，就可以无数次以本地机器指令的形式运行。在ART中，打包在APK里面的Dex字节码是通过LLVM翻译成本地机器指令的。LLVM是一个用来快速开发自己的编译器的框架系统</p>
<p>在ART运行时中，APK在安装的时候，安装服务PackageManagerService会通过守护进程installd调用另外一个工具dex2oat对打包在APK里面包含有Dex字节码进翻译。这个翻译器实际上就是基于LLVM架构实现的一个编译器，它的前端是一个Dex语法分析器。</p>
<p>ART的运行原理：</p>
<ul>
<li>在Android系统启动过程中创建的Zygote进程利用ART运行时导出的Java虚拟机接口创建ART虚拟机。</li>
<li>APK在安装的时候，打包在里面的classes.dex文件会被工具dex2oat翻译成本地机器指令，最终得到一个ELF格式的oat文件。</li>
<li>APK运行时，上述生成的oat文件会被加载到内存中，并且ART虚拟机可以通过里面的oatdata和oatexec段找到任意一个类的方法对应的本地机器指令来执行。</li>
</ul>
<h3 id="ART加载OAT文件"><a href="#ART加载OAT文件" class="headerlink" title="ART加载OAT文件"></a>ART加载OAT文件</h3><p>Android运行时ART，它的核心是OAT文件。OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p>APK在安装的过程中，会通过dex2oat工具生成一个OAT文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_dex2oat</span><span class="params">(<span class="type">int</span> zip_fd, <span class="type">int</span> oat_fd, <span class="type">const</span> <span class="type">char</span>* input_file_name,    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* output_file_name, <span class="type">const</span> <span class="type">char</span>* dexopt_flags)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* DEX2OAT_BIN = <span class="string">&quot;/system/bin/dex2oat&quot;</span>;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_INT_LEN = <span class="number">12</span>;      <span class="comment">// &#x27;-&#x27;+10dig+&#x27;\0&#x27; -OR- 0x+8dig    </span></span><br><span class="line">    <span class="type">char</span> zip_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> zip_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-location=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    <span class="type">char</span> oat_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> oat_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-name=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_fd_arg, <span class="string">&quot;--zip-fd=%d&quot;</span>, zip_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_location_arg, <span class="string">&quot;--zip-location=%s&quot;</span>, input_file_name);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_fd_arg, <span class="string">&quot;--oat-fd=%d&quot;</span>, oat_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_location_arg, <span class="string">&quot;--oat-location=%s&quot;</span>, output_file_name);    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Running %s in=%s out=%s\n&quot;</span>, DEX2OAT_BIN, input_file_name, output_file_name);    </span><br><span class="line">    <span class="built_in">execl</span>(DEX2OAT_BIN, DEX2OAT_BIN,    </span><br><span class="line">          zip_fd_arg, zip_location_arg,    </span><br><span class="line">          oat_fd_arg, oat_location_arg,    </span><br><span class="line">          (<span class="type">char</span>*) <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;execl(%s) failed: %s\n&quot;</span>, DEX2OAT_BIN, <span class="built_in">strerror</span>(errno));    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="ART堆组成"><a href="#ART堆组成" class="headerlink" title="ART堆组成"></a>ART堆组成</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141224005343406" alt="img"></p>
<p>​		ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space。其中，Image Space、Zygote Space、Allocation Space是在地址上连续的空间，称为Continuous Space，而Large Object Space是一些离散地址的集合，用来分配一些大对象，称为Discontinuous Space。</p>
<p>​		在Image Space和Zygote Space之间，隔着一段用来映射system@<a href="mailto:&#x66;&#114;&#97;&#109;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#x6f;&#x74;&#46;&#97;&#x72;&#x74;">&#x66;&#114;&#97;&#109;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#x6f;&#x74;&#46;&#97;&#x72;&#x74;</a>@classes.oat文件的内存。system@<a href="mailto:&#x66;&#114;&#97;&#x6d;&#101;&#x77;&#x6f;&#114;&#x6b;&#64;&#x62;&#111;&#x6f;&#x74;&#x2e;&#97;&#x72;&#x74;">&#x66;&#114;&#97;&#x6d;&#101;&#x77;&#x6f;&#114;&#x6b;&#64;&#x62;&#111;&#x6f;&#x74;&#x2e;&#97;&#x72;&#x74;</a>@classes.oat是一个OAT文件，它是由在系统启动类路径中的所有DEX文件翻译得到的，而<strong>Image Space空间就包含了那些需要预加载的系统类对象。</strong>这意味着需要预加载的类对象是在生成system@<a href="mailto:&#102;&#x72;&#97;&#109;&#x65;&#x77;&#111;&#114;&#x6b;&#64;&#x62;&#x6f;&#x6f;&#x74;&#x2e;&#x61;&#114;&#116;">&#102;&#x72;&#97;&#109;&#x65;&#x77;&#111;&#114;&#x6b;&#64;&#x62;&#x6f;&#x6f;&#x74;&#x2e;&#x61;&#114;&#116;</a>@classes.oat这个OAT文件的时候创建并且保存在文件system@<a href="mailto:&#102;&#x72;&#x61;&#109;&#x65;&#x77;&#111;&#x72;&#107;&#x40;&#98;&#111;&#x6f;&#x74;&#46;&#x61;&#x72;&#x74;">&#102;&#x72;&#x61;&#109;&#x65;&#x77;&#111;&#x72;&#107;&#x40;&#98;&#111;&#x6f;&#x74;&#46;&#x61;&#x72;&#x74;</a>@classes.dex中，以后只要系统启动类路径中的DEX文件不发生变化（即不发生更新升级），那么以后每次系统启动只需要将文件system@<a href="mailto:&#102;&#x72;&#x61;&#x6d;&#101;&#119;&#111;&#x72;&#x6b;&#x40;&#98;&#111;&#x6f;&#116;&#x2e;&#97;&#114;&#x74;">&#102;&#x72;&#x61;&#x6d;&#101;&#119;&#111;&#x72;&#x6b;&#x40;&#98;&#111;&#x6f;&#116;&#x2e;&#97;&#114;&#x74;</a>@classes.dex直接映射到内存即可，省去了创建各个类对象的时间。之前使用Dalvik虚拟机作为应用程序运行时时，每次系统启动时，都需要为那些预加载的类创建类对象。因此，虽然ART运行时第一次启动时会比较慢，但是以后启动实际上会更快。</p>
<pre><code>     Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的。Zygote Space在Zygote进程和应用程序进程之间共享的，而Allocation Space则是每个进程独占的。同样的，Zygote进程一开始只有一个Image Space和一个Zygote Space。**在Zygote进程fork第一个子进程之前，就会把Zygote Space一分为二，原来的已经被使用的那部分堆还叫Zygote Space，而未使用的那部分堆就叫Allocation Space。以后的对象都在Allocation Space上分配。**
</code></pre>
<p>​		Image Space和Zygote Space在Zygote进程和应用程序进程之间进行共享，而Allocation Space就每个进程都独立地拥有一份。注意，虽然Image Space和Zygote Space都是在Zygote进程和应用程序进程之间进行共享，但是前者的对象只创建一次，而后者的对象需要在系统每次启动时根据运行情况都重新创建一遍。</p>
<p>与Dalivk虚拟机类似，ART运行时也使用一个Heap对象来描述堆：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141229201435625" alt="img"></p>
<p>Heap类包含了以下重要成员变量描述ART运行时的堆，它们的作用如下所述：</p>
<pre><code>   1. mark_sweep_collectors_: 一个std::vector&lt;collector::MarkSweep*&gt;向量，保存了六种Mark-Sweep垃圾收集器。

   2. continuous_spaces_: 一个std::vector&lt;space::ContinuousSpace*&gt;向量，保存了图1所示的三个在地址空间上连续的Image Space、Zygote Space和Allocation Space。

   3. concurrent_gc_: 一个bool变量，描述是否支持并行GC，可以通过ART运行时启动选项-Xgc来指定。

   4. parallel_gc_threads_: 一个size_t变量，指定在GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ParallelGCThreads指定。如果没有指定，它的值就等于CPU核心数减1。这里之所以要减1是因为parallel_gc_threads_描述的实际上是除了当前GC线程之外的其它也用于GC任务的线程的个数。

   5. conc_gc_threads_: 一个size_t变量，指定非GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ConcGCThreads来指定。

   6. discontinuous_spaces_: 一个std::vector&lt;space::DiscontinuousSpace*&gt;向量，保存了图1所示的在地址空间上不连续的Large Object Space。

   7. alloc_space_: 一个space::DlMallocSpace指针，指向一个space::DlMallocSpace对象，该对象描述的是图1所示的Allocation Space。

   8. large_object_space_: 一个space::LargeObjectSpace指针，指向一个space::LargeObjectSpace对象，该对象描述的是图1所示的Large Object Space。

   9. card_table_: 一个UniquePtr&lt;accounting::CardTable&gt;指针，指向一个accounting::CardTable对象，该对象描述的是图1所示的Card Table。

   10. image_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于上方的Mod Union Table对象，用来记录在GC并行阶段在Image Space上分配的对象对在Zygote Space和Allocation Space上分配的对象的引用。

   11. zygote_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于下方的Mod Union Table，用来记录在GC并行阶段在Zygote Space上分配的对象对在Allocation Space上分配的对象的引用。

   12. mark_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Mark Stack，用来在GC过程中实现递归对象标记。

   13. allocation_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Allocation Stack，用来记录上一次GC后分配的对象，用来实现类型为Sticky的Mark Sweep Collector。

   14. live_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Live Stack，配合allocation_stack_一起使用，用来实现类型为Sticky的Mark Sweep Collector。

   15. mark_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Mark Bitmap，与Dalvik虚拟机的Mark Bitmap作用是一样的，用来标记当前GC之后还存活的对象。

   16. live_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Live Bitmap，与Dalvik虚拟机的Live Bitmap作用是一样的，用来标记上一次GC之后还存活的对象。

    除了上述的16个成员变量，Heap类还定义了以下三个垃圾收集接口：

    1. CollectGarbage: 用来执行显式GC，例如用实现System.gc接口。

    2. ConcurrentGC: 用来执行并行GC，只能被ART运行时内部的GC守护线程调用。

    3. CollectGarbageInternal: ART运行时内部调用的GC接口，可以执行各种类型的GC。
</code></pre>
<p>​		上面我们提到，Heap类的成员变量mark_sweep_collectors_保存了ART运行时内部使用的六种垃圾收集器，这六种垃圾收集器分为两组。其中一组是支持并行GC的，另一组是不支持并行GC的。每一组都由MarkSweep、PartialMarkSweep和StickyMarkSweep三种类型的垃圾收集器组成</p>
<p>​		StickyMarkSweep继承于PartialMarkSweep，PartialMarkSweep又继承于MarkSweep、而MarkSweep又继承于GarbageCollector。因此，我们可以推断出，GarbageCollector定义了垃圾收集器接口，而MarkSweep、PartialMarkSweep和StickyMarkSweep通过重定某些接口来实现不同类型的垃圾收集器。</p>
<p>​		 在GarbageCollector中，有一个成员变量heap_，指向的是ART运行时堆，同时定义了两个public成员函数IsConcurrent和GetGcType。前者用来获得一个垃圾收集器是否支持并行GC，后者用来获得垃圾收集器类型 。</p>
<p> 垃圾收集器类型通过枚举类型GcType：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  kGcTypeNone, <span class="comment">// 一个占位符</span></span><br><span class="line">  kGcTypeSticky, <span class="comment">// 指的就是StickyMarkSweep类型的垃圾收集器，用来收集上次GC以来分配的对象。</span></span><br><span class="line">  kGcTypePartial,<span class="comment">// 指的就是PartialMarkSweep类型的垃圾收集器，用来收集在Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeFull, <span class="comment">//指的就是MarkSweep类型的垃圾收集器，用来收集在Zygote Space和Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeMax, <span class="comment">// 垃圾收集器类型个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GarbageCollector通过定义以下五个虚函数描述GC的各个阶段：</p>
<pre><code>   1. InitializePhase: 用来实现GC的初始化阶段，用来初始化垃圾收集器内部的状态。

   2. MarkingPhase: 用来实现GC的标记阶段，该阶段有可能是并行的，也有可能不是并行。

   3. HandleDirtyObjectsPhase: 用来实现并行GC的Dirty Object标记，也就是递归标记那些在并行标记对象阶段中被修改的对象。

   4. ReclaimPhase: 用来实现GC的回收阶段。

   5. FinishPhase: 用来实现GC的结束阶段。
</code></pre>
<p>MarkSweep类通过重写上述五个虚函数实现自己的垃圾收集过程，同时，它又通过定义以下三个虚函数来让子类PartialMarkSweep和StickyMarkSweep实现特定的垃圾收集器：</p>
<ol>
<li><p>MarkReachableObjects: 用来递归标记从根集对象引用的其它对象。</p>
</li>
<li><p>BindBitmap: 用来指定垃圾收集范围。</p>
</li>
<li><p>Sweep: 用来回收垃圾对象。</p>
</li>
</ol>
<p>   其中，MarkSweep类通过自己实现的成员函数BindBitmap将垃圾收集范围指定为Zygote和Allocation空间，而PartialMarkSweep和StickyMarkSweep类通过重写成员函数BindBitmap将垃圾收集范围指定为Allocation空间和上次GC后所分配的对象。此外，StickyMarkSweep类还通过重定成员函数MarkReachableObjects和Sweep将对象标记和回收限制为上次GC后所分配的对象</p>
<h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><p>ART模式英文全称为：Android runtime，谷歌Android 4.4系统新增的一种应用运行模式。<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<p>ART GC 与 Dalvik 的一个主要区别在于 <strong>ART GC 引入了移动垃圾回收器。</strong>使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。</p>
<ol>
<li>半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc&#x2F;DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。</li>
<li>同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。</li>
</ol>
<p><strong>OAT文件</strong></p>
<p>OAT文件是Android运行时ART的核心，它是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20ART%20GC.png" alt="Android ART GC"></p>
<p>非并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>恢复第2步挂起的ART运行时线程。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记即可。</li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。</li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。</li>
</ol>
<p>ART 的优点主要有三点：</p>
<ol>
<li>标记自身：ART在对象分配时会将新分配的对象压入到Heap类的成员变量allocation<em>stack</em>描述的Allocation Stack中去，从而可以一定程度上缩减对象遍历范围。</li>
<li>预读取：对于标记Allocation Stack的内存时，会预读取接下来要遍历的对象，同时在取出来该对象后又会将该对象引用的其他对象压入栈中，直至遍历完毕。</li>
<li>减少挂起时间：在Mark阶段是不会Block其他线程的，这个阶段会有Dirty数据，比如Mark发现不会使用的但是这个时候又被其他线程使用的数据，在Mark阶段也会处理一些Dirty数据而不是留在最后Block的时候再去处理，这样也会减少后面Block阶段对于脏数据的处理的时间。</li>
</ol>
<h3 id="Android-5-0-7-0-ART-GC"><a href="#Android-5-0-7-0-ART-GC" class="headerlink" title="Android 5.0 ~ 7.0 ART GC"></a>Android 5.0 ~ 7.0 ART GC</h3><p><strong>引入分代管理</strong></p>
<p>将堆分为新生代 (Young Generation) 和老年代 (Old Generation)，对应的GC也分为两种：</p>
<ul>
<li>Minor GC: 针对新生代的垃圾回收</li>
<li>Major GC (Full GC) : 针对整个堆的垃圾回收</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://lihaizhou.top/2021/10/27/%E5%AF%B9Android-S-ART-GC%E7%9A%84%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86/">对Android-S-ART-GC的源码梳理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6875678394332217357">ART虚拟机 | GC的触发时机和条件</a></p>
<p><a target="_blank" rel="noopener" href="https://hello2mao.github.io/2015/12/11/ART_GC_VS_Dalvik_GC/">Android 5.0 ART GC 对比 Android 4.x Dalvik GC</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6966205309782065159">android-gc-简史</a></p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@banerjee.s.sayans/android-garbage-collection-in-a-nutshell-e5c8acfa1538">Android Garbage Collection in a Nutshell</a></p>
<p><a target="_blank" rel="noopener" href="https://paul.pub/android-art-vm/">Android上的ART虚拟机</a></p>
<p><a target="_blank" rel="noopener" href="https://source.android.com/docs/core/runtime/gc-debug?hl=zh-cn">谷歌文档</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24835977">Android GC原理探究</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/297654028">Android Devlik和ART采用的是哪种垃圾收集器？</a></p>
<h3 id="ART-GC-回收策略的类型"><a href="#ART-GC-回收策略的类型" class="headerlink" title="ART GC 回收策略的类型"></a>ART GC 回收策略的类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># art/runtime/gc/collector/gc_type.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  <span class="comment">// Placeholder for when no GC has been performed.</span></span><br><span class="line">  kGcTypeNone,</span><br><span class="line">  <span class="comment">// Sticky mark bits GC that attempts to only free objects allocated since the last GC.</span></span><br><span class="line">  kGcTypeSticky,</span><br><span class="line">  <span class="comment">// Partial GC that marks the application heap but not the Zygote.</span></span><br><span class="line">  kGcTypePartial,</span><br><span class="line">  <span class="comment">// Full GC that marks and frees in both the application and Zygote heap.</span></span><br><span class="line">  kGcTypeFull,</span><br><span class="line">  <span class="comment">// Number of different GC types.</span></span><br><span class="line">  kGcTypeMax,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>kGcTypeNone:</strong><ul>
<li>描述：表示没有进行垃圾回收。</li>
<li>用途：作为占位符，表示在此时没有执行垃圾回收操作。</li>
</ul>
</li>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
<li><strong>kGcTypeFull:</strong><ul>
<li>描述：表示完全垃圾回收，同时标记并释放应用和Zygote堆中的对象。</li>
<li>用途：执行整个堆的垃圾回收，涉及应用堆和Zygote堆的所有对象。</li>
</ul>
</li>
<li><strong>kGcTypeMax:</strong><ul>
<li>描述：表示不同垃圾回收类型的总数。</li>
<li>用途：作为一个计数器，表示所有可能的垃圾回收类型的数量。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201211109922.png" alt="image-20240201211109922"></p>
<h3 id="ART-Heap的创建"><a href="#ART-Heap的创建" class="headerlink" title="ART Heap的创建"></a>ART Heap的创建</h3><p>看一下Heap创建时的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kMemMapSpaceName[<span class="number">2</span>] = &#123;<span class="string">&quot;main space&quot;</span>, <span class="string">&quot;main space 1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kRegionSpaceName = <span class="string">&quot;main space (region space)&quot;</span></span><br><span class="line"></span><br><span class="line">Heap::<span class="built_in">Heap</span>(……)&#123;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;space::ImageSpace&gt;&gt; boot_image_spaces;</span><br><span class="line">  <span class="comment">// 创建ImageSpace,用来加载boot.oat</span></span><br><span class="line">  <span class="keyword">if</span> (space::ImageSpace::<span class="built_in">LoadBootImage</span>(……,&amp;boot_image_spaces,……)) &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemMap main_mem_map_1;</span><br><span class="line">  MemMap main_mem_map_2;</span><br><span class="line"></span><br><span class="line">  std::string error_str;</span><br><span class="line">  MemMap non_moving_space_mem_map;</span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="comment">// 创建ZygoteSpace虚拟内存，大小为64M</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* space_name = is_zygote ? kZygoteSpaceName : kNonMovingSpaceName;</span><br><span class="line">    <span class="keyword">if</span> (heap_reservation.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      non_moving_space_mem_map = heap_reservation.<span class="built_in">RemapAtEnd</span>(</span><br><span class="line">          heap_reservation.<span class="built_in">Begin</span>(), space_name, PROT_READ | PROT_WRITE, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      non_moving_space_mem_map = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          space_name, request_begin, non_moving_space_capacity, &amp;error_str);</span><br><span class="line">    &#125;</span><br><span class="line">    request_begin = kPreferredAllocSpaceBegin + non_moving_space_capacity;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 前台gc不是并发复制回收时，会创建两个space，5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ != kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (separate_non_moving_space || !is_zygote) &#123;</span><br><span class="line">    <span class="comment">//3. 创建name为“main space”的space的虚拟内存</span></span><br><span class="line">      main_mem_map_1 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          kMemMapSpaceName[<span class="number">0</span>], request_begin, capacity_, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ……</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//同样是5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (support_homogeneous_space_compaction ||</span><br><span class="line">      background_collector_type_ == kCollectorTypeSS ||</span><br><span class="line">      foreground_collector_type_ == kCollectorTypeSS) &#123;</span><br><span class="line">    <span class="comment">//4. 创建name为“main space 1”的space的虚拟内存</span></span><br><span class="line">    main_mem_map_2 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">        kMemMapSpaceName[<span class="number">1</span>], main_mem_map_1.<span class="built_in">End</span>(), capacity_, &amp;error_str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = non_moving_space_mem_map.<span class="built_in">Size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* non_moving_space_mem_map_begin = non_moving_space_mem_map.<span class="built_in">Begin</span>();</span><br><span class="line">    <span class="comment">//通过DlMallocSpace来管理ZygoteSpze</span></span><br><span class="line">    non_moving_space_ = space::DlMallocSpace::<span class="built_in">CreateFromMemMap</span>(std::<span class="built_in">move</span>(non_moving_space_mem_map),</span><br><span class="line">                                                               <span class="string">&quot;zygote / non moving space&quot;</span>,</span><br><span class="line">                                                               kDefaultStartingSize,</span><br><span class="line">                                                               initial_size,</span><br><span class="line">                                                               size,</span><br><span class="line">     ……</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前台gc为并发复制回收，8.0及以上系统采用的gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ == kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="comment">//创建一个容量为capacity_ * 2，即1g的space，虽然这里创建了1g，但是可用的只有512，另外一半是GC时，用于对象移动的</span></span><br><span class="line">    MemMap region_space_mem_map =</span><br><span class="line">        space::RegionSpace::<span class="built_in">CreateMemMap</span>(kRegionSpaceName, capacity_ * <span class="number">2</span>, request_begin);</span><br><span class="line">   </span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsMovingGc</span>(foreground_collector_type_)) &#123;</span><br><span class="line">    <span class="comment">// 通过BumpPointerSpace管理前面创建的main space和main space</span></span><br><span class="line">    bump_pointer_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 1&quot;</span>,</span><br><span class="line">                                                                    std::<span class="built_in">move</span>(main_mem_map_1));</span><br><span class="line">   </span><br><span class="line">    temp_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 2&quot;</span>,</span><br><span class="line">                                                            std::<span class="built_in">move</span>(main_mem_map_2));</span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//通过MainMallocSpace来管理前面创建的main space和main space</span></span><br><span class="line">    <span class="built_in">CreateMainMallocSpace</span>(std::<span class="built_in">move</span>(main_mem_map_1), initial_size, growth_limit_, capacity_);</span><br><span class="line">    <span class="keyword">if</span> (main_mem_map_2.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* name = kUseRosAlloc ? kRosAllocSpaceName[<span class="number">1</span>] : kDlMallocSpaceName[<span class="number">1</span>];</span><br><span class="line">      main_space_backup_.<span class="built_in">reset</span>(<span class="built_in">CreateMallocSpaceFromMemMap</span>(std::<span class="built_in">move</span>(main_mem_map_2),</span><br><span class="line">                                                           initial_size,</span><br><span class="line">                                                           growth_limit_,</span><br><span class="line">                                                           capacity_,</span><br><span class="line">                                                           name,</span><br><span class="line">                                                           <span class="comment">/* can_move_objects= */</span> <span class="literal">true</span>));</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请并创建LargeObjectSpace</span></span><br><span class="line">  <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kFreeList) &#123;</span><br><span class="line">    large_object_space_ = space::FreeListSpace::<span class="built_in">Create</span>(<span class="string">&quot;free list large object space&quot;</span>, capacity_);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kMap) &#123;</span><br><span class="line">    large_object_space_ = space::LargeObjectMapSpace::<span class="built_in">Create</span>(<span class="string">&quot;mem map large object space&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>所有的 Space 创建，都是先通过 mmap 申请一块匿名内存，然后将这块内存放入对应的 Space 空间中进行管理</strong>。比如 ZygoteSpace 的创建，会先通过 CreateFromMemMap 函数创建一个名字为 zygote，大小为 64M 的匿名内存，然后将这一块内存放入 DlMallocSpace 管理。下面简单介绍一下用来管理申请内存的 Space：</p>
<ol>
<li><strong>DlMallocSpace</strong>：通过 dlmalloc 内存分配器来申请和释放内存，这是一个很出名的内存分配器，网上有大量的资料介绍，这里就不详细介绍了。</li>
<li><strong>MainMallocSpace</strong>：通过谷歌开发的 rosalloc 内存分配管理器来申请和释放内存。rosalloc 的用法比 dlmalloc 要复杂得多，而且还需要 ART 虚拟机中其他模块进行配合。但是分配的效果要比 dlmalloc 更好，并且多线程下表现更好。</li>
<li><strong>BumpPointerSpace</strong>：很简单的内存分配算法，按照顺序分配，类似于链表，容易出现内存碎片，所以只用在线程本地存储或者存活周期很长的对象空间上。</li>
<li><strong>RegionSpace</strong>：RegionSpace 的内存分配算法比 BumpPointerSpace 稍微高级一点。它先将内存资源划分成一个个固定大小（由 kRegionSize 指定，默认为 1MB）的内存块，每一个内存块由一个 Region 对象表示，进行内存分配时，先找到满足要求的 Region，然后从这个 Region 中分配资源。</li>
<li><strong>FreeListSpace&#x2F;LargeObjectMapSpace</strong>：通过 list 或者 map 来分配和释放内存，比 BumpPointerSpace 更简单。</li>
</ol>
<p>MainSpace 会根据 GC 回收器类型这个条件判断，有不同的创建方式，并且选择是放入 RegionSpace、BumpPointerSpace 还是 MainMallocSpace 中，这里判断规则如下：</p>
<ol>
<li>Android5.x~7.x：会创建名字为 “main space” 和 “main space 1”，大小都为 512M 的空间，并且 main space 和 main space 1 会通过 MainMallocSpace 来维护和管理，实际只会使用其中的一个空间，只有当执行 GC 的时候，另一个空间才派上用场。此时，GC 回收器会将前面所使用的空间中的存活对象全部移动到另一个空间来。</li>
<li>Android8.0 及以上：创建 main space (region space)，并且通过 <strong>RegionSpace</strong> 来维护和管理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9865353d11a44837aec2fd55a1e4aff3%7Etplv-k3u1fbpfcp-jj-mark%3A2079%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace(</strong><code>region space</code>**)**：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p><strong>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。</strong></p>
<h3 id="ART堆对象分配"><a href="#ART堆对象分配" class="headerlink" title="ART堆对象分配"></a>ART堆对象分配</h3><p>在 Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存，我们直接看这个接口申请内存的代码逻辑（完整的代码可以看：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">heap-inl.h</a>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只保留了主逻辑，通过注释可以看到，虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<p>什么是大对象呢？通过 ShouldAllocLargeObject 判断接口可以看到，申请的内存大小大于 3页，且是基本类型数组或者字符串便认为是大对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::ShouldAllocLargeObject</span><span class="params">(ObjPtr&lt;mirror::Class&gt; c, <span class="type">size_t</span> byte_count)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> byte_count &gt;= large_object_threshold_ &amp;&amp; (c-&gt;<span class="built_in">IsPrimitiveArray</span>() || c-&gt;<span class="built_in">IsStringClass</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ART堆对象的释放"><a href="#ART堆对象的释放" class="headerlink" title="ART堆对象的释放"></a>ART堆对象的释放</h3><p> Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC，在上面申请流程中我们可以看到申请内存失败后，会调用 AllocateInternalWithGc 接口去重新申请，这个接口会调用 CollectGarbageInternal 接口进行 GC。(源码连接：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">c++复制代码<span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//1. 选择对应的垃圾回收器</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) </span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// Try to read each page of the memory map in case mprotect didn&#x27;t work properly b/19894268.</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">      current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 执行GC</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的逻辑比较简单：</p>
<ol>
<li>选择合适的 GarbageCollector（垃圾回收器），并设置好这个 collector 的环境，如 kCollectorTypeSS（半空间回收）就会设置好 FromSpace 和 ToSpace。</li>
<li>接着调用执行 collector-&gt;Run 接口，collector 会执行对象的回收策略。</li>
</ol>
<p>不同的 GarbageCollector 对应了不同的 GC 算法，这一块的知识比较庞大，超出了该篇章的内容，不做详细的介绍了，只简单介绍一下 GarbageCollector 是如何判断一个对象是否可回收的。</p>
<h2 id="ART-GC-1"><a href="#ART-GC-1" class="headerlink" title="ART  GC"></a>ART  GC</h2><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>root set的定义在虚拟机的<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android13-release:art/">art</a>&#x2F;<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/">runtime</a>&#x2F;<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/gc_root.h">gc_root.h</a>文件下，</p>
<p>在 Android 内存管理中，”根对象” 是指那些能够直接或间接引用其他对象的对象。垃圾收集器通过识别和遍历这些根对象，能够确定哪些对象是可达的，哪些对象是不可达的，从而进行垃圾回收。</p>
<p><strong>虚拟机能直接找到的Object对象都属于root set。</strong>所谓的”root set”指的是包含了一些Java对象（在ART虚拟机中具体是mirror Object对象）的集合。这些对象不是通过其他对象的引用型成员变量来找到的，而是由虚拟机根据其实现特点来确定的。一般而言，”root set”包含多种类型的root信息。</p>
<p>这些根对象的类型用于表示对象的引用来源和作用域,这些内容以枚举类型的形式存放在gc_root.h下。</p>
<p>以下是其中一些根对象类型的简要解释：</p>
<ul>
<li><code>kRootJNIGlobal</code>: <strong>JNI 全局引用</strong>，即由 JNI（Java Native Interface）创建的全局引用。</li>
<li><code>kRootJNILocal</code>: <strong>JNI 局部引用</strong>，即由 JNI 创建的局部引用。</li>
<li><code>kRootJavaFrame</code>: <strong>表示 Java 方法调用的栈帧</strong>，即 Java 方法中的局部变量和操作数栈。</li>
<li><code>kRootNativeStack</code>: <strong>表示 Native 方法的调用栈</strong>，即 Native 方法中的局部变量和操作数栈。</li>
<li><code>kRootStickyClass</code>: Sticky 类，通常指的是被标记为 “sticky” 的类对象。在垃圾回收的实现中，可能会有一些对象在回收过程中被标记为 “sticky”，这表示它们在接下来的阶段中，例如移动对象的阶段，将不会被移动或发生其他变化。这样的标记有助于提高垃圾回收的效率，因为不需要频繁地处理这些对象。</li>
<li><code>kRootThreadBlock</code>: <strong>线程块</strong>，表示线程的信息块。</li>
<li><code>kRootMonitorUsed</code>: 正在使用的监视器，即被线程锁，锁住的对象。</li>
<li><code>kRootThreadObject</code>: <strong>线程对象，表示 Java 中的线程对象。</strong></li>
<li><code>kRootInternedString</code>: Interned 字符串，表示在字符串常量池中的字符串。</li>
<li><code>kRootFinalizing</code>: 正在进行 finalization（终结操作）的对象。</li>
<li><code>kRootDebugger</code>: 被调试器引用的对象。</li>
<li><code>kRootReferenceCleanup</code>: 引用清理，通常与引用队列相关。</li>
<li><code>kRootVMInternal</code>: <strong>虚拟机内部使用的对象。</strong></li>
<li><code>kRootJNIMonitor</code>: JNI 监视器对象，即由 JNI 创建的监视器。</li>
</ul>
<p>这些根对象类型的识别和分析对于 Android 内存分析和垃圾回收是至关重要的，它们帮助系统找出哪些对象是存活的，哪些对象可以被回收。</p>
<h3 id="ART-GC-方案"><a href="#ART-GC-方案" class="headerlink" title="ART  GC 方案"></a>ART  GC 方案</h3><p>ART 默认的GC方案Android 14 为CMC，Android 13-8为CMS。</p>
<p>​	下面这段代码时JNI层设置AndroidRuntime，大概是读取配置文件来解析对应的GC处理器选项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># /frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"><span class="comment">// 解析运行时选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.gctype&quot;</span>, gctypeOptsBuf, <span class="string">&quot;-Xgc:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取是否启用分代收集的配置</span></span><br><span class="line">std::string enable_generational_cc =</span><br><span class="line">    server_configurable_flags::<span class="built_in">GetServerConfigurableFlag</span>(RUNTIME_NATIVE_BOOT_NAMESPACE,</span><br><span class="line">                                                         ENABLE_GENERATIONAL_CC,</span><br><span class="line">                                                         <span class="comment">/*default_value=*/</span> <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 根据配置值决定是否启用分代收集，并添加相应选项</span></span><br><span class="line"><span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kGenerationalCCRuntimeOption);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;false&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kNoGenerationalCCRuntimeOption);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析后台GC处理器的配置选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.backgroundgctype&quot;</span>, backgroundgcOptsBuf, <span class="string">&quot;-XX:BackgroundGC=&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的<code>backgroundgcOptsBuf</code>和<code>gctypeOptsBuf</code>分别读取配置然后解析设置了前台GC和后台GC，下面看下GC具体的解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># art/cmdline/cmdline_types.h</span></span><br><span class="line"><span class="comment">// 解析垃圾收集器类型的方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> gc::CollectorType <span class="title">ParseCollectorType</span><span class="params">(<span class="type">const</span> std::string&amp; option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (option == <span class="string">&quot;MS&quot;</span> || option == <span class="string">&quot;nonconcurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CMS&quot;</span> || option == <span class="string">&quot;concurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;SS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeSS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CC&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCC;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上面就是前后台通用的GC处理器项有：</p>
<ul>
<li><code>kCollectorTypeMS</code>: 代表标记-清除（Mark-Sweep）垃圾回收器。在这种回收器中，首先标记不再使用的内存，然后清除或回收这些标记的内存。</li>
<li><code>kCollectorTypeCMS</code>: 代表并发标记-清除（Concurrent Mark-Sweep）垃圾回收器。这是一种改进的标记-清除算法，它允许在标记过程中应用程序线程和垃圾回收线程并发运行。</li>
<li><code>kCollectorTypeSS</code>: 代表单步垃圾回收器（Sticky-Start）。这可能是一种实验性的或者特殊用途的垃圾回收策略，具体实现和特性可能因系统和环境而异。</li>
<li>kCollectorTypeGSS：GSS 垃圾回收器是在 SS 的基础上引入了分代的概念。</li>
<li><code>kCollectorTypeCC</code>: 代表并发复制回收器（Compact Collection）垃圾回收器。这种回收器的目标是在回收内存的同时压缩内存，以减少内存碎片化。</li>
</ul>
<p>后台会多一个</p>
<ul>
<li>kCollectorTypeHomogeneousSpaceCompact：代表同质空间压缩垃圾回收器，将存活对象压缩到内存区域的一端，从而在另一端创建一个连续的空闲空间。这有助于减少内存碎片，提高内存的可用性。</li>
</ul>
<h3 id="ART-GC-分配器实现"><a href="#ART-GC-分配器实现" class="headerlink" title="ART GC 分配器实现"></a>ART GC 分配器实现</h3><p>分配器的类型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AllocatorType</span> : <span class="type">char</span> &#123;</span><br><span class="line">  kAllocatorTypeBumpPointer,      <span class="comment">// 使用全局 CAS（Compare and Swap）实现的 BumpPointer 分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeTLAB,             <span class="comment">// 在 BumpPointer 空间内使用 TLAB（Thread-Local Allocation Buffer）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeRosAlloc,         <span class="comment">// 使用 RosAlloc（分离大小、自由列表）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeDlMalloc,         <span class="comment">// 使用 dlmalloc（著名的 C malloc）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeNonMoving,        <span class="comment">// 用于非移动对象的特殊分配器。</span></span><br><span class="line">  kAllocatorTypeLOS,              <span class="comment">// 大对象空间。</span></span><br><span class="line">  <span class="comment">// 以下与 BumpPointer 分配器的主要区别在于从多个区域而不是单个连续空间分配内存。</span></span><br><span class="line">  kAllocatorTypeRegion,           <span class="comment">// 在区域内使用 CAS 实现的连续 BumpPointer 分配。 (*)</span></span><br><span class="line">  kAllocatorTypeRegionTLAB,       <span class="comment">// 使用区域片段作为 TLAB。对大多数小对象的默认设置。 (*)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>不同的分配器，对应着不同的内存空间，而不同的内存空间，又都有着自身的内存分配方式 。</strong>ART GC中所涉及的内存空间是用 一 个枚举类型 SpaceType 来表示的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpaceType</span> &#123;</span><br><span class="line">  kSpaceTypeImageSpace,           <span class="comment">// 用于存储应用程序的可执行代码和资源的空间</span></span><br><span class="line">  kSpaceTypeMallocSpace,          <span class="comment">// 用于分配堆对象的普通堆空间</span></span><br><span class="line">  kSpaceTypeZygoteSpace,          <span class="comment">// 用于存储 Zygote 进程中的共享对象的空间</span></span><br><span class="line">  kSpaceTypeBumpPointerSpace,     <span class="comment">// 用于快速分配对象的堆空间</span></span><br><span class="line">  kSpaceTypeLargeObjectSpace,     <span class="comment">// 用于存储大对象的空间，通常采用不同的分配和回收策略</span></span><br><span class="line">  kSpaceTypeRegionSpace,          <span class="comment">// 用于分配堆对象的区域化空间，实现一种分代垃圾回收策略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过switch- case 结构，根据分配器类型 allocator_ type 的不同取值，去选择对应的<strong>空间类</strong>，并调用其分配空间函数，以此去实现内存分配 。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201230533603.png" alt="image-20240201230533603"></p>
<p>空间类的继承关系：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1163119-20170514004423957-2085494711.jpg" alt="img"></p>
<h3 id="ATR-GC-回收器的实现"><a href="#ATR-GC-回收器的实现" class="headerlink" title="ATR GC 回收器的实现"></a>ATR GC 回收器的实现</h3><p>​		在ART中，回收器的实现代码位于<code>art/Runtime/gc/collector</code>目录之下。回收器本身有一个实现类<code>GarbageCollector</code>，不同回收方案所对应的回收器是作为<code>GarbageCollector</code>的子类进行实现的。</p>
<p>​		<code>GarbageCollector</code>类的声明和实现分别位于<code>art/Runtime/gc/collector</code>目录下的<code>garbage_collector.h</code>和<code>garbage_collector.cc</code>中。<code>GarbageCollector</code>类继承自<code>RootVisitor</code>、<code>IsMarkedVisitor</code>和<code>MarkObjectVisitor</code>。</p>
<p>​		<code>GarbageCollector</code>类中包含一个<code>ScopedPause</code>类，<code>ScopedPause</code>类有一个重要的成员变量<code>collector_</code>，它是指向回收器的指针。在<code>GarbageCollector</code>类中，比较重要的成员函数包括<code>Run()</code>函数和<code>RunPhases()</code>函数。<code>Run()</code>函数用于运行回收器，而<code>RunPhases()</code>函数用于运行GC的所有阶段。</p>
<p>​		<code>GarbageCollector::Run()</code>函数在实现垃圾回收功能时，通过调用<code>RunPhases()</code>函数来运行所有的GC阶段，从而最终实现垃圾回收的目标。</p>
<p>​		<code>RunPhases()</code>函数在<code>GarbageCollector</code>类中并没有具体实现，而是要在其子类中根据需要去实现。因此，<code>GarbageCollector</code>类的子类的<code>RunPhases()</code>函数是对应回收器的核心实现。这种设计允许每个具体的垃圾回收方案有自己的实现方式，以满足特定的需求。</p>
<p>下面是GC中主要类的关系</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240202192845076.png" alt="image-20240202192845076"></p>
<h3 id="分配器与回收器"><a href="#分配器与回收器" class="headerlink" title="分配器与回收器"></a>分配器与回收器</h3><p>​	选择回收器</p>
<p>​	<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heap::ChangeCollector</span><span class="params">(CollectorType collector_type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 只有在挂起所有 Mutator 线程以避免竞态条件时才执行此操作。</span></span><br><span class="line">  <span class="keyword">if</span> (collector_type != collector_type_) &#123;</span><br><span class="line">    <span class="comment">// 更新收集器类型</span></span><br><span class="line">    collector_type_ = collector_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除当前 GC 计划</span></span><br><span class="line">    gc_plan_.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据新的收集器类型生成新的 GC 计划</span></span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC: &#123;</span><br><span class="line">        <span class="comment">// 如果使用分代 CC（Generational CC），添加 Sticky GC 类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB（Thread-Local Allocation Buffer） 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegionTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegion);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">UNIMPLEMENTED</span>(FATAL);</span><br><span class="line">        <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的并发启动字节数</span></span><br><span class="line">    <span class="built_in">SetDefaultConcurrentStartBytesLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配器和回收器对应表</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201231055275.png" alt="image-20240201231055275"></p>
<h3 id="堆内存GC流程"><a href="#堆内存GC流程" class="headerlink" title="堆内存GC流程"></a>堆内存GC流程</h3><h4 id="对象内存申请"><a href="#对象内存申请" class="headerlink" title="对象内存申请"></a>对象内存申请</h4><p>分配器要为新建立的对象分配空间，这个操作主要靠 Heap 类的 AllocObjectWithAllocator( ）函数实现， AllocObjectWithAll ocator( ）函数的实现位于 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">art &#x2F; Runtime&#x2F;gc&#x2F; heap- inl. h</a> 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h4><p>GC 回收器主要在进行垃圾回收的时候使用，而垃圾回收的执行需要触发事件进行触发 。垃圾回收的触发，在实现上专门由 一 个枚举类型 GcCause 表示，这个枚举类型的定义位于 art &#x2F; Runtime &#x2F; gc &#x2F; gc_cause. h 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcCause</span> &#123;</span><br><span class="line">  <span class="comment">// 无效的 GC 原因，用作占位符。</span></span><br><span class="line">  kGcCauseNone,</span><br><span class="line">  <span class="comment">// 由于分配失败而触发的 GC。执行分配的线程在重试分配之前被阻塞，等待 GC 完成。</span></span><br><span class="line">  kGcCauseForAlloc,</span><br><span class="line">  <span class="comment">// 用于确保在分配之前有足够的空闲内存的后台 GC。</span></span><br><span class="line">  kGcCauseBackground,</span><br><span class="line">  <span class="comment">// 显式的 System.gc() 调用。</span></span><br><span class="line">  kGcCauseExplicit,</span><br><span class="line">  <span class="comment">// 在超过 NativeAllocationGcWatermark 时触发的为本地分配而进行的 GC。</span></span><br><span class="line">  <span class="comment">// （根据是否运行非并发收集器，这可能是一个阻塞的 GC）。</span></span><br><span class="line">  kGcCauseForNativeAlloc,</span><br><span class="line">  <span class="comment">// 为了进行收集器转换而触发的 GC。</span></span><br><span class="line">  kGcCauseCollectorTransition,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于禁用移动 GC（目前用于 GetPrimitiveArrayCritical）。</span></span><br><span class="line">  kGcCauseDisableMovingGc,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于修整堆。</span></span><br><span class="line">  kGcCauseTrim,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和插装之间的排除。</span></span><br><span class="line">  kGcCauseInstrumentation,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除应用程序图像空间。</span></span><br><span class="line">  kGcCauseAddRemoveAppImageSpace,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和调试器之间的排除。</span></span><br><span class="line">  kGcCauseDebugger,</span><br><span class="line">  <span class="comment">// 在前台和后台收集器都是 CMS 时触发的用于背景转换的 GC。</span></span><br><span class="line">  kGcCauseHomogeneousSpaceCompact,</span><br><span class="line">  <span class="comment">// 类链接器原因，用于保护填充 art 方法的特殊值。</span></span><br><span class="line">  kGcCauseClassLinker,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现代码缓存元数据和 GC 之间的排除。</span></span><br><span class="line">  kGcCauseJitCodeCache,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除系统弱引用持有者。</span></span><br><span class="line">  kGcCauseAddRemoveSystemWeakHolder,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 hprof 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseHprof,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 GetObjectsAllocated 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseGetObjectsAllocated,</span><br><span class="line">  <span class="comment">// 用于 Profile Saver 的 GC 原因。</span></span><br><span class="line">  kGcCauseProfileSaver,</span><br><span class="line">  <span class="comment">// 在启动时删除 dex 缓存数组的 GC 原因。</span></span><br><span class="line">  kGcCauseDeletingDexCacheArrays,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于开发者而言，常见的是其中三种：</p>
<ul>
<li>GcCauseForAlloc：通过new分配新对象时，堆中剩余空间(普通应用默认上限为256M，声明largeHeap的应用为512M)不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>GcCauseExplicit：当应用调用系统API System.gc()时，会产生一次GC动作。</li>
<li>GcCauseBackground：后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。相比于前两种GC，后台GC出现的更多也更加隐秘。这个触发动作是在分配内存成功之后进行的触发 。为了确保每次分配空 间都 有空 间可用。</li>
</ul>
<p>最终的GC 触发最终都会通过调用CollectGarbagelnternal ( ）函数进行 GC 。实现位于<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc;l=2709">art&#x2F;Runtime&#x2F;gc &#x2F; heap.cc</a> 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前线程和运行时对象</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果堆无法运行GC，则静默失败并返回未运行任何GC。</span></span><br><span class="line">  <span class="keyword">switch</span> (gc_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> collector::kGcTypePartial: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">HasZygoteSpace</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果没有Zygote空间，不增加gcs_completed_计数，应该使用kGcTypeFull重试。</span></span><br><span class="line">        <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// 其他GC类型没有特殊情况，这使它们不可运行。主要的情况是全GC。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换线程状态，确保没有持有Mutator锁</span></span><br><span class="line">  <span class="function">ScopedThreadStateChange <span class="title">tsc</span><span class="params">(self, ThreadState::kWaitingPerformingGc)</span></span>;</span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程正在处理堆栈溢出，则不足够的剩余堆栈空间运行GC。</span></span><br><span class="line">  <span class="keyword">if</span> (self-&gt;<span class="built_in">IsHandlingStackOverflow</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果我们正在抛出堆栈溢出错误，我们可能没有足够的剩余堆栈空间来运行GC。</span></span><br><span class="line">    <span class="comment">// 计数此GC，以防有人在等待它完成。</span></span><br><span class="line">    gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">    <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> compacting_gc;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取GC完成锁并切换线程状态，等待GC完成</span></span><br><span class="line">    gc_complete_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">    <span class="function">ScopedThreadStateChange <span class="title">tsc2</span><span class="params">(self, ThreadState::kWaitingForGcToComplete)</span></span>;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *gc_complete_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保一次只有一个GC</span></span><br><span class="line">    <span class="built_in">WaitForGcToCompleteLocked</span>(gc_cause, self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经在其他地方触发了适当的GC，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (requested_gc_num != GC_NUM_ANY &amp;&amp; !<span class="built_in">GCNumberLt</span>(<span class="built_in">GetCurrentGcNum</span>(), requested_gc_num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compacting_gc = <span class="built_in">IsMovingGc</span>(collector_type_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是压缩式GC，检查是否禁用了移动GC。</span></span><br><span class="line">    <span class="keyword">if</span> (compacting_gc &amp;&amp; disable_moving_gc_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Skipping GC due to disable moving GC count &quot;</span> &lt;&lt; disable_moving_gc_count_;</span><br><span class="line">      <span class="comment">// 再次计数此GC。</span></span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在关机过程中禁用了GC，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (gc_disabled_for_shutdown_) &#123;</span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置正在运行的收集器类型和最后的GC原因。</span></span><br><span class="line">    collector_type_running_ = collector_type_;</span><br><span class="line">    last_gc_cause_ = gc_cause;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是由于分配而触发的GC，增加统计信息计数。</span></span><br><span class="line">  <span class="keyword">if</span> (gc_cause == kGcCauseForAlloc &amp;&amp; runtime-&gt;<span class="built_in">HasStatsEnabled</span>()) &#123;</span><br><span class="line">    ++runtime-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">    ++self-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取在堆上执行GC的垃圾收集器对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes_allocated_before_gc = <span class="built_in">GetBytesAllocated</span>();</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(gc_type, collector::kGcTypeMax);</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(gc_type, collector::kGcTypeNone);</span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据GC类型和分配器类型选择垃圾收集器。</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(current_allocator_ == kAllocatorTypeBumpPointer ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeTLAB ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegion ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegionTLAB);</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        <span class="comment">// 选择SemiSpace收集器并设置SemiSpace的源和目标空间。</span></span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC:</span><br><span class="line">        <span class="comment">// 选择MarkCompact收集器。</span></span><br><span class="line">        collector = mark_compact_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        <span class="comment">// 选择ConcurrentCopying收集器。</span></span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> 其他线程必须在开始检查active_concurrent_copying_collector_之前进行翻转检查。</span></span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          <span class="built_in">DCHECK</span>(active_cc_collector-&gt;<span class="built_in">RegionSpace</span>() == region_space_);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid collector type &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于kCollectorTypeCMC，temp_space_将为null。</span></span><br><span class="line">    <span class="keyword">if</span> (temp_space_ != <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// 尝试读取内存映射的每一页，以防mprotect没有正确工作 b/19894268。</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">CHECK</span>(temp_space_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">             current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    <span class="comment">// 根据分配器类型选择垃圾收集器。</span></span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查垃圾收集器是否可用。</span></span><br><span class="line">  <span class="built_in">CHECK</span>(collector != <span class="literal">nullptr</span>)</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Could not find garbage collector with collector_type=&quot;</span></span><br><span class="line">      &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_) &lt;&lt; <span class="string">&quot; and gc_type=&quot;</span> &lt;&lt; gc_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行垃圾收集器。</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加已释放内存的计数。</span></span><br><span class="line">  <span class="built_in">IncrementFreedEver</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求堆修剪。</span></span><br><span class="line">  <span class="built_in">RequestTrim</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展堆，以便知道何时执行下一次GC。</span></span><br><span class="line">  <span class="built_in">GrowForUtilization</span>(collector, bytes_allocated_before_gc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录旧的本地分配的字节数。</span></span><br><span class="line">  old_native_bytes_allocated_.<span class="built_in">store</span>(<span class="built_in">GetNativeBytes</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录GC日志。</span></span><br><span class="line">  <span class="built_in">LogGC</span>(gc_cause, collector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成GC过程。</span></span><br><span class="line">  <span class="built_in">FinishGC</span>(self, gc_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际上将所有清除的引用入队。在GC正式完成后执行此操作，否则可能会发生死锁。</span></span><br><span class="line">  SelfDeletingTask* clear = reference_processor_-&gt;<span class="built_in">CollectClearedReferences</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行清理引用任务。</span></span><br><span class="line">  clear-&gt;<span class="built_in">Run</span>(self);</span><br><span class="line">  clear-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知DDMS GC已完成。</span></span><br><span class="line">  Dbg::<span class="built_in">GcDidFinish</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类卸载时卸载本地库。我们在调用FinishGC之后执行此操作，以防JNI_OnUnload函数进行分配。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line">    soa.<span class="built_in">Vm</span>()-&gt;<span class="built_in">UnloadNativeLibraries</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回GC的类型。</span></span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="GC流程补充"><a href="#GC流程补充" class="headerlink" title="GC流程补充"></a>GC流程补充</h3><p>Android 版本 8 到 13 期间，系统一直使用的是 Concurrent Copy 垃圾回收算法（CC）。该算法通过使用 FromSpace 和 ToSpace 两个内存空间，实现了一种巧妙的复制机制。这种机制通过在垃圾回收过程中，同时利用这两个空间，来达到空间换时间的效果，或者说通过复杂度来提高垃圾回收的效率。在具体操作中，对象被从一个空间（FromSpace）复制到另一个空间（ToSpace），从而清理掉 FromSpace 中不再被引用的对象。</p>
<p>这种复制机制会在垃圾回收过程中使用两倍的内存，因为需要同时维护两个空间。在极端情况下，这可能导致内存占用量翻倍，因为系统需要为每个对象在 FromSpace 和 ToSpace 中都分配空间。尽管这可能带来一些额外的内存消耗，但由于复制算法的高效性，通常能够更迅速地回收垃圾，从而提高整体性能。这种垃圾回收方式在某些场景下可能更适用，特别是对于实时性能要求较高的系统。</p>
<p>ART虚拟机创建时先确定内存回收器的类型，进而绑定对应的内存分配器，因回收器已设置为CC(ConcurrentCopying)即并发复制回收器，则Heap内存的主要分配区域定为RegionSpace，RegionSpace由一个个256KB的Region组成。对应的RegionSpace内存分配器定为kAllocatorTypeRegion。</p>
<p>从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。</p>
<p>并发复制 GC 的一些主要特性包括：</p>
<ul>
<li>CC 支持使用名为“RegionTLAB”的触碰指针分配器。此分配器可以向每个应用线程分配一个线程本地分配缓冲区 (TLAB)，这样，应用线程只需触碰“栈顶”指针，而无需任何同步操作，即可从其 TLAB 中将对象分配出去。</li>
<li>CC 通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理。这是在读取屏障的帮助下实现的，<strong>读取屏障会拦截来自堆的引用读取</strong>，无需应用开发者进行任何干预。</li>
<li>GC 只有一次很短的暂停，对于堆大小而言，该次暂停在时间上是一个常量。</li>
<li>在 Android 10 及更高版本中，CC 会扩展为分代 GC。它支持轻松回收存留期较短的对象，这类对象通常很快便会无法访问。这有助于提高 GC 吞吐量，并显著延迟执行全堆 GC 的需要。</li>
</ul>
<p>ART代码中的heap则是一个类，其作用更像是堆内存的管理器。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Android 4.4</th>
<th>Android 5~6</th>
<th>Android 7</th>
<th>Android 8~9</th>
<th>Android 10</th>
</tr>
</thead>
<tbody><tr>
<td>回收算法</td>
<td>CMS</td>
<td>CMS</td>
<td>CMS</td>
<td>CC</td>
<td>CC</td>
</tr>
<tr>
<td>内存分配机制</td>
<td>Single-Thread</td>
<td>Per-Thread</td>
<td>Per-thread</td>
<td>Bump Pointer</td>
<td>Bump Pointer</td>
</tr>
<tr>
<td>内存分配性能</td>
<td>1x</td>
<td>4-5x</td>
<td>10x</td>
<td>18x</td>
<td>18x</td>
</tr>
<tr>
<td>临时变量开销</td>
<td>高</td>
<td>低(分代)</td>
<td>低(分代)</td>
<td>中</td>
<td>低(分代)</td>
</tr>
<tr>
<td>内存整理(防止碎片化)</td>
<td>后台</td>
<td>后台&#x2F;事件</td>
<td>后台&#x2F;事件</td>
<td>前台并发</td>
<td>前台并发</td>
</tr>
</tbody></table>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是 Concurrent Mark Sweep 的简称，中文翻译为并发标记清除方案，可以简单地理解为并发的标记清除方案 。为了提高垃圾回收的效率，学者们提出了并发垃圾回收 。 并发垃圾回收允许赋值器线程和回收器线程同时执行以提高回收效率 。 在这里需要注意区分并发垃圾回收和并行垃圾回收 。 与并发垃圾回收不同的是，并行垃圾回收通常使用多个回收器线程进行垃圾回收 。CMS 方案允许赋值器和回收器线程同时执行，并且其回收器分为标记和清除两个阶段 。</p>
<h3 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h3><p>它是 “Semi-Space”（半空间）和 “Mark-Sweep”（标记-清除）两种垃圾回收算法的混合方案。</p>
<ol>
<li><strong>Semi-Space (半空间)</strong>: Semi-Space 是一种年轻代垃圾回收算法，通常用于处理新生代对象的回收。它将堆空间分为两个大小相等的半空间，一个是源空间，一个是目标空间。在垃圾回收过程中，存活的对象从源空间复制到目标空间，然后清理源空间中的所有对象。这有助于提高内存分配的效率，减少内存碎片。</li>
<li><strong>Mark-Sweep (标记-清除)</strong>: Mark-Sweep 是一种用于整个堆的垃圾回收算法。它分为两个主要阶段。首先，标记阶段会遍历并标记所有可达的对象。然后，在清除阶段，未标记的对象会被释放，堆空间得到整理。</li>
</ol>
<p>“SS” 方案将这两种算法结合在一起。在堆的年轻代使用 Semi-Space 进行垃圾回收，而在整个堆使用 Mark-Sweep 进行垃圾回收。这样，可以结合两种算法的优点，达到更好的性能和空间利用率。</p>
<h3 id="GSS"><a href="#GSS" class="headerlink" title="GSS"></a>GSS</h3><p>GSS 是 SS 回收方案的分代回收版本 。分代回收在对象中引入了“年龄＂的概念， 将对象分为新生代对象和老年代对象 。其中， 新生代对象指的是刚生成的对象，老年代对象指的是到达 一 定“年龄＂的对象 。因为新生代对象大部分会变成垃圾，所以分代回收将新生代对象和老年代对象分别进行 GC ，对新生代对象进行的 GC 称为新生代 GC ，对老年代对象进行的 GC 称为老年代 GC ， 一 般情况下会提高新生代 GC 的频率，降低老年代 GC 的频率，这样可以提高效率 。分代回收并不能单独作为 一 种方案而直接使用，它通常会和标记 －清除、复制等基本 GC方案结合起来进行使用 。在这里，分代回收会和 SS 回收方案结合起来，形成 一 个新的方案，即 GSS 。</p>
<h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>CC 是 Concurrent Copying 的简称，中文翻译为并发复制回收，它可以看作复制回收的并发版本 。CC 可以在读取屏障的帮助下，通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理，比非并发版本更加高效 </p>
<h3 id="CMC"><a href="#CMC" class="headerlink" title="CMC"></a>CMC</h3><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GCRoots Set</p>
<p>ART Java Heap</p>
<p>​		从Android 8 (Oreo) 开始默认方案是并发复制 (CC)，cc涉及到的堆空间的区域为RegionSpace。</p>
<p>​		在GC触发章节讲到在GC Case 枚举中对于开发者而言，常见的是其中三种：申请内存时触发的GcCauseForAlloc、调用系统API System.gc()时GcCauseExplicit、并发GCGcCauseBackground。具体的执行过程可以看章节的详解，但最终的GC 触发最终都会通过调用CollectGarbagelnternal。</p>
<p>​		CollectGarbageInternal里会通过switch casel来通过回收器类型来选择合适的 GarbageCollector（垃圾回收器），这里的类型就是<code>kCollectorTypeCC</code>。看下具体代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据垃圾回收器的类型选择相应的回收器</span></span><br><span class="line"><span class="keyword">switch</span> (collector_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> kCollectorTypeCC: <span class="comment">// 如果是并发拷贝垃圾回收器类型</span></span><br><span class="line">    collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_) &#123; <span class="comment">// 如果使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 根据回收类型选择相应的活跃拷贝垃圾回收器</span></span><br><span class="line">      active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">              young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">      <span class="comment">// 将选择的拷贝垃圾回收器存储为活跃拷贝垃圾回收器</span></span><br><span class="line">      active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                 std::memory_order_relaxed);</span><br><span class="line">      <span class="comment">// 设置当前回收器为选择的拷贝垃圾回收器</span></span><br><span class="line">      collector = active_cc_collector;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 获取存储的活跃拷贝垃圾回收器</span></span><br><span class="line">      collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 处理其他类型的垃圾回收器</span></span><br><span class="line">    <span class="comment">// 添加适当的处理逻辑或错误处理代码</span></span><br><span class="line">    <span class="comment">// 可以根据实际情况进行补充</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取对应的GarbageCollector后这里获取的应该是<a target="_blank" rel="noopener" href="http://aospxref.com/android-13.0.0_r3/xref/art/runtime/gc/collector/concurrent_copying.h">concurrent_copying.h</a>，接着调用执行 collector-&gt;Run 接口，然后会执行RunPhases()函数。</p>
<p>这里简单看一下具体的代码实现，应该看不懂但是知道有这个流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentCopying::RunPhases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否使用Baker读屏障或TableLookup读屏障</span></span><br><span class="line">  <span class="built_in">CHECK</span>(kUseBakerReadBarrier || kUseTableLookupReadBarrier);</span><br><span class="line">  <span class="comment">// 检查垃圾回收是否处于非活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收标记为活动状态</span></span><br><span class="line">  is_active_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">// 记录当前运行垃圾回收的线程</span></span><br><span class="line">  thread_running_gc_ = self;</span><br><span class="line">  <span class="comment">// 断言Mutator锁未被当前线程持有</span></span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化阶段</span></span><br><span class="line">    <span class="built_in">InitializePhase</span>();</span><br><span class="line">    <span class="comment">// 如果是分代垃圾回收，不是年轻代，且不强制撤离所有对象，则执行标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_ &amp;&amp; !young_gen_ &amp;&amp; !force_evacuate_all_) &#123;</span><br><span class="line">      <span class="built_in">MarkingPhase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用Baker读屏障且存在灰色的Dirty Immune对象</span></span><br><span class="line">  <span class="keyword">if</span> (kUseBakerReadBarrier &amp;&amp; kGrayDirtyImmuneObjects) &#123;</span><br><span class="line">    <span class="comment">// 切换到读屏障标记入口点，确保在灰色对象标记之前切换</span></span><br><span class="line">    <span class="built_in">ActivateReadBarrierEntrypoints</span>();</span><br><span class="line">    <span class="comment">// 并发标记灰色的Dirty Immune对象，以减少垃圾回收暂停时间</span></span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="built_in">GrayAllDirtyImmuneObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 翻转线程根</span></span><br><span class="line">  <span class="built_in">FlipThreadRoots</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行拷贝阶段</span></span><br><span class="line">    <span class="built_in">CopyingPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用NoFromSpaceRefsVerification</span></span><br><span class="line">  <span class="keyword">if</span> (kEnableNoFromSpaceRefsVerification) &#123;</span><br><span class="line">    <span class="comment">// 计时器，用于记录暂停时长</span></span><br><span class="line">    <span class="function">TimingLogger::ScopedTiming <span class="title">split</span><span class="params">(<span class="string">&quot;(Paused)VerifyNoFromSpaceReferences&quot;</span>, GetTimings())</span></span>;</span><br><span class="line">    <span class="comment">// 暂停，执行验证</span></span><br><span class="line">    <span class="function">ScopedPause <span class="title">pause</span><span class="params">(<span class="keyword">this</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;正在验证不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行验证不存在From-Space引用</span></span><br><span class="line">    <span class="built_in">VerifyNoFromSpaceReferences</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;验证完成，确保不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行回收阶段</span></span><br><span class="line">    <span class="built_in">ReclaimPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完成垃圾回收阶段</span></span><br><span class="line">  <span class="built_in">FinishPhase</span>();</span><br><span class="line">  <span class="comment">// 断言垃圾回收仍处于活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收状态标记为非活动</span></span><br><span class="line">  is_active_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 清空运行垃圾回收的线程信息</span></span><br><span class="line">  thread_running_gc_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		我们知道cc是基于标记-复制算法的，在Android 10 CC垃圾回收器引入了分代。但是ConcurrentCopying并非将空间划分为两个半空间，而是以RegionSpace中的Region为单位进行处理，同时还能根据存活对象所占内存的比例来灵活设置Region被划归为From Space的条件。这个分代思想有点类似于JavaJVM中的G1收集器的算法。<strong>从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现。</strong></p>
<p>​		上面的ART GC回收策略章节知道，kCollectorTypeCC对应的回收策略有kGcTypeSticky, kGcTypePartial。再看一遍这两个的定义</p>
<ol>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
</ol>
<p>GC的大体流程为：</p>
<ul>
<li><p>InitializePhase，初始化统计量，设置标记等。</p>
</li>
<li><p>MarkingPhase，遍历所有Root根集，将根集对象直接引用对象压入mark_stack，并发标记存活对象记录在mark_bitmap中（此阶段只用于确定回收区域，StickyGC和ExplicitGC不需要）。</p>
</li>
<li><p>FlipThreadRoots，依据上一阶段的标记信息，确定回收区域（倾向于回收垃圾对象多的region），回收区域设置为from_space。</p>
</li>
<li><p>CopyingPhase，处理跨代、跨区引用的dirty_card,将from_space中的存活对象拷贝至to_space，更新引用等。</p>
</li>
<li><p>ReclaimPhase，释放from_space的空间，重置为to_space。</p>
</li>
</ul>
<p>Sticky GC，基于“标记-复制”算法实现</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/01fa2365dfacd63e02e5d201654d7124.png" alt="01fa2365dfacd63e02e5d201654d7124.png"></p>
<p>Partial GC 基于标记-整理算法</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/90d0ecea1c99af4058c88b8af80c864e.png" alt="90d0ecea1c99af4058c88b8af80c864e.png"></p>
<p>其中还涉及的一些东西：</p>
<ol>
<li><p>内存分配算法：整个堆划分为多个同样大小的Region（256KB），Region内分配内存使用最高效的BumpPointer指针碰撞算法，缺点是无法单独释放某个对象的内存(漂浮垃圾无法避免)，只能整个释放Region占用的空间。</p>
</li>
<li><p>回收算法：全局层面为标记-整理算法，两个Region间为标记-复制算法。有效地减少内存碎片。</p>
</li>
<li><p>跨区引用：写屏障支持，用CardTable实现RememberSet，记录跨代&#x2F;特殊Space与RegionSpace间的引用。</p>
<ul>
<li><strong>跨区引用</strong>：在垃圾回收的上下文中，”跨区引用” 指的是对象之间的引用关系，其中被引用的对象位于不同的内存区域。在这种情况下，需要考虑如何有效地跟踪和处理这些跨区引用。写屏障是一种支持跨区引用的机制，通过它可以在修改对象引用时执行额外的代码。在这个特定的实现中，使用 CardTable 来实现 RememberSet。RememberSet 是一种数据结构，用于记录指向其他内存区域的引用。CardTable 会被标记为 “Dirty”，以指示某个区域内的引用发生了变化，需要在后续的回收阶段中进行处理。</li>
</ul>
</li>
<li><p>并发：由CardTable，转发指针，起始快照，目标空间不变(只访问to_space对象)等特性支持。</p>
<ul>
<li><p><strong>CardTable（卡表）</strong>：CardTable 是一种数据结构，通常是一个字节数组，用于跟踪堆内存中每个小块（通常是一小块连续的内存，称为 Card）的状态。在并发垃圾回收中，卡表被用来记录对象引用的变化，特别是在写入引用时，标记与之相关的卡为”Dirty”（脏）。这有助于回收器识别哪些部分的内存发生了变化，需要在后续的回收阶段中处理。</p>
</li>
<li><p><strong>转发指针</strong>：在并发垃圾回收期间，当一个对象被复制到新的内存空间时，原始的引用需要被修正，指向新的内存地址。这个修正过程中可能会用到转发指针，即在原始地址上放置一个指针，指向新的内存地址。</p>
</li>
<li><p><strong>起始快照</strong>：在并发垃圾回收开始时，需要对内存状态进行一次快照，即记录当前所有对象的状态和位置。这个快照通常称为起始快照，它是垃圾回收器追踪对象移动和变化的基准。</p>
</li>
<li><p><strong>目标空间不变</strong>：指的是在并发垃圾回收期间，被回收的对象会被复制到新的内存空间（通常称为 to_space），而这个 to_space 在整个回收过程中是保持不变的。这确保了应用线程在访问 to_space 中的对象时，可以避免对正在进行的垃圾回收操作产生干扰。</p>
</li>
</ul>
</li>
<li><p><strong>写屏障（Write Barrier）</strong>：</p>
</li>
</ol>
<ul>
<li><p><strong>写前屏障</strong>：<strong>在修改对象的引用型成员变量之前执行一段特殊代码。这段代码负责标记与该对象相关的内存卡（Card）为Dirty。</strong>在并发复制垃圾收集中，Card通常是内存空间的一个固定大小的块。Dirty表示该块中的对象引用发生了变化。</p>
</li>
<li><p><strong>写后屏障</strong>：在修改对象的引用型成员变量之后执行一段特殊代码。这段代码也负责标记与该对象相关的内存卡为Dirty（脏）。</p>
</li>
<li><p>作用：通过这两种写屏障，垃圾收集器能够跟踪在上一次垃圾回收之后和并发期间发生的引用变化。<strong>Dirty（脏）的标记会被用于确定哪些对象需要在垃圾回收期间进行复制。</strong></p>
</li>
</ul>
<ol start="6">
<li><strong>读屏障（Read Barrier）</strong>：</li>
</ol>
<ul>
<li><p>读取对象的引用型成员变量时，会在访问目标对象之前执行一段特殊代码。<strong>这段代码负责检查目标对象是否已经被拷贝到新的内存位置。</strong></p>
</li>
<li><p>在并发复制垃圾收集中，如果目标对象尚未被拷贝，Mutator（应用程序线程）会执行拷贝操作，将对象复制到新的内存位置，并更新原对象的LockWord，使其指向新的目标对象。然后，引用会被修正为新的目标对象。</p>
</li>
<li><p>作用：读屏障确保在读取对象引用时，始终能够获得有效的引用<strong>。如果目标对象已经被拷贝到新的位置，读屏障负责确保引用被修正为新的目标对象，而不是指向旧的内存位置。</strong></p>
</li>
</ul>
<ol start="7">
<li><p>转发指针：被拷贝后的from_space原对象LockWord配置转发指针，之后所有访问原对象都会自动指向to_space新对象。</p>
<ul>
<li><p>“转发指针” 是一种在垃圾回收中用于处理对象拷贝的机制。在并发复制（Concurrent Copying）的垃圾回收算法中，当一个对象被移动到新的内存空间（例如从 from_space 到 to_space）时，为了确保之前对原对象的引用仍然有效，会在原对象的位置留下一个特殊的标记，即 “转发指针”。</p>
<p>具体来说，转发指针是一个指向新的拷贝对象的指针。当程序试图访问原对象时，会经过这个转发指针，从而自动指向新的对象。这样一来，即使对象在垃圾回收过程中被移动，引用该对象的代码仍然能够正确地访问到新的位置。</p>
<p>这种机制的好处是，无需修改引用原对象的代码，就能够实现对象的动态迁移。这对于需要在垃圾回收过程中保持应用程序线程的活动性（不需要停顿应用线程）的并发垃圾回收算法是非常有用的。</p>
</li>
</ul>
</li>
<li><p>优势：</p>
</li>
</ol>
<p>指针碰撞分配，贡献最高的内存分配速度。</p>
<p>前后台内存整理，更少的内存碎片，可控的漂浮垃圾数量。</p>
<p>更灵活的内存管理单位，提升内存利用率，相比CMS降低平均32%的堆占用（google官方数据）。</p>
<p>更精准的分代垃圾回收策略，提升吞吐量（回收效率），减少PauseTime。</p>
<ol start="9">
<li>不足：</li>
</ol>
<p>预留两倍堆空间的内存地址（32位应用影响明显，增加虚拟内存地址不足OOM概率）。</p>
<p>并发复制过程耗时随堆大小、对象数递增，耗时较长。</p>
<p>Mutator线程参与对象拷贝和Tracing，存在对象移动风暴。</p>
<p>读写互斥锁与锁堆特殊场景阻塞应用线程。</p>
<p>无法单独释放某个对象的内存，并发过程中新增对象默认为存活，存在一定的漂浮垃圾。</p>
<p>有关回收器的知识可以看上面的章节“ART GC 的分配器实现”的讲解。</p>
<p>有关Space的东西看上面的ART Heap创建。</p>
<p>有关GC Case的情况看上面的回收器使用章节。</p>
<p>有关对象创建的东西看上面的ART堆对象分配章节。</p>
<p>有关对象释放的东西看上面的ART堆对象释放章节。</p>
<p>有关回收器的东西看上面的ART GC 回收器的实现</p>
<p>CC垃圾处理器涉及到的分配器是<strong>kAllocatorTypeReg1onTLAB</strong>，涉及到的空间类是<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/space/region_space.h">region_space</a>。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/25/JavaJVM/" title="Java JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java JVM</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">Android 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dalvik-DVM"><span class="toc-number">1.1.</span> <span class="toc-text">Dalvik DVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8EJVM%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.</span> <span class="toc-text">与JVM对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM%E6%9C%AC%E8%BA%AB%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">DVM本身的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">DVM内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0GC"><span class="toc-number">1.1.4.</span> <span class="toc-text">简述GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91-JIT"><span class="toc-number">1.1.5.</span> <span class="toc-text">即时编译(JIT)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.6.</span> <span class="toc-text">DVM进程和线程管理特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.1.7.</span> <span class="toc-text">DVM启动分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM%E4%B8%8B%E7%9A%84GC"><span class="toc-number">1.1.8.</span> <span class="toc-text">DVM下的GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ART"><span class="toc-number">1.2.</span> <span class="toc-text">ART</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E6%9B%BF%E6%8D%A2DVM"><span class="toc-number">1.2.1.</span> <span class="toc-text">ART替换DVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">ART简要介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E5%8A%A0%E8%BD%BDOAT%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">ART加载OAT文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E5%A0%86%E7%BB%84%E6%88%90"><span class="toc-number">1.2.4.</span> <span class="toc-text">ART堆组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-GC"><span class="toc-number">1.2.5.</span> <span class="toc-text">ART GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-5-0-7-0-ART-GC"><span class="toc-number">1.2.6.</span> <span class="toc-text">Android 5.0 ~ 7.0 ART GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-GC-%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">ART GC 回收策略的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-Heap%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.8.</span> <span class="toc-text">ART Heap的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">1.2.9.</span> <span class="toc-text">ART堆对象分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART%E5%A0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">1.2.10.</span> <span class="toc-text">ART堆对象的释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ART-GC-1"><span class="toc-number">1.3.</span> <span class="toc-text">ART  GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Roots"><span class="toc-number">1.3.1.</span> <span class="toc-text">GC Roots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-GC-%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">ART  GC 方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART-GC-%E5%88%86%E9%85%8D%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">ART GC 分配器实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ATR-GC-%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">ATR GC 回收器的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E4%B8%8E%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">分配器与回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98GC%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">堆内存GC流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">对象内存申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E8%A7%A6%E5%8F%91"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">GC触发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E6%B5%81%E7%A8%8B%E8%A1%A5%E5%85%85"><span class="toc-number">1.3.7.</span> <span class="toc-text">GC流程补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">1.3.8.</span> <span class="toc-text">CMS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SS"><span class="toc-number">1.3.9.</span> <span class="toc-text">SS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GSS"><span class="toc-number">1.3.10.</span> <span class="toc-text">GSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CC"><span class="toc-number">1.3.11.</span> <span class="toc-text">CC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMC"><span class="toc-number">1.3.12.</span> <span class="toc-text">CMC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC"><span class="toc-number">1.4.</span> <span class="toc-text">GC</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20ANR/" title="Android ANR">Android ANR</a><time datetime="2024-03-26T11:10:09.254Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Fragment/" title="Fragment相关">Fragment相关</a><time datetime="2024-03-26T11:10:09.252Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Handler%E6%9C%BA%E5%88%B6/" title="Android Handler消息机制">Android Handler消息机制</a><time datetime="2024-03-26T11:10:09.250Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Jetpack/" title="Android JetPack">Android JetPack</a><time datetime="2024-03-26T11:10:09.249Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/" title="Android编译流程">Android编译流程</a><time datetime="2024-03-26T11:10:09.242Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>