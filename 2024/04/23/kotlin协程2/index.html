<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kotlin协程2 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介​		协程是一种更高效和更简单的方式管理并发的框架，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。 ​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。  协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K  减少了线程切换的成本，协程">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin协程2">
<meta property="og:url" content="https://zrmomo.github.io/2024/04/23/kotlin%E5%8D%8F%E7%A8%8B2/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="简介​		协程是一种更高效和更简单的方式管理并发的框架，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。 ​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。  协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K  减少了线程切换的成本，协程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-04-23T14:33:30.758Z">
<meta property="article:modified_time" content="2024-04-22T06:21:25.723Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/04/23/kotlin%E5%8D%8F%E7%A8%8B2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kotlin协程2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-22 14:21:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">kotlin协程2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T14:33:30.758Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-22T06:21:25.723Z" title="更新于 2024-04-22 14:21:25">2024-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="kotlin协程2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		协程是一种<strong>更高效和更简单的方式管理并发的框架</strong>，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。</p>
<p>​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。</p>
<ul>
<li><p>协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K</p>
</li>
<li><p>减少了线程切换的成本，协程可以挂起和恢复，它不会产生额外的开销，由程序自身控制</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispather.main)&#123;</span><br><span class="line">	<span class="keyword">val</span> user =  api.getUser()</span><br><span class="line">	nameTv.text = user.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>协程的作用是使用同步的方式写出异步的代码消灭了回调，然后将运行在不同线程的代码写在一个代码块里。协程让之前的并发代码写起来更简单。</strong></p>
</li>
</ul>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p>协程框架大致有如下部分组成：</p>
<ul>
<li>协程作用域(<em>CoroutineScope</em>)</li>
<li>协程上下文(<em>CoroutineContext</em>)</li>
<li>协程调度器(<em>CoroutineDispatcher</em>)</li>
<li>作业(<em>Job</em>)</li>
</ul>
<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>​		<em>CoroutineScope</em>是一种用于启动协程的盒子。可以同时对盒子里的所有协程执行操作，比如一次性取消盒子里的所有子协程。<strong>每个任务都会对应一个盒子，但是可以同时对所有的盒子进行操作。</strong></p>
<p>比如在Activity中通过lifecycleScope创建一个作用域</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launchWhenXXX &#123;</span><br><span class="line">   <span class="keyword">val</span> user = fetchUser()         </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看下它的定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># LifecycleOwner</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> LifecycleOwner.lifecycleScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() = lifecycle.coroutineScope</span><br><span class="line">    </span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="comment">// CoroutineScope与此Lifecycle绑定。当Lifecycle被销毁时，这个范围将被取消。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> Lifecycle.coroutineScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> existing = internalScopeRef.<span class="keyword">get</span>() <span class="keyword">as</span> LifecycleCoroutineScopeImpl?</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> existing</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> newScope = LifecycleCoroutineScopeImpl(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                SupervisorJob() + Dispatchers.Main.immediate</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (internalScopeRef.compareAndSet(<span class="literal">null</span>, newScope)) &#123;</span><br><span class="line">                newScope.register()</span><br><span class="line">                <span class="keyword">return</span> newScope</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleCoroutineScope</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>() : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">val</span> lifecycle: Lifecycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 activity created 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenCreated</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenCreated(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity started 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenStarted</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenStarted(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity resumed 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenResumed</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenResumed(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lifecycleScope</code> 是与 Android Jetpack Lifecycle 库集成的协程作用域，与组件（如 Activity 或 Fragment）的生命周期相关联。</li>
<li>当使用 <code>lifecycleScope.launch</code> 启动协程时，协程会在组件的生命周期内执行，并且会根据组件的生命周期自动取消。例如，如果在一个 Fragment 中启动了一个协程，当 Fragment 被销毁时，该协程也会被自动取消。</li>
</ul>
<p>ViewModel中的协程作用域通过viewModelScope来创建</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> user = fetchUser()</span><br><span class="line">            <span class="comment">// show user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">// fetch user</span></span><br><span class="line">            <span class="comment">// return user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>ViewModelStore</code>:</strong> 负责存储 <code>ViewModel</code> 实例，并与 <code>Activity</code> 或 <code>Fragment</code> 的生命周期绑定。当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，<code>ViewModelStore</code> 也会清除所有存储的 <code>ViewModel</code> 实例。</p>
<p>​		<strong><code>CloseableCoroutineScope</code>:</strong> 实现了 <code>Closeable</code> 接口，并在 <code>ViewModel</code> 实例中被 <code>setTag</code> 保存。当 <code>ViewModel</code> 被清除时，<code>ViewModelStore</code> 会调用 <code>ViewModel</code> 的 <code>onCleared()</code> 方法，在此方法中会自动关闭 <code>viewModelScope</code>，即调用 <code>CloseableCoroutineScope.close()</code> 方法。</p>
<p>作用域还有GlobalScope，MainScope等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>



<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>​		Job, CoroutineDispatcher, ContinuationInterceptor 等都是 CoroutineContext 的子类，即它们都是协程上下文。CoroutineContext 中有一个重载了(+)操作符的plus方法，可以将 Job 和 CoroutineDispatcher 等元素集合起来，代表一个协程的场景。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">// 重载 [] 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		它是一个包含了用户定义的一些各种不同元素的<code>Element</code>对象集合。其中主要元素是<code>Job</code>、协程调度器<code>CoroutineDispatcher</code>、还有包含协程异常<code>CoroutineExceptionHandler</code>、拦截器<code>ContinuationInterceptor</code>、协程名<code>CoroutineName</code>等。这些数据都是和协程密切相关的，每一个<code>Element</code>都有一个唯一key。</p>
<h3 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h3><p>​		它是在特定线程或线程组上执行协程的必要步骤。它们作为调度员负责将协程”分派“到底层线程，它决定着协程内部的代码将在哪个线程上执行。</p>
<p><strong>在主线程执行：</strong></p>
<ul>
<li>Dispatchers.Main</li>
<li>Dispatchers.Main.immediate</li>
</ul>
<p>​		两者不同点，Dispatchers.Main.immediate 的行为类似于Activity.runOnUiThread(…)，而Dispatchers.Main的行为就类似于Handler(Looper.getMainLooper()).post(…)</p>
<p>​		runOnUiThread在UI线程上运行指定的操作，如果当前线程是UI线程的话，该操作会立即执行，否则相关操作会被投递到UI线程的事件队列中去。</p>
<p>​		<code>Handler(Looper.getMainLooper()).post(...)</code>: 无论当前线程是否是主线程，都会被投递到UI线程的事件队列中去。</p>
<p><strong>后台线程执行：</strong></p>
<ul>
<li><em>Dispatchers.Default</em></li>
<li><em>Dispatchers.IO</em></li>
</ul>
<p><em>Dispatchers.Default</em>和<em>Dispatchers.IO</em>都可以允许在后台执行任务</p>
<p>​		<code>Dispatchers.Default</code> 通常用于执行计算密集型任务，比如处理大量数据或进行复杂计算。它 使用的线程池是一个固定大小的线程池，大小通常等于 CPU 核心的数量。这使得它适合并行执行计算密集型任务，而不会因为创建过多线程而导致资源耗尽。</p>
<p>​		<code>Dispatchers.IO</code> 专门用于执行 I&#x2F;O 密集型任务，比如读写文件、网络通信、数据库操作等。它使用的线程池则是一个可扩展的线程池，线程数量可以根据需要增长。这使得它适合 I&#x2F;O 密集型任务，因为这些任务可能会阻塞线程，而扩展的线程池可以提供更多线程来处理其他任务，从而保持应用的响应性。，但这个线程池被优化以适应 I&#x2F;O 操作的特性。</p>
<p><strong>其他</strong></p>
<p><em>Dispatchers.unconfined</em></p>
<p>简单来说，它只是在调用启动函数的线程上执行代码，并且它会立即执行。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>​		每个协程都与一个作业相关联。每当启动新协程时，它都会返回对作业的引用。协程的作业是可取消的，取消它会取消协程本身。但是如果我们想处理范围内的所有协程，就不再需要通过单独的作业来完成，我们可以使用<em>CoroutineScope</em>。</p>
<p>​		Job是继承自CoroutineContext的Element接口</p>
<p>再回头看ViewModel的作用域方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>launch返回的就是一个Job对象，然后机会所有的作用域都是通过launch来开启的。</p>
<p>常用方法：</p>
<ul>
<li>start() 开始</li>
</ul>
<p>​	<em>start</em>函数很直接，就是用来启动协程，这里就不过多描述</p>
<ul>
<li>join() 加入</li>
</ul>
<p>​		<em>join</em>函数是一个挂起函数，即它可以从协程或另一个挂起函数中调用。作业阻塞所有线程，直到写入它的协程或上下		完成其工作。只有当协程完成时，才会执行<strong>join()函数之后的行</strong>。</p>
<ul>
<li>cancel() 关闭</li>
</ul>
<p>​		<em>cancel</em>方法用于取消协程，而不用等待它完成它的工作。可以说它与<em>join</em>方法正好相反，在某种意义上，<em>join</em>方法等待协程完成其全部工作并阻塞所有其他线程，而<em>cancel</em> 方法在遇到时杀死协程协程（即停止协程）。</p>
<p>SupervisorJob是Job的一个子分支，它有一个作用就是如果子协程出现了异常，不会导致父协程以及其他兄弟协程取消关闭。</p>
<p>先看下使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">supervisorJob</span> <span class="operator">=</span> SupervisorJob()</span><br><span class="line"><span class="type">val</span> <span class="variable">scope</span> <span class="operator">=</span> CoroutineScope(Dispatchers.IO + supervisorJob)</span><br></pre></td></tr></table></figure>

<p>使用supervisorJob为context创建的作用域，不会因为一个子协程的异常导致全部协程取消。</p>
<p>​		综上所述，<em>SupervisorJob</em>更适合干一些独立互相不影响的任务，这样一旦某个任务出现了问题，对其他任务是没有任何影响的，比如说日常开发中一些UI需求，如果我点击的一个按钮出现了异常，但并不会影响手机状态栏的刷新</p>
<h2 id="suspend挂起"><a href="#suspend挂起" class="headerlink" title="suspend挂起"></a>suspend挂起</h2><p>​		被suspend修饰的函数叫做挂起函数，它们只能从另一个挂起函数或在协程中调用，它们可以在不阻塞当前线程的情况下挂起协程执行。</p>
<p>​		<strong>挂起是什么意思？</strong></p>
<p>​		挂起就是稍后会自动切回来的线程切换，切回来的动作在协程里叫做resume恢复。如果没有挂起的话suspend修饰没有意义。</p>
<p>​		下面是一个用来演示的伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">   <span class="keyword">val</span> image = suspendingGetImage(<span class="string">&quot;https://example.com/image.jpg&quot;</span>)</span><br><span class="line">   avatarIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendingGetImage</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getImage(s)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​			上面讲到Dispatchers.Main相当与将<strong>代码块的代码这部分就是协程</strong>通过Handler.post到主线程消息队列执行，然后<strong>主线程可以继续执行自己的任务。</strong>协程在执行到suspendingGetImage时会遇到<code>withContext(Dispatchers.IO)</code>会进行线程切换，在子线程执行完代码之后会自动的再次被post到主线程，然后继续执行后面的<code>avatarIv.setImageBitmap(image)</code>。</p>
<p>​		上面的主动让出线程然后自动恢复继续执行后面逻辑的这个过程叫做挂起。</p>
<p>​		挂起不一定必须有线程切换，如果将上面示例中的withContext(Dispatchers.IO)换成delay函数的话依然会挂起，但是不会切线程。所以说挂起和线程切换没有必然的联系。</p>
<p>​		在 Kotlin 协程中，挂起（Suspension）是一种特殊的状态，它允许协程在不阻塞线程的情况下暂停执行，并在条件满足时恢复执行。具体来说，挂起包含以下几个关键点：</p>
<ol>
<li><strong>非阻塞：</strong> 当协程挂起时，它不会阻塞底层的线程。这意味着线程可以用来执行其他任务，从而提高应用程序的并发性能。</li>
<li><strong>挂起点：</strong> 挂起发生在所谓的挂起点（Suspension Point）。挂起点通常是对挂起函数的调用。挂起函数是使用 <code>suspend</code> 关键字标记的函数，它们可以在执行过程中暂停协程，并在适当的时候恢复。</li>
<li><strong>恢复执行：</strong> 当挂起的条件（例如异步操作完成、延时结束等）得到满足时，协程会被恢复。恢复后，协程会从上次挂起的地方继续执行。</li>
<li><strong>调度器和线程：</strong> 挂起和恢复协程的执行可能伴随着线程的切换，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。调度器负责将协程的执行分派到合适的线程上。</li>
</ol>
<p><strong>suspend关键字的作用？</strong></p>
<p>​		suspend用来标志当前函数是一个挂起函数，需要在协程或者另外一个挂起函数中被调用。真正的挂起操作靠的是挂起函数里面的实际切换线程的代码，suspend作为函数使用者的提醒。</p>
<p><strong>怎么实现一个挂起函数？</strong></p>
<ul>
<li><p>什么时候定义？</p>
<p>原则：耗时</p>
</li>
<li><p>怎么写？</p>
<p>通常使用withContext这个挂起函数实现，它的功能最简单就是把线程切走又切回来。</p>
</li>
</ul>
<p><strong>非阻塞式挂起？</strong></p>
<p>​		非阻塞指的是不阻塞主线程，挂起的话一定是切到子线程了当然不会阻塞主线程。这个子线程会承载耗时操作，在等待的过程中就是阻塞的了。</p>
<h2 id="协程恢复"><a href="#协程恢复" class="headerlink" title="协程恢复"></a>协程恢复</h2><p>协程恢复时不一定会切回原线程，因为可能它的父协程是基于线程池的，在回调回父协程时可能换了个线程执行任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;主协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">&quot;协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;挂起并切换到 IO 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;恢复并继续在 Default 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;主协程结束 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">主协程开始 - 线程：main</span><br><span class="line">协程开始 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">挂起并切换到 IO 线程 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">恢复并继续在 Default 线程 - 线程：DefaultDispatcher-worker-<span class="number">3</span></span><br><span class="line">主协程结束 - 线程：main</span><br></pre></td></tr></table></figure>



<h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><p>Kotlin 协程的启动方式主要有以下几种，每种方式都有其特定的用途和行为：</p>
<ol>
<li><p>**<code>launch</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Job</code> 实例，用于管理协程的生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用，通过 CoroutineContext 参数去管理和控制协程的生命周期</span></span><br><span class="line"><span class="comment">// 例如：context = Dispatchers.Default + EmptyCoroutineContext</span></span><br><span class="line"><span class="keyword">val</span> coroutineScope = CoroutineScope(context)</span><br><span class="line"><span class="keyword">val</span> job = coroutineScope.launch &#123; </span><br><span class="line">    getName(id) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>async</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Deferred</code> 实例，用于获取协程的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async启动的Job是Deferred类型，它可以有返回结果，通过await方法获取</span></span><br><span class="line"><span class="comment">// public suspend fun await(): T</span></span><br><span class="line"><span class="keyword">val</span> id = coroutineScope.async &#123; getName(id) &#125;</span><br><span class="line">id.await()</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>runBlocking</code>**：创建一个新的协程并阻塞当前线程，直到协程完成。通常用于桥接协程和非协程代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>withContext</code>**：在指定的调度器上下文中执行协程代码块，并返回结果。用于在不同的调度器之间切换协程的执行上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 在 IO 调度器上执行的协程体，返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>launch() 和 async()之间的主要区别在于 :</p>
<ul>
<li><em>launch()</em> 将创建一个新的协程并立即启动它</li>
<li><em>async()</em> 将创建一个新的协程但不会启动它直到某些东西在结果<em>Deferred</em> 上调用 <em>await()</em></li>
</ul>
<p>​		launch 更多是用来发起一个无需结果的耗时任务（如批量文件删除、创建），这个工作不需要返回结果。<em>async</em> 函数则是更进一步，用于异步执行耗时任务，并且需要返回值（如网络请求、数据库读写、文件读写），在执行完毕通过<em>await()</em> 函数获取返回值。</p>
<p>启动协程需要三样东西，分别是上下文(CoroutineContext)、启动模式(CoroutineStart)、协程体。</p>
<p>看源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT, <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上下文可以看上面章节，启动模式一共有四种：</p>
<ul>
<li><strong>DEFAULT:</strong> 默认启动模式。协程会在被调度的第一时间开始执行。</li>
<li><strong>LAZY:</strong> 懒启动模式。协程只有在需要的时候才会开始执行，比如调用 <code>start</code>、<code>join</code> 或 <code>await</code> 方法时。</li>
<li><strong>ATOMIC:</strong> 原子启动模式。协程会立即开始执行，但如果协程在启动后立即被取消，它将不会执行任何操作。</li>
<li><strong>UNDISPATCHED:</strong> 立即启动模式。协程会在当前线程立即开始执行，直到遇到第一个挂起点。之后，它将根据其上下文恢复执行。</li>
</ul>
<p>协程体就是launch大括号里的代码内容了。</p>
<h2 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h2><p><strong>kotlin编译器</strong> 会对带有 <code>suspend</code> 的方法在最终的字节码生成上进行额外更改，这个过程又被称作 <strong>CPS转换</strong> (下面会再解释)，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun <span class="title function_">xx</span><span class="params">()</span></span><br><span class="line">-&gt;</span><br><span class="line">Object <span class="title function_">xx</span><span class="params">(Continuation c)</span></span><br></pre></td></tr></table></figure>

<p>在字节码中，我们原有的函数方法参数中会再增加一个 <code>Continuation</code> ，而 <code>Continuation</code> 就相当于一个参数传递的纽带(或者你也可以理解其就是一个 <code>CallBack</code> )，负责保存函数的执行状态、执行 挂起与恢复 操作，具体如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 参数类似于 <code>Android</code> 开发中的 <code>context</code> 一样，其代表了当前的配置，对使用协程的同学而言，context就相当于<strong>当前协程所运行的环境与参数</strong> ，而 <code>resumeWith()</code> 则是负责对我们函数方法进行挂起与恢复</p>
<h2 id="协程源码解读"><a href="#协程源码解读" class="headerlink" title="协程源码解读"></a>协程源码解读</h2><h3 id="协程的创建和启动"><a href="#协程的创建和启动" class="headerlink" title="协程的创建和启动"></a>协程的创建和启动</h3><h4 id="协程体的转换"><a href="#协程体的转换" class="headerlink" title="协程体的转换"></a>协程体的转换</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">	<span class="comment">// 协程体</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​	回看launch的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job</span><br></pre></td></tr></table></figure>

<p>​		block就是对应的协程体，在经过编译后这部分内容会被编译成SuspendLambda 的子类。</p>
<p>这里研究一下函数类型的定义</p>
<p>初始代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLambda</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sum = &#123; a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line">    sum.invoke(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">testLambda</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Function2</span> <span class="variable">sum</span> <span class="operator">=</span> (Function2)<span class="literal">null</span>.INSTANCE;</span><br><span class="line">      sum.invoke(<span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">      sum.invoke(<span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再来看下协程lambda</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">testFunction</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 此处是以匿名函数的形式  并且传入了一个Continuation</span></span><br><span class="line">   <span class="type">Function1</span> <span class="variable">var0</span> <span class="operator">=</span> (Function1)(<span class="keyword">new</span> <span class="title class_">Function1</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">         <span class="comment">// 将原来的函数体封装进了当前函数中</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">var2</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">         <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">               ResultKt.throwOnFailure(var1);</span><br><span class="line">               <span class="comment">// 此处的1</span></span><br><span class="line">               <span class="keyword">return</span> Boxing.boxInt(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@NotNull</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">         <span class="comment">// 把completion传入，并创建一个新的Function1，作为Continuation返回，</span></span><br><span class="line">         <span class="comment">// 这就是创建出来的协程体对象，协程的工作核心就是它内部的状态机，</span></span><br><span class="line">         <span class="comment">// invokeSuspend函数</span></span><br><span class="line">         Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">         <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">         <span class="keyword">return</span> var2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这里的Function1会被编译器编译成继承SuspendLambda的对象，不然普通的Function1哪来的invokeSuspend、create这么多的方法。invokeSuspend方法的实现就是状态机。</p>
<p>​		<strong>SuspendLambda 实现了 Continuation 续体接口，其 resume 方法可以恢复协程的执行；另外它将协程体封装成 SuspendLambda 对象，其内以状态机的形式消除回调地狱，并实现逻辑的顺序执行</strong>。</p>
<p>SuspendLambda 的继承关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Continuation: 续体，恢复协程的执行</span><br><span class="line">    - BaseContinuationImpl: 实现 resumeWith(Result) 方法，控制状态机的执行，定义了 invokeSuspend 抽象方法</span><br><span class="line">        - ContinuationImpl: 增加 intercepted 拦截器，实现线程调度等</span><br><span class="line">            - SuspendLambda: 封装协程体代码块</span><br><span class="line">                - 协程体代码块生成的子类: 实现 invokeSuspend 方法，其内实现状态机流转逻辑</span><br></pre></td></tr></table></figure>

<h4 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h4><blockquote>
<p>Continuation Passing Style(续体传递风格): 约定一种编程规范，函数不直接返回结果值，而是在函数最后一个参数位置传入一个 callback 函数参数，并在函数执行完成时通过 callback 来处理结果。回调函数 callback 被称为续体(Continuation)，它决定了程序接下来的行为，整个程序的逻辑通过一个个 Continuation 拼接在一起。</p>
</blockquote>
<p><strong>Kotlin 协程本质就是利用 CPS 来实现对过程的控制，并解决了 CPS 会产生的问题(如回调地狱，栈空间占用)</strong></p>
<ul>
<li><p>Kotlin suspend 挂起函数写法与普通函数一样，但编译器会对 suspend 关键字的函数做 CPS 变换，这就是咱们常说的用看起来同步的方式写出异步的代码，消除回调地狱(callback hell)。</p>
</li>
<li><p>另外为了避免栈空间过大的问题, Kotlin 编译器并没有把代码转换成函数回调的形式，而是利用状态机模型。<strong>每两个挂起点之间可以看为一个状态，每次进入状态机时都有一个当前的状态，然后执行该状态对应的代码；</strong>如果程序执行完毕则返回结果值，否则返回一个特殊值，表示从这个状态退出并等待下次进入。相当于创建了一个可复用的回调，每次都使用这同一个回调，根据不同状态来执行不同的代码。</p>
<blockquote>
<p>如果不使用状态机复用回调逻辑的话，每次延续续体都要把大量的重复逻辑带入后面的回调中。</p>
</blockquote>
</li>
</ul>
<h4 id="Continuation-1"><a href="#Continuation-1" class="headerlink" title="Continuation"></a>Continuation</h4><p>Kotlin 续体有两个接口: Continuation 和 CancellableContinuation, 顾名思义 CancellableContinuation 是一个可以取消的 Continuation。</p>
<p><strong>Continuation 成员</strong>：</p>
<ul>
<li><code>val context: CoroutineContext</code>: 当前协程的 CoroutineContext 上下文</li>
<li><code>fun resumeWith(result: Result&lt;T&gt;)</code>: 传递 result 恢复协程</li>
</ul>
<p><strong>CancellableContinuation 成员</strong>：</p>
<ul>
<li><code>isActive, isCompleted, isCancelled</code>: 表示当前 Continuation 的状态</li>
<li><code>fun cancel(cause: Throwable? = null)</code>: 可选通过一个异常 cause 来取消当前 Continuation 的执行</li>
</ul>
<p>​		**可以将 Continuation 看成是在挂起点恢复后需要执行的代码封装(通过之前的文章可以知道是通过状态机实现的)**，比如说对如下逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">()</span></span> = suspendCoroutine&lt;Response&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> response = doRequest()</span><br><span class="line">    it.resume(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> response = request()</span><br><span class="line">    handle(response)</span><br><span class="line">    <span class="comment">// xxxx逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假装是 Continuation 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(t: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">request</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">Response</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = doRequest()</span><br><span class="line">    continuation.resume(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 此处将之前要执行的handle(response)封装进了resume方法中</span></span><br><span class="line">    request(<span class="keyword">object</span> :Continuation&lt;Response&gt;&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resume</span><span class="params">(response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">            handle(response)</span><br><span class="line">            <span class="comment">// xxxx逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>对于 suspend 关键词修饰的挂起函数，编译器会为其增加一个 Continuation 续体类型的参数(相当于 CPS 中的回调)，可以通过这个 Continuation 续体对象的 resume 方法返回结果值来恢复协程的执行</strong>。</p>
<h4 id="协程三层包装"><a href="#协程三层包装" class="headerlink" title="协程三层包装"></a>协程三层包装</h4><ul>
<li>第一层包装: launch &amp; async 返回的 Job, Deferred 继承自 AbstractCoroutine, 里面封装了协程的状态，提供了 cancel 等接口；</li>
<li>第二层包装: 编译器生成的 SuspendLambda 子类，封装了协程的真正执行逻辑，其继承关系为 <code>SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl</code>, 它的 completion 参数就是第一层包装实例；</li>
<li>第三层包装: DispatchedContinuation, 封装了线程调度逻辑，它的 continuation 参数就是第二层包装实例。</li>
</ul>
<p>注意这里说的只是包装，不是针对某层的Continuation。</p>
<h3 id="真正的开启协程"><a href="#真正的开启协程" class="headerlink" title="真正的开启协程"></a>真正的开启协程</h3><p>​		在通过 SuspendLambda 对象创建了 DispatchedContinuation 续体后，接着执行其 resumeCancellableWith() 方法，具体执行代码不贴出了，最终会调用到 <code>continuation.resumeWith(result)</code> 方法，而这个 continuation 就是之前传入的第二层封装 SuspendLambda 对象，其 resumeWith() 方法在父类 BaseContinuationImpl 中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseContinuationImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上面的 invokeSuspend() 是一个抽象方法，它的实现在编译器生成的 SuspendLambda 子类中，具体逻辑是通过状态机来执行协程体中的逻辑。</p>
<h3 id="挂起和恢复原理"><a href="#挂起和恢复原理" class="headerlink" title="挂起和恢复原理"></a>挂起和恢复原理</h3><p>​		协程的启动，挂起和恢复有两个<strong>关键方法</strong>: <code>invokeSuspend()</code> 和 <code>resumeWith(Result)</code>。<strong>invokeSuspend() 方法是对协程代码块的封装，内部加入状态机机制将整个逻辑分为多块，分隔点就是每个挂起点。</strong></p>
<p>​		<strong>协程启动时会先调用一次 invokeSuspend() 函数触发协程体的开始执行，后面每当调用到一个挂起函数时，挂起函数会返回 COROUTINE_SUSPENDED 标识，从而 return 停掉 invokeSuspend() 函数的执行，即非阻塞挂起。</strong></p>
<p>​		<strong>编译器会为挂起函数自动添加一个 continuation 续体对象参数，表示调用它的那个协程代码块，在该挂起函数执行完成后，就会调用到续体 continuation.resumeWith() 方法来返回结果(或异常)，而在 resumeWith() 中又调用了 invokeSuspend() 方法，其内根据状态机的状态来恢复协程的执行</strong>。这就是整个协程的挂起和恢复过程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseContinuationImpl</span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; = <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// invokeSuspend() 执行续体下一个状态的逻辑</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="comment">// 如果续体里调用到了挂起函数，则直接 return</span></span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果到了第一层包装的话会直接返回了，否则会继续走第二层的包装逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// top-level completion reached -- invoke and return</span></span><br><span class="line">                    <span class="comment">// 对于 launch 启动的协程体，传入的 completion 是 AbstractCoroutine 子类对象</span></span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协程启动后会调用到上面这个 resumeWith() 方法，接着调用其 invokeSuspend() 方法：</p>
<ol>
<li>当 invokeSuspend() 返回 COROUTINE_SUSPENDED 后，就直接 return 终止执行了，此时协程被挂起。</li>
<li>当 invokeSuspend() 返回非 COROUTINE_SUSPENDED 后，说明协程体执行完毕了，对于 launch 启动的协程体，传入的 completion 是 AbstractCoroutine 子类对象，最终会调用其 AbstractCoroutine.resumeWith() 方法做一些状态改变之类的收尾逻辑。至此协程便执行完毕了。</li>
</ol>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = CoroutineScope(Dispatchers.Main).launch &#123;</span><br><span class="line">    println(<span class="string">&quot;label 0&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> isLogin = checkLogin() <span class="comment">// suspend</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;label 1&quot;</span>)</span><br><span class="line">    println(isLogin)</span><br><span class="line">    <span class="keyword">val</span> login = login() <span class="comment">// suspend</span></span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;label 2&quot;</span>)</span><br><span class="line">    println(login)</span><br><span class="line">    <span class="keyword">val</span> id = getId() <span class="comment">// suspend</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;label 3&quot;</span>)</span><br><span class="line">    println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KotlinTest$main$1</span> <span class="keyword">extends</span> <span class="title class_">SuspendLambda</span> <span class="keyword">implements</span> <span class="title class_">Function2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 状态码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>.label) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                println(<span class="string">&quot;label 0&quot;</span>);</span><br><span class="line">                label = <span class="number">1</span>;</span><br><span class="line">                result = checkLogin(<span class="built_in">this</span>); <span class="comment">// this 是编译器添加的续体参数</span></span><br><span class="line">                <span class="keyword">if</span> (result == COROUTINE_SUSPENDED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> COROUTINE_SUSPENDED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">// 此时传入的 result 是 checkLogin() 的结果</span></span><br><span class="line">                println(<span class="string">&quot;label 1&quot;</span>)</span><br><span class="line">                <span class="type">val</span> <span class="variable">isLogin</span> <span class="operator">=</span> result;</span><br><span class="line">                println(isLogin)</span><br><span class="line">                label = <span class="number">2</span>;</span><br><span class="line">                result = login(<span class="built_in">this</span>); <span class="comment">// this 是编译器添加的续体参数</span></span><br><span class="line">                <span class="keyword">if</span> (result == COROUTINE_SUSPENDED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> COROUTINE_SUSPENDED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">// 此时传入的 result 是 login() 的结果</span></span><br><span class="line">                println(<span class="string">&quot;label 2&quot;</span>)</span><br><span class="line">                <span class="type">val</span> <span class="variable">login</span> <span class="operator">=</span> result;</span><br><span class="line">                println(login)</span><br><span class="line">                label = <span class="number">3</span>;</span><br><span class="line">                result = getId(<span class="built_in">this</span>); <span class="comment">// this 是编译器添加的续体参数</span></span><br><span class="line">                <span class="keyword">if</span> (result == COROUTINE_SUSPENDED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> COROUTINE_SUSPENDED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">// 此时传入的 result 是 getId() 的结果</span></span><br><span class="line">                println(<span class="string">&quot;label 3&quot;</span>)</span><br><span class="line">                <span class="type">val</span> <span class="variable">id</span> <span class="operator">=</span> result;</span><br><span class="line">                println(id)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上面每次调用 suspend 函数时都会传一个 this 参数(continuation)，这个参数是编译器添加的续体参数，表示的是协程体自身，在 suspend 挂起函数执行完毕后会调用 <code>continuation.resumeWith() -&gt; invokeSuspend(result)</code> 来恢复该状态机的执行。</p>
<p><strong>如果不使用状态机的话，每次传入的this就会携带大量的逻辑代码。而不是仅仅是当前的对象了。</strong></p>
<h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line"><span class="keyword">val</span> jobA = scope.launch(CoroutineName(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">   <span class="keyword">val</span> jobChildA = launch(CoroutineName(<span class="string">&quot;child-A&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        println(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">  	<span class="comment">// jobChildA.cancel()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> jobB = scope.launch(CoroutineName(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">  			 delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// scope.cancel()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		要取消整个作用域时 <code>scope.cancel()</code>,jobA,jobB 都会被取消，相应 jobA 被取消时, 因为其也有自己的作用域，所以 jobChildA 也会被取消，以此类推。而这就是协程的 <strong>结构化并发特性</strong>。</p>
<h3 id="协程的异常传递"><a href="#协程的异常传递" class="headerlink" title="协程的异常传递"></a>协程的异常传递</h3><p>​		默认情况下，任意一个协程发生异常时都会影响到整个协程树，而异常的传递通常是双向的，也即协程会向子协程与父协程共同传递。</p>
<p>整体流程如下：</p>
<ul>
<li>先 cancel 子协程</li>
<li>取消自己</li>
<li>将异常传递给父协程</li>
<li>(重复上述过程,直到根协程关闭)</li>
</ul>
<p><strong>什么时候该用 SupervisorJob ，什么时候该用 Job?</strong></p>
<p>引用官方的一句话就是：想要避免取消操作在异常发生时被传播，记得使用 <code>SupervisorJob</code> ；反之则使用 <code>Job</code>。</p>
<p><strong>对于一个普通的协程，如何处理我的异常？</strong></p>
<p>对于一个普通的协程，你可以在其协程作用域内使用 <code>tryCatch(runCatching)</code> ,如果其是根协程，你也可以使用 <code>CoroutineExceptionHandler</code> 作为最后的拦截手段</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">scope.launch &#123;</span><br><span class="line">    runCatching &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scope.launch(CoroutineExceptionHandler &#123; _, throwable -&gt; &#125;) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在某个子协程中,想使用 SupervisorJob 的特性去作为某个作用域去执行？</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Job())</span><br><span class="line">scope.launch(CoroutineExceptionHandler &#123; _, _ -&gt; &#125;) &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch(CoroutineName(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> NullPointerException()</span><br><span class="line">        &#125;</span><br><span class="line">        launch(CoroutineName(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            Log.e(<span class="string">&quot;petterp&quot;</span>, <span class="string">&quot;依然会正常执行&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a><strong>异常处理方式</strong></h3><h4 id="tryCatch"><a href="#tryCatch" class="headerlink" title="tryCatch"></a>tryCatch</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NullPointerException()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;嘿害哈&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当异常发生时,我们底部的输出依然能正常打印</p>
<h4 id="CoroutineExceptionHandler"><a href="#CoroutineExceptionHandler" class="headerlink" title="CoroutineExceptionHandler"></a>CoroutineExceptionHandler</h4><p>​		用于在协程中全局捕获异常行为的最后一种机制，可以理解为类似 <a href="https://link.juejin.cn/?target=https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html%23setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><code>Thread.uncaughtExceptionHandler</code></a> 一样。仅在未捕获的异常上调用，也即这个异常没有任何方式处理时(比如在源头tryCatch了)。</p>
<p>​		由于协程是结构化的，当子协程发生异常时，它会优先将异常委托给父协程区处理，以此类推 直到根协程作用域或者顶级协程 。因此其永远不会使用我们子协程 <code>CoroutineContext</code> 传递的 <code>CoroutineExceptionHandler</code>(<code>SupervisorJob</code> 除外),对于 <code>async</code> 这种,而是直接向用户直接暴漏该异常,所以我们在具体调用处直接处理就行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化scope时</span></span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Job() + CoroutineExceptionHandler &#123; _, _ -&gt; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根协程</span></span><br><span class="line">scope.launch(CoroutineExceptionHandler &#123; _, _ -&gt; &#125;) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用CoroutineExceptionHandler进行捕获，最终传递到顶层的异常会直接造成崩溃。</p>
<h4 id="SupervisorJob"><a href="#SupervisorJob" class="headerlink" title="SupervisorJob"></a>SupervisorJob</h4><p>​		supervisorJob 是一个特殊的Job,其会改变异常的传递方式，当使用它时,我们子协程的失败不会影响到其他子协程与父协程，通俗点理解就是:子协程会自己处理异常，并不会影响其兄弟协程或者父协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(CoroutineExceptionHandler &#123; _, _ -&gt; &#125;+ SupervisorJob())</span><br><span class="line">    scope.launch(CoroutineName(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line">    scope.launch(CoroutineName(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println( <span class="string">&quot;正常执行,我不会收到影响&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>​		<code>SupervisorJob</code> 仅只能用于同一级别的子协程。如果我们在初始化 <code>scope</code> 时添加了 <code>SupervisorJob</code> ,那么整个scope对应的所有 <strong>根协程</strong> 都将默认携带 <code>SupervisorJob</code> ，否则就必须在 <code>CoroutineContext</code> 显示携带 <code>SupervisorJob</code>。z</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scope.launch &#123;</span><br><span class="line">   launch(CoroutineName(<span class="string">&quot;A&quot;</span>) + SupervisorJob()) &#123;</span><br><span class="line">       delay(<span class="number">10</span>)</span><br><span class="line">       <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">   &#125;</span><br><span class="line">   launch(CoroutineName(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">       delay(<span class="number">200</span>)</span><br><span class="line">       Log.e(<span class="string">&quot;petterp&quot;</span>, <span class="string">&quot;猜猜我还能不能打印&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面这种将SupervisorJob添加在launch中可以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> scope = CoroutineScope(CoroutineExceptionHandler &#123; _, _ -&gt; &#125;)</span><br><span class="line">scope.launch(SupervisorJob()) &#123;</span><br><span class="line">    launch(CoroutineName(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line">    launch(CoroutineName(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        Log.e(<span class="string">&quot;petterp&quot;</span>, <span class="string">&quot;正常执行,我不会收到影响&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种就不行，子协程在 <code>launch</code> 时会创建新的协程作用域，其会使用默认新的 <code>Job</code> 替代我们传递 <code>SupervisorJob</code>。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7130132604568731655#heading-4">Kotlin | 关于协程异常处理，你想知道的都在这里</a></p>
<h3 id="协程如果调度的线程"><a href="#协程如果调度的线程" class="headerlink" title="协程如果调度的线程"></a>协程如果调度的线程</h3><p>​		之前讲过协程体会经过三次包装，最后一次包装会被包装成一个CoroutineDispatcher，这里看一下intercepted方法，看其在ContinuationImpl的intercepted方法实现。这个方法会最终返回的是一个CoroutineDispatcher对象，这个对象封装了线程调度的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 顶层函数</span><br><span class="line"><span class="keyword">public</span> actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =</span><br><span class="line">    <span class="comment">// 如果是ContinuationImpl类型，则调用intercepted方法，否则返回自身</span></span><br><span class="line">    (<span class="built_in">this</span> as? ContinuationImpl)?.intercepted() ?: <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"># ContinuationImpl</span><br><span class="line"><span class="keyword">public</span> fun <span class="title function_">intercepted</span><span class="params">()</span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    <span class="comment">// context[ContinuationInterceptor]是 CoroutineDispatcher 实例 </span></span><br><span class="line">    <span class="comment">// 需要线程调度 - 返回 DispatchedContinuation，其 continuation 参数值为 SuspendLambda</span></span><br><span class="line">    <span class="comment">// 不需要线程调度 - 返回 SuspendLambda 就是本身</span></span><br><span class="line">    intercepted ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="built_in">this</span>) ?: <span class="built_in">this</span>).also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">#  CoroutineDispatcher</span><br><span class="line"><span class="comment">// continuation - SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =</span><br><span class="line">    DispatchedContinuation(<span class="built_in">this</span>, continuation)</span><br></pre></td></tr></table></figure>

<p>上面的注释可以了解大概的流程，其中核心的逻辑是下面这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span> </span><br></pre></td></tr></table></figure>

<p>这部分代码做了以下事情：</p>
<ul>
<li><code>context[ContinuationInterceptor]</code> 尝试从上下文中获取一个 <code>ContinuationInterceptor</code>。</li>
<li>如果找到了拦截器 (<code>ContinuationInterceptor</code>)，那么会调用其 <code>interceptContinuation(this)</code> 方法，将当前的延续 (<code>this</code> 指当前延续) 传递给拦截器，让拦截器有机会对延续进行处理。</li>
<li>如果没有找到任何拦截器，或者拦截器返回 <code>null</code>，则使用 <code>?:</code> 操作符返回当前的延续（<code>this</code>）。</li>
</ul>
<p>​		调度器的是实现原理即在协程启动时通过拦截器进行拦截，返回一个Continuation，再在协程恢复进行resumeWith操作时，进行线程切换判断和线程切换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> context = continuation.context</span><br><span class="line">    <span class="keyword">val</span> state = result.toState()</span><br><span class="line">    <span class="comment">//判断是否需要分发</span></span><br><span class="line">    <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">        _state = state</span><br><span class="line">        resumeMode = MODE_ATOMIC</span><br><span class="line">        dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeUnconfined(state, MODE_ATOMIC) &#123;</span><br><span class="line">            withCoroutineContext(<span class="keyword">this</span>.context, countOrElement) &#123;</span><br><span class="line">                <span class="comment">//不需要分发，直接使用原先的continuation对象的resumewith</span></span><br><span class="line">                continuation.resumeWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>CoroutineDispatcher</code>调度器指定执行协程的目标载体，它确定了相关的协程在哪个线程或哪些线程上执行。可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。</strong></p>
<p>​		协程需要调度的位置就是挂起点的位置，只有当挂起点正在挂起的时候才会进行调度，实现调度需要使用协程的拦截器。<strong>调度的本质就是解决挂起点恢复之后的协程逻辑在哪里运行的问题</strong>。调度器也属于协程上下文一类，它继承自拦截器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//询问调度器是否需要分发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将可运行块的执行分派到给定上下文中的另一个线程上。这个方法应该保证给定的[block]最终会被调用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个continuation，它封装了提供的[continuation]，拦截了所有的恢复。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CoroutineDispatcher是一个协程上下文元素，而&#x27;+&#x27;是一个用于协程上下文的集合和操作符。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">CoroutineDispatcher</span>)</span></span>: CoroutineDispatcher = other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987724340775108622#heading-28">一文看透 Kotlin 协程本质</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vivotech/p/16573309.html">Kotlin协程解析系列（上）：协程调度与挂起 </a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404061849127.webp" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7137905800504148004#heading-8">Kotlin协程之再次读懂协程工作原理</a></p>
<ol>
<li>协程和语言级别</li>
</ol>
<p>协程确实是 Kotlin 提供的一种并发框架，它允许以同步的方式编写异步代码。不过，协程不仅仅是 Kotlin 特有的，其他语言也有类似的概念，如 Python 的异步 IO (asyncio)、JavaScript 的 async&#x2F;await 等。</p>
<ol start="2">
<li>挂起和线程切换</li>
</ol>
<p>挂起并不总是意味着线程切换。挂起函数可以释放当前线程，使其可供其他任务使用，但协程在恢复时可能在相同的线程或不同的线程上继续执行，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。</p>
<ol start="3">
<li>CPS 转换和回调</li>
</ol>
<p>CPS（Continuation-Passing Style）转换是协程实现中的一个关键技术。它将协程的代码转换为一系列连续的回调。每当协程遇到挂起点时，它都会保存当前的状态（包括局部变量等）并暂停执行。恢复协程时，会从上次挂起的地方继续执行。这个过程是由 Kotlin 编译器和协程库自动处理的，对开发者来说是透明的。</p>
<ol start="4">
<li>挂起函数</li>
</ol>
<p>挂起函数是通过 <code>suspend</code> 关键字标记的函数，它们可以在不阻塞线程的情况下暂停和恢复协程的执行。挂起函数可以调用其他挂起函数，形成一个挂起函数的调用链。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6">https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6</a></p>
<p>​		协程是 Kotlin 提供的一种语言级别的并发框架，它允许以编写同步代码的方式来实现异步操作。在协程中，挂起机制可以实现线程的非阻塞切换。挂起允许协程在某个挂起点暂停执行，并在满足条件时自动恢复，这个过程可能伴随着线程的切换。</p>
<p>​		具体实现逻辑是，首先通过 <code>suspend</code> 关键字定义挂起函数，然后在协程作用域内调用这些挂起函数。这些函数在执行过程中可能会挂起协程，并在适当的时候恢复。挂起和恢复的过程由协程框架管理，涉及到 Continuation-Passing Style (CPS) 转换，这个转换过程会将协程的执行逻辑转换为一系列连续的回调，<strong>这些回调封装了协程在恢复后要执行的逻辑</strong>。</p>
<p>​		协程是kotlin语言级别的并发框架，它可以通过同步代码的方式实现异步的操作。在协程中通过挂起实现的线程切换。挂起就是可以在切换线程之后可以自己再切回来。具体的实现逻辑是，首先通过Suspend定义挂起函数，然后在协程作用域内启动。这个函数经过cps转换会添加一个回调。这个回调封装的是协程挂起恢复后要执行的逻辑。</p>
<h4 id="在工具类中创建协程进行耗时操作"><a href="#在工具类中创建协程进行耗时操作" class="headerlink" title="在工具类中创建协程进行耗时操作"></a>在工具类中创建协程进行耗时操作</h4><p>非单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNonContextClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = SupervisorJob()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default + job)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行异步操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AudioPlayerImpl : AudioPlayer, CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceAll</span><span class="params">(songList: <span class="type">List</span>&lt;<span class="type">SongEntity</span>&gt;, song: <span class="type">SongEntity</span>)</span></span> &#123;</span><br><span class="line">        launch(Dispatchers.Main.immediate) &#123;</span><br><span class="line">            withContext(Dispatchers.IO) &#123;</span><br><span class="line">                <span class="comment">// 这里执行异步操作</span></span><br><span class="line">                db.playlistDao().clear()</span><br><span class="line">                db.playlistDao().insertAll(songList)</span><br><span class="line">            &#125;</span><br><span class="line">            _playlist.value = songList</span><br><span class="line">            _currentSong.value = song</span><br><span class="line">            play(song)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MainScope()</code> 是绑定到主线程的生命周期的，通常在应用程序终止时，这个作用域会自动被取消。</p>
<h4 id="Dispatchers-Default和Dispatchers-IO的线程池"><a href="#Dispatchers-Default和Dispatchers-IO的线程池" class="headerlink" title="Dispatchers.Default和Dispatchers.IO的线程池"></a>Dispatchers.Default和Dispatchers.IO的线程池</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7114968347325759501#heading-11">Kotlin 协程之线程池探索之旅(与Java线程池PK)</a></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403201859132.webp" alt="image.png"></p>
<p>Dispatchers.IO 侧重于任务本身是阻塞型的，比如文件、数据库、网络等操作，此时是不怎么占用CPU的。而Dispatchers.Default 侧重于计算型的任务，可能会长时间占用CPU。</p>
<p><em>Dispatchers.Default</em> 由线程池支持，最大线程数为 2 或 CPU 核心数。它可以用于计算密集型任务。</p>
<p><em>Dispatchers.IO</em> 类似于<em>Default</em>，但最大线程数为 64 或 CPU 核心数。通过调整系统属性可以进一步增加最大线程数。用于 IO 任务，例如大部分时间都处于等待的工作，而非密集型</p>
<h4 id="协程线程池原理"><a href="#协程线程池原理" class="headerlink" title="协程线程池原理"></a>协程线程池原理</h4><ul>
<li>全局队列（阻塞+非阻塞）+ 本地队列。</li>
<li>IO 任务分发还有个缓存队列。</li>
<li>线程从队列里寻找任务（包括偷）并执行，若是使用IO 分发器，则超出限制的任务将会放到缓存队列里。</li>
</ul>
<h4 id="协程线程池和Java线程池的区别"><a href="#协程线程池和Java线程池的区别" class="headerlink" title="协程线程池和Java线程池的区别"></a>协程线程池和Java线程池的区别</h4><ul>
<li>Java 线程池开放API，比较灵活，调用者可以根据不同的需求组合不同形式的线程池，没有区分任务的特点（阻塞&#x2F;非阻塞）。</li>
<li>协程线程池专供协程使用，区分任务特点，进而进行更加合理的调度。</li>
</ul>
<h4 id="coroutineScope和CoroutineScope-launch的区别"><a href="#coroutineScope和CoroutineScope-launch的区别" class="headerlink" title="coroutineScope和CoroutineScope.launch的区别"></a>coroutineScope和CoroutineScope.launch的区别</h4><p><code>coroutineScope</code></p>
<ul>
<li><strong>类型</strong>：<code>coroutineScope</code>是一个挂起函数，可以在其他挂起函数或协程中调用。</li>
<li><strong>作用域继承</strong>：它创建一个新的协程作用域，并继承外部的协程作用域（包括协程上下文和取消状态）。</li>
<li><strong>等待子协程</strong>：在<code>coroutineScope</code>块内启动的所有协程都完成之前，<code>coroutineScope</code>会挂起当前的外部协程。这意味着<code>coroutineScope</code>块之后的代码会等待块内的所有协程完成后才执行。</li>
<li><strong>使用场景</strong>：当你需要在某个挂起函数中启动多个协程，并且要等待这些协程全部完成时，<code>coroutineScope</code>是一个好的选择。</li>
</ul>
<p><code>CoroutineScope.launch</code></p>
<ul>
<li><strong>类型</strong>：<code>launch</code>是一个扩展函数，用于在给定的<code>CoroutineScope</code>上启动新的协程。</li>
<li><strong>作用域创建</strong>：它需要一个<code>CoroutineScope</code>实例来调用，并在这个实例的作用域内启动新的协程。这个作用域通常由外部提供，比如通过<code>Activity</code>的<code>lifecycleScope</code>、<code>viewModelScope</code>或自定义的<code>CoroutineScope</code>。</li>
<li><strong>不等待子协程</strong>：<code>launch</code>会立即返回一个<code>Job</code>对象，并且不会等待协程内部的代码执行完毕。调用<code>launch</code>的代码会继续执行，而不会阻塞等待<code>launch</code>块内的协程完成。</li>
<li><strong>使用场景</strong>：当你需要在协程作用域内启动一个新的协程，并且不需要等待这个新启动的协程完成时，<code>launch</code>是合适的选择。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用coroutineScope</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUserData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123; <span class="comment">/* 加载并处理用户数据 */</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123; <span class="comment">/* 加载用户的其他信息 */</span> &#125;</span><br><span class="line">        <span class="comment">// 等待job1和job2完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// coroutineScope块外的代码会等待所有内部协程完成后才执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CoroutineScope.launch</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">startJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 在CoroutineScope的作用域内启动新的协程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的代码不会等待launch块内的协程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>使用<code>coroutineScope</code>可以确保在其代码块内启动的所有协程都完成之后，才继续执行后续代码，适合控制一组协程的执行。</li>
<li>使用<code>CoroutineScope.launch</code>可以在指定的协程作用域内启动一个新的协程，适合无需等待协程完成的场景。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7212311942613385253?searchId=20240313204055C36AC19ED84D47206D72#heading-30">写给Android工程师的协程指南</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7137905800504148004">Kotlin协程之再次读懂协程工作原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6890348438873964551">Kotlin协程之深入理解协程工作原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7220235452292137019#heading-8">谱写Kotlin面试指南三部曲-协程篇</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901956626324914184#heading-2">Kotlin协程之基础使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JE411R7hp/?spm_id_from=333.788.recommend_more_video.-1&vd_source=214b10aedbc4bde847f4f4260b4d4787">扔物线协程视频</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/LeakCanary/" title="LeakCanary"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LeakCanary</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/Kotlin%E9%9D%A2%E8%AF%95%E9%A2%98/" title="kotlin面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kotlin面试题</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">2.</span> <span class="toc-text">成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">协程作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">协程上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">协程调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Job"><span class="toc-number">2.4.</span> <span class="toc-text">Job</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suspend%E6%8C%82%E8%B5%B7"><span class="toc-number">3.</span> <span class="toc-text">suspend挂起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%81%A2%E5%A4%8D"><span class="toc-number">4.</span> <span class="toc-text">协程恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">协程启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuation"><span class="toc-number">6.</span> <span class="toc-text">Continuation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">协程源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-number">7.1.</span> <span class="toc-text">协程的创建和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%93%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.1.1.</span> <span class="toc-text">协程体的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPS"><span class="toc-number">7.1.2.</span> <span class="toc-text">CPS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Continuation-1"><span class="toc-number">7.1.3.</span> <span class="toc-text">Continuation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%89%E5%B1%82%E5%8C%85%E8%A3%85"><span class="toc-number">7.1.4.</span> <span class="toc-text">协程三层包装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BC%80%E5%90%AF%E5%8D%8F%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">真正的开启协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">挂起和恢复原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">7.4.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="toc-number">7.5.</span> <span class="toc-text">结构化并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92"><span class="toc-number">7.6.</span> <span class="toc-text">协程的异常传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">7.7.</span> <span class="toc-text">异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryCatch"><span class="toc-number">7.7.1.</span> <span class="toc-text">tryCatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoroutineExceptionHandler"><span class="toc-number">7.7.2.</span> <span class="toc-text">CoroutineExceptionHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SupervisorJob"><span class="toc-number">7.7.3.</span> <span class="toc-text">SupervisorJob</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%A6%82%E6%9E%9C%E8%B0%83%E5%BA%A6%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.8.</span> <span class="toc-text">协程如果调度的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B%E8%BF%9B%E8%A1%8C%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.1.</span> <span class="toc-text">在工具类中创建协程进行耗时操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatchers-Default%E5%92%8CDispatchers-IO%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.0.2.</span> <span class="toc-text">Dispatchers.Default和Dispatchers.IO的线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">8.0.3.</span> <span class="toc-text">协程线程池原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.4.</span> <span class="toc-text">协程线程池和Java线程池的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#coroutineScope%E5%92%8CCoroutineScope-launch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.5.</span> <span class="toc-text">coroutineScope和CoroutineScope.launch的区别</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>