<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android 面试题 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android9.0版本有哪些大的改动 Android 9默认情况下对所有应用启用了HTTPS的强制使用。这意味着，如果应用试图通过HTTP（而不是HTTPS）发送网络请求，那么这些请求将会被默认阻止，除非应用明确地在其网络安全配置中允许HTTP流量。  在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity这类问题一般会在点击推送消">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 面试题">
<meta property="og:url" content="https://zrmomo.github.io/2024/04/23/Android%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="Android9.0版本有哪些大的改动 Android 9默认情况下对所有应用启用了HTTPS的强制使用。这意味着，如果应用试图通过HTTP（而不是HTTPS）发送网络请求，那么这些请求将会被默认阻止，除非应用明确地在其网络安全配置中允许HTTP流量。  在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity这类问题一般会在点击推送消">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-04-23T14:33:30.735Z">
<meta property="article:modified_time" content="2024-04-23T05:49:45.887Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/04/23/Android%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android 面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-23 13:49:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T14:33:30.735Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-23T05:49:45.887Z" title="更新于 2024-04-23 13:49:45">2024-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android 面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h4 id="Android9-0版本有哪些大的改动"><a href="#Android9-0版本有哪些大的改动" class="headerlink" title="Android9.0版本有哪些大的改动"></a>Android9.0版本有哪些大的改动</h4><ol>
<li><p>Android 9默认情况下对所有应用启用了HTTPS的强制使用。这意味着，如果应用试图通过HTTP（而不是HTTPS）发送网络请求，那么这些请求将会被默认阻止，除非应用明确地在其网络安全配置中允许HTTP流量。</p>
</li>
<li><p>在9.0 中，不能直接非 <code>Activity</code> 环境中（比如<code>Service</code>，<code>Application</code>）启动 <code>Activity</code>这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="Android13权限"><a href="#Android13权限" class="headerlink" title="Android13权限"></a>Android13权限</h4><p>​		在 Android 13（TIRAMISU）及以上版本中，引入了更细粒度的媒体文件访问权限。与之前的版本相比，需要请求特定类型的媒体访问权限，而不是通用的 <code>READ_EXTERNAL_STORAGE</code> 权限。这些新权限包括：</p>
<ul>
<li><code>READ_MEDIA_IMAGES</code>：用于读取图片文件。</li>
<li><code>READ_MEDIA_VIDEO</code>：用于读取视频文件。</li>
<li><code>READ_MEDIA_AUDIO</code>：用于读取音频文件。</li>
</ul>
<p>​		在Android 13以下版本中还是需要的 <code>READ_EXTERNAL_STORAGE</code> 权限。</p>
<p>​		对应的写权限是 <code>WRITE_EXTERNAL_STORAGE</code>。在 Android 6.0（API 级别 23）及以上版本中，如果应用需要写入外部存储，你需要在运行时请求这个权限。</p>
<p>​		但是从 Android 10（API 级别 29）开始，Google 引入了分区存储（Scoped Storage）模型，对应用程序访问外部存储的方式进行了限制。在分区存储模式下，应用程序默认只能访问自己的应用专属目录，不需要 <code>WRITE_EXTERNAL_STORAGE</code> 权限。如果应用需要访问其他目录或执行更广泛的文件操作，可以使用 <code>MANAGE_EXTERNAL_STORAGE</code> 权限，但这需要更严格的审核。</p>
<h4 id="权限更改是在哪个版本改的？存储是在哪个版本改的？"><a href="#权限更改是在哪个版本改的？存储是在哪个版本改的？" class="headerlink" title="权限更改是在哪个版本改的？存储是在哪个版本改的？"></a>权限更改是在哪个版本改的？存储是在哪个版本改的？</h4><ol>
<li><p><strong>动态权限管理（Android 6.0，API 23）：</strong>Android在6.0版本开始引入了动态权限管理，用户可以在运行时授予或拒绝应用的权限，而不是在安装应用时一次性授予所有权限。</p>
</li>
<li><p><strong>分区存储（Android 10，API 29）</strong>：Android 10引入了分区存储，在这个模型中，应用默认只能访问自己的沙盒目录，对于公共目录的访问需要用户在运行时授予权限。requestLegacyExternalStorage标签可以暂时关闭Android10的强制分区存储。</p>
</li>
<li><p><strong>多媒体文件访问（Android 11，API 30）：</strong>Android11 可以使用直接路径访问多媒体文件，文件保存目录还是遵守沙盒机制，只能访问自己的沙盒目录，且requestLegacyExternalStorage标签失效。</p>
</li>
</ol>
<h4 id="compose与原生View的区别，优点和缺点"><a href="#compose与原生View的区别，优点和缺点" class="headerlink" title="compose与原生View的区别，优点和缺点"></a>compose与原生View的区别，优点和缺点</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37438128/article/details/130390554">https://blog.csdn.net/weixin_37438128/article/details/130390554</a></p>
<h4 id="显式Intent和隐式Intent区别"><a href="#显式Intent和隐式Intent区别" class="headerlink" title="显式Intent和隐式Intent区别"></a>显式Intent和隐式Intent区别</h4><p>显示 Intent 是直接指定要启动的 Activity 的一种方式。显示 Intent 的构造方法通常如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, SecondActivity.class);</span><br></pre></td></tr></table></figure>

<p>隐式 Intent 是通过 Intent Filter 来指定要启动的 Activity 的一种方式。在清单文件中注册指定 Activity 的 action、data 和 category 等属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--取别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.test.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>隐式 Intent 的构造方法通常如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;http://www.baidu.com&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上述 Intent 会启动所有具有 Intent Filter 中指定 action 和 data 属性的 Activity。</p>
<h4 id="隐式Intent还有什么作用"><a href="#隐式Intent还有什么作用" class="headerlink" title="隐式Intent还有什么作用"></a>隐式Intent还有什么作用</h4><ol>
<li><strong>数据分享</strong>：可以通过隐式 Intent 将数据分享给其他应用。例如，可以使用隐式 Intent 将图片分享到社交媒体应用。</li>
<li><strong>系统功能调用</strong>：可以使用隐式 Intent 调用系统功能。例如，可以使用隐式 Intent 拨打电话、发送短信、打开地图等。</li>
<li><strong>应用间通信</strong>：可以使用隐式 Intent 实现应用间通信。例如，可以使用隐式 Intent 让用户在一个应用中选择另一个应用的某个功能</li>
</ol>
<h4 id="canvas跟Paint的区别，以及作用？"><a href="#canvas跟Paint的区别，以及作用？" class="headerlink" title="canvas跟Paint的区别，以及作用？"></a><strong>canvas跟Paint的区别，以及作用？</strong></h4><ul>
<li><p><strong>Canvas</strong> 是 Android 绘图的画布，它提供了绘制图形、文本和位图的方法。Canvas 通常与 View 的 <code>onDraw</code> 方法一起使用，用于自定义绘制 View 的内容。屏幕显示与 Canvas 根本不是一个概念！ Canvas 是一个很虚幻的概念，相当于一个透明图层。每次在 Canvas 上画图时 （调用 draw:XXX 系列函 数），都会先产生一个透明图层，然后在这个图层上画图，画完之后覆盖在屏幕上显示。</p>
<p>​		在调用 canvas.drawRect(rectl , paint_green）时， 产生一个 Canvas 透明图层，由于当时还没有对坐标系进行平移，所以坐标原点是（0, 0） ；在 Canvas 上画好之后，覆盖到屏幕上显示出来。</p>
<p>​		在调用 canvas.drawRect(rectl, paint_red）时，又会产生一个全新 的 Canvas 透明图层，</p>
<blockquote>
<p>(1）当每次调用 draw:XXX 系列函数来绘图时，都会产生一个全新的 Canvas 透明图层 。</p>
<p>(2） 如果在调用 draw:XXX 系列函数前，调用平移、旋转等函数对 Canvas 进行了操作，那么这个操作是不可逆的 。每次产生的画布的最新位置都是这些操作后的位置 。</p>
<p>(3）在 Canvas 图层与屏幕合成时，超出屏幕范围的图像是不会显示出来的 。</p>
</blockquote>
</li>
<li><p><strong>Paint</strong> 是用于描述绘制属性的对象，它包括颜色、线条样式、字体等绘制信息。Paint 用于定义绘制的样式和效果，然后应用于 Canvas 上的绘制操作。</p>
</li>
</ul>
<h4 id="DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"><a href="#DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？" class="headerlink" title="DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"></a>DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？</h4><p>​		Dalvik VM 和 ART 之间的交替发生在 Android 5.0（Lollipop）版本。</p>
<ul>
<li><p><strong>那为什么要做这种交替呢？</strong></p>
<p>从 Dalvik VM 到 ART 的交替是为了改善 Android 应用程序的性能和效率。ART 使用预编译的方式运行应用程序，提供了更快的应用启动和更低的内存占用。</p>
</li>
</ul>
<h4 id="四大引用？"><a href="#四大引用？" class="headerlink" title="四大引用？"></a><strong>四大引用？</strong></h4><p>四种主要的引用类型是：</p>
<ol>
<li><strong>强引用（Strong Reference）</strong>：强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。</li>
<li><strong>软引用（Soft Reference）</strong>：软引用允许在内存不足时回收对象。垃圾回收器会根据内存需求来回收软引用对象。</li>
<li><strong>弱引用（Weak Reference）</strong>：弱引用更弱于软引用，只要没有强引用指向对象，垃圾回收器就可能回收它。</li>
<li><strong>虚引用（Phantom Reference）</strong>：虚引用是最弱的引用类型，它几乎没有直接作用，主要用于管理对象的生命周期。</li>
</ol>
<h4 id="什么情况下用虚引用、弱引用？"><a href="#什么情况下用虚引用、弱引用？" class="headerlink" title="什么情况下用虚引用、弱引用？"></a><strong>什么情况下用虚引用、弱引用？</strong></h4><ul>
<li><p><strong>虚引用</strong> 主要用于跟踪对象被垃圾回收的状态，通常与引用队列（ReferenceQueue）一起使用。当对象被垃圾回收时，会被放入引用队列中，用于执行一些清理操作。</p>
</li>
<li><p><strong>弱引用</strong> 通常用于缓存或缓存敏感数据，当内存不足时，垃圾回收器可能会回收被弱引用引用的对象，允许释放内存。</p>
</li>
<li><p><strong>什么是强引用？</strong></p>
<p>强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。强引用通常用于确保对象不会被提前回收。</p>
</li>
</ul>
<h4 id="APK瘦身你做过的有哪些？"><a href="#APK瘦身你做过的有哪些？" class="headerlink" title="APK瘦身你做过的有哪些？"></a><strong>APK瘦身你做过的有哪些？</strong></h4><p>APK瘦身是减少Android应用包的大小，常见的优化方法包括：</p>
<ol>
<li><strong>资源压缩和混淆</strong>：删除未使用的资源和代码，进行资源压缩和混淆处理。</li>
<li><strong>代码优化</strong>：检查和优化代码，减少冗余和不必要的库和依赖。</li>
<li><strong>图像压缩</strong>：使用工具对图像进行压缩和优化。</li>
<li><strong>延迟加载</strong>：将某些资源和模块延迟加载，只在需要时加载。</li>
<li><strong>分包</strong>：将应用分为多个模块，按需下载。</li>
<li><strong>动态化</strong>：将一些功能以插件或动态加载的方式提供，减少初始安装包的大小。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016225898768629773?searchId=202404231349085B07172A49F979A0C0CE">Android包体积优化（常规、进阶、极致）</a></p>
<h4 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h4><p>​		在Android开发中，<code>onNewIntent()</code>是一个生命周期方法，它在活动(Activity)的实例已经存在于任务栈中，且该活动的启动模式为<code>singleTop</code>、<code>singleTask</code>或<code>singleInstance</code>，并且通过Intent再次启动时，会被调用。</p>
<h4 id="每五秒发一个消息的实现方式"><a href="#每五秒发一个消息的实现方式" class="headerlink" title="每五秒发一个消息的实现方式"></a>每五秒发一个消息的实现方式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定时器</span><br><span class="line">    <span class="keyword">val</span> timer = Timer()</span><br><span class="line">    timer.schedule(MyTimerTask(), <span class="number">0</span>, <span class="number">5000</span>)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> : <span class="type">TimerTask</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>定时或者周期性任务线程池</span><br><span class="line"><span class="keyword">val</span> scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>)</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(</span><br><span class="line">            &#123; println(<span class="string">&quot;我爱你中国&quot;</span>) &#125;,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            TimeUnit.SECONDS</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Handler循环发送消息</span><br><span class="line"><span class="keyword">var</span> handler: Handler = <span class="keyword">object</span> : Handler(mainLooper) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            msg?.let &#123; <span class="keyword">super</span>.handleMessage(it) &#125;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>协程作用域</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是你想要执行的代码，例如发送消息的逻辑</span></span><br><span class="line">            println(<span class="string">&quot;发送消息 - <span class="subst">$&#123;Date()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000</span>) <span class="comment">// 暂停5秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止主线程退出</span></span><br><span class="line">    readLine()</span><br><span class="line">    <span class="comment">// 关闭协程作用域</span></span><br><span class="line">    scope.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="广播是安全的吗？"><a href="#广播是安全的吗？" class="headerlink" title="广播是安全的吗？"></a><strong>广播是安全的吗？</strong></h4><p>​		广播是 Android 中一种跨组件通信的方式，但它可以被其他应用程序接收。因此，广播不是完全安全的，需要小心处理敏感信息，可以使用权限来限制广播的接收范围。</p>
<h4 id="SharedPreferences-优缺点"><a href="#SharedPreferences-优缺点" class="headerlink" title="SharedPreferences 优缺点"></a>SharedPreferences 优缺点</h4><p>优点<br> 1.轻量级，以键值对的方式进行存储，使用方便，易于理解。<br> 2.采用的是 <code>XML</code> 文件形式存储在本地，程序卸载后会也会一并被清除，不会残留信息。</p>
<p>缺点<br> 1.由于是对文件 <code>IO</code> 读取，因此在 <code>IO</code> 上的瓶颈是个大问题。<br> 2.多线程场景下效率比较低，因为 <code>get</code> 操作的时候，会锁定 <code>SharedPreferencesImpl</code> 里面的对象，互斥其他操作，而当 <code>put、commit()</code> 和 <code>apply()</code> 操作的时候都会锁住 <code>Editor</code> 的对象，这样的情况下，效率会降低。<br> 3.不支持跨进程通讯。<br> 4.由于每次的更新都是全量更新，因此，如果 <code>SharedPreferences</code> 文件过大，或者在其中的键值对是大对象的 <code>json</code> 数据则会占用大量内存，读取较慢是一方面，同时也会引发程序频繁<code>GC</code>，导致的界面卡顿。</p>
<h4 id="SharedPreferences-提交apply-和-commit-的区别"><a href="#SharedPreferences-提交apply-和-commit-的区别" class="headerlink" title="SharedPreferences 提交apply() 和 commit()的区别"></a>SharedPreferences 提交apply() 和 commit()的区别</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = getSharedPreferences(<span class="string">&quot;123&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> string = sharedPreferences.getString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line"><span class="keyword">val</span> editor = sharedPreferences.edit()</span><br><span class="line">editor.putString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">editor.commit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>commit()</code> 是同步的，而 <code>apply()</code> 采用异步的方式通常来说效率会更高一些。在不需要返回值的情况下，使用 <code>apply()</code> 方法可以极大的提高性能。**<code>apply()</code> 和 <code>commit()</code> 的区别是在 <code>commit()</code> 把内容同步提交到了硬盘，而 <code>apply()</code> 是先立即把修改提交给了内存，然后开启了一个异步的线程提交到硬盘。**</p>
<h4 id="Android-组件化"><a href="#Android-组件化" class="headerlink" title="Android 组件化"></a>Android 组件化</h4><h4 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h4><h4 id="构建-apk-的过程"><a href="#构建-apk-的过程" class="headerlink" title="构建 apk 的过程"></a>构建 apk 的过程</h4><h4 id="说一下今日头条屏幕适配的原理"><a href="#说一下今日头条屏幕适配的原理" class="headerlink" title="说一下今日头条屏幕适配的原理"></a>说一下今日头条屏幕适配的原理</h4><h4 id="屏幕适配-dp-和-sp-有什么区别-dins-干什么用的"><a href="#屏幕适配-dp-和-sp-有什么区别-dins-干什么用的" class="headerlink" title="屏幕适配 dp 和 sp 有什么区别, dins 干什么用的"></a>屏幕适配 dp 和 sp 有什么区别, dins 干什么用的</h4><h4 id="说一下-RecycleView-三级缓存"><a href="#说一下-RecycleView-三级缓存" class="headerlink" title="说一下 RecycleView 三级缓存"></a>说一下 RecycleView 三级缓存</h4><h4 id="说一下-R8-和-D8-的区别"><a href="#说一下-R8-和-D8-的区别" class="headerlink" title="说一下 R8 和 D8 的区别"></a>说一下 R8 和 D8 的区别</h4><h4 id="AOP-面向切面编程思想"><a href="#AOP-面向切面编程思想" class="headerlink" title="AOP 面向切面编程思想"></a>AOP 面向切面编程思想</h4><h4 id="apk-解析安装过程"><a href="#apk-解析安装过程" class="headerlink" title="apk 解析安装过程"></a>apk 解析安装过程</h4><h4 id="mvvm-比-mpv-好在哪里"><a href="#mvvm-比-mpv-好在哪里" class="headerlink" title="mvvm 比 mpv 好在哪里"></a>mvvm 比 mpv 好在哪里</h4><h4 id="mvp-说一下-mvp-和-mvc-的区别"><a href="#mvp-说一下-mvp-和-mvc-的区别" class="headerlink" title="mvp 说一下 mvp 和 mvc 的区别"></a>mvp 说一下 mvp 和 mvc 的区别</h4><h4 id="mvp-使用中的内存泄漏情况"><a href="#mvp-使用中的内存泄漏情况" class="headerlink" title="mvp 使用中的内存泄漏情况"></a>mvp 使用中的内存泄漏情况</h4><h4 id="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？"><a href="#网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？" class="headerlink" title="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？"></a>网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？</h4><ol>
<li><strong>使用弱引用（WeakReference）</strong>：在回调中使用弱引用来引用 Activity。这样，即使 Activity 被销毁，回调中的弱引用也不会阻止垃圾回收器回收 Activity，从而避免内存泄漏。</li>
<li><strong>取消网络请求</strong>：在 Activity 的 <code>onDestroy</code> 方法中取消所有未完成的网络请求。这样可以确保 Activity 销毁时不会有未完成的网络请求尝试更新 UI。</li>
<li><strong>检查 Activity 状态</strong>：在回调中检查 Activity 的状态，确保 Activity 仍然有效（未被销毁）时才更新 UI。</li>
<li><strong>使用生命周期感知组件（如 LiveData）</strong>：使用 LiveData 等组件可以自动管理与 Activity 生命周期相关的操作，减少内存泄漏的风险。</li>
</ol>
<h4 id="looper-咋停"><a href="#looper-咋停" class="headerlink" title="looper 咋停"></a>looper 咋停</h4><p>​		looper.quit()和looper.quitSafety()，调用 <code>quit()</code> 方法后，<code>Looper</code> 会立即停止处理消息队列中的所有消息。如果希望 <code>Looper</code> 在处理完当前消息后再停止，可以使用 <code>quitSafely()</code> 方法。</p>
<h4 id="handler-内存泄漏如何去避免"><a href="#handler-内存泄漏如何去避免" class="headerlink" title="handler 内存泄漏如何去避免"></a>handler 内存泄漏如何去避免</h4><h4 id="处理消息的，除了用-handler-还用啥"><a href="#处理消息的，除了用-handler-还用啥" class="headerlink" title="处理消息的，除了用 handler 还用啥"></a>处理消息的，除了用 handler 还用啥</h4><ul>
<li>将Handler声明为静态内部类或者一个单独的外部类，并持有对Activity的弱引用（WeakReference），而不是直接使用匿名类或非静态内部类。</li>
<li>在组件（如Activity或Fragment）的生命周期结束时（如<code>onDestroy</code>），调用<code>Handler.removeCallbacksAndMessages(null)</code>方法移除所有的回调和消息。这样可以防止已经排队的消息或者延迟执行的任务在组件销毁后继续持有组件的引用。</li>
<li>使用View.post()方法</li>
</ul>
<h4 id="Android原生和H5交互"><a href="#Android原生和H5交互" class="headerlink" title="Android原生和H5交互"></a>Android原生和H5交互</h4><p><strong>JavaScript 调用原生代码：</strong></p>
<ul>
<li><p>注入window</p>
<p>Android WebView 通过 addJavascriptInterface(Object object, String name) 方法，提供了向 Web 端全局 window 注入对象的能力，通过这个对象可以调用 Native 提供的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addJavascriptInterface(JsBridge(<span class="built_in">this</span><span class="meta">@MainActivity</span>, webView), <span class="string">&quot;JsBridge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsBridge</span>(<span class="keyword">private</span> val activity: Activity, <span class="keyword">private</span> val webView: WebView) &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@JavascriptInterface</span>  </span><br><span class="line">    fun <span class="title function_">webCallNative</span><span class="params">(message: String)</span> &#123;  </span><br><span class="line">        Log.e(<span class="string">&quot;JsBridge&quot;</span>, <span class="string">&quot;webCallNative: $&#123;Thread.currentThread().name&#125;&quot;</span>)  </span><br><span class="line">        Toast.makeText(activity, message, Toast.LENGTH_SHORT).show()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码注入了名叫 JsBridge 的全局对象，在 Web 端可以直接这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.JsBridge.webCallNative(<span class="string">&quot;webCallNative&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意 Native 端注入对象的方法需要添加 @JavascriptInterface （API 17 可用）注解，才可以暴露给 Web 调用。</p>
</li>
<li><p>使用shouldOverrideUrlLoading 拦截请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        url = URLDecoder.decode(url, <span class="string">&quot;UTF-8&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; <span class="comment">// 如果是返回数据  </span></span><br><span class="line">        webView.handlerReturnData(url);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123;</span><br><span class="line">        webView.flushMessageQueue();  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里的url是H5将要进行跳转的链接，使用这个方法进行拦截*/</span></span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (url.equals(<span class="string">&quot;http://10.20.58.190:8081/intercept&quot;</span>)) &#123;</span><br><span class="line">                    text4.setText(<span class="string">&quot;intercept&quot;</span>);</span><br><span class="line"><span class="comment">//                    startActivity(new Intent(MainActivity.this,SecondFragment.class));</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mWebView.loadUrl(url);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">H5调用：</span><br><span class="line"></span><br><span class="line">location.href = <span class="string">&quot;http://10.20.58.190:8081/intercept&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​		上面的代码也直接说明了通信原理，在 Web 端加载携带数据的指定格式的 url，在 Native 端通过 shouldOverrideUrlLoading 拦截并解析以获取数据，完成通信。</p>
<p>​		在网页的 JavaScript 代码中，通过特定的协议（如 <code>scheme://host/method?params</code>）发起请求，这通常通过修改 <code>window.location</code> 或使用 <code>iframe.src</code> 实现</p>
<p>Web 端通常使用 iFrame.src 来，开源的 JsBridge 也是如此：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bizMessagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="built_in">encodeURIComponent</span>(messageQueueSt)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Native 调用 Web:</strong></p>
<p>Native 调用 Web，直接利用 WebView 的系统能力执行 JS 代码即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;handleMessage: &quot;</span> + message)  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nativeCallWeb&quot;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>H5 中定义了 handleMessage() 方法，返回值是一个字符串。现在要从 Native 端去调用的话，可以通过  WebView.evaluateJavascript(String script, ValueCallback<String> resultCallback) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webView.evaluateJavascript(<span class="string">&quot;javascript:window.handleMessage(&#x27;Hello&#x27;)&quot;</span>) &#123;  </span><br><span class="line">    Log.e(<span class="string">&quot;JsBridge&quot;</span>, <span class="string">&quot;receive from web: $it&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/hip0nRQSLiUNeBsUi7ROHQ">如何实现JsBridge？怎么实现回调？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7293728293768855587">APP与H5通信-JsBridge</a></p>
<h4 id="Android中如何请求权限、如何知道请求权限的结果、权限请求封装"><a href="#Android中如何请求权限、如何知道请求权限的结果、权限请求封装" class="headerlink" title="Android中如何请求权限、如何知道请求权限的结果、权限请求封装"></a>Android中如何请求权限、如何知道请求权限的结果、权限请求封装</h4><p>​		传统方式，直接在业务类中，调用activity或者fragment的<code>requestPermissions(@NonNull String[] permissions, int requestCode)</code>，然后在activity或者fragment的<code>onRequestPermissionResult()</code>中方法获取请求结果。这种方式缺陷在于会存在大量的模板代码。</p>
<p>以相机权限为例：<br>先在清单文件中添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后进行代码请求：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 权限尚未授予，需要请求权限</span></span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                <span class="keyword">this</span>, arrayOf(Manifest.permission.CAMERA), REQUEST_CODE_CAMERA</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 权限已经授予，可以执行需要权限的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            REQUEST_CODE_CAMERA -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;权限被授予&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 权限被拒绝，需要处理权限拒绝的情况</span></span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;权限被拒绝&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式就是代理Fragment</p>
<p>通过一个Fragment来代理然后再将结果回调回去。</p>
<h4 id="使用静态变量或单例类来共享数据时的问题"><a href="#使用静态变量或单例类来共享数据时的问题" class="headerlink" title="使用静态变量或单例类来共享数据时的问题"></a>使用静态变量或单例类来共享数据时的问题</h4><ul>
<li>线程安全问题：</li>
</ul>
<p><strong>多线程访问：</strong> 如果多个线程同时访问和修改静态变量或单例类中的数据，可能会导致数据不一致或竞态条件。可以使用同步机制（如 <code>synchronized</code> 关键字或 <code>ReentrantLock</code>）来确保一次只有一个线程可以修改数据。</p>
<ul>
<li>内存泄漏问题：</li>
</ul>
<p><strong>持有 Context 引用：</strong> 如果单例类或静态变量持有了 Context（特别是 Activity 或 View 的引用），那么很容易导致内存泄漏。</p>
<h4 id="Android优化"><a href="#Android优化" class="headerlink" title="Android优化"></a>Android优化</h4><p><a target="_blank" rel="noopener" href="http://www.notex.cc/2020-04-24/android-optimization/">http://www.notex.cc/2020-04-24/android-optimization/</a></p>
<h4 id="Android的Activity-、-Window-、-View之间的关系"><a href="#Android的Activity-、-Window-、-View之间的关系" class="headerlink" title="Android的Activity 、 Window 、 View之间的关系"></a>Android的Activity 、 Window 、 View之间的关系</h4><p>​		Activity就像是一扇贴着窗花的窗口，Window就想上窗口上面的玻璃，而View对象就像一个个贴在玻璃上的窗花。</p>
<p>​		Activity会调用PhoneWindow的setContentView()将layout布局添加到DecorView上，而此时的DecorView就是那个最底层的View。然后通过LayoutInflater.infalte()方法加载布局生成View对象并通过addView()方法添加到Window上，（一层一层的叠加到Window上）所以，Activity其实不是显示视图，Window才是真正的显示视图。</p>
<blockquote>
<p>注：一个Activity构造的时候只能初始化一个Window(PhoneWindow)，另外这个PhoneWindow有一个View容器 mContentParent，这个View容器是一个ViewGroup，是最初始的跟视图，然后通过addView方法将View一个个层叠到mContentParent上，这些层叠的View最终放在Window这个载体上面。</p>
</blockquote>
<h4 id="SharedPreferences的缺点"><a href="#SharedPreferences的缺点" class="headerlink" title="SharedPreferences的缺点"></a>SharedPreferences的缺点</h4><p>优点</p>
<ol>
<li><strong>简单易用</strong>：SharedPreferences 提供了一个简单的方式来存储键值对数据，使得开发者可以轻松地保存少量数据。</li>
<li><strong>轻量级存储</strong>：它非常适合存储少量的数据，如用户设置或应用的配置。</li>
<li><strong>直接支持原语数据类型</strong>：SharedPreferences 支持直接存储基本数据类型和字符串，无需额外的序列化或转换。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>持续占用内存</strong>：由于所有 SharedPreferences 实例都被缓存在内存中，这可能导致内存使用不断增加，特别是在存储了大量数据或频繁访问 SharedPreferences 时。</li>
<li><strong>线程阻塞和ANR风险</strong>：SharedPreferences 在初始化和读取数据时可能会阻塞调用线程，特别是在文件很大或设备磁盘操作较慢的情况下。如果在主线程进行这些操作，可能会导致应用响应变慢或ANR（应用无响应）。</li>
<li><strong>数据类型安全问题</strong>：SharedPreferences 不限制同一个键对应的值的数据类型，这可能在运行时导致 ClassCastException，因此需要开发者自行保证数据类型的一致性。</li>
<li><strong>不支持多进程数据共享</strong>：SharedPreferences 不保证多进程间的数据一致性，即使使用了 <code>MODE_MULTI_PROCESS</code> 也不能完全解决问题，官方已不推荐使用该模式。</li>
<li><strong>不支持增量更新</strong>：每次调用 <code>commit()</code> 或 <code>apply()</code> 时，SharedPreferences 都会写入全部数据，而非只更新被修改的部分。这种全量更新方式增加了磁盘I&#x2F;O操作，降低了性能，尤其是当存储的数据量较大时。</li>
<li><strong>复杂的异步行为</strong>：尽管 <code>apply()</code> 方法提供了异步数据提交，但其实现和行为较为复杂，可能在特定情况下影响应用的生命周期处理，增加了ANR的风险。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6932277268110639112#heading-1">一文读懂 SharedPreferences 的缺陷及一点点思考</a></p>
<h4 id="那个生命周期方法可以获取某个View宽高信息"><a href="#那个生命周期方法可以获取某个View宽高信息" class="headerlink" title="那个生命周期方法可以获取某个View宽高信息"></a>那个生命周期方法可以获取某个View宽高信息</h4><p>​		由于布局过程可能在<code>Activity</code>的<code>onCreate()</code>、<code>onStart()</code>或<code>onResume()</code>方法之后完成，这些生命周期方法不保证视图已经被测量和布局。所以，直接在这些方法中查询视图的大小可能不会得到正确的结果。</p>
<p>解决的四种方法</p>
<ul>
<li><p>onWindowFocusChanged</p>
<p>该方法的含义是：View已经初始化完毕了，宽&#x2F;高已经准备好了，所以此时去获取宽&#x2F;高是没有问题的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">        <span class="comment">// 现在可以安全地获取视图的宽高了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用View.post(Runnable)方法</strong>：可以将一个<code>Runnable</code>对象发布到视图的事件队列中，这样可以确保<code>Runnable</code>在视图布局完成后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myView.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">        <span class="comment">// 使用视图的宽高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ViewTreeObserver.OnGlobalLayoutListener</strong>：此监听器在视图树的全局布局状态或视图树中视图的可视状态发生改变时被调用。这是一个非常可靠的方式来获取视图尺寸，尤其是当<strong>需要获取自定义视图或动态添加到视图树中的视图的尺寸时。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ViewTreeObserver</span> <span class="variable">viewTreeObserver</span> <span class="operator">=</span> myView.getViewTreeObserver();</span><br><span class="line">viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> <span class="title class_">ViewTreeObserver</span>.OnGlobalLayoutListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onGlobalLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 移除监听器以防重复调用</span></span><br><span class="line">        myView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">        <span class="comment">// 使用视图的宽高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="View-post-为何能够获取到-View-的宽高值？"><a href="#View-post-为何能够获取到-View-的宽高值？" class="headerlink" title="View.post() 为何能够获取到 View 的宽高值？"></a>View.post() 为何能够获取到 View 的宽高值？</h4><p>​		通过 View # post() 方法添加待执行任务 <strong>Runnable</strong>，在 View 还未添加到 Window 之前先通过 HandlerActionQueue # post() 方法将待执行的 Runnable 封装成 HandlerAction，然后将封装的 <strong>HandlerAction</strong> 对象保存在长度为 <strong>4</strong> 的 <strong>HandlerAction</strong> 数组 <strong>mActions</strong> 中，等待时机执行。</p>
<p>​		在 ViewRootImpl # performTraversals() 方法中会调用 View # dispatchAttachedToWindow() 方法为每个子 <strong>View</strong> 设置 <strong>AttachInfo</strong> 关联信息。然后调用 mRunQueue # executeActions() 方法执行 <strong>mActions</strong> 数组中通过 View # post() 方法添加的待执行任务，这里所谓的执行，其实是通过 <strong>mAttachInfo</strong> 内持有的 <strong>ViewRootHandler</strong> 的 postDelayed() 方法将待执行任务添加到 <strong>UI</strong> 主线程的 <strong>MessageQueen</strong> 中排队执行（排在 <strong>View</strong> 的测量、布局和绘制任务的后面）。</p>
<p>​		此时 <strong>UI</strong> 主线程中已经在执行 ViewRootImpl # performTraversals() 方法中 View 的测量、布局和绘制操作，移除了 <strong>MessageQueen</strong> 中的同步屏障消息后，会继续执行上面的逻辑。</p>
<h4 id="Android11分区存储强制执行"><a href="#Android11分区存储强制执行" class="headerlink" title="Android11分区存储强制执行"></a>Android11分区存储强制执行</h4><p><strong>访问文件和媒体</strong></p>
<ul>
<li><strong>应用私有目录</strong>：应用可以在其私有目录（内部存储和外部存储中的 <code>Android/data/</code> 目录）无需任何权限地自由读写文件。</li>
<li><strong>媒体文件访问</strong>：应用可以通过媒体存储 API（如 <code>MediaStore</code>）访问音乐、视频和图片等媒体文件，但对于用户的其他文件类型，如文档和下载项，访问将受到限制。<strong>Android11可以使用<code>直接文件路径</code>访问访问媒体文件。</strong>也就是说有两种访问方式媒体存储 API和原生路径。但是写的话还是得使用媒体存储 API。</li>
<li><strong>文件管理器访问</strong>：应用可以使用系统文件选择器（<code>Intent.ACTION_OPEN_DOCUMENT</code>、<code>Intent.ACTION_CREATE_DOCUMENT</code>）让用户选择特定文件，而无需直接访问文件系统。</li>
</ul>
<p><strong>权限变化</strong></p>
<ul>
<li><strong>存储权限</strong>：<code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限的作用被限制。在分区存储模式下，即使应用被授予这些权限，对非媒体文件的访问也受到限制。</li>
<li><strong>管理所有文件的权限</strong>（<code>MANAGE_EXTERNAL_STORAGE</code>）：应用可以请求此权限以获得对整个外部存储的访问权限，但Google Play对此类应用的审查非常严格，只有满足特定用例（如文件管理器、备份还原应用）的应用才可能被批准。</li>
</ul>
<p><strong>外部存储根目录</strong></p>
<ul>
<li>直接在外部存储的根目录创建文件或访问文件将不再可行，除非应用具有特殊权限，如 <code>MANAGE_EXTERNAL_STORAGE</code></li>
</ul>
<p><strong>可以访问的目录</strong></p>
<p><strong>应用专属目录</strong></p>
<ul>
<li><strong>内部存储上的应用专属目录</strong>：通过 <code>Context.getFilesDir()</code> 获取的目录，用于存储应用的私有数据。</li>
<li>外部存储上的应用专属目录：<ul>
<li>通过 <code>Context.getExternalFilesDir()</code> 获取的目录，用于存储应用的私有数据，但在用户卸载应用时会被清除。该方法可以接受一个参数来指定特定类型的目录（如 <code>Environment.DIRECTORY_PICTURES</code>），但这些目录是应用私有的。</li>
<li>通过 <code>Context.getExternalCacheDir()</code> 获取的目录，主要用于存储临时缓存数据。</li>
</ul>
</li>
</ul>
<p><strong>公共目录</strong></p>
<p>对于公共文件存储，应用可以在特定的公共目录中保存文件，这些目录主要包括媒体文件（图片、视频、音频等）和下载文件。</p>
<ul>
<li><strong>图片、视频和音频</strong>：应用可以通过 <code>MediaStore</code> API 在 <code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code>、<code>MediaStore.Video.Media.EXTERNAL_CONTENT_URI</code> 和 <code>MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</code> 对应的媒体库中添加媒体文件。</li>
<li><strong>下载文件</strong>：应用可以使用 <code>DownloadManager</code> 或系统文件选择器保存文件到下载目录。如果使用 <code>DownloadManager</code>，文件会自动保存到系统的下载文件夹，无需特殊权限。若通过系统文件选择器（<code>Intent.ACTION_CREATE_DOCUMENT</code>），用户可以选择保存文件的具体位置。</li>
</ul>
<p><strong>特殊权限</strong></p>
<p>请求 <code>MANAGE_EXTERNAL_STORAGE</code> 权限后可以无限制的访问目录。</p>
<h4 id="Android进程间通信的方式"><a href="#Android进程间通信的方式" class="headerlink" title="Android进程间通信的方式"></a>Android进程间通信的方式</h4><ol>
<li><strong>Intent</strong>:<ul>
<li>用于启动其他应用组件（如活动、服务等）并传递简单数据。</li>
<li>可以通过 <code>Intent</code> 在不同应用的组件之间共享数据，但它不适用于复杂的数据交换或双向通信。</li>
</ul>
</li>
<li><strong>Bundle</strong>:<ul>
<li>通常与 <code>Intent</code> 一起使用，用于传递复杂的数据类型。</li>
<li><code>Bundle</code> 可以包含不同类型的数据，并通过 <code>Intent</code> 在不同的组件或应用间传递。</li>
</ul>
</li>
<li><strong>Content Provider</strong>:<ul>
<li>提供了一种在不同应用间共享数据的机制。</li>
<li>允许一个应用访问另一个应用的数据库，并对数据进行增删改查操作。</li>
<li>适用于需要跨应用共享数据的场景。</li>
</ul>
</li>
<li><strong>Broadcast Receiver</strong>:<ul>
<li>用于接收和响应广播消息。</li>
<li>应用可以发送广播消息，其他应用的广播接收器可以监听并响应这些消息。</li>
<li>适用于不同应用间的事件通知和简单数据传递。</li>
</ul>
</li>
<li><strong>Binder</strong>:<ul>
<li>Android 的一种 IPC 机制，允许客户端和服务端进行双向通信。</li>
<li>使用 <code>AIDL</code>（Android Interface Definition Language）定义跨进程接口，实现跨进程的方法调用。</li>
<li>适用于需要复杂通信和高效率的场景，如服务绑定、远程方法调用等。</li>
</ul>
</li>
<li><strong>Messenger</strong>:<ul>
<li>基于 <code>Binder</code> 的一种简化的 IPC 机制。</li>
<li>使用 <code>Message</code> 对象在客户端和服务端之间传递数据，但只支持单向通信。</li>
<li>适用于不需要频繁通信的简单场景。</li>
</ul>
</li>
<li><strong>Socket</strong>:<ul>
<li>使用网络套接字进行通信，适用于需要跨网络进行 IPC 的场景。</li>
<li>可以实现两个应用间的双向通信，但相比于其他机制，使用更复杂。</li>
</ul>
</li>
</ol>
<h4 id="zygote为什么用scoket而不是binder"><a href="#zygote为什么用scoket而不是binder" class="headerlink" title="zygote为什么用scoket而不是binder"></a>zygote为什么用scoket而不是binder</h4><p>​		Zygote 是 Android 系统的一个特殊进程，负责启动和初始化应用进程。它使用 socket 而不是 Binder 来接收来自 <code>system_server</code> 或其他进程的请求，主要基于以下几个原因：</p>
<ol>
<li><strong>启动阶段</strong>：Zygote 是在系统启动过程中非常早期就启动的，此时还没有建立完整的 Binder 机制。因此，使用 socket 可以在没有 Binder 通信机制的情况下与 Zygote 进行通信。</li>
<li><strong>简单性</strong>：Zygote 的主要职责是为新的应用进程提供一个预初始化的环境。它接收的请求相对简单（主要是创建新进程的请求），使用 socket 通信足以满足这种简单的请求和响应模式。</li>
<li><strong>性能</strong>：在 Zygote 的使用场景中，socket 通信的性能已经足够好。考虑到 Zygote 的启动阶段和职责，使用 socket 可以减少不必要的复杂性，从而有助于提高系统的启动速度。</li>
<li><strong>历史原因</strong>：Zygote 的设计和实现是在 Android 系统早期就完成的，那时候可能考虑到了上述因素，选择了 socket 作为通信机制。随着 Android 系统的发展，虽然 Binder 机制已经成为 IPC 的主要方式，但 Zygote 仍然保持使用 socket，以保持向后兼容性和稳定性。</li>
</ol>
<h4 id="App-启动流程（基于Android8-0）"><a href="#App-启动流程（基于Android8-0）" class="headerlink" title="App 启动流程（基于Android8.0）"></a>App 启动流程（基于Android8.0）</h4><ul>
<li>点击桌面 App 图标，Launcher 进程采用 Binder IPC（具体为ActivityManager.getService 获取 AMS 实例） 向 system_server 的 AMS 发起 startActivity 请求</li>
<li>system_server 进程收到请求后，向 Zygote 进程发送创建进程的请求；</li>
<li>Zygote 进程 fork 出新的子进程，即 App 进程</li>
<li>App 进程创建即初始化 ActivityThread，然后通过 Binder IPC 向 system_server 进程的 AMS 发起 attachApplication 请求</li>
<li>system_server 进程的 AMS 在收到 attachApplication 请求后，做一系列操作后，然后向App进程发送 H.BIND_APPLICATION 消息</li>
<li>主线程收到 H.BIND_APPLICATION 消息，调用 handleBindApplication 处理后做一系列的初始化操作，初始化 Application 等</li>
<li>system_server 进程的 AMS 在 bindApplication 后，会通过 Binder IPC 向 App 进程发送 scheduleLaunchActivity 请求；</li>
<li>App进程的 binder 线程（ApplicationThread）在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息；</li>
<li>主线程收到 message 后经过 handleLaunchActivity，performLaunchActivity 方法，然后通过反射机制创建目标 Activity；</li>
<li>通过 Activity attach 方法创建 window 并且和 Activity 关联，然后设置 WindowManager 用来管理 window，然后通知 Activity 已创建，即调用 onCreate</li>
<li>然后调用 handleResumeActivity，Activity 可见</li>
</ul>
<p>附图：<br><img src="https://github.com/huazidev/Android-Notes/blob/master/image/app-launch.jpg?raw=true" alt="img">  </p>
<p>补充：</p>
<ul>
<li>ActivityManagerService 是一个注册到 SystemServer 进程并实现了 IActivityManager 的 Binder，可以通过 ActivityManager 的 getService 方法获取 AMS 的代理对象，进而调用 AMS 方法</li>
<li>ApplicationThread 是 ActivityThread 的内部类，是一个实现了 IApplicationThread 的 Binder。AMS通过 Binder IPC 经 ApplicationThread 对应用进行控制</li>
<li>普通的 Activity 启动和本流程差不多，至少不需要再创建 App 进程了</li>
<li>Activity A 启动 Activity B，A 先 pause 然后 B 才能 resume，因此在 onPause 中不能做耗时操作，不然会影响下一个 Activity 的启动</li>
</ul>
<h4 id="Android进程启动流程"><a href="#Android进程启动流程" class="headerlink" title="Android进程启动流程"></a>Android进程启动流程</h4><ul>
<li>点击Launcher桌面程序的APP图标时，Launcher程序会调用startActivity()函数，通过Binder跨进程通信，发送消息给system_server进程中的AMS。在system_server进程中，由AMS通过socket通信告知Zygote进程fork出一个子进程(APP进程)。</li>
<li>APP进程启动后，会实例化一个ActivityThread，并在native层面通过反射执行其main函数，同时触发执行attach函数，同时会创建ApplicationThread、Looper、Handler对象，开启主线程消息循环Looper.loop()。</li>
<li>ActivityThread的main函数通过调用attach方法进行 Binder 通信，通知system_server进程执行AMS的attachApplication方法。</li>
<li>在attachApplication方法中，AMS分别通过bindApplication、scheduleLaunchActivity方法，并且将这些操作封装成Message并通知APP进程的主线程Handler，对APP进程的Application和Activity进行初始化，并执行Application、Activity的生命周期。最后在Activity的生命周期中执行UI的创建和显示。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7252171148757106743">每日一题：Android app进程是怎么启动的？</a></p>
<h4 id="v1-v2签名的原理"><a href="#v1-v2签名的原理" class="headerlink" title="v1&#x2F;v2签名的原理"></a>v1&#x2F;v2签名的原理</h4><p><strong>v1 签名（JAR 签名）</strong></p>
<ul>
<li><strong>原理</strong>：v1 签名基于 JAR 签名机制。它对 APK 文件中的每个文件进行签名，并将签名信息存储在 META-INF 目录下的 MANIFEST.MF 文件中。签名过程不包括对整个 APK 文件的完整性校验。</li>
<li><strong>缺点</strong>：由于 v1 签名只对 APK 文件中的单个文件进行签名，而不对整个 APK 文件进行完整性校验，因此存在一些安全隐患。例如，攻击者可以在不破坏签名的情况下修改 APK 文件的内容。</li>
</ul>
<p><strong>v2 签名（APK 签名方案 v2）</strong></p>
<ul>
<li><strong>原理</strong>：v2 签名是一种全新的签名机制，它在 APK 文件的末尾添加了一个签名块，该签名块包含了对整个 APK 文件（除了签名块本身）的完整性校验信息。这种方法可以确保 APK 文件的完整性和真实性。</li>
<li><strong>优点</strong>：v2 签名提供了更强的安全性。由于它对整个 APK 文件进行了完整性校验，因此可以有效防止对 APK 文件的篡改。此外，v2 签名还提高了安装速度，因为系统可以更快地验证 APK 文件的完整性。</li>
</ul>
<p><strong>APK 签名方案 v3（从 Android 9 Pie 开始支持）</strong></p>
<ul>
<li><strong>特点</strong>：v3 签名方案在 v2 的基础上增加了对密钥轮转的支持。这意味着开发者可以在不更换应用签名的情况下更换签名密钥，从而提高了安全性和灵活性。</li>
<li><strong>应用场景</strong>：v3 签名主要用于支持密钥轮转，便于开发者管理签名密钥，特别是在需要更换密钥的情况下，无需重新签名所有的 APK 文件。</li>
</ul>
<p><strong>APK 签名方案 v4（从 Android 11 开始支持）</strong></p>
<ul>
<li><strong>特点</strong>：v4 签名方案引入了一个单独的签名块文件（<code>.vbsign</code> 文件），该文件包含对 APK 文件的完整性校验信息。v4 签名不是替代 v2 或 v3 签名，而是作为一个补充，用于支持更大的 APK 文件和更快的安装速度。</li>
<li><strong>应用场景</strong>：v4 签名主要用于优化大型 APK 文件的安装速度，以及支持新的应用分发格式（如 Android App Bundle）。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p><strong>v1 签名</strong>（JAR 签名）：基于单个文件的签名，安全性较低。</p>
</li>
<li><p><strong>v2 签名</strong>（APK 签名方案 v2）：基于整个 APK 文件的签名，提高了安全性和安装速度。</p>
</li>
<li><p><strong>v3 签名</strong>（APK 签名方案 v3）：在 v2 基础上增加了密钥轮转支持，提高了灵活性。</p>
</li>
<li><p><strong>v4 签名</strong>（APK 签名方案 v4）：引入了单独的签名块文件，优化了大型 APK 文件的安装速度。</p>
<blockquote>
<p>密钥轮转提供了一种机制，允许开发者在不影响已发布应用的情况下，更新和管理密钥。这对于维护长期支持的应用尤其重要。</p>
</blockquote>
</li>
</ul>
<h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><p>并发：在单个处理器核心上交替执行，并发是逻辑上的同时发生。</p>
<p>并行：在多个处理器核心上真正同时执行的，而并行是物理上的同时发生。</p>
<h4 id="HandlerThread是什么？"><a href="#HandlerThread是什么？" class="headerlink" title="HandlerThread是什么？"></a>HandlerThread是什么？</h4><p><strong>HandlerThread 是一个特殊的线程类，它内部拥有一个 Looper 对象，使得它可以拥有自己的消息循环。这使得 HandlerThread 能够像主线程一样处理消息和任务，非常适合用于需要执行多个任务或频繁操作数据库、文件和网络的场景。</strong></p>
<p><strong>使用场景：</strong> 与普通的 Thread 相比，HandlerThread 的优势在于它可以重复使用来执行多个任务，而不需要每次都创建新的线程。这不仅减少了资源消耗，还可以简化代码，因为你可以通过向 HandlerThread 的 Handler 发送消息来排队执行任务，而不需要手动管理线程的生命周期。这使得 HandlerThread 成为在后台线程中执行串行任务的理想选择。</p>
<h4 id="AsyncTask的原理"><a href="#AsyncTask的原理" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p>​		<code>AsyncTask</code> 是 Android 中用于简化异步操作的一个抽象类。它允许你在后台线程中执行长时间运行的操作，然后在主线程中更新 UI。<code>AsyncTask</code> 的工作原理大致如下：</p>
<ol>
<li><strong>执行任务</strong>：当你创建一个 <code>AsyncTask</code> 的子类并调用 <code>execute()</code> 方法时，**<code>AsyncTask</code> 会在内部使用线程池（<code>Executor</code>）来启动一个新的线程。**</li>
<li><strong>后台处理</strong>：在新线程中，<code>doInBackground(Params...)</code> 方法会被调用。这是你执行长时间运行操作的地方，例如网络请求、数据库操作等。这个方法运行在后台线程中，所以它不会阻塞主线程。</li>
<li><strong>进度更新</strong>：如果你需要在任务执行过程中更新 UI（例如显示进度条），你可以在 <code>doInBackground()</code> 方法中调用 <code>publishProgress(Progress...)</code> 方法。这将触发 <code>onProgressUpdate(Progress...)</code> 方法的调用，该方法运行在主线程中，可以安全地更新 UI。</li>
<li><strong>任务完成</strong>：当 <code>doInBackground()</code> 方法完成后，返回的结果会被传递给 <code>onPostExecute(Result)</code> 方法。这个方法也运行在主线程中，你可以在这里更新 UI 或进行其他操作，以响应任务的完成。</li>
</ol>
<p><code>AsyncTask</code> 的一个重要特点是它提供了一种机制，使得在不同线程中执行的代码能够安全地与 UI 交互。</p>
<p>AsyncTask中的任务在4.0以上是串行执行的，在 AsyncTask 中提交的任务默认都会通过：</p>
<h4 id="AsyncTask的优缺点"><a href="#AsyncTask的优缺点" class="headerlink" title="AsyncTask的优缺点"></a>AsyncTask的优缺点</h4><p>优点</p>
<ol>
<li><strong>简单易用</strong>：<code>AsyncTask</code> 提供了一个简单的框架来处理异步任务，不需要直接操作线程或处理线程之间的通信。</li>
<li><strong>自动线程管理</strong>：<code>AsyncTask</code> 自动在后台线程中执行 <code>doInBackground()</code> 方法，并在主线程中执行 <code>onPostExecute()</code>、<code>onPreExecute()</code> 和 <code>onProgressUpdate()</code> 方法，简化了线程管理。</li>
<li><strong>适合简单的异步操作</strong>：对于一些简单的异步操作，如从网络获取数据或执行简单的数据库查询，<code>AsyncTask</code> 是一个方便的选择。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>内存泄漏风险</strong>：如果 <code>AsyncTask</code> 持有 Activity 的引用，而且任务执行时间较长，可能会导致 Activity 无法被回收，从而引发内存泄漏。</li>
<li><strong>生命周期管理问题</strong>：<code>AsyncTask</code> 不会随着 Activity 的销毁而自动取消，如果在 Activity 销毁后仍然尝试更新 UI，可能会引发崩溃。</li>
<li><strong>并发限制</strong>：默认情况下，所有的 <code>AsyncTask</code> 实例共享同一个后台线程池，这可能会导致任务执行排队，特别是在多个 <code>AsyncTask</code> 同时运行时。</li>
<li><strong>不适合长时间运行的任务</strong>：对于需要长时间运行的任务，<code>AsyncTask</code> 可能不是最佳选择，因为它在长时间运行时可能会遇到上述问题。</li>
<li><strong>已被弃用</strong>：从 Android 11（API 级别 30）开始，<code>AsyncTask</code> 已被弃用。建议使用其他替代方案，如 Kotlin 协程、<code>Executor</code> 或 <code>RxJava</code> 等。</li>
</ol>
<h4 id="Android中操作多线程的方式有哪些？"><a href="#Android中操作多线程的方式有哪些？" class="headerlink" title="Android中操作多线程的方式有哪些？"></a>Android中操作多线程的方式有哪些？</h4><p>常见的实现多线程的手段有五种：<br>第一种：Thread，Runnable<br>第二种：HandlerThread<br>第三种：AsyncTask<br>第四种：Executor<br>第五种：IntentService</p>
<h4 id="Android开发中怎样判断当前线程是否是主线程"><a href="#Android开发中怎样判断当前线程是否是主线程" class="headerlink" title="Android开发中怎样判断当前线程是否是主线程"></a>Android开发中怎样判断当前线程是否是主线程</h4><p>Android开发中, 有时需要判断当前线程到底是主线程, 还是子线程, 例如: 我们在自定义View时, 想要让View重绘, 需要先判断当前线程到底是不是主线程, 然后根据判断结果来决定到底是调用 invalidate()还是 postInvalidate() 方法。<br>在工作中获取当前的主线程，主要是借助Android中的Looper：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread();</span><br><span class="line">Looper.getMainLooper().getThread().getId() == Thread.currentThread().getId();</span><br></pre></td></tr></table></figure>

<h4 id="Application为啥不能作为Dialog的context？"><a href="#Application为啥不能作为Dialog的context？" class="headerlink" title="Application为啥不能作为Dialog的context？"></a>Application为啥不能作为Dialog的context？</h4><p>Application作为Dialog的context时，传入的token是null</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7314125877486616615">https://juejin.cn/post/7314125877486616615</a></p>
<h4 id="Activity-window-view之间的关系"><a href="#Activity-window-view之间的关系" class="headerlink" title="Activity window view之间的关系"></a>Activity window view之间的关系</h4><p>​		Activity在setContentView的时候最终调用的是getWindow的setContentView，而window的唯一实现类是PhoneWindow。在PhoneWindow的setContentView里面会初始化一个DecorView。然后将我们自定义的布局add到DecorView上。</p>
<blockquote>
<p>一个Activity构造的时候只能初始化一个Window(PhoneWindow)，在attach方法中。</p>
</blockquote>
<h4 id="Android中的context"><a href="#Android中的context" class="headerlink" title="Android中的context"></a>Android中的context</h4><p>​		可以理解为应用程序环境中全局信息的接口，它整合了相当多系统级的服务，可以用来得到应用中的类、资源，以及可以进行应用程序级的调起操作，比如启动 Activity、Service等等，而且 Context 这个类是 抽象abstract 的，不含有具体的函数实现。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404081342436.png" alt="img"></p>
<p>Context数量&#x3D;Activity数量+Service数量+1</p>
<p>使用Context的正确姿势：<br>1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br>2：不要让生命周期长于Activity的对象持有到Activity的引用。<br>3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p>
<h4 id="线程切换方式"><a href="#线程切换方式" class="headerlink" title="线程切换方式"></a>线程切换方式</h4><p><strong>使用Handler</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> handler = Handler(Looper.getMainLooper())</span><br><span class="line">handler.post &#123;</span><br><span class="line">    <span class="comment">// 在主线程中执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	原理：<code>Handler.post(Runnable)</code>方法允许你将一个任务安排到<code>Handler</code>所在线程的消息队列中，以便稍后在该线程的消息循环中执行。如果<code>Handler</code>是在主线程中创建的，那么通过<code>Handler.post(Runnable)</code>提交的任务将在主线程中执行</p>
<p><strong>使用AsyncTask</strong>：AsyncTask是一个抽象类，用于在后台线程中执行耗时操作，并在完成后在主线程中更新UI。不过，请注意，从Android 11开始，AsyncTask已被弃用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Void, Void, String</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">Void</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="comment">// 在后台线程中执行的耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostExecute</span><span class="params">(result: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程中更新UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTask().execute()</span><br></pre></td></tr></table></figure>

<p><strong>使用runOnUiThread</strong>：如果你在Activity中需要从后台线程切换到主线程，可以使用<code>runOnUiThread</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runOnUiThread &#123;</span><br><span class="line">    <span class="comment">// 在主线程中执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	原理：<code>runOnUiThread(Runnable)</code>是<code>Activity</code>类提供的一个方法，其原理与<code>Handler.post(Runnable)</code>类似。不过多了一步检查，当<code>runOnUiThread(Runnable)</code>被调用时，首先检查当前线程是否已经是主线程。如果是，那么直接在当前线程中执行<code>Runnable</code>任务。不是的话直接post会主线程。</p>
<p><strong>使用协程（Kotlin Coroutines）</strong>：在Kotlin中，协程提供了一种更简洁和强大的方式来处理异步任务和线程切换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 在后台线程中执行耗时操作</span></span><br><span class="line">    <span class="keyword">val</span> result = doSomething()</span><br><span class="line"></span><br><span class="line">    withContext(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="comment">// 在主线程中更新UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Android中序列化"><a href="#Android中序列化" class="headerlink" title="Android中序列化"></a>Android中序列化</h4><p><strong>序列化</strong></p>
<p>​		Java序列化是指把Java对象保存为二进制字节码的过程，Java反序列化是指把二进制码重新转换成Java对象的过程。</p>
<p>那么为什么需要序列化呢？</p>
<p>第一种情况是：一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。</p>
<p>第二种情况是：需要把Java对象通过网络进行传输的时候。因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。</p>
<p>Android 支持两种主要的序列化机制：Java 序列化Serializable和 Parcelable。</p>
<p><strong>Serializable</strong></p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器、getter 和 setter 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(person);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Parcelable</strong></p>
<p><strong>使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parcelable 接口方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parcelable.Creator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(source.readString(), source.readInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;person_key&quot;</span>, person);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>两者对比：</strong></p>
<p>性能</p>
<ul>
<li><strong>Parcelable</strong>：专为 Android 设计，性能优于 Serializable。它在序列化和反序列化过程中使用的是内存映射（Memory Mapping），这使得 Parcelable 更快。</li>
<li><strong>Serializable</strong>：一个标准的 Java 接口，性能相对较差。它使用反射来实现序列化，这会产生大量的临时对象并导致频繁的垃圾回收。</li>
</ul>
<p>实现复杂度</p>
<ul>
<li><strong>Parcelable</strong>：实现相对复杂，需要编写更多的代码。你需要实现 <code>Parcelable</code> 接口，并重写 <code>writeToParcel</code> 方法和 <code>CREATOR</code> 静态字段。</li>
<li><strong>Serializable</strong>：实现非常简单，只需要让类实现 <code>Serializable</code> 接口即可，无需编写其他代码。</li>
</ul>
<p>使用场景</p>
<ul>
<li><strong>Parcelable</strong>：推荐用于 Android 平台，特别是在需要将数据通过 Intent 在 Activity 或服务之间传递时。</li>
<li><strong>Serializable</strong>：由于其简单性，适用于不需要高性能序列化的场景，或者在需要将对象通过网络传输或保存到文件时。</li>
</ul>
<p>兼容性</p>
<ul>
<li><strong>Parcelable</strong>：仅适用于 Android 平台。</li>
<li><strong>Serializable</strong>：作为 Java 标准的一部分，可以跨平台使用。</li>
</ul>
<p>安全性</p>
<ul>
<li><strong>Parcelable</strong>：由于不使用反射，理论上更安全。</li>
<li><strong>Serializable</strong>：使用反射，可能会暴露出安全漏洞。</li>
</ul>
<p>结论</p>
<ul>
<li>在 Android 组件间传递，对性能有较高要求，应该使用 <code>Parcelable</code>。</li>
<li>网络传输和保存至磁盘的时候用<code>Serializable</code>，是因为<code>Parcelable</code>不能保证，当<strong>外部条件</strong>发生变化时数据的连续性。</li>
</ul>
<h4 id="Serializable原理"><a href="#Serializable原理" class="headerlink" title="Serializable原理"></a>Serializable原理</h4><p><strong>transient</strong></p>
<p>不让指定字段进行序列化保存，为字段添加transient修饰。</p>
<p><strong>serialVersionUID</strong></p>
<ul>
<li>没有定义serialVersionUID值, 反序列化可能会出现<code>local class incompatible</code>异常, 是Java的安全机制.反序列化时会通过比较serialVersionUID进行<code>判断反序列化内容是否安全</code>。将serialVersionUID值固定下来, 可以防止这种情况下的反序列化失败.</li>
<li>如果对象升级版本，修改了结构，而且不想兼容之前的版本，那么只需要修改下 serialVersionUID 的值就可以了。</li>
</ul>
<p><strong>Serializable接口</strong></p>
<p>这是一个标识，告诉程序所有实现了”我”的对象都需要进行序列化。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6883309627933458445">Serializable 和Parcelable 的区别(Android每日面试题)</a></p>
<h4 id="Parcelable原理"><a href="#Parcelable原理" class="headerlink" title="Parcelable原理"></a>Parcelable原理</h4><p>将数据写入到一段共享的内存中</p>
<p>其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象,下图是这个过程的模型</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404101124680.webp" alt="img"></p>
<ol>
<li><code>Parcelable</code>在对与只需要进行内存序列化的操作时很快，因为<code>Serializable</code>需要频繁的进行I&#x2F;O。</li>
<li><code>Parcelable</code>实现较为复杂且要注意读写顺序的一致性，<code>Serializable</code>相对来说实现很简单。</li>
<li><code>Parcelable</code>不适合用于做数据持久化，而Serializable适合。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904050702434311#heading-3">Android Parcelable原理分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e5ec851088a">Parcelable的原理</a></p>
<h4 id="Parcelable比Serializable快的原因"><a href="#Parcelable比Serializable快的原因" class="headerlink" title="Parcelable比Serializable快的原因"></a>Parcelable比Serializable快的原因</h4><ol>
<li>中间过程。根据Serializable的原理，序列化与反序列化过程要创建大量的中间变量来获取、存储数据。而Parcelable则不用，直接将各种需要的数据写入Parcel.cpp中</li>
<li>反射。Serializable使用了大量反射，而反射操作耗时。Parcelable使用了非常少的反射操作，来获取入口，而数据，由对象来读入写出，因此省略了Serializable中必要的通过反射才能获取数据的多数时间</li>
<li>存储方式。即数据的存储位置，以及数据本身和助记信息</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573218334769166#heading-7">Parcelable 是如何实现的</a></p>
<h4 id="Android中的设计模式"><a href="#Android中的设计模式" class="headerlink" title="Android中的设计模式"></a>Android中的设计模式</h4><p>​		在 Android 开发中，经常使用多种设计模式来解决特定的问题或实现某些功能。以下是一些常见的设计模式及其在 Android 中的应用示例：</p>
<ol>
<li><strong>单例模式（Singleton）</strong>：<ul>
<li>用于确保一个类只有一个实例，并提供一个全局访问点。例如，可以用于管理数据库连接或共享偏好设置实例。</li>
</ul>
</li>
<li><strong>工厂模式（Factory Method）</strong>：<ul>
<li>用于创建对象，而不需要指定对象的具体类。在 Android 中，工厂模式可以用于创建不同类型的对话框或视图。</li>
</ul>
</li>
<li><strong>观察者模式（Observer）</strong>：<ul>
<li>用于实现发布-订阅机制，允许对象在状态改变时通知其他对象。在 Android 中，观察者模式广泛用于实现事件监听和数据绑定，例如使用 <code>LiveData</code> 和 <code>Observable</code>。</li>
</ul>
</li>
<li><strong>策略模式（Strategy）</strong>：<ul>
<li>用于定义一系列算法，并将它们封装起来使它们可以互换。在 Android 中，策略模式可以用于处理不同的动画效果或图像加载策略。</li>
</ul>
</li>
<li><strong>适配器模式（Adapter）</strong>：<ul>
<li>用于将一个类的接口转换成客户期望的另一个接口。在 Android 中，适配器模式常用于实现 <code>RecyclerView</code> 的适配器，以适配不同类型的数据源。</li>
</ul>
</li>
<li><strong>装饰器模式（Decorator）</strong>：<ul>
<li>用于动态地给对象添加额外的职责。在 Android 中，装饰器模式可以用于给视图添加额外的功能，如添加滚动条或边框。</li>
</ul>
</li>
<li><strong>构建者模式（Builder）</strong>：<ul>
<li>用于创建复杂对象的一种模式，它允许逐步构建对象。在 Android 中，构建者模式常用于构建复杂的对话框或通知。</li>
</ul>
</li>
<li><strong>命令模式（Command）</strong>：<ul>
<li>用于将请求封装为一个对象，从而允许用户使用不同的请求、队列请求或记录请求日志。在 Android 中，命令模式可以用于实现撤销功能或将用户操作封装为命令对象。</li>
</ul>
</li>
</ol>
<h4 id="Android中主动更新View"><a href="#Android中主动更新View" class="headerlink" title="Android中主动更新View"></a>Android中主动更新View</h4><h4 id="Bundle可以存储那些数据"><a href="#Bundle可以存储那些数据" class="headerlink" title="Bundle可以存储那些数据"></a>Bundle可以存储那些数据</h4><ol>
<li><strong>基本数据类型</strong>：如 <code>int</code>、<code>float</code>、<code>boolean</code>、<code>long</code>、<code>double</code>、<code>byte</code>、<code>char</code>、<code>short</code> 等。</li>
<li><strong>字符串</strong>：可以存储 <code>String</code> 类型的数据。</li>
<li><strong>数组</strong>：支持基本数据类型的数组，如 <code>int[]</code>、<code>float[]</code>、<code>boolean[]</code> 等，以及 <code>String[]</code>。</li>
<li><strong>集合</strong>：可以存储 <code>ArrayList</code>，它可以是基本数据类型的包装类（如 <code>Integer</code>、<code>Float</code>、<code>Boolean</code> 等）的 <code>ArrayList</code>，也可以是 <code>String</code> 的 <code>ArrayList</code>，甚至是 <code>Parcelable</code> 对象的 <code>ArrayList</code>。</li>
<li><strong>Serializable 对象</strong>：可以存储实现了 <code>Serializable</code> 接口的对象。</li>
<li><strong>Parcelable 对象</strong>：可以存储实现了 <code>Parcelable</code> 接口的对象，这是 Android 推荐的序列化方式，性能优于 <code>Serializable</code>。</li>
<li><strong>SparseArray</strong>：可以存储 <code>SparseArray</code> 类型的数据，这是 Android 中的一个用于替代 <code>HashMap&lt;Integer, Object&gt;</code> 的类，更为内存高效。</li>
<li><strong>Bundle</strong>：可以嵌套存储 <code>Bundle</code> 对象，从而实现更复杂的数据结构。</li>
</ol>
<h4 id="Android中进程的优先级"><a href="#Android中进程的优先级" class="headerlink" title="Android中进程的优先级"></a>Android中进程的优先级</h4><p>​		android系统是基于进程的优先级来决定它们的被回收的顺序。它们的回收顺序从先到后分别是：空进程，后台进程，服务进程，可见进程，前台进程。</p>
<p><strong>前台进程</strong> 这个进程是最重要的，是最后被销毁的。前台进程是目前正在屏幕上显示的进程和一些系统进程，也就是和用户正在交互的进程。例如，我正在使用qq跟别人聊天，在我的Android手机上这个进程就应该是前台进程。</p>
<p><strong>可见进程</strong> 可见进程指部分程序界面能够被用户看见，却不在前台与用户交互的进程。例如，我们在一个界面上弹出一个对话框（该对话框是一个新的Activity），那么在对话框后面的原界面是可见的，但是并没有与用户进行交互，那么原界面就是可见进程。</p>
<p><strong>服务进程</strong> 服务进程是通过 startService() 方法启动的进程，但不属于前台进程和可见进程。例如，在后台播放音乐或者在后台下载就是服务进程。</p>
<p><strong>后台进程</strong> 后台进程指的是目前对用户不可见的进程。例如我正在使用qq和别人聊天，这个时候qq是前台进程，但是当我点击Home键让qq界面消失的时候，这个时候它就转换成了后台进程。当内存不够的时候，可能会将后台进程回收。</p>
<p><strong>空进程</strong> 空进程指的是在这些进程内部，没有任何东西在运行。保留这种进程的的唯一目的是用作缓存，以缩短该应用下次在其中运行组件所需的启动时间。</p>
<h4 id="Android-为什么用-dex不用class"><a href="#Android-为什么用-dex不用class" class="headerlink" title="Android 为什么用 dex不用class?"></a>Android 为什么用 dex不用class?</h4><p>主要涉及到性能优化、存储效率和Android运行时的特点：</p>
<ol>
<li><strong>存储优化</strong>：<ul>
<li>DEX文件格式专为Android设计，能够有效减少文件的存储大小。DEX合并了多个CLASS文件中的共享数据，通过这种方式可以减少重复信息，从而减少了应用的总体大小。</li>
</ul>
</li>
<li><strong>执行效率</strong>：<ul>
<li>DEX文件经过特殊优化，适合在内存和处理能力有限的移动设备上运行。它支持在Dalvik虚拟机（以及后来的Android Runtime, ART）上运行，这些运行时环境为Android设备特别优化。</li>
</ul>
</li>
<li><strong>加载速度</strong>：<ul>
<li>DEX格式设计时考虑到了快速加载的需求，格式本身支持更快的解析和加载，这对于移动设备上的应用程序来说尤其重要，因为它们经常需要快速启动。</li>
</ul>
</li>
<li><strong>Dalvik和ART运行时</strong>：<ul>
<li>Android设备最初使用Dalvik虚拟机，它是专为Android优化的，使用DEX而非CLASS文件，以提高执行效率和减少内存消耗。后来，Android引入了ART，它在安装应用时将DEX编译为机器代码，进一步提高了执行效率。</li>
</ul>
</li>
</ol>
<h4 id="冷启动和热启动的区别"><a href="#冷启动和热启动的区别" class="headerlink" title="冷启动和热启动的区别"></a>冷启动和热启动的区别</h4><ol>
<li><strong>冷启动</strong>：<ul>
<li>当应用从完全停止状态启动时，称为冷启动。在这种启动过程中，Android操作系统需要创建应用的进程，并且应用需要初始化所有的资源和数据。冷启动通常需要较长的时间，因为它涉及到更多的设置步骤和资源加载。</li>
<li>冷启动发生在用户首次启动应用、应用被系统杀死后的重启，或者是应用的任务栈被清除后的启动。</li>
</ul>
</li>
<li><strong>热启动</strong>：<ul>
<li>热启动指的是应用已经在运行，但用户通过任务管理器回到应用，或者通过Intent再次启动应用的情况。在热启动过程中，应用的所有活动和资源通常已经加载到内存中，所以重启速度较快。</li>
<li>这种启动过程不需要像冷启动那样加载大量资源，因为大部分所需资源已经处于活跃状态或存储在内存中。</li>
</ul>
</li>
</ol>
<h4 id="Android-开发中多线程场景"><a href="#Android-开发中多线程场景" class="headerlink" title="Android 开发中多线程场景"></a>Android 开发中多线程场景</h4><ol>
<li><strong>网络请求</strong>：<ul>
<li>执行网络操作（如下载文件、请求数据）时，需要在后台线程中进行，以避免阻塞主线程。网络请求在 Android 中通常通过使用 <code>AsyncTask</code>, <code>Thread</code>, <code>ExecutorService</code>, <code>Volley</code>, <code>Retrofit</code> 等库来实现。</li>
</ul>
</li>
<li><strong>数据库操作</strong>：<ul>
<li>对数据库进行读写操作（如 SQLite 数据库）也应该在后台线程进行，特别是对于大量数据的查询或更新操作，这些操作可能需要较长时间才能完成。</li>
</ul>
</li>
<li><strong>大量数据处理</strong>：<ul>
<li>当应用需要处理或计算大量数据（如图像处理、大数据集计算）时，后台线程可以用来执行这些任务，避免UI冻结。</li>
</ul>
</li>
<li><strong>文件读写</strong>：<ul>
<li>在本地文件系统进行文件读写操作时，如日志记录、用户数据存储等，也应当在后台线程执行，特别是涉及到大文件或高频操作。</li>
</ul>
</li>
<li><strong>定时任务与后台任务</strong>：<ul>
<li>执行定时任务或长时间运行的后台任务（如后台更新、数据同步等）时，也需要使用多线程来处理，以保证应用界面的流畅性。</li>
</ul>
</li>
<li><strong>多媒体处理</strong>：<ul>
<li>在处理多媒体资源，如播放视频、录音、处理音频流时，通常涉及到复杂的数据处理，这些也应该在后台线程中完成。</li>
</ul>
</li>
<li><strong>资源加载</strong>：<ul>
<li>加载大图或多个资源时（如在游戏或大型应用中），后台线程用于资源加载可以避免画面的卡顿。</li>
</ul>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" title="Android内存泄漏"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android内存泄漏</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/Android%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/" title="MVC MVP MVVM MVI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MVC MVP MVVM MVI</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android9-0%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%A7%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">Android9.0版本有哪些大的改动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android13%E6%9D%83%E9%99%90"><span class="toc-number">2.</span> <span class="toc-text">Android13权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%9B%B4%E6%94%B9%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E6%94%B9%E7%9A%84%EF%BC%9F%E5%AD%98%E5%82%A8%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E6%94%B9%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">权限更改是在哪个版本改的？存储是在哪个版本改的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose%E4%B8%8E%E5%8E%9F%E7%94%9FView%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">compose与原生View的区别，优点和缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8FIntent%E5%92%8C%E9%9A%90%E5%BC%8FIntent%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">显式Intent和隐式Intent区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8FIntent%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">隐式Intent还有什么作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#canvas%E8%B7%9FPaint%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">canvas跟Paint的区别，以及作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DalvikVM%E5%92%8CART%EF%BC%8C%E8%AF%B7%E9%97%AE%E8%BF%99%E4%B8%A4%E4%B8%AA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E5%81%9A%E7%9A%84%E4%BA%A4%E6%9B%BF%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">四大引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E8%99%9A%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">什么情况下用虚引用、弱引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#APK%E7%98%A6%E8%BA%AB%E4%BD%A0%E5%81%9A%E8%BF%87%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">APK瘦身你做过的有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onNewIntent"><span class="toc-number">12.</span> <span class="toc-text">onNewIntent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%BA%94%E7%A7%92%E5%8F%91%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">每五秒发一个消息的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">广播是安全的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SharedPreferences-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">15.</span> <span class="toc-text">SharedPreferences 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SharedPreferences-%E6%8F%90%E4%BA%A4apply-%E5%92%8C-commit-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">SharedPreferences 提交apply() 和 commit()的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">Android 组件化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">18.</span> <span class="toc-text">组件之间的通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-apk-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">构建 apk 的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">说一下今日头条屏幕适配的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D-dp-%E5%92%8C-sp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-dins-%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">屏幕适配 dp 和 sp 有什么区别, dins 干什么用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-RecycleView-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">22.</span> <span class="toc-text">说一下 RecycleView 三级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-R8-%E5%92%8C-D8-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">说一下 R8 和 D8 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">24.</span> <span class="toc-text">AOP 面向切面编程思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#apk-%E8%A7%A3%E6%9E%90%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-number">25.</span> <span class="toc-text">apk 解析安装过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvvm-%E6%AF%94-mpv-%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">26.</span> <span class="toc-text">mvvm 比 mpv 好在哪里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvp-%E8%AF%B4%E4%B8%80%E4%B8%8B-mvp-%E5%92%8C-mvc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">mvp 说一下 mvp 和 mvc 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvp-%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%83%85%E5%86%B5"><span class="toc-number">28.</span> <span class="toc-text">mvp 使用中的内存泄漏情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%9C%A8%E5%BC%B1%E7%BD%91%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E5%9B%9E%E8%B0%83%E8%BF%98%E6%B2%A1%E5%9B%9E%E6%9D%A5%E4%B9%8B%E5%89%8D%E5%85%B3%E9%97%AD%E6%8E%89-activity%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%A6%82%E6%9E%9C%E5%9B%9E%E8%B0%83%E5%9B%9E%E6%9D%A5%E6%98%AF%E5%90%A6%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%88%96%E8%80%85-crash%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#looper-%E5%92%8B%E5%81%9C"><span class="toc-number">30.</span> <span class="toc-text">looper 咋停</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handler-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E5%8E%BB%E9%81%BF%E5%85%8D"><span class="toc-number">31.</span> <span class="toc-text">handler 内存泄漏如何去避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%EF%BC%8C%E9%99%A4%E4%BA%86%E7%94%A8-handler-%E8%BF%98%E7%94%A8%E5%95%A5"><span class="toc-number">32.</span> <span class="toc-text">处理消息的，除了用 handler 还用啥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E5%8E%9F%E7%94%9F%E5%92%8CH5%E4%BA%A4%E4%BA%92"><span class="toc-number">33.</span> <span class="toc-text">Android原生和H5交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AF%B7%E6%B1%82%E6%9D%83%E9%99%90%E3%80%81%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E8%AF%B7%E6%B1%82%E6%9D%83%E9%99%90%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%81%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85"><span class="toc-number">34.</span> <span class="toc-text">Android中如何请求权限、如何知道请求权限的结果、权限请求封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%88%96%E5%8D%95%E4%BE%8B%E7%B1%BB%E6%9D%A5%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">35.</span> <span class="toc-text">使用静态变量或单例类来共享数据时的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%BC%98%E5%8C%96"><span class="toc-number">36.</span> <span class="toc-text">Android优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E7%9A%84Activity-%E3%80%81-Window-%E3%80%81-View%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">37.</span> <span class="toc-text">Android的Activity 、 Window 、 View之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SharedPreferences%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">38.</span> <span class="toc-text">SharedPreferences的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AAView%E5%AE%BD%E9%AB%98%E4%BF%A1%E6%81%AF"><span class="toc-number">39.</span> <span class="toc-text">那个生命周期方法可以获取某个View宽高信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#View-post-%E4%B8%BA%E4%BD%95%E8%83%BD%E5%A4%9F%E8%8E%B7%E5%8F%96%E5%88%B0-View-%E7%9A%84%E5%AE%BD%E9%AB%98%E5%80%BC%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">View.post() 为何能够获取到 View 的宽高值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android11%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">41.</span> <span class="toc-text">Android11分区存储强制执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">42.</span> <span class="toc-text">Android进程间通信的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zygote%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8scoket%E8%80%8C%E4%B8%8D%E6%98%AFbinder"><span class="toc-number">43.</span> <span class="toc-text">zygote为什么用scoket而不是binder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E5%9F%BA%E4%BA%8EAndroid8-0%EF%BC%89"><span class="toc-number">44.</span> <span class="toc-text">App 启动流程（基于Android8.0）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">45.</span> <span class="toc-text">Android进程启动流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v1-v2%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">46.</span> <span class="toc-text">v1&#x2F;v2签名的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">并发和并行的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HandlerThread%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">48.</span> <span class="toc-text">HandlerThread是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncTask%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">49.</span> <span class="toc-text">AsyncTask的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AsyncTask%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">50.</span> <span class="toc-text">AsyncTask的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">51.</span> <span class="toc-text">Android中操作多线程的方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E5%BC%80%E5%8F%91%E4%B8%AD%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">52.</span> <span class="toc-text">Android开发中怎样判断当前线程是否是主线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BADialog%E7%9A%84context%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">Application为啥不能作为Dialog的context？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity-window-view%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">54.</span> <span class="toc-text">Activity window view之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E7%9A%84context"><span class="toc-number">55.</span> <span class="toc-text">Android中的context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">56.</span> <span class="toc-text">线程切换方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">57.</span> <span class="toc-text">Android中序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serializable%E5%8E%9F%E7%90%86"><span class="toc-number">58.</span> <span class="toc-text">Serializable原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parcelable%E5%8E%9F%E7%90%86"><span class="toc-number">59.</span> <span class="toc-text">Parcelable原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parcelable%E6%AF%94Serializable%E5%BF%AB%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">60.</span> <span class="toc-text">Parcelable比Serializable快的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">61.</span> <span class="toc-text">Android中的设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0View"><span class="toc-number">62.</span> <span class="toc-text">Android中主动更新View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E9%82%A3%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="toc-number">63.</span> <span class="toc-text">Bundle可以存储那些数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android%E4%B8%AD%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">64.</span> <span class="toc-text">Android中进程的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-dex%E4%B8%8D%E7%94%A8class"><span class="toc-number">65.</span> <span class="toc-text">Android 为什么用 dex不用class?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">66.</span> <span class="toc-text">冷启动和热启动的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">67.</span> <span class="toc-text">Android 开发中多线程场景</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>