<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java 面试题 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SparseArrary和HashMap比较SparseArray 使用两个数组来存储数据，避免了 HashMap 中的Integer自动装箱（autoboxing）过程，减少了内存占用。在处理小型数据集时，这种差异尤为明显。但这也就是仅仅的优点了。 123456SparseArray+---------------------+| keys:   | 3 | 5 | 8 | +---------">
<meta property="og:type" content="article">
<meta property="og:title" content="java 面试题">
<meta property="og:url" content="https://zrmomo.github.io/2024/04/23/Java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="SparseArrary和HashMap比较SparseArray 使用两个数组来存储数据，避免了 HashMap 中的Integer自动装箱（autoboxing）过程，减少了内存占用。在处理小型数据集时，这种差异尤为明显。但这也就是仅仅的优点了。 123456SparseArray+---------------------+| keys:   | 3 | 5 | 8 | +---------">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-04-23T14:33:30.751Z">
<meta property="article:modified_time" content="2024-04-19T07:24:45.875Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/04/23/Java%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java 面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-19 15:24:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java 面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T14:33:30.751Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-19T07:24:45.875Z" title="更新于 2024-04-19 15:24:45">2024-04-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java 面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h4 id="SparseArrary和HashMap比较"><a href="#SparseArrary和HashMap比较" class="headerlink" title="SparseArrary和HashMap比较"></a>SparseArrary和HashMap比较</h4><p><code>SparseArray</code> 使用两个数组来存储数据，避免了 <code>HashMap</code> 中的Integer自动装箱（autoboxing）过程，减少了内存占用。在处理小型数据集时，这种差异尤为明显。但这也就是仅仅的优点了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SparseArray</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> keys:   <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">values</span>: <span class="operator">|</span> A <span class="operator">|</span> B <span class="operator">|</span> C <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>SparseArray的局限性：</p>
<ol>
<li><strong>只适用于整数键</strong>：<code>SparseArray</code> 只能使用整数作为键，而 <code>HashMap</code> 可以使用任何类型的对象作为键。</li>
<li><strong>可能不适合大型数据集</strong>：对于非常大的数据集，<code>SparseArray</code> 的二分查找可能不如 <code>HashMap</code> 的哈希查找高效。</li>
</ol>
<h4 id="ConcurrentHashMap基本原理"><a href="#ConcurrentHashMap基本原理" class="headerlink" title="ConcurrentHashMap基本原理"></a>ConcurrentHashMap基本原理</h4><p>ConcurrentHashMap的get方法是没有使用同步锁的，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点</p>
<h4 id="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥"><a href="#HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥" class="headerlink" title="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?"></a>HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?</h4><p>存取过程：看下图是存的过程，取得过程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxVEh1RWdFR2lhVkV3N0JoazBvVWRDVnNnN2dObG5yYUtuemljUEo2M3JiNDlvNFhRTTJWak5pY2ljdy8" alt="img"></p>
<p>其中对key得hash操作具体得内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原始哈希值 <code>h</code> 的高16位右移16位（<code>h &gt;&gt;&gt; 16</code>），然后与原始哈希值进行异或运算（<code>^</code>）得到hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>一切以算的位置为基础寻找对应的数组节点，然后再遍历红黑树或者链表查找对应的元素。</p>
<p><strong>红黑树与完全二叉树对比：</strong></p>
<p>红黑树查找、插入和删除操作的最坏情况时间复杂度为 O(log n)。而完全二叉树是O(n)。</p>
<p><strong>Hashtable结构：</strong></p>
<p>它对几乎大部分方法都上了synchronized锁，底层结构为数组+链表，因为已经被废弃所以研究没有意义。</p>
<h4 id="Java的concurrent包里有啥："><a href="#Java的concurrent包里有啥：" class="headerlink" title="Java的concurrent包里有啥："></a><strong>Java的concurrent包里有啥：</strong></h4><p><strong>线程池和执行器框架</strong></p>
<ul>
<li><code>Executor</code>：执行已提交的 <code>Runnable</code> 任务的对象的接口。</li>
<li><code>ExecutorService</code>：扩展了 <code>Executor</code> 的接口，提供了更完整的异步任务执行框架。</li>
<li><code>ScheduledExecutorService</code>：扩展了 <code>ExecutorService</code>，支持定时以及周期性任务执行。</li>
<li><code>ThreadPoolExecutor</code>：<code>ExecutorService</code> 的实现类，用于管理和执行线程池中的任务。</li>
<li><code>ScheduledThreadPoolExecutor</code>：<code>ScheduledExecutorService</code> 的实现类，用于执行定时或周期性任务。</li>
</ul>
<p><strong>同步器</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他线程完成操作的同步辅助工具。</li>
<li><code>CyclicBarrier</code>：使一组线程在达到某个屏障时互相等待的同步辅助工具。</li>
<li><code>Semaphore</code>：基于计数的信号量，用于控制对资源的访问。</li>
<li><code>Exchanger</code>：用于在两个线程之间交换数据的同步点。</li>
<li><code>Phaser</code>：提供了一种更灵活的线程同步机制，类似于 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 的结合。</li>
</ul>
<p><strong>并发集合</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的 <code>HashMap</code> 实现。</li>
<li><code>ConcurrentLinkedQueue</code>：基于链接节点的、线程安全的无界队列。</li>
<li><code>ConcurrentSkipListMap</code>：线程安全的、可排序的 <code>Map</code> 实现。</li>
<li><code>ConcurrentSkipListSet</code>：基于 <code>ConcurrentSkipListMap</code> 的 <code>Set</code> 实现。</li>
<li><code>CopyOnWriteArrayList</code>：在写操作时复制底层数组的线程安全 <code>List</code> 实现。</li>
<li><code>CopyOnWriteArraySet</code>：基于 <code>CopyOnWriteArrayList</code> 的 <code>Set</code> 实现。</li>
</ul>
<p><strong>原子变量</strong></p>
<ul>
<li><code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 等：提供原子操作的变量类。</li>
<li><code>AtomicReference</code>：提供对对象引用的原子操作。</li>
<li><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>：提供对数组元素的原子操作。</li>
</ul>
<p><strong>锁</strong></p>
<ul>
<li><code>Lock</code>：锁的基本接口。</li>
<li><code>ReentrantLock</code>：可重入的互斥锁实现。</li>
<li><code>ReadWriteLock</code>：读写锁的接口。</li>
<li><code>ReentrantReadWriteLock</code>：可重入的读写锁实现。</li>
<li><code>StampedLock</code>：提供了一种乐观读锁的实现。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>Future</code>：表示异步计算的结果。</li>
<li><code>Callable</code>：类似于 <code>Runnable</code>，但可以返回结果并抛出异常。</li>
<li><code>FutureTask</code>：<code>Future</code> 的实现类，用于表示异步计算。</li>
<li><code>CompletionService</code>：用于提交一组可调用任务，并以异步方式获取它们的结果。</li>
</ul>
<h4 id="ArrayList-如何保证线程安全？"><a href="#ArrayList-如何保证线程安全？" class="headerlink" title="ArrayList 如何保证线程安全？"></a>ArrayList 如何保证线程安全？</h4><ul>
<li>继承Arraylist，然后重写或按需求编写自己的方法，这些方法要写成synchronized，在这些<br>synchronized的方法中调用ArrayList的方法。</li>
<li>可以使用Collections.synchronizedList()这个函数进行包装</li>
</ul>
<h4 id="请说一说ArrayList、HashMap、LinkedHashMap-？"><a href="#请说一说ArrayList、HashMap、LinkedHashMap-？" class="headerlink" title="请说一说ArrayList、HashMap、LinkedHashMap ？"></a>请说一说ArrayList、HashMap、LinkedHashMap ？</h4><p><strong>ArrayList：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 的底层是一个动态数组，而不是双向链表。初始长度默认为 10。当数组容量不足时，通常扩展为原来的 1.5 倍。</li>
<li><strong>时间复杂度</strong>：获取元素的时间复杂度是 O(1)，因为可以直接通过数组索引来访问。但是插入和删除操作的时间复杂度可能是 O(n)，因为可能需要移动元素来维护数组的连续性。</li>
</ul>
<p><strong>HashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>HashMap</code> 的底层是一个数组，数组中的每个位置（或称为“桶”）包含了一个链表或红黑树（当链表中的元素数量超过某个阈值时，链表会转换为红黑树）来处理哈希冲突。</li>
<li><strong>哈希冲突处理</strong>：当多个键的哈希值相同，或者不同的哈希值经过处理后落在同一个桶中时，这些键值对会以链表的形式存储。在 Java 8 及以后的版本中，链表过长时会转换为红黑树来提高查找效率。</li>
</ul>
<p><strong>LinkedHashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，因此也是基于哈希表，但它还维护了一个双向链表来记录插入顺序或访问顺序。</li>
<li><strong>顺序性</strong>：遍历 <code>LinkedHashMap</code> 时，元素将按照插入顺序（默认）或访问顺序（如果在构造函数中设置）返回。</li>
<li><strong>访问顺序</strong>：在访问顺序模式下，每次 get 或 put 操作都会将被访问的元素移至双向链表的末尾。这种行为使得 <code>LinkedHashMap</code> 可以用来实现像最近最少使用（LRU）缓存策略这样的数据结构。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8f4f58b4b8ab">图解LinkedHashMap原理</a></p>
<h4 id="Java中提供了抽象类还有接口，开发中如何去选择呢？"><a href="#Java中提供了抽象类还有接口，开发中如何去选择呢？" class="headerlink" title="Java中提供了抽象类还有接口，开发中如何去选择呢？"></a>Java中提供了抽象类还有接口，开发中如何去选择呢？</h4><p><strong>抽象类的设计目的，是代码复用；接口的设计目的，是对类的行为进行约束。抽象类强调从属关系，接口强调功能。</strong></p>
<p>总结一下异同：</p>
<ol>
<li>关键字不同</li>
<li>一个类可以继承多个接口，只能继承一个抽象类</li>
<li>抽象类有构造方法，接口没有</li>
<li>继承所用的关键字不同</li>
<li><strong>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default且可以使用其他的权限修饰符，可在子类中被重新定义，也可被重新赋值。</strong></li>
<li>抽象类可以继承接口，抽象类可以继承实体类。接口也可以继承接口</li>
</ol>
<p>同：</p>
<p>都可以包含抽象方法</p>
<p>都可以有默认实现的方法</p>
<p>都不能被实例化。</p>
<h4 id="静态内部类是什么？和非静态内部类的区别是什么"><a href="#静态内部类是什么？和非静态内部类的区别是什么" class="headerlink" title="静态内部类是什么？和非静态内部类的区别是什么"></a>静态内部类是什么？和非静态内部类的区别是什么</h4><p>当内部类被static声明，那么在内部类中就无法直接使用外部类的属性。<strong>普通内部类构造方法中实际上会隐式的传递外部类实例对象给内部类。在内部类中使用外部类的属性实际上是通过外部类的实例对象获取的。</strong></p>
<p>因此静态内部类与非静态内部类的区别有：</p>
<ol>
<li>非静态内部类能够访问外部类的静态和非静态成员，静态类只能访问外部类的静态成员。</li>
<li>非静态内部类不能脱离外部类被创建，静态内部类可以。</li>
</ol>
<h4 id="Java中在传参数时是将值进行传递，还是传递引用？"><a href="#Java中在传参数时是将值进行传递，还是传递引用？" class="headerlink" title="Java中在传参数时是将值进行传递，还是传递引用？"></a>Java中在传参数时是将值进行传递，还是传递引用？</h4><p>Java 总是<strong>采用值传递</strong>的方式来处理变量。这意味着当你将一个变量传递给一个方法时，实际上传递的是变量的一个副本，不是变量本身。</p>
<p>对于基本类型（如 <code>int</code>, <code>double</code>, <code>char</code> 等），这意味着方法得到的是基本值的副本。</p>
<p>对于对象，传递的是对象引用的副本，而不是对象本身。</p>
<h4 id="equals和-进行比较的区别"><a href="#equals和-进行比较的区别" class="headerlink" title="equals和&#x3D;&#x3D;进行比较的区别"></a>equals和&#x3D;&#x3D;进行比较的区别</h4><p>equals和&#x3D;&#x3D;的区别，需要分情况讨论：</p>
<ol>
<li>没有重写 equals ，则 equals 和 &#x3D;&#x3D; 是一样的。</li>
<li>如果重写了 equals，则需看 equals 的方法实现。以 String 类为例：</li>
<li>equals 是比较字符串的内容是否一样；</li>
<li>&#x3D;&#x3D; 是比较字符串的堆内存地址是否一样，或者说引用的值是否相等。</li>
</ol>
<h4 id="String-s-new-String-“xxx”-创建了几个String对象"><a href="#String-s-new-String-“xxx”-创建了几个String对象" class="headerlink" title="String s &#x3D; new String(“xxx”);创建了几个String对象?"></a>String s &#x3D; new String(“xxx”);创建了几个String对象?</h4><ol>
<li>由于字符串字面量 <code>&quot;xxx&quot;</code> 出现在代码中，它会被放入 Java 字符串常量池中（如果常量池中还没有一个相同的字符串的话）。</li>
<li><code>new String(&quot;xxx&quot;)</code> 表达式将使用 <code>&quot;xxx&quot;</code> 字符串字面量作为参数创建一个新的 <code>String</code> 对象，并且这个新对象不在常量池中，而是在堆上分配。</li>
</ol>
<p>所以，如果常量池中之前没有 <code>&quot;xxx&quot;</code> 字符串，那么这条语句总共会创建两个字符串对象：一个在常量池中，一个在堆上。如果常量池中已经包含了 <code>&quot;xxx&quot;</code> 字符串，那么这条语句只会在堆上创建一个新的 <code>String</code> 对象。</p>
<p><code>String s = &quot;xxx&quot;;</code>只会创建一个 <code>String</code> 对象，或者一个都不创建。</p>
<h4 id="finally中的代码一定会执行吗？try里有return，finally还执行么"><a href="#finally中的代码一定会执行吗？try里有return，finally还执行么" class="headerlink" title="finally中的代码一定会执行吗？try里有return，finally还执行么"></a>finally中的代码一定会执行吗？try里有return，finally还执行么</h4><p><code>finally</code> 块中的代码几乎总是会被执行，即便 <code>try</code> 块中有 <code>return</code> 语句。<code>finally</code> 块的设计目的就是为了确保重要的清理工作总是会发生，比如关闭文件流或者数据库连接等。</p>
<p>当 <code>try</code> 块中的代码执行了 <code>return</code> 语句后，方法返回之前，<code>finally</code> 块中的代码会先被执行。之后，方法才真正返回。</p>
<p>只有在以下特殊情况下，<code>finally</code> 块不会被执行：</p>
<ul>
<li>在 <code>try</code> 或 <code>catch</code> 块中调用了 <code>System.exit()</code> 方法。</li>
<li>程序或线程崩溃，或者 <code>JVM</code> 由于某些原因挂掉了。</li>
<li>线程在 <code>finally</code> 块执行之前被中断或杀死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java异常机制中，异常Exception与错误Error区别"><a href="#Java异常机制中，异常Exception与错误Error区别" class="headerlink" title="Java异常机制中，异常Exception与错误Error区别"></a>Java异常机制中，异常Exception与错误Error区别</h4><p><code>Exception</code> 和 <code>Error</code> 都是 <code>Throwable</code> 的子类，它们都可以被 <code>throw</code> 和 <code>catch</code>。但它们通常代表着不同类型的问题，并且处理方式也不同。</p>
<p><strong>Exception</strong></p>
<p><code>Exception</code> 类代表了程序可以处理的异常情况。它们通常是由于程序错误或外部环境问题导致的。<code>Exception</code> 可以分为两类：</p>
<ul>
<li><strong>检查型异常（Checked Exceptions）</strong>：这类异常必须在编译时被捕获处理（<code>catch</code>）或者通过方法签名抛出（<code>throws</code>）。这类异常表示可恢复的条件，如 <code>IOException</code> 或 <code>SQLException</code>。</li>
<li><strong>非检查型异常（Unchecked Exceptions）</strong>：也称为运行时异常（<code>RuntimeException</code>），它们不需要显式的捕获处理。这些异常通常是程序逻辑错误，比如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。</li>
</ul>
<p><strong>Error</strong></p>
<p><code>Error</code> 类代表了严重的错误事件，这种情况下，JVM 无法继续运行。它们通常是描述系统级错误，如硬件故障、JVM 错误等。例如，<code>OutOfMemoryError</code> 表示 JVM 没有足够的内存继续执行，<code>StackOverflowError</code> 表示栈空间溢出。</p>
<ul>
<li><strong>不需要显式捕获</strong>：通常情况下，应用程序不应该捕获这类错误。它们是如此基础严重，以至于应用通常无法处理。</li>
<li><strong>预防而非恢复</strong>：对于错误，我们通常要通过编码和测试来预防它们，而不是在运行时尝试恢复。</li>
</ul>
<p>总结：</p>
<ul>
<li><code>Exception</code> 是程序可以预期并尝试恢复的条件。</li>
<li><code>Error</code> 是指在正常情况下，程序不应该尝试捕获的系统级错误。</li>
</ul>
<h4 id="序列Parcelable-Serializable的区别？"><a href="#序列Parcelable-Serializable的区别？" class="headerlink" title="序列Parcelable,Serializable的区别？"></a>序列Parcelable,Serializable的区别？</h4><p><strong>Serializable</strong></p>
<p><code>Serializable</code> 是Java原生序列化接口，其实现简单：</p>
<ul>
<li>只需实现 <code>java.io.Serializable</code> 接口，不需要实现任何方法，即可使类可序列化。</li>
<li>是一个标记接口，它告诉JVM该对象可以被序列化。</li>
<li>使用反射来序列化对象，这个过程相对较慢，并且会随着序列化对象的大小而增加更多的内存开销。</li>
<li>序列化过程会自动进行，不需要手动编写序列化过程。</li>
<li>适用于网络传输或者本地存储。</li>
</ul>
<p><strong>Parcelable</strong></p>
<p><code>Parcelable</code> 是Android特有的序列化机制，其设计目的是为了更高效的序列化，以便在Bundle中传递数据：</p>
<ul>
<li>需要实现 <code>android.os.Parcelable</code> 接口，并手动实现序列化过程。</li>
<li>性能高于 <code>Serializable</code>，因为它使用的是手动添加的序列化方法，不依赖于Java的反射机制。</li>
<li>虽然性能更好，但代码更复杂，因为开发者需要实现 <code>Parcelable</code> 接口的 <code>writeToParcel</code> 和 <code>createFromParcel</code> 方法。</li>
<li>主要用于Intent中在Activity或服务之间传递数据，不推荐用于网络传输或本地存储。</li>
</ul>
<p><strong>区别总结</strong></p>
<ul>
<li><strong>性能</strong>：<code>Parcelable</code> 通常比 <code>Serializable</code> 更快，因为它是为Android优化的。</li>
<li><strong>实现方式</strong>：<code>Serializable</code> 实现起来更简单，<code>Parcelable</code> 更复杂但提供了更好的性能。</li>
<li><strong>用途</strong>：<code>Parcelable</code> 通常用于Android中的IPC传输，<code>Serializable</code> 可用于IPC以及将对象持久化到文件或数据库。</li>
</ul>
<p>因此，在Android中，<strong>当需要在Activity和Fragment之间传递数据时，推荐使用<code>Parcelable</code>，因为它更加高效。如果需要通过网络发送对象或者将对象写入文件，<code>Serializable</code> 可能是一个更好的选择，因为它实现起来更简单，并且是Java平台的标准序列化方式。</strong></p>
<p>对于<code>Parcelable</code>，需要实现<code>Parcelable</code>接口并定义序列化和反序列化的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">User</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Parcelable</code>传递数据的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, AnotherActivity.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane Doe&quot;</span>, <span class="number">25</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;user_key&quot;</span>, user);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>在接收Activity中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getIntent().getParcelableExtra(<span class="string">&quot;user_key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>记住，<code>Parcelable</code>是Android推荐的方式，尤其是在需要频繁地序列化和反序列化，并且在应用内部传递复杂数据结构时。</p>
<h4 id="为什么Intent传递对象为什么需要序列化？"><a href="#为什么Intent传递对象为什么需要序列化？" class="headerlink" title="为什么Intent传递对象为什么需要序列化？"></a>为什么Intent传递对象为什么需要序列化？</h4><p>在Android中使用Intent传输数据除了基本数据类型之外，对于其他类型对象需要此类型实现了Serializable或者Parcelable序列化接口才能进行传输。</p>
<p>Intent传输数据本质上是使用Binder来完成的。Intent启动组件需要借助AMS完成，因此startActivity 会离开当前应用进程，进入AMS所在的system_server进程进行跨进程通信。<strong>这就意味着传输的对象需要在不同进程之间进行传输。为了保护不同进程互不干扰，进程隔离让system_server进程无法直接获取应用进程内存中的对象。</strong>因此必须通过类似于复制的手段，将应用进程的对象传递给system_server进程，再由system_server进程传递给应用中的 OtherActivity 。</p>
<h4 id="kotlin中进行序列化的方式"><a href="#kotlin中进行序列化的方式" class="headerlink" title="kotlin中进行序列化的方式"></a>kotlin中进行序列化的方式</h4><p>在 Kotlin 中，序列化也可以通过两种主要方式实现：使用标准 Java 的 <code>Serializable</code> 接口，或者使用 Kotlin 特有的 <code>Parcelize</code> 插件来实现 <code>Parcelable</code> 接口。</p>
<p><strong>使用 Serializable</strong></p>
<p>与 Java 相同，你可以简单地通过让类实现 <code>Serializable</code> 接口来使类可序列化。Kotlin 代码更加简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class User(val name: String, val age: Int) : Serializable</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中，通常推荐使用数据类（<code>data class</code>）来存储序列化数据，因为它们自动为你的字段生成 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。</p>
<p><strong>使用 Parcelable</strong></p>
<p>Kotlin 为 <code>Parcelable</code> 实现提供了一个名为 <code>@Parcelize</code> 的注解，这可以极大简化实现过程。首先，你需要在你的 <code>build.gradle</code> 文件中启用 <code>kotlin-android-extensions</code> 插件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-android-extensions&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以如下定义一个实现 <code>Parcelable</code> 的数据类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"><span class="keyword">import</span> kotlinx.parcelize.Parcelize</span><br><span class="line"></span><br><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) : Parcelable</span><br></pre></td></tr></table></figure>

<p>这样，编译器会自动为你生成所有必要的 <code>Parcelable</code> 实现细节。</p>
<p><strong>注意事项</strong></p>
<p>如果你打算在多个平台上使用序列化，比如在 JVM 和 Android 上，你可能会考虑使用 Kotlin 的 <code>kotlinx.serialization</code> 库，它提供了一个跨平台的序列化框架。</p>
<p>下面是一个使用 <code>kotlinx.serialization</code> 库的例子：</p>
<p>首先，在 <code>build.gradle</code> 文件中添加序列化库的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.2.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以像这样使用 <code>@Serializable</code> 注解：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.serialization.Serializable</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>这个库提供了丰富的序列化和反序列化选项，包括 JSON、Protobuf 和 CBOR 等格式。这可以是一个在 Kotlin 中进行复杂序列化任务的强大工具。</p>
<h4 id="Java中变量的存储"><a href="#Java中变量的存储" class="headerlink" title="Java中变量的存储"></a>Java中变量的存储</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在 <code>Main</code> 类中，<code>a</code>、<code>s</code> 和 <code>str</code> 被称为实例变量（Instance Variables）或成员变量（Member Variables）。这些变量属于类的每个实例，因此每个 <code>Main</code> 类的对象都会有自己的一份 <code>a</code>、<code>s</code> 和 <code>str</code> 变量的副本。它们的值可以在对象之间独立变化。</p>
<p>​		创建 <code>Main</code> 类的一个实例时，像 <code>a</code> 这样的基本类型实例变量会在堆内存的对象分配区域中为该特定对象分配空间，并存储其值。每个 <code>Main</code> 对象都会有自己的 <code>a</code> 变量副本，它们是相互独立的。</p>
<p>​		</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 基本数据类型的局部变量</span></span><br><span class="line">    <span class="type">Main</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>(); <span class="comment">// 在方法中创建一个对象实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>localVar</code> 是一个基本数据类型的局部变量，它存储在栈内存中。当 <code>myMethod</code> 方法被调用时，<code>localVar</code> 被创建并存储在方法的栈帧中。当 <code>myMethod</code> 方法执行完成后，<code>localVar</code> 会随着栈帧的销毁而销毁。</p>
<p><strong>基本数据类型的局部变量通常存储在栈内存中，而基本数据类型的实例变量（作为对象的一部分）存储在堆内存中。</strong></p>
<p>​		obj是new Main()所创建的对象的引用，对象的引用（通常是一个局部变量）会存储在栈内存中，这个对象及其实例变量会存储在堆内存中。</p>
<h4 id="怎么理解Java中的多态"><a href="#怎么理解Java中的多态" class="headerlink" title="怎么理解Java中的多态"></a>怎么理解Java中的多态</h4><p>​		用白话来说，就是多个对象调用同一个方法，得到不同的结果。</p>
<p><strong>方法重写（Override）：</strong> 子类可以覆盖（重写）父类的方法，实现自己特定的行为。父类引用可以指向子类对象，并且在运行时将调用子类的方法，这称为动态方法调度。这种多态性可以实现基于继承的多态。</p>
<p><strong>接口多态性：</strong> Java中，多个类可以实现同一个接口，然后使用接口类型的引用来引用这些不同的对象，从而实现接口多态性。这允许不同的类以统一的方式执行相同的接口定义的操作。</p>
<h4 id="什么是Java对象，不生成实例就不是对象吗"><a href="#什么是Java对象，不生成实例就不是对象吗" class="headerlink" title="什么是Java对象，不生成实例就不是对象吗"></a>什么是Java对象，不生成实例就不是对象吗</h4><p>​		如果没有生成实例，那么就没有对象。在 Java 中，对象是根据类创建的一个实例。类是一个蓝图，定义了对象的属性和行为。当使用 <code>new</code> 关键字和构造器来创建类的实例时，就创建了一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>person</code> 是一个指向 <code>Person</code> 对象的引用，这个对象有 <code>name</code> 和 <code>age</code> 这两个属性。</p>
<p>​		对象是类的具体实例，它们在内存中占用空间，并拥有实际的状态（属性值）和行为（方法）。在没有创建实例的情况下，只有类的定义，而没有实际的对象。</p>
<h4 id="java中的foreash和普通for循环对比"><a href="#java中的foreash和普通for循环对比" class="headerlink" title="java中的foreash和普通for循环对比"></a>java中的foreash和普通for循环对比</h4><p><strong>普通<code>for</code>循环</strong></p>
<p>普通<code>for</code>循环使用索引来访问元素，其语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 访问元素 array[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遍历数组或<code>ArrayList</code>时，普通<code>for</code>循环通常会有更好的性能，因为它直接通过索引访问元素，这在内存中是连续的，因此访问速度快。但是，当遍历<code>LinkedList</code>时，普通<code>for</code>循环的性能会显著下降，因为每次通过索引访问元素都需要从链表头开始遍历，导致时间复杂度为O*(*n方)</p>
<p><strong><code>foreach</code>循环</strong></p>
<p><code>foreach</code>循环是基于迭代器的遍历方式，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javafor (ElementType element : collection) &#123;</span><br><span class="line">    // 访问元素 element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foreach</code>循环在遍历<code>ArrayList</code>时与普通<code>for</code>循环性能相近，但在遍历<code>LinkedList</code>时性能要优于普通<code>for</code>循环，因为它使用迭代器按顺序访问元素，每次调用<code>next()</code>方法的时间复杂度为O*(1)，因此总的时间复杂度为O*(<em>n</em>)</p>
<p>性能比较</p>
<ul>
<li>对于数组或<code>ArrayList</code>，普通<code>for</code>循环通常比<code>foreach</code>循环快，尤其是在数据量较大时</li>
<li>对于<code>LinkedList</code>，<code>foreach</code>循环比普通<code>for</code>循环快得多，因为普通<code>for</code>循环需要从链表头开始遍历以访问每个元素，而<code>foreach</code>循环则不需要</li>
</ul>
<p>结论</p>
<ul>
<li>基于数组实现的集合，使用普通for循环遍历数据</li>
<li>基于链表实现的集合，使用增强型for循环遍历数据</li>
</ul>
<h4 id="Serialible的原理"><a href="#Serialible的原理" class="headerlink" title="Serialible的原理"></a>Serialible的原理</h4><p>​		Serializable是<a href="https://link.zhihu.com/?target=http://java.io">http://java.io</a>包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。</p>
<p>​		实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。</p>
<p>​		例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。</p>
<p>​		<strong>序列化是指把对象转换为字节序列的过程，我们称之为对象的序列化，就是把内存中的这些对象变成一连串的字节(bytes)描述的过程。反序列化则相反，就是把持久化的字节文件数据恢复为对象的过程。</strong></p>
<h4 id="serialVersionUID的作用"><a href="#serialVersionUID的作用" class="headerlink" title="serialVersionUID的作用"></a>serialVersionUID的作用</h4><p>​		对于JVM来说，要进行持久化的类必须要有一个标记，只有持有这个标记JVM才允许类创建的对象可以通过其IO系统转换为字节数据，从而实现持久化，而这个标记就是Serializable接口。</p>
<ul>
<li>而在反序列化的过程中则需要使用serialVersionUID来确定由那个类来加载这个对象，所以我们在实现Serializable接口的时候，一般还会要去尽量显示地定义serialVersionUID。</li>
<li>类的序列化版本由 <code>serialVersionUID</code> 字段确定。如果类发生了变化（如添加或删除字段），但 <code>serialVersionUID</code> 没有改变，那么反序列化时可能会出现问题。因此，建议显式声明 <code>serialVersionUID</code> 字段以确保版本兼容性。</li>
</ul>
<h4 id="equals-和hashcode"><a href="#equals-和hashcode" class="headerlink" title="equals 和hashcode"></a>equals 和hashcode</h4><p>&#x3D;&#x3D;：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：</p>
<p>（1）基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。</p>
<p>（2）引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。</p>
<p>equals()于Object方法中的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说在重写equals方法之前它和&#x3D;&#x3D;的作用是一致的。</p>
<p>​		<code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。</p>
<p>​		<strong>重写equals的同时必须同时重写hashcode</strong>：<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）简单来说就是：<strong>如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等</strong>。</p>
<p>总结：</p>
<p>如果 x.equals(y) 返回“true”，那么 x 和 y 的 hashCode() 必须相等。</p>
<p>如果 x.equals(y) 返回“false”，那么 x 和 y 的 hashCode() 有可能相等，也有可能不等。</p>
<h4 id="Java中的深拷贝和浅拷贝"><a href="#Java中的深拷贝和浅拷贝" class="headerlink" title="Java中的深拷贝和浅拷贝"></a>Java中的深拷贝和浅拷贝</h4><p>首先看两者定义：</p>
<ul>
<li>浅拷贝：创建一个新对象，指向被复制对象的内存引用地址。</li>
<li>深拷贝：创建一个新对象，且创建一个新的内存地址，并将被复制对象的值复制到新对象中。</li>
</ul>
<p>基本数据类型与引用类型浅拷贝的区别：</p>
<ul>
<li><strong>基本数据类型</strong>：新对象在浅拷贝时会直接复制被拷贝对象的基本数据类型值，但这两者之间是独立的值，也就是说，修改这两者之间的任何一个对象的基本数据类型属性都不会影响到另外一个对象。</li>
<li><strong>引用类型</strong>：新对象在浅拷贝时会复制被拷贝对象的引用。这两者对象持有同一内存引用地址，所以是关联的。也就是说，修改这两者之间的任何一个对象的属性，另外一个对象也会跟着一起发生更改。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7236305021594664997?utm_source=gold_browser_extension#heading-3">一次由 List.addAll 所引起的深入</a></p>
<h3 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h3><h4 id="泛型是什么，泛型擦除呢？"><a href="#泛型是什么，泛型擦除呢？" class="headerlink" title="泛型是什么，泛型擦除呢？"></a>泛型是什么，泛型擦除呢？</h4><p>在 Java 中，泛型用于在编译时提供类型检查并消除类型转换的需要。泛型让你可以编写更通用、更安全的代码，因为它们让你在类、接口和方法上定义类型参数。</p>
<p>例如，一个泛型类 <code>Box&lt;T&gt;</code> 可以存储任何类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个类型参数，它可以在创建 <code>Box</code> 对象时被替换为任何类型，例如 <code>Integer</code>、<code>String</code> 等。</p>
<p><strong>泛型擦除</strong> (Type Erasure)</p>
<p>泛型擦除是 Java 泛型的一种实现机制。在编译时，泛型类型参数会被擦除，替换为它们的边界（如果有的话）或者 <code>Object</code>。这意味着在运行时，泛型信息是不可用的，所有泛型类型都被视为原始类型（raw types）。</p>
<p>例如，考虑以下泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在编译时，泛型类型参数 <code>String</code> 会被擦除，因此在运行时，<code>list</code> 的类型实际上就是 <code>List</code>，而不是 <code>List&lt;String&gt;</code>。</p>
<p>泛型擦除的主要目的是为了确保 Java 泛型的向后兼容性。这意味着使用泛型的 Java 代码可以与不支持泛型的旧版 Java 代码互操作。</p>
<h4 id="List能否转为List"><a href="#List能否转为List" class="headerlink" title="List能否转为List"></a>List<String>能否转为List<Object></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br></pre></td></tr></table></figure>

<p>因此List<String>其实能够强转为List<Object>。但是存在隐患：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br><span class="line">objects.add(<span class="number">123</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码使用objects（List<Object> ）向集合中增加整型数据：123。然后通过 strs获取数据时，因为其类型为List<String>，但是真实数据类型为整型。此时就会发生运行时异常</p>
<h4 id="Java的泛型中super-和-extends-有什么区别？"><a href="#Java的泛型中super-和-extends-有什么区别？" class="headerlink" title="Java的泛型中super 和 extends 有什么区别？"></a>Java的泛型中super 和 extends 有什么区别？</h4><p>? extends T 为上界通配符，也就是说限制类型只能是T 或者 T 的派生类</p>
<p>? super T 为通配符下界，也就是说限制类型只能是T 或者T的超类。</p>
<p>生产使用extends，消费使用super。结合上下界的特点可知：<br>经常读取数据，使用Extends；<br>经常加入数据，使用Super；</p>
<h4 id="注解是什么？有哪些使用场景？"><a href="#注解是什么？有哪些使用场景？" class="headerlink" title="注解是什么？有哪些使用场景？"></a>注解是什么？有哪些使用场景？</h4><p>注解（Annotations）是 Java 提供的一种元数据形式，它允许在代码中添加信息，这些信息可以在编译时、类加载时或运行时被读取和处理。注解本身不会直接影响程序的操作，但它们可以被编译器或运行时环境用来生成额外的代码、执行额外的检查或者在运行时改变行为。</p>
<h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><h4 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h4><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403042110717.png" alt="LinkedHashMap 逻辑结构"></p>
<p>​		其中的head节点和tail节点就像两个对链表操作的指针，不断的按照顺序移动。head节点和tail节点是额外的专门用来标志头尾的节点。</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/linkedhashmap-source-code.html">LinkedHashMap 源码分析</a></p>
<h4 id="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"><a href="#Set底层存放怎么数据，是有序的还是无序的，可以重复吗" class="headerlink" title="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"></a>Set底层存放怎么数据，是有序的还是无序的，可以重复吗</h4><p>Set只是一个接口，其实现类有HashSet无序，TreeSet有序，不过都不允许有重复元素</p>
<p>Set集合不允许存储重复元素的实现原理主要依赖于其底层数据结构的特性。在Java中，Set接口的常用实现类如HashSet和TreeSet，分别使用哈希表和红黑树作为底层数据结构。</p>
<p>HashSet</p>
<p>HashSet是基于HashMap实现的。当向HashSet中添加元素时，HashSet会首先计算元素的hashCode值，然后根据这个hashCode值来找到在哈希表中的存储位置。如果该位置没有元素，则直接存储；如果该位置已经有元素存在，则通过equals方法来检查两个元素是否相等。如果equals方法返回true，表明两个元素相同，新元素就不会被添加到集合中。如果equals方法返回false，表明两个元素不同，新元素会被添加到集合中，这可能会导致哈希冲突，并通过链表或红黑树解决冲突</p>
<p>TreeSet</p>
<p>TreeSet是基于TreeMap实现的，TreeMap是一种红黑树结构。在TreeSet中，元素在插入时会进行排序，排序依据是元素的compareTo方法（如果元素实现了Comparable接口）或者Comparator比较器（如果在TreeSet的构造器中提供了Comparator）。如果两个元素通过compareTo或Comparator比较结果为0，表明两个元素相同，新元素就不会被添加到集合中</p>
<p>总结</p>
<p>无论是HashSet还是TreeSet，它们都不允许存储重复元素。这是通过元素的hashCode和equals方法（对于HashSet）或者compareTo方法（对于TreeSet）来实现的。当添加一个新元素时，这些方法被用来检查新元素是否与集合中已存在的元素相同。如果相同，则新元素不会被添加，从而保证了集合中元素的唯一性</p>
<h4 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h4><p>​		ConcurrentHashMap 使用 Node 数组加链表加红黑树的数据结构。在并发操作时使用synchronized锁住了链表的头节点或红黑树的根节点</p>
<h4 id="ConcurrentHashMap去get元素的时候有加锁吗？"><a href="#ConcurrentHashMap去get元素的时候有加锁吗？" class="headerlink" title="ConcurrentHashMap去get元素的时候有加锁吗？"></a>ConcurrentHashMap去get元素的时候有加锁吗？</h4><p>​		get元素没加锁，增删改查四个种类操作只有查这一操作没有加锁</p>
<h4 id="Object-finalize了解吗，只要有GC就会调用吗？"><a href="#Object-finalize了解吗，只要有GC就会调用吗？" class="headerlink" title="Object finalize了解吗，只要有GC就会调用吗？"></a>Object finalize了解吗，只要有GC就会调用吗？</h4><p>​		<code>finalize()</code>方法的主要目的是在对象从内存中删除之前释放对象使用的资源。</p>
<p>​		<code>finalize()</code>方法在特定对象的垃圾回收之前被调用，<strong>当垃圾回收器确定不存在对该对象的更多引用时</strong>，对象的垃圾回收器就会调用这个方法。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/551713593">https://zhuanlan.zhihu.com/p/551713593</a></p>
<h4 id="Object-notify了解吗，自己平时写代码有用过吗？"><a href="#Object-notify了解吗，自己平时写代码有用过吗？" class="headerlink" title="Object notify了解吗，自己平时写代码有用过吗？"></a>Object notify了解吗，自己平时写代码有用过吗？</h4><p>Java Object 中的 wait() 和 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=notify&spm=1001.2101.3001.7020">notify</a>() 方法和synchronized 实现多线程的同步等待。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22076345/article/details/107881591">https://blog.csdn.net/qq_22076345/article/details/107881591</a></p>
<h4 id="java反射的原理"><a href="#java反射的原理" class="headerlink" title="java反射的原理"></a>java反射的原理</h4><p><strong>反射的基本应用：</strong></p>
<ul>
<li>获取类的 Class 对象实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过传递类的完全限定名（包括包名）作为字符串来获取对应的 Class 对象。</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.zhenai.api.Apple&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在编译时已经知道具体的类，可以直接使用 .class 语法来获取 Class 对象。</span></span><br><span class="line">Class&lt;?&gt; cls = String.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有一个类的实例，可以通过调用该实例的 getClass() 方法来获取其 Class 对象。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">Class&lt;?&gt; cls = str.getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>根据 Class 对象实例获取 Constructor 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">appleConstructor</span> <span class="operator">=</span> clz.getConstructor();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Constructor 对象的 newInstance 方法获取反射类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">appleObj</span> <span class="operator">=</span> appleConstructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>而如果要调用某一个方法，则需要经过下面的步骤：</p>
<ul>
<li>获取方法的 Method 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">setPriceMethod</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 invoke 方法调用方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a><strong>Java反射机制</strong></h4><p>JAVA反射机制是在<strong>运行状态中</strong>，</p>
<p>对于任意一个类，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个属性和方法；</p>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为 <strong>java语言的反射机制。</strong></p>
<h4 id="反射性能耗在哪里？"><a href="#反射性能耗在哪里？" class="headerlink" title="反射性能耗在哪里？"></a>反射性能耗在哪里？</h4><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">https://pdai.tech/md/java/basic/java-basic-x-reflection.html</a></p>
<h4 id="new-String-内存优化"><a href="#new-String-内存优化" class="headerlink" title="new String()内存优化"></a>new String()内存优化</h4><ol>
<li><strong>直接使用字符串字面量</strong>：在Java中，字符串字面量（如<code>String s = &quot;example&quot;;</code>）会自动被存储在字符串池中。如果你试图创建一个已经在字符串池中存在的字符串，Java会直接返回对现有字符串的引用，而不会创建新的对象。这样可以节省内存。</li>
<li><strong>使用<code>String.intern()</code>方法</strong>：<code>String.intern()</code>方法会返回字符串对象在字符串池中的引用。如果字符串池中已经存在相同的字符串，<code>intern()</code>方法会返回现有字符串的引用；如果字符串池中不存在该字符串，<code>intern()</code>方法会将该字符串添加到字符串池中，然后返回新添加的字符串的引用。</li>
<li><strong>避免使用<code>+</code>操作符进行字符串拼接</strong>：在Java中，使用<code>+</code>操作符进行字符串拼接会在每次拼接时创建新的字符串对象。这可能会导致大量的内存浪费。为了避免这个问题，你可以使用<code>StringBuilder</code>或<code>StringBuffer</code>进行字符串拼接。</li>
</ol>
<h4 id="ArrayList和LinkendList区别"><a href="#ArrayList和LinkendList区别" class="headerlink" title="ArrayList和LinkendList区别"></a>ArrayList和LinkendList区别</h4><ol>
<li><strong>数据结构</strong>:<ul>
<li><code>ArrayList</code> 基于动态数组实现，可以随机访问元素。</li>
<li><code>LinkedList</code> 基于双向链表实现，每个元素都由节点组成，节点包含数据和指向前后节点的引用。</li>
</ul>
</li>
<li><strong>性能</strong>:<ul>
<li><strong>访问元素</strong>: <code>ArrayList</code> 由于其基于数组的特性，支持快速随机访问，访问时间复杂度为 O(1)。而 <code>LinkedList</code> 的访问时间复杂度为 O(n)，因为它需要从头节点或尾节点遍历到指定位置。</li>
<li><strong>添加&#x2F;删除元素</strong>: <code>ArrayList</code> 添加或删除非末尾元素时，需要移动后续所有元素，时间复杂度为 O(n)。<code>LinkedList</code> 添加或删除元素只需修改前后节点的引用，时间复杂度为 O(1)，但是找到指定位置的节点还是需要 O(n) 的时间。</li>
<li><strong>内存占用</strong>: <code>ArrayList</code> 由于使用连续内存，空间利用率较高，但可能会有额外的内存开销以支持数组的动态扩容。<code>LinkedList</code> 每个元素都需要额外的空间来存储节点引用，因此内存开销相对较大。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li><code>ArrayList</code> 适合于频繁访问元素的场景，如索引查找。</li>
<li><code>LinkedList</code> 适合于频繁添加或删除元素的场景，尤其是在列表的头部或尾部进行操作。</li>
</ul>
</li>
<li>元素的添加都是有序的</li>
</ol>
<h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h4><p>​		<code>ArrayList</code> 的扩容机制通常将当前数组容量增加到原来的 1.5 倍。这是通过将当前容量右移一位并加到当前容量来实现的（即 <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>); <span class="comment">// 初始容量为 3</span></span><br><span class="line">        list.add(<span class="number">1</span>); <span class="comment">// 添加元素，不需要扩容</span></span><br><span class="line">        list.add(<span class="number">2</span>); <span class="comment">// 继续添加元素</span></span><br><span class="line">        list.add(<span class="number">3</span>); <span class="comment">// 容量达到上限，下一个添加将触发扩容</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">4</span>); <span class="comment">// 触发扩容，新容量应为 4 + 4/2 = 6</span></span><br></pre></td></tr></table></figure>



<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><p>数组加链表加红黑树</p>
<h5 id="转化红黑树"><a href="#转化红黑树" class="headerlink" title="转化红黑树"></a>转化红黑树</h5><p>链表的长度大于 8 后，如果前数组的长度小于 64才会转化，否则会进行扩容。</p>
<h5 id="HashMap的长度为什么时2的n次放"><a href="#HashMap的长度为什么时2的n次放" class="headerlink" title="HashMap的长度为什么时2的n次放"></a>HashMap的长度为什么时2的n次放</h5><p> <strong>索引计算优化</strong></p>
<p>​		数组的长度是 2 的 n 次方时，可以通过位运算（例如 <code>hash &amp; (length - 1)</code>）来快速计算索引，这比模运算（<code>hash % length</code>）更高效。</p>
<p>​		位运算比模运算快得多，因为模运算在底层实现时涉及到除法运算，而除法运算是相对较慢的。</p>
<p><strong>减少哈希冲突</strong></p>
<p>​		使用 2 的 n 次方作为数组长度有助于减少哈希冲突。哈希冲突是指不同的键经过哈希函数计算后得到相同的索引。</p>
<p><strong>动态扩容</strong></p>
<p>​		使用 2 的 n 次方作为长度可以使得扩容过程更加平滑，同时保持索引计算的优化和哈希冲突的减少。</p>
<h5 id="红黑树退化"><a href="#红黑树退化" class="headerlink" title="红黑树退化"></a>红黑树退化</h5><p>红黑树大小小于等于6时，红黑树转化成链表</p>
<h5 id="HashMap-扩容机制"><a href="#HashMap-扩容机制" class="headerlink" title="HashMap 扩容机制"></a>HashMap 扩容机制</h5><p>触发扩容：当前容量大于等于阈值 或 在树化之前，当前数组的长度小于64，链表长度大于等于8 也会发生扩容。</p>
<p>阈值的计算公式：当前长度*0.75</p>
<p>扩容结果：原长度 * 2</p>
<p>元素迁移：</p>
<p>​		判断当前的桶的位置有没有链表或者红黑树，如果没有链表或者红黑树会重新计算每个同hash值（也有可能不计算），找到新数组中的对应位置，以尾插法插入新的链表。</p>
<p>​		如果有链表，不需要重新计算元素的hash进行元素迁移。而是用原先位置key的hash值与旧数组的长度（oldCap）进行”与”操作。</p>
<ul>
<li><p>如果结果是0，那么当前元素的桶位置不变。</p>
</li>
<li><p>如果结果为1，那么桶的位置就是原位置+原数组 长度</p>
<p> 如果是红黑树，将红黑树切分为两个链表，之后进行扩容操作。</p>
</li>
</ul>
<h5 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h5><p>最大容量：2的30次方 ，当容量超过2的30次方 ，容量不再扩大，阈值变为2的31次方-1</p>
<h5 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h5><p>16</p>
<h5 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h5><p>​		HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突</p>
<p>扰动函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="如果HashMap只装载100个元素，new-HashMap-int-x-中x的最佳值是多少，为什么？"><a href="#如果HashMap只装载100个元素，new-HashMap-int-x-中x的最佳值是多少，为什么？" class="headerlink" title="如果HashMap只装载100个元素，new HashMap(int x)中x的最佳值是多少，为什么？"></a>如果HashMap只装载100个元素，new HashMap(int x)中x的最佳值是多少，为什么？</h5><p>理想初始容量&#x3D;⌈预期元素数量 &#x2F; 加载因子⌉</p>
<p>给定预期的元素数量是 100 个，且默认加载因子为 0.75，计算如下：</p>
<p>理想初始容量&#x3D;⌈1000 &#x2F; 75⌉ &#x3D; 134</p>
<p>​		这意味着，为了存储 100 个元素而避免扩容，初始容量应设置为最接近 134 的2的幂次。<code>HashMap</code> 的设计通常建议使用2的幂次作为容量，因为它允许使用位掩码来计算索引，而不是更慢的取模操作。</p>
<p>​		而最接近134的2的幂次为128，但是这个值小于134，所以应该取值为256。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jelly12345/p/16726184.html">Hashmap的扩容机制及扩容后元素迁移·</a></p>
<h3 id="类加载相关"><a href="#类加载相关" class="headerlink" title="类加载相关"></a>类加载相关</h3><h4 id="java内部类为什么能访问外部类的私有方法"><a href="#java内部类为什么能访问外部类的私有方法" class="headerlink" title="java内部类为什么能访问外部类的私有方法"></a>java内部类为什么能访问外部类的私有方法</h4><p>内部类会持有外部类的引用</p>
<h4 id="Java创建对象的流程"><a href="#Java创建对象的流程" class="headerlink" title="Java创建对象的流程"></a>Java创建对象的流程</h4><ol>
<li><p><strong>声明引用变量</strong>：首先，声明一个引用变量来存储对象的引用。这个引用变量通常是对象所属的类的类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass myObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实例化对象</strong>：使用 <code>new</code> 关键字创建对象的实例。<code>new</code> 操作符负责在堆内存中为对象分配空间，并返回一个指向该空间的引用。</p>
<ul>
<li><strong>类加载</strong>：在创建对象之前，JVM 需要加载对象所属的类（如果该类还未被加载）。类加载过程包括加载、链接（验证、准备、解析）和初始化。</li>
<li><strong>分配内存</strong>：JVM 在堆内存中为新对象分配空间。分配的内存大小取决于对象的类定义中的实例变量。JVM 可能使用不同的内存分配策略，如指针碰撞（Bump the Pointer）或空闲列表（Free List）。</li>
</ul>
</li>
<li><p><strong>初始化对象</strong>：通过调用类的构造器（构造方法）来初始化对象。构造器的作用是初始化对象的状态（即其成员变量）。如果没有显式定义构造器，Java 会提供一个默认的无参构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyClass()</code> 是构造器，它负责初始化 <code>myObject</code> 对象。</p>
</li>
</ol>
<p>完成上述步骤后，对象创建并初始化完成，<code>new</code> 操作符返回一个引用，指向堆内存中的新对象。这个引用被赋值给声明的引用变量，用于后续操作对象。</p>
<h4 id="Classloader-类加载机制"><a href="#Classloader-类加载机制" class="headerlink" title="Classloader 类加载机制"></a>Classloader 类加载机制</h4><p>​		Java 的类加载机制是通过类加载器 (<code>ClassLoader</code>) 来实现的。类加载器负责将类的字节码文件加载到 JVM 中，并转换为 <code>Class</code> 对象。Java 类加载机制主要遵循三个原则：委托模型、可见性原则和单一性原则。</p>
<p><strong>类加载过程</strong></p>
<p>类加载过程主要包括以下几个步骤：</p>
<ol>
<li><strong>加载</strong>：类加载器从文件系统、网络或其他来源读取类的字节码文件，并将其转换为 JVM 中的 <code>Class</code> 对象。</li>
<li><strong>链接</strong>：<ul>
<li><strong>验证</strong>：确保加载的类符合 JVM 规范，没有安全问题。</li>
<li><strong>准备</strong>：为类的静态变量分配内存，并设置默认初始值。</li>
<li><strong>解析</strong>：将类、方法、变量等符号引用转换为直接引用。</li>
</ul>
</li>
<li><strong>初始化</strong>：执行类的静态初始化块和静态变量的初始化表达式。</li>
</ol>
<p><strong>类加载器的类型</strong></p>
<p>Java 中主要有以下几种类型的类加载器：</p>
<ol>
<li><strong>Bootstrap ClassLoader</strong>：启动类加载器，负责加载 JVM 的核心类库，如 <code>java.lang.*</code> 等。</li>
<li><strong>Extension ClassLoader</strong>：扩展类加载器，负责加载 <code>JAVA_HOME/lib/ext</code> 目录下的类库或通过系统属性 <code>java.ext.dirs</code> 指定的目录下的类库。</li>
<li><strong>System&#x2F;Application ClassLoader</strong>：系统（应用）类加载器，负责加载应用程序类路径（<code>CLASSPATH</code>）上的类库。</li>
<li><strong>User-defined ClassLoader</strong>：用户自定义类加载器，可以继承 <code>ClassLoader</code> 类来实现自定义的加载逻辑。</li>
</ol>
<p><strong>委托模型</strong></p>
<p>​		Java 类加载器采用委托模型（Delegation Model）来加载类。当一个类加载器需要加载一个类时，它首先会委托给其父类加载器尝试加载该类，如果父类加载器无法加载，则当前类加载器再尝试加载。</p>
<p>​		这种委托机制确保了类加载的安全性和一致性，例如，保证了 <code>java.lang.Object</code> 类始终由 Bootstrap ClassLoader 加载，从而避免了在 Java 程序中出现多个不同版本的 <code>Object</code> 类。</p>
<p><strong>可见性原则和单一性原则</strong></p>
<ul>
<li><strong>可见性原则</strong>：子类加载器可以访问父类加载器加载的类，但父类加载器不能访问子类加载器加载的类。</li>
<li><strong>单一性原则</strong>：由同一个类加载器加载的类在 JVM 中是唯一的，即使是同一个字节码文件，被不同的类加载器加载也会视为不同的类。</li>
</ul>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>​		类的加载流程：类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析 3 个部分统称为连接</p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h5><p>类加载过程的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>
</ol>
<p>​		虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p>
<p>​		<strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDQzNjUtMjQ4YjkyYjcyM2FlM2FhNi5wbmc?x-oss-process=image/format,png" alt="示意图"></p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h5><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>Class 文件可以由其他的语言生成，甚至可以我们自己编写，所以为了避免恶意波坏，必须要验证 Class 文件，这一阶段也是比较复杂的阶段，需要非常严谨的态度，内部太多大致可以分为 4 个部分。</p>
<p>1 文件格式验证</p>
<p>这个阶段的校验都是对字节流层面的验证，经过文件格式验证之后，就把字节流正确解析并存储在方法区之内，后面的校验都是基于方法区的存储结构进行的。</p>
<p>2 元数据验证</p>
<p>这个类是否有父类。这个类的父类是否继承了不允许被继承的类（被 final 修饰）。如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法。类中的字段，方法，是否与父类产生矛盾。</p>
<p>这个阶段的校验主要目的是对类的元数据信息进行语义检查，保证不存在不合符 Java 语言规范的元数据信息。</p>
<p>3 字节码验证</p>
<p>主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。另外就是校验类中的方法体，保证方法在运行时不会做出危害虚拟机安全的事件。</p>
<p>4 符号引用验证</p>
<p>通过全限定名是否能找到对应的类。方法或是字段的名称。符号引用中的类、字段、方法（看权限控制符）是否可以被当前类访问。（如果无法通过符号引用验证，那么可能会发生如下异常， java.lang.NoSuchFileError, java.lang.NoSuchMethodError。这个校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。）</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271119544.png" alt="示意图"></p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易混淆的概念需要强调一下。首先，这时候进行内存分配的只是类变量，而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值通常情况下是数据的零值。假设定义 public static int value &#x3D; 23，那么在准备阶段 value 的值是 0 ，而不是 23 。因为这时候还没有开始执行任何 Java 方法。把 value 赋值为 23 的 putstatic 指令是程序被编译后，存放在类构造器 <clinit>() 方法之中，所以把 value 赋值为 23 的动作将在初始化阶段才会执行。</p>
<ul>
<li><strong>内存分配的对象。</strong>Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。</li>
</ul>
<p>​			从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
<ul>
<li><p><strong>初始化的类型。</strong>在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271119557.png" alt="示意图"></p>
</li>
</ul>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h5><p>当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在<strong>常量池中的符号引用替换成直接其在内存中的直接引用。</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，<strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</strong></p>
<p>String s2 &#x3D; new String(“abc”)</p>
<p>String s3 &#x3D; new String(“abc”)</p>
<p>String s4 &#x3D; new String(“abc”).intern()</p>
<p>问 s1 &#x3D;&#x3D; s2 ,s1 &#x3D;&#x3D; s4, s2&#x3D;&#x3D;s3,s2 &#x3D;&#x3D; s4的结果</p>
<p>考虑一下 分别为 false true false false<br>s1是java栈中的变量，存储的是对字符串常量池中的“abc”的引用即地址，</p>
<p>s2，s3会先在java堆中创建一个对象，存储对字符串常量池中的“abc”的引用，然后在java栈中的引用变量指向这个对象，</p>
<p>s4 intern()方法直接返回“abc”常量的引用<br><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271119009.png" alt="image"></p>
<p><strong>三个阶段：</strong></p>
<p><strong>1.类&#x2F;接口的解析</strong><br>首先理解的概念：</p>
<p>1.符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
<p>2.直接引用：<br> 直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
<p>然后开始解析的原理理解：</p>
<p>要把一个类或者接口的符号引用解析为直接引用，需要以下三个步骤：</p>
<ol>
<li><p>如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给类加载器去加载这个类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载</p>
</li>
<li><p>如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java&#x2F;lang&#x2F;Integer”的形式，将会按照上面的规则进行加载数组元素类型，如果描述符如前面假设的形式，需要加载的元素类型就是java.lang.Integer ,接着由虚拟机将会生成一个代表此数组对象的直接引用</p>
</li>
<li><p>如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常</p>
</li>
</ol>
<p><strong>2.方法的解析</strong></p>
<ol>
<li><p>类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常</p>
</li>
<li><p>如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束</p>
</li>
<li><p>否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束</p>
</li>
<li><p>否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常</p>
</li>
<li><p>否则，查找失败，抛出java.lang.NoSuchMethodError异常</p>
</li>
</ol>
<p><strong>3.字段的解析</strong></p>
<ol>
<li><p>如果该字段符号引用就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束</p>
</li>
<li><p>否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束</p>
</li>
<li><p>否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束</p>
</li>
<li><p>否则，解析失败，抛出java.lang.NoSuchFieldError异常</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271119013.png" alt="示意图"></p>
</li>
</ol>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h5><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：</p>
<ul>
<li><p>实例化类的对象。</p>
</li>
<li><p>访问类的静态方法。</p>
</li>
<li><p>访问或修改类的静态字段（除了常量字段，这些字段在编译时已经被放入调用类的常量池中）。</p>
</li>
<li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时。</p>
</li>
<li><p>初始化一个类的子类（首先会初始化父类）。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271119584.png" alt="示意图"></p>
</li>
</ul>
<h5 id="初始化完成之后"><a href="#初始化完成之后" class="headerlink" title="初始化完成之后"></a>初始化完成之后</h5><ol>
<li><strong>实例化（Instantiation）</strong>：可以使用 <code>new</code> 关键字创建类的实例。这涉及到调用构造函数，为对象分配内存，并设置实例变量的初始值。</li>
<li><strong>使用（Usage）</strong>：可以访问和使用类的成员，包括实例方法、实例变量、静态方法和静态变量。</li>
<li><strong>继承处理</strong>：如果该类有子类，那么在子类被初始化时，会首先确保父类已经被初始化。</li>
<li><strong>卸载（Unloading）</strong>：在某些情况下，当类不再被需要时，Java 虚拟机（JVM）可以卸载类，释放占用的资源。但是在实际应用中，类的卸载比较少见，因为它需要满足一定的条件，比如该类的 <code>ClassLoader</code> 实例已经被回收等。</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271121039.png" alt="示意图"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403271121352.png" alt="示意图"></p>
<h5 id="缩减版"><a href="#缩减版" class="headerlink" title="缩减版"></a>缩减版</h5><ol>
<li><strong>加载（Loading）</strong>：这个阶段负责通过类的全限定名来查找并加载类的二进制数据，生成对应的 <code>Class</code> 对象。</li>
<li><strong>链接（Linking）</strong>：<ul>
<li><strong>验证（Verification）</strong>：确保被加载的类满足 Java 语言的安全约束。</li>
<li><strong>准备（Preparation）</strong>：为类的静态变量分配内存，并设置默认初始值。</li>
<li><strong>解析（Resolution）</strong>：将符号引用转换为直接引用。</li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong>：这个阶段负责执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。<code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的。类构造器是在类加载的初始化阶段执行的。</li>
</ol>
<h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><p>​		在虚拟机规范中是有严格规定的，虚拟机规范指明 有且只有 五种情况必须立即对类进行初始化（而这一过程自然发生在加载、验证、准备之后）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：<ul>
<li>使用new关键字实例化对象的时候；</li>
<li>读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；</li>
<li>调用一个类的静态方法的时候</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
</ol>
<h4 id="静态常量不会触发初始化"><a href="#静态常量不会触发初始化" class="headerlink" title="静态常量不会触发初始化"></a>静态常量不会触发初始化</h4><p>​		在 Java 中，访问静态内部类的静态常量不一定会触发类加载。这取决于常量是否是编译时常量（即编译器在编译时就能确定其值的常量）。</p>
<ul>
<li><p><strong>编译时常量</strong>：如果静态常量是编译时常量（例如，基本类型或字符串字面量的静态 final 常量），那么访问这个常量不会触发静态内部类的加载。这是因为编译时常量会在编译时被内联到使用它们的地方。</p>
</li>
<li><p><strong>非编译时常量</strong>：如果静态常量不是编译时常量（例如，它是一个复杂对象的引用或者其值在运行时计算得到），那么访问这个常量会触发静态内部类的加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="comment">// 编译时常量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非编译时常量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NON_CONSTANT</span> <span class="operator">=</span> getNumber();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不会触发 StaticInnerClass 的加载</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">constant</span> <span class="operator">=</span> OuterClass.StaticInnerClass.CONSTANT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会触发 StaticInnerClass 的加载</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nonConstant</span> <span class="operator">=</span> OuterClass.StaticInnerClass.NON_CONSTANT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="以下几种情况不会触发类的初始化"><a href="#以下几种情况不会触发类的初始化" class="headerlink" title="以下几种情况不会触发类的初始化"></a>以下几种情况不会触发类的初始化</h4><ul>
<li><strong>访问静态字段但不修改其值，且该字段是常量（final static）</strong>：<ul>
<li>如果一个静态字段是编译时常量（例如，<code>static final int x = 100;</code>），对这个字段的访问不会触发类的初始化。这是因为常量在编译时会被存入调用类的常量池中。</li>
</ul>
</li>
<li><strong>通过子类引用父类的静态字段</strong>：<ul>
<li>只会触发父类加载不会触发子类加载。</li>
</ul>
</li>
<li><strong>通过类字面量获取 <code>Class</code> 对象</strong>：<ul>
<li>使用类字面量（如 <code>Something.class</code>）来获取对应的 <code>Class</code> 对象不会触发该类的初始化。这仅涉及类的加载和链接，而不包括初始化。</li>
</ul>
</li>
<li><strong>使用 <code>instanceof</code> 关键字</strong>：<ul>
<li>使用 <code>instanceof</code> 来检查对象是否为特定类的实例，不会触发该类的初始化。因为 <code>instanceof</code> 检查并不需要类的具体实现细节，仅需要类型信息。</li>
</ul>
</li>
<li><strong>访问静态方法但不执行它们</strong>：<ul>
<li>仅仅获取对静态方法的引用（例如通过方法引用或者将其赋值给函数接口变量），而不实际执行这些方法，不会触发类的初始化。</li>
</ul>
</li>
<li><strong>创建数组类的实例</strong>：<ul>
<li>如果创建一个类的数组（如 <code>new MyClass[10]</code>），这不会触发 <code>MyClass</code> 类的初始化。数组的初始化仅涉及到为数组本身分配内存，并不需要类本身的初始化。</li>
</ul>
</li>
</ul>
<h4 id="父类子类加载顺序"><a href="#父类子类加载顺序" class="headerlink" title="父类子类加载顺序"></a>父类子类加载顺序</h4></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/kotlin%20flow/" title="Kotlin flow"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kotlin flow</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="多线程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多线程</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#SparseArrary%E5%92%8CHashMap%E6%AF%94%E8%BE%83"><span class="toc-number">1.</span> <span class="toc-text">SparseArrary和HashMap比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">ConcurrentHashMap基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%8E%9F%E7%90%86%EF%BC%8C%E5%AD%98%E5%8F%96%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94%EF%BC%8CHashTab%E3%80%81concurrentHashMap%EF%BC%8Cconcurrent%E5%8C%85%E9%87%8C%E6%9C%89%E5%95%A5"><span class="toc-number">3.</span> <span class="toc-text">HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84concurrent%E5%8C%85%E9%87%8C%E6%9C%89%E5%95%A5%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Java的concurrent包里有啥：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">ArrayList 如何保证线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList%E3%80%81HashMap%E3%80%81LinkedHashMap-%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">请说一说ArrayList、HashMap、LinkedHashMap ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%BF%98%E6%9C%89%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%BB%E9%80%89%E6%8B%A9%E5%91%A2%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">Java中提供了抽象类还有接口，开发中如何去选择呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.</span> <span class="toc-text">静态内部类是什么？和非静态内部类的区别是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E5%9C%A8%E4%BC%A0%E5%8F%82%E6%95%B0%E6%97%B6%E6%98%AF%E5%B0%86%E5%80%BC%E8%BF%9B%E8%A1%8C%E4%BC%A0%E9%80%92%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">Java中在传参数时是将值进行传递，还是传递引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals%E5%92%8C-%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">equals和&#x3D;&#x3D;进行比较的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxxx%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AAString%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">String s &#x3D; new String(“xxx”);创建了几个String对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9Ftry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E6%89%A7%E8%A1%8C%E4%B9%88"><span class="toc-number">12.</span> <span class="toc-text">finally中的代码一定会执行吗？try里有return，finally还执行么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E4%B8%AD%EF%BC%8C%E5%BC%82%E5%B8%B8Exception%E4%B8%8E%E9%94%99%E8%AF%AFError%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">Java异常机制中，异常Exception与错误Error区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97Parcelable-Serializable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">序列Parcelable,Serializable的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Intent%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">为什么Intent传递对象为什么需要序列化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kotlin%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">kotlin中进行序列化的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">17.</span> <span class="toc-text">Java中变量的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">18.</span> <span class="toc-text">怎么理解Java中的多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%8D%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B%E5%B0%B1%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%90%97"><span class="toc-number">19.</span> <span class="toc-text">什么是Java对象，不生成实例就不是对象吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84foreash%E5%92%8C%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">20.</span> <span class="toc-text">java中的foreash和普通for循环对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serialible%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">21.</span> <span class="toc-text">Serialible的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serialVersionUID%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">22.</span> <span class="toc-text">serialVersionUID的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-%E5%92%8Chashcode"><span class="toc-number">23.</span> <span class="toc-text">equals 和hashcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">24.</span> <span class="toc-text">Java中的深拷贝和浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="toc-number"></span> <span class="toc-text">泛型相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E5%91%A2%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">泛型是什么，泛型擦除呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E8%83%BD%E5%90%A6%E8%BD%AC%E4%B8%BAList"><span class="toc-number">2.</span> <span class="toc-text">List能否转为List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%ADsuper-%E5%92%8C-extends-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">Java的泛型中super 和 extends 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">注解是什么？有哪些使用场景？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3"><span class="toc-number"></span> <span class="toc-text">集合相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">LinkedHashMap的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E5%BA%95%E5%B1%82%E5%AD%98%E6%94%BE%E6%80%8E%E4%B9%88%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E5%90%97"><span class="toc-number">2.</span> <span class="toc-text">Set底层存放怎么数据，是有序的还是无序的，可以重复吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.</span> <span class="toc-text">ConcurrentHashMap如何保证线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap%E5%8E%BBget%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E5%8A%A0%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">ConcurrentHashMap去get元素的时候有加锁吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-finalize%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%89GC%E5%B0%B1%E4%BC%9A%E8%B0%83%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">Object finalize了解吗，只要有GC就会调用吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-notify%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%B9%B3%E6%97%B6%E5%86%99%E4%BB%A3%E7%A0%81%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">Object notify了解吗，自己平时写代码有用过吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">java反射的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">Java反射机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%80%A7%E8%83%BD%E8%80%97%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">反射性能耗在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-String-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">new String()内存优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E5%92%8CLinkendList%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">ArrayList和LinkendList区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">ArrayList扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">13.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">13.1.</span> <span class="toc-text">底层结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">13.2.</span> <span class="toc-text">转化红黑树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B62%E7%9A%84n%E6%AC%A1%E6%94%BE"><span class="toc-number">13.3.</span> <span class="toc-text">HashMap的长度为什么时2的n次放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E9%80%80%E5%8C%96"><span class="toc-number">13.4.</span> <span class="toc-text">红黑树退化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">13.5.</span> <span class="toc-text">HashMap 扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F"><span class="toc-number">13.6.</span> <span class="toc-text">最大容量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F"><span class="toc-number">13.7.</span> <span class="toc-text">初始容量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hash%E7%AE%97%E6%B3%95"><span class="toc-number">13.8.</span> <span class="toc-text">Hash算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CHashMap%E5%8F%AA%E8%A3%85%E8%BD%BD100%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8Cnew-HashMap-int-x-%E4%B8%ADx%E7%9A%84%E6%9C%80%E4%BD%B3%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.9.</span> <span class="toc-text">如果HashMap只装载100个元素，new HashMap(int x)中x的最佳值是多少，为什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%85%B3"><span class="toc-number"></span> <span class="toc-text">类加载相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">java内部类为什么能访问外部类的私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Java创建对象的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Classloader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">Classloader 类加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">4.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">4.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E"><span class="toc-number">4.6.</span> <span class="toc-text">初始化完成之后</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E5%87%8F%E7%89%88"><span class="toc-number">4.8.</span> <span class="toc-text">缩减版</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number">5.</span> <span class="toc-text">类初始化时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">静态常量不会触发初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8D%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">以下几种情况不会触发类的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">父类子类加载顺序</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>