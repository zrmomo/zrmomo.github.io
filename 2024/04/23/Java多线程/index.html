<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>多线程 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="多线程竞态竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。 通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。 以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下 1234load(shop.goodsCount , r1) &#x2F;&#x2F;指令1，将变量 shop.good">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="https://zrmomo.github.io/2024/04/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="多线程竞态竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。 通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。 以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下 1234load(shop.goodsCount , r1) &#x2F;&#x2F;指令1，将变量 shop.good">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-04-23T14:33:30.749Z">
<meta property="article:modified_time" content="2024-04-22T12:54:44.715Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/04/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-22 20:54:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T14:33:30.749Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-22T12:54:44.715Z" title="更新于 2024-04-22 20:54:44">2024-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。</p>
<p>通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。</p>
<p>以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load(shop.goodsCount , r1) //指令1，将变量 shop.goodsCount 的值从内存读到寄存器 r1</span><br><span class="line">increment(r1) //指令2，将寄存器 r1 的值加1</span><br><span class="line">store(shop.goodsCount , r1) //指令3，将寄存器 r1 的内容写入变量 shop.goodsCount 所对应的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程 A 在执行完指令1，开始执行或者正在执行指令2时，线程 B 可能已经执行完了指令3，这使得线程 A 当前持有的共享变量 shop.goodsCount 是旧值，当线程 A 执行完指令3时，这就使得线程 B 对共享变量的更新被覆盖了，即造成了更新丢失。</p>
<blockquote>
<p>竞态可以看做是由于访问（读取、更新）同一组共享变量的多个线程所执行的操作被相互交错而导致的。而上述代码中遇到的<strong>更新丢失</strong>和<strong>读到脏数据</strong>问题就是由于竞态的存在而导致的</p>
<p>需要注意的是，竞态的产生前提是涉及到了多个线程和共享变量。如果系统仅包含单个线程，或者不涉及共享变量，那么就不会产生竞态。对于局部变量（包括形式参数和方法体内定义的变量），由于不同的线程访问的是各自的那一份局部变量，<strong>因此局部变量的使用不会导致竞态</strong><br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6899452217528025095">https://juejin.cn/post/6899452217528025095</a></p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程安全问题概括来说表现为三个方面：<strong>原子性、可见性、有序性</strong></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>​		对于涉及共享变量访问的操作，若该操作从其执行线程以外的其它任意线程来看是不可分割的，那么该操作就是<strong>原子操作</strong>，相应的就称该操作具有<strong>原子性</strong>。</p>
<p>简单来说就是如果当前线程的一块逻辑，相对于其他线程来说要么是已经执行完了要么是还未执行，不会出现执行到一半的情况。</p>
<p>Java 中有两种方式来提供原子性：</p>
<ul>
<li>第一种是使用锁（Lock）。锁具有排他性，它能够保障共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，从而消除了竞态</li>
<li>第二种是利用处理器提供的 CAS 指令。CAS 指令实现原子性的方式与锁在本质上是相同的，差别在于锁通常是在软件这一层面实现的，而 CAS 是直接在硬件（处理器和内存）这一层次实现的，可以被看做“硬件锁”</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>​		在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的其它线程可能无法立即读取到这个更新的结果，甚至永远也无法读取到，这体现了多线程安全性问题中的一个：可见性。<strong>可见性是指一个线程对共享变量的更新结果对于其它读取相应共享变量的线程而言是否可见的问题。</strong>多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据，而这往往会导致我们的程序出现意想不到的问题。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640.jpg" alt="640"></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排一般分为以下三种：</p>
<ul>
<li><p><strong>编译器优化重排</strong></p>
<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下会出现执行<code>instance.doSomething();</code>时instance还未完成初始化的情况。</p>
<p>使用关键字new创建一个对象，大致分为一下过程：</p>
<ul>
<li>在栈空间创建引用地址</li>
<li>以类文件为模版在堆空间对象分配内存</li>
<li>成员变量初始化</li>
<li>使用构造函数初始化</li>
<li>将引用值赋值给左侧存储变量</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>​		并发的实现和是否拥有多个处理器无关，即使只有单个处理器也能够通过处理器<strong>时间片分配</strong>技术来实现并发。操作系统通过给每个线程分配一小段占有处理器使用权的时间来供其运行，然后在每个线程的运行时间结束后又快速切换到下一个线程来运行，多个线程以这种断断续续的方式来实现并发并完成各自的任务。</p>
<p>​		操作系统会分出一个个时间片，每个线程每次运行会分配到若干个时间片，时间片决定了一个线程可以连续占用处理器运行的时间长度，一般是只有几十毫秒，单处理器上的多线程就是通过这种<strong>时间片分配</strong>的方式来实现并发。当一个进程中的一个线程由于其时间片用完或者由于其自身的原因被迫或者主动暂停其运行时，另外一个线程（当前进程中的线程或者其它进程中的线程）就可以被线程调度器选中来占用处理器并开始运行。这种一个线程被剥夺处理器的使用权并暂停运行，另外一个线程被赋予处理器的使用权并开始运行的过程就称为线程上下文切换。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度是指操作系统为线程分配处理器使用权的过程。主要的调度方式有两种：</p>
<ul>
<li>协同式线程调度。在这种策略下，线程的执行时机由线程本身来决定，线程通过主动通知系统切换到另一个线程的方式来让出处理器的使用权。该策略的优点是实现简单，可以通过精准控制线程的执行顺序来避免线程安全性问题。缺点是可能会由于单个线程的代码缺陷问题导致无法切换到下一个线程，最终导致进程被阻塞</li>
<li>抢占式线程调度。这也是 Java 平台使用的线程调度策略。在这种策略下，由操作系统来决定当前处理器时间片交由哪个线程来使用，线程无法决定具体的运行时机和运行顺序。虽然我们可以通过 <code>Thread.yieid()</code> 方法来让出时间片，但是无法主动抢夺时间片，且虽然 Thread 类也提供了设置线程优先级的方法，但线程的具体执行顺序还是取决于其运行系统。该策略的优点是不会由于一个线程的问题导致整个进程被阻塞，且提高了并发性。缺点是实现较为复杂，且会带来多线程安全性问题。</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<p>在没有锁的情况下，当一个Thread创建后，start()调用后就会变成Runnable状态，然后当该线程抢到时间片后，就会Running状态（即开始运行），当执行完毕后便会结束Terminated，当然在运行中如果调用wait()后便会转为等待状态Waiting，然后一直到其他线程调用notify()或者notifyAll()才会被唤醒会，进入Runnable状态，然后抢时间片，重新Running。</p>
<p>如果涉及到锁的时候，当该线程抢到锁后，其他线程便会处于Blocked状态，等到该线程释放锁之后，那些阻塞的线程拿到锁后进入Runnable状态，然后Running：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>线程创建时的内存分配默认大小是1M，也就是1024k</p>
<h2 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h2><h3 id="synchronize使用"><a href="#synchronize使用" class="headerlink" title="synchronize使用"></a>synchronize使用</h3><p>先举个线程不安全的例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRunnable</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = LockRunnable()</span><br><span class="line">    <span class="keyword">val</span> thread1 = Thread(runnable)</span><br><span class="line">    <span class="keyword">val</span> thread2 = Thread(runnable)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread2.join()</span><br><span class="line">        thread1.join()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    println(LockRunnable.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待两个线程执行完成之后a的值理论上应该是2000，但是实际上值是不确定的。</p>
<p>使用synchronized来保证线程安全</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">           synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">               a++</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronize各自的锁对象"><a href="#synchronize各自的锁对象" class="headerlink" title="synchronize各自的锁对象"></a>synchronize各自的锁对象</h3><p>普通方法：锁对象是this，所谓的<strong>方法锁</strong>（本质上属于对象锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">	 System.out.println(<span class="string">&quot;Hello,everyone...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块(<strong>方法中</strong>)：锁对象是synchronized(obj)的对象，所谓的<strong>对象锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="type">boolean</span> isYou)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同步静态方法：锁对象是当前类的Class对象,即(XXX.class)，所谓的<strong>类锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Work hard...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized要理解为加锁，而不是锁。</strong></p>
<p>总结：</p>
<ol>
<li>当synchronized作用在实例方法时，监视器锁（monitor）便是对象实例（this）；</li>
<li>当synchronized作用在静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；</li>
<li>当synchronized作用在某一个对象实例时，监视器锁（monitor）便是括号括起来的对象实例；</li>
</ol>
<h3 id="synchronize的作用"><a href="#synchronize的作用" class="headerlink" title="synchronize的作用"></a>synchronize的作用</h3><p>synchronized 关键字主要用来解决的是多线程同步问题，其可以保证在被其修饰的代码任意时刻只有一个线程执行。</p>
<ol>
<li>若是对象锁，则每个对象都持有一把自己的独一无二的锁，且对象之间的锁互不影响 。若是类锁，所有该类的对象共用这把锁。</li>
<li>一个线程获取一把锁，<strong>没有得到锁的线程只能排队等待</strong>；</li>
<li>synchronized 是可重入锁，避免很多情况下的死锁发生。</li>
<li>synchronized 方法若发生异常，则JVM会自动释放锁。</li>
<li>锁对象不能为空，否则抛出NPE(NullPointerException)</li>
<li>同步本身是不具备继承性的：即父类的synchronized 方法，子类重写该方法,分情况讨论：没有synchonized修饰，则该子类方法不是线程同步的。(PS ：涉及同步继承性的问题要分情况)</li>
<li>synchronized本身修饰的范围越小越好。毕竟是同步阻塞。跑不快还占着超车道</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/14655412.html">多线程面试题（史上最全、持续更新、吐血推荐）</a></p>
<h3 id="synchronized内存特性"><a href="#synchronized内存特性" class="headerlink" title="synchronized内存特性"></a>synchronized内存特性</h3><p><strong>内存可见性</strong></p>
<ul>
<li><strong>获取锁（进入 <code>synchronized</code> 块）</strong>：当一个线程获取锁并进入 <code>synchronized</code> 块时，它会清空本地内存（如果有的话），然后从主内存中读取共享变量的最新值。</li>
<li><strong>释放锁（退出 <code>synchronized</code> 块）</strong>：当一个线程释放锁并退出 <code>synchronized</code> 块时，它会将在 <code>synchronized</code> 块中对共享变量的所有修改刷新（写回）到主内存中。</li>
</ul>
<p><strong>原子性</strong></p>
<ul>
<li><code>synchronized</code>通过<code>monitorenter</code>和<code>monitorexit</code> 指令来保证原子性</li>
</ul>
<h3 id="synchronize原理"><a href="#synchronize原理" class="headerlink" title="synchronize原理"></a>synchronize原理</h3><p>​		先看一个知识点，Java对象是在堆区里，它是由对象头、实例数据和对齐填充数据组成的，而一个对象的锁状态信息就是记录在对象头里的。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/2931590af3214062b83e36980a36a0b2.jpeg" alt="在这里插入图片描述"></p>
<p><code>mark word</code>用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32bit，64位系统上长度为64bit。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<p>根据对象锁状态的不同，系统位数所记载的信息也不同。比如无锁状态下前25位就代表hashcode。</p>
<p>来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="comment">//需要同步的代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同步块部分的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: 3: monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit						  // monitorexit指令退出同步块 getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit	</span><br></pre></td></tr></table></figure>

<p>进入到synchronized同步块中，需要通过monitorenter指令获取到对象的monitor（也通常称之为对象锁）后才能往下进行执行，在处理完对应的方法内部逻辑之后通过monitorexit指令来释放所持有的monitor，以供其他并发实体进行获取。</p>
<p>再具体的原理可以看重量级锁的释放锁部分</p>
<h3 id="synchronize锁状态"><a href="#synchronize锁状态" class="headerlink" title="synchronize锁状态"></a>synchronize锁状态</h3><table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody></table>
<p>一个对象其实有四种锁状态,级别由低到高:</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。</p>
<h4 id="偏向锁（JDK15被废弃）"><a href="#偏向锁（JDK15被废弃）" class="headerlink" title="偏向锁（JDK15被废弃）"></a>偏向锁（JDK15被废弃）</h4><p>​		偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在<strong>资源无竞争</strong>情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</p>
<p>​		当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。</p>
<p>​		<strong>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁记录的线程id指向当前线程。</p>
<p>​		<strong>也就是只有一个线程尝试获取锁。</strong></p>
<p>​		引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</p>
<p><strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>​		升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：<strong>一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</strong></p>
<p>​		当线程首次获取轻量级锁时，它会在自己的栈帧中创建一个锁记录，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>发现是无锁状态，线程会<strong>把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）</strong> ，然后<strong>通过CAS尝试将锁的Mark Word修改指向自己的Displaced Mark Word的指针</strong>（Displaced Mark Word与原mark word的内容一模一样，保存了HashCode，GC年龄等信息）。</p>
</li>
<li><p>发现处于轻量级锁状态</p>
</li>
</ol>
<ul>
<li>如果轻量级锁的mark word指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功。JVM 会递增锁记录中的计数器以跟踪重入的次数。当线程退出同步块时，计数器会递减，直到计数器为零时，锁被释放。</li>
<li>如果轻量级锁的mark word不是指向自己，锁膨胀，升级为「重量级锁」</li>
</ul>
<p><strong>CAS失败直接膨胀</strong></p>
<p><strong>总结</strong></p>
<p>​		在很多情况下，锁是由同一个线程多次获取，或者是不同线程但不同时刻获取的，这种情况下使用重量级锁（操作系统级别的锁）是一种资源浪费，因为它涉及到更多的系统调用和上下文切换。</p>
<p>​		轻量级锁的目的是在无竞争或轻度竞争的情况下提高同步的性能，通过避免与操作系统的交互来减少同步的开销。它是 JVM 对 <code>synchronized</code> 实现的优化之一，用于提高多线程程序的执行效率。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>由原来线程主动去抢锁对象变成由系统内核来决定最后锁对象分配给谁</p>
<p>从轻量级锁开始膨胀：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将mark word保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>monitor对象的结构：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<ul>
<li>Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构，采取的是头插法</li>
<li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</li>
<li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li>
<li>Owner：获得锁的线程称为Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
<p>ContentionList，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p>​		<strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>​		如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<p>​		JVM每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。</p>
<p>​		Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。</p>
<p>​		OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。</p>
<p>​		处于ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。</p>
<p>​		<strong>Synchronized是非公平锁，在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。</strong></p>
<h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a><strong>获取锁</strong></h5><blockquote>
<p>对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己</p>
</blockquote>
<p>当一个线程尝试获得重量级锁时</p>
<ul>
<li>首先尝试「<strong>自旋</strong>」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』</li>
<li>进入cxq后，陷入「<strong>死循环</strong>」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「<strong>死循环</strong>」</li>
</ul>
<p>CAS尝试修改ObjectMonitor的_owner字段，会有几种结果：<br> 1、锁没被其它线程占用，当前线程成功获取锁。<br> 2、锁被当前线程占用，当前线程重入该锁，获取锁成功。<br> 3、锁被LockRecord占用，而LockRecord又属于当前线程，属于重入，重入次数为1。<br> 4、以上条件都不满足，调用EnterI()函数。</p>
<h6 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h6><p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
<h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h6><p>​		所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p>
<h6 id="自旋逻辑：trySpin"><a href="#自旋逻辑：trySpin" class="headerlink" title="自旋逻辑：trySpin"></a><strong>自旋逻辑</strong>：trySpin</h6><p>首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：</p>
<p>开始自旋5000次（假设是第一次开始自旋，上限就为5000）</p>
<ul>
<li>成功，下次+100，下次可以最多自旋5100次</li>
<li>失败，下次- 200，下次可以最多自旋4800次，不会少于1000次</li>
</ul>
<h6 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a><strong>死循环</strong></h6><p>死循环主要是在「阻塞」和「自旋」之间切换</p>
<ul>
<li>park阻塞，注意不会移动到WaitSet中</li>
<li>unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞</li>
</ul>
<p>只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>monitor有个计数器recursions，起初为0，Monitorenter + 1，Monitorexit - 1，减为0会释放锁</p>
<ol>
<li>通过CAS的方式将Monitor结构的Owner修改为nullptr</li>
<li>根据QMode参数的不同，执行不同的逻辑</li>
</ol>
<p>因为QMode默认值为0，我们来看一下<strong>默认的逻辑</strong>：</p>
<ul>
<li>如果EntryList和cxq均为空：什么也不做</li>
<li>如果EntryList非空：就取EntryList首元素唤醒</li>
<li>如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；</li>
</ul>
<p>锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。</p>
<h3 id="重量级锁小结"><a href="#重量级锁小结" class="headerlink" title="重量级锁小结"></a>重量级锁小结</h3><ol>
<li>加锁过程是不断地尝试加锁，实在不行了才放入队列里，而且还是插入队列头的位置，最后才挂起自己。</li>
<li>想象一种场景：现在A线程持有锁，B线程在队列里等待，在A释放锁的时候，C线程刚好插进来获取锁，还未等B被A唤	  醒，C就获取了锁，B苦苦等待那么久还是没有获取锁。B线程不排队的行为造成了不公平竞争锁。</li>
<li>再想象另一种场景：还是A线程持有锁，B线程在队列里等待，此时C线程也要获取锁，因此要进入队列里排队，此处进入的是队列头，也就是在B的前面排着。当A释放锁后，唤醒队列里的头节点，也就是C线程。C线程插队的行为造成了不公平	竞争锁。<br>综合1、2、3点可知，<strong>因为有走后门(不排队)\、插队(插到队头)、重量级锁是不公平锁。</strong></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/be4ef14e123c">Java Synchronized 重量级锁原理深入剖析上(互斥篇)</a></p>
<h2 id="wait-notify底层原理"><a href="#wait-notify底层原理" class="headerlink" title="wait&#x2F;notify底层原理"></a>wait&#x2F;notify底层原理</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><ol>
<li>将当前线程包装成ObjectWaiter对象，放入WaitSet中，并调用park挂起</li>
<li>执行「释放锁」的逻辑。</li>
</ol>
<blockquote>
<p>只有notify方法有可能将线程从WaitSet拯救出来，处于WaitSet的线程永远是阻塞状态，不可能参与锁竞争</p>
</blockquote>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>从WaitSet中取出第一个线程，根据Policy的不同，将这个线程放入EntryList或者cxq队列中的起始或末尾位置</p>
<p>默认Policy为2，即：</p>
<ul>
<li>EntryList队列为空，将线程放入EntryList</li>
<li>EntryList队列非空，将线程放入cxq队列的头部位置（栈顶）；</li>
</ul>
<p>强调一下：notify方法只是将线程从WaitSet移动到EntryList或者cxq，不是直接让它开始自旋CAS。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量</li>
<li>E：旧值</li>
<li>N：新值</li>
</ul>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p>简单来说：</p>
<p>​		当我要修改当前变量的值时，如果它的值和旧值一样说明没有被修改过，就将新值赋值给当前变量。如果它的值和旧值不一样。说明已经被修改过就啥都不干了。</p>
<p>​		如果它再次获取当前的值然后进入新的比较操作的话这个重新尝试的过程被称为<strong>自旋</strong>。</p>
<p>​		Synchronized属于<strong>悲观锁</strong>，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于<strong>乐观锁</strong>，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>​		<strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>可见性</strong>：</p>
<p>​		第一项是保证此变量对所有线程的可见性，这里的“性”是指<strong>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<p>​		volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>禁止指令重排序优化</strong></p>
<p>​		普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2可能会比步骤1先执行</p>
<p>JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。如下所示：</p>
<blockquote>
<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>
<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>
</blockquote>
<p>​		当编译器遇到<code>volatile</code>变量的写操作时，会在写操作之前插入一个StoreStore屏障，防止写操作和之前的写操作发生重排；并在写操作之后插入一个StoreLoad屏障，防止写操作和之后的读写操作发生重排。</p>
<p>​		同样，当编译器遇到<code>volatile</code>变量的读操作时，会在读操作之后插入一个LoadLoad屏障，防止读操作和之后的读操作发生重排。</p>
<p>​		内存屏障（Memory Barrier），也称为内存栅栏，是一种用于处理器指令的同步机制，可以防止指令重排序。内存屏障主要分为以下四种类型： ，   </p>
<ol>
<li><strong>LoadLoad屏障</strong>：这种屏障确保在其前面的读操作（Load）不会被重排序到其后面的读操作之后。</li>
<li><strong>StoreStore屏障</strong>：这种屏障确保在其前面的写操作（Store）不会被重排序到其后面的写操作之后。</li>
<li><strong>LoadStore屏障</strong>：这种屏障确保在其前面的读操作不会被重排序到其后面的写操作之后。</li>
<li><strong>StoreLoad屏障</strong>：这种屏障确保在其前面的写操作不会被重排序到其后面的读操作之后。</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>) <span class="comment">// true设置为公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientThread</span>(name: String) : Thread(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(currentThread().name + <span class="string">&quot;开始尝试获取锁&quot;</span>)</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;成功获取锁&quot;</span>)</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;完成释放锁&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t1 = ClientThread(<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t2 = ClientThread(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t3 = ClientThread(<span class="string">&quot;线程3&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：					</span><br><span class="line">线程<span class="number">2</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">1</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">3</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">2</span>成功获取锁</span><br><span class="line">线程<span class="number">3</span>成功获取锁</span><br><span class="line">线程<span class="number">2</span>完成释放锁</span><br><span class="line">线程<span class="number">3</span>完成释放锁</span><br><span class="line">线程<span class="number">1</span>成功获取锁</span><br><span class="line">线程<span class="number">1</span>完成释放锁</span><br></pre></td></tr></table></figure>

<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ol>
<li><strong>公平锁</strong>：公平锁是指多个线程按照申请锁的顺序来获取锁。也就是说，锁会被授予等待时间最长的线程。这种方式可以防止资源饥饿，但是在锁的释放和获取之间会产生较大的开销，因此公平锁的整体吞吐量会比非公平锁小。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>类的构造函数可以接受一个布尔值，用来表示这个锁是否是公平的。</li>
<li><strong>非公平锁</strong>：非公平锁是指多个线程获取锁的顺序并不固定，也就是说，有可能新请求的线程比已经在等待的线程更早获取到锁。这种方式可能会导致某些线程等待时间过长甚至无限期等待，也就是所谓的饥饿现象。但是非公平锁的优点是吞吐量大，因为线程获取锁的速度通常比公平锁快，上下文切换次数也少。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>默认就是非公平锁。</li>
</ol>
<h3 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h3><p>​		可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>​		如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p>
<p><strong>核心原理：</strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，<strong>AQS中的队列是CLH变体的虚拟双向队列（FIFO）</strong>，AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1ebefeb23a184f2a9b515bf01eb430da%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p>
<p>AQS 中的 CLH 变体等待队列拥有以下特性</p>
<ol>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋（进入一个循环中，不断检查锁是否已经被释放，而不是进入睡眠状态）获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ol>
<h3 id="ReentrantLock与AQS的关联"><a href="#ReentrantLock与AQS的关联" class="headerlink" title="ReentrantLock与AQS的关联"></a>ReentrantLock与AQS的关联</h3><p>追一下ReentrantLock加锁时的源码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>)</span><br><span class="line">lock.lock()</span><br></pre></td></tr></table></figure>

<p>lock()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个sync是FairSync对象或NonfairSync对象，是sync抽象类的实现类。然后看一下Sync的定义，AbstractQueuedSynchronizer就是AQS。下面都以NonfairSync非公平锁为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> <span class="comment">// 公平锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Syn</span> <span class="comment">// 非公平锁</span></span><br></pre></td></tr></table></figure>

<p>sync.lock()的实现看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Sync</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个initialTryLock方法就是用来尝试获取锁的，这个方法尝试获取一个可重入的独占锁，如果成功则返回true，如果失败则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">initialTryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用CAS操作尝试将锁的状态从0（未锁定）改变为1（已锁定）</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁已经被某个线程持有，检查锁的所有者是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">        <span class="comment">// 如果锁的所有者是当前线程，说明这是一个重入操作</span></span><br><span class="line">        <span class="comment">// 获取锁的当前状态并加1，表示锁被重入了一次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查锁的状态是否超过了int的最大值，如果超过，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 将锁的状态设置为新的值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁的所有者不是当前线程，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setState(c)就是设置之前说的那个表示同步状态的state值，如果获取锁成功将锁的所有者设置为当前线程，获取失败的话返回false开始执行 acquire(1);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># AbstractQueuedSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            acquire(<span class="literal">null</span>, arg, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"># NonfairSync</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查锁的状态是否为0（未被锁定）</span></span><br><span class="line">    <span class="comment">// 如果锁的状态为0，使用CAS操作尝试将锁的状态从0改变为传入的acquires值</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁的状态不为0或者CAS操作失败，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会再次重试获取锁，如果获取失败的话就执行acquire方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">acquire</span><span class="params">(Node node, <span class="type">int</span> arg, <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> interruptible, <span class="type">boolean</span> timed, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些变量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">spins</span> <span class="operator">=</span> <span class="number">0</span>, postSpins = <span class="number">0</span>; <span class="comment">// 用于控制&quot;自旋&quot;的变量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, first = <span class="literal">false</span>; <span class="comment">// interrupted记录线程是否被中断，first记录node是否是队列的第一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// pred记录node的前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个无限循环，直到成功获取锁或者线程被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">                Thread.onSpinWait();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">                <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">                cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点是null，则根据是否共享锁创建相应类型的节点</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果CAS失败，回滚操作</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">            Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">            node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束，调用cancelAcquire方法取消获取锁，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个队列就是上面说的CLH变体的虚拟双向队列，acquire方法开启了一个死循环直到当前线程成功获取锁或者线程被中断才终止循环。</p>
<p>分析for内的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line"><span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(first = (head == pred))) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">    <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cleanQueue();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">        Thread.onSpinWait();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码首先检查当前节点是否是第一个节点，如果不是，并且当前节点有前驱节点，那么就检查前驱节点的状态。如果前驱节点的状态小于0，那么说明前驱节点已经被取消，此时需要调用cleanQueue()方法清理队列，然后继续下一轮循环。</p>
<p>如果前驱节点没有前驱，那么就调用<code>Thread.onSpinWait()</code>方法让出CPU，并继续下一轮循环。<code>Thread.onSpinWait()</code>是Java 9引入的一个新方法，它可以用来提示JVM当前线程正在进行自旋操作，这样JVM可以采取一些优化措施，如减少线程的调度优先级，以避免占用过多的CPU资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line"><span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> acquired;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (shared)</span><br><span class="line">            acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquired = tryAcquire(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">        cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是尝试获取锁。如果<code>node</code>是第一个节点或者没有前驱节点，那么就会尝试获取锁。</p>
<p>在这段代码中，如果锁是共享锁，那么就调用<code>tryAcquireShared(arg)</code>方法尝试获取锁，如果成功获取锁（返回值大于等于0），那么<code>acquired</code>就会被设置为<code>true</code>。如果锁是独占锁，那么就调用<code>tryAcquire(arg)</code>方法尝试获取锁，如果成功获取锁，那么<code>acquired</code>就会被设置为<code>true</code>。</p>
<p>如果在尝试获取锁的过程中发生异常，那么就调用<code>cancelAcquire(node, interrupted, false)</code>方法取消获取，并抛出异常。</p>
<p>这段代码是一个典型的锁获取过程，它使用了Java的并发编程技术来实现线程安全的锁获取。</p>
<p>获取锁之后会进行一个清理的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是在成功获取锁之后进行一系列的操作。如果成功获取了锁（<code>acquired</code>为<code>true</code>），并且当前节点是第一个节点（<code>first</code>为<code>true</code>），那么就会进行一些清理和设置操作。</p>
<p>在代码中，如果成功获取了锁，并且当前节点是第一个节点，那么就会将当前节点的<code>prev</code>属性设置为<code>null</code>，将<code>head</code>设置为当前节点，将前驱节点的<code>next</code>属性设置为<code>null</code>，并将当前节点的<code>waiter</code>属性设置为<code>null</code>。这些操作都是为了清理和设置节点的状态。</p>
<p>接下来，如果获取的是共享锁，那么就会调用<code>signalNextIfShared(node)</code>方法通知下一个等待的节点。如果在获取锁的过程中线程被中断，那么就会调用<code>current.interrupt()</code>方法来中断当前线程。</p>
<p>最后，如果成功获取了锁，那么就返回1，表示成功获取了锁。</p>
<p>这段代码是一个典型的并发编程的代码片段，它使用了Java的并发编程技术来实现线程安全的锁获取和释放。</p>
<p>根据原来的代码流程来看，第一次进来node会是null会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br></pre></td></tr></table></figure>

<p>这个shared默认是false，会给node赋值一个ExclusiveNode实例，然后开始下一个循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExclusiveNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123; &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">volatile</span> Node prev;       <span class="comment">// initially attached via casTail</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;       <span class="comment">// visibly nonnull when signallable</span></span><br><span class="line">      Thread waiter;            <span class="comment">// visibly nonnull when enqueued</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">      。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">    node.waiter = current;  <span class="comment">// 将当前线程设置为节点的等待线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取队列的尾节点</span></span><br><span class="line">    node.setPrevRelaxed(t);  <span class="comment">// 将尾节点设置为当前节点的前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        tryInitializeHead();  <span class="comment">// 如果尾节点为null，尝试初始化头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node)) </span><br><span class="line">        node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果使用CAS设置尾节点失败，回滚操作，将当前节点的前驱设置为null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首相将节点的waiter属性设置为当前线程，然后判断tail，这个tail是队列的尾节点，如果是第一次初始化队列的话会为null，然后就走了tryInitializeHead方法，这个方法内部会通过CAS的方式给tail初始化。</p>
<p><code>casTail(t, node)</code>是一个CAS操作，它尝试将队列的尾节点从<code>t</code>更新为<code>node</code>。如果在这个过程中，其他线程已经修改了尾节点，那么CAS操作会失败，这时就需要进行回滚操作，将当前节点的前驱设置为<code>null</code>。如果CAS操作成功，那么就将当前节点设置为新的尾节点。</p>
<p>看下下面部分的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">    --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">    Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">    node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">long</span> nanos;</span><br><span class="line">    spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">    <span class="keyword">if</span> (!timed)</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">        LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">    node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">    <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，如果当前节点是第一个节点并且<code>spins</code>不为0，那么就减少<code>spins</code>的值，并调用<code>Thread.onSpinWait()</code>方法进行自旋等待，这是一种轻量级的等待方式，相比于阻塞等待，它可以在等待时间较短的情况下减少线程切换的开销。如果当前节点的状态是0，那么就将其状态设置为等待状态。如果当前节点的状态不是0，那么就会更新<code>spins</code>和<code>postSpins</code>的值，并根据是否是定时等待来决定是调用<code>LockSupport.park(this)</code>方法使线程进入阻塞等待状态，还是调用<code>LockSupport.parkNanos(this, nanos)</code>方法使线程进入定时阻塞等待状态。如果等待时间已经过去，那么就跳出循环。然后，清除节点状态。最后，如果线程被中断并且是可中断的，那么就跳出循环。</p>
<p>上面就是一个加锁的逻辑</p>
<p>解锁的话从<strong>unlock</strong>方法入手探索，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#AbstractOwnableSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            signalNext(head);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> #Sync</span><br><span class="line"> <span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// 获取当前锁的状态并减少指定的数量</span></span><br><span class="line">    <span class="comment">// 检查当前线程是否是锁的所有者，如果不是，抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> (c == <span class="number">0</span>);  <span class="comment">// 检查是否可以释放锁（锁的状态是否为0）</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">// 如果可以释放锁，将锁的所有者设置为null</span></span><br><span class="line">    setState(c);  <span class="comment">// 更新锁的状态</span></span><br><span class="line">    <span class="keyword">return</span> free;  <span class="comment">// 返回是否成功释放了锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果tryRelease失败的话就执行signalNext方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 检查头节点是否存在，以及头节点的下一个节点是否存在并且其状态不为0</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);  <span class="comment">// 清除下一个节点的等待状态</span></span><br><span class="line">        LockSupport.unpark(s.waiter);  <span class="comment">// 唤醒下一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是唤醒下一个在等待锁的线程。它首先检查头节点（通常是当前占用锁的线程）是否存在，以及头节点的下一个节点（通常是等待锁的下一个线程）是否存在并且其状态不为0。如果满足这些条件，那么它将清除下一个节点的等待状态，并使用<code>LockSupport.unpark(s.waiter)</code>方法唤醒下一个等待的线程。</p>
<h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><p>原理弄清楚了，顺便总结了几点Synchronized和ReentrantLock的区别：</p>
<ol>
<li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>ReentrantLock#isLocked</code>判断；</li>
<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>Synchronized是不可以被中断的，而<code>ReentrantLock#lockInterruptibly</code>方法是可以被中断的；</li>
<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说），而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>锁实现机制</td>
<td>对象头监视器模式</td>
<td>依赖 AQS</td>
</tr>
<tr>
<td>灵活性</td>
<td>不灵活</td>
<td>支持响应中断、超时、尝试获取锁</td>
</tr>
<tr>
<td>释放锁形式</td>
<td>自动释放锁</td>
<td>显示调用 unlock()</td>
</tr>
<tr>
<td>支持锁类型</td>
<td>非公平锁</td>
<td>公平锁 &amp; 非公平锁</td>
</tr>
<tr>
<td>条件队列</td>
<td>单条件队列</td>
<td>多个条件队列</td>
</tr>
<tr>
<td>是否支持可重入</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><p>​		Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子&#x2F;原子操作特征的类。<strong>可以在不涉及锁的情况下提供线程安全的操作，从而提高性能。</strong></p>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
</ul>
<h3 id="AtomicInteger线程安全源码分析"><a href="#AtomicInteger线程安全源码分析" class="headerlink" title="AtomicInteger线程安全源码分析"></a>AtomicInteger线程安全源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		<code>AtomicInteger</code> 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>​		CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。<strong>UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。</strong>另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<p>参考连接：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23">https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA">https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA">https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501</a></p>
<h2 id="多线程代码实操题"><a href="#多线程代码实操题" class="headerlink" title="多线程代码实操题"></a>多线程代码实操题</h2><h4 id="三个线程循环打印ABC-100次"><a href="#三个线程循环打印ABC-100次" class="headerlink" title="三个线程循环打印ABC 100次"></a>三个线程循环打印ABC 100次</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>注意点：需要使用notifyAll来唤醒所有线程，然后根据while (total % 3 !&#x3D; i)来判断那个线程应该执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = Object()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 计数打印的轮数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> total = <span class="number">0</span> <span class="comment">// 总打印字符数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(s: <span class="type">String</span>, i: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (total % <span class="number">3</span> != i) &#123;</span><br><span class="line">                    lock.wait()</span><br><span class="line">                &#125;</span><br><span class="line">                println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: <span class="variable">$s</span>  total:<span class="variable">$total</span>  count:<span class="variable">$count</span>&quot;</span>)</span><br><span class="line">                total++</span><br><span class="line">                lock.notifyAll() <span class="comment">// 改为notifyAll确保所有线程被唤醒</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当total为3的倍数且当前打印索引为2（即完成一轮&quot;C&quot;的打印）时，计数一个完整轮次</span></span><br><span class="line">                <span class="keyword">if</span> (total % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i == <span class="number">2</span>) &#123;</span><br><span class="line">                    count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> main = Test()</span><br><span class="line">    thread(name = <span class="string">&quot;Thread-A&quot;</span>) &#123; main.print(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>) &#125; <span class="comment">// 更正为 0, 并添加线程名</span></span><br><span class="line">    thread(name = <span class="string">&quot;Thread-B&quot;</span>) &#123; main.print(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>) &#125; <span class="comment">// 更正为 1, 并添加线程名</span></span><br><span class="line">    thread(name = <span class="string">&quot;Thread-C&quot;</span>) &#123; main.print(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>) &#125; <span class="comment">// 更正为 2, 并添加线程名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>​		思想和上面相同使用AtomicInteger来标志总量，同时通过if (total.get() % 3 &#x3D;&#x3D; check) 来判断是否符合状态。这里使用的是if因为没有涉及到线程同步操作。</p>
<p>使用 <code>while</code> 的情况：</p>
<ul>
<li>使用 <code>while</code> 来循环检查条件适用于需要在条件成立前持续等待的情况。在同步控制中尤为重要，因为在多线程环境中，即使你的线程被唤醒（或轮询到一个看似正确的时机），条件可能由于其他线程的干预而不再适用。</li>
<li><code>while</code> 循环可以确保即使在多个线程竞争或条件由于某些外部变化而变得不再有效的情况下，线程会继续等待直到条件确实成立。这被称为“防止虚假唤醒”，在使用 <code>wait()</code>&#x2F;<code>notify()</code> 时尤为重要。</li>
</ul>
<p>​		总结就是在同步代码块中需要使用while循环不断的检查条件是否成立。但是如果使用原子变量的话没有设计到多线程同步操作所以直接使用if判断就行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> total = AtomicInteger(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(s: <span class="type">String</span>, check: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (total.<span class="keyword">get</span>() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (total.<span class="keyword">get</span>() % <span class="number">3</span> == check) &#123;</span><br><span class="line">                println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread().name&#125;</span>: <span class="variable">$s</span>   total: <span class="variable">$total</span>&quot;</span>)</span><br><span class="line">                total.incrementAndGet() <span class="comment">// 增加总数，向前推动状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> main = Test()</span><br><span class="line">    <span class="comment">// 在每个线程开启任务的时候就指定每个线程的状态和要打印的内容</span></span><br><span class="line">    thread(name = <span class="string">&quot;Thread-A&quot;</span>) &#123; main.print(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>) &#125;</span><br><span class="line">    thread(name = <span class="string">&quot;Thread-B&quot;</span>) &#123; main.print(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>) &#125;</span><br><span class="line">    thread(name = <span class="string">&quot;Thread-C&quot;</span>) &#123; main.print(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="假如只有一个cpu，单核，多线程还有用吗-？"><a href="#假如只有一个cpu，单核，多线程还有用吗-？" class="headerlink" title="假如只有一个cpu，单核，多线程还有用吗 ？"></a>假如只有一个cpu，单核，多线程还有用吗 ？</h4><p>CPU的执行速度要远大于IO的过程，因此在大多数情况下增加一些复杂的CPU计算都比增加一次IO要快。单核CPU可以通过给每个线程分配CPU时间片（时间单元）来实现多线程机制。由于CPU频率很高，故时间单元非常短。所以单核也可以实现多线程机制。</p>
<h4 id="sychronied修饰普通方法和静态方法的区别？什么是可见性"><a href="#sychronied修饰普通方法和静态方法的区别？什么是可见性" class="headerlink" title="sychronied修饰普通方法和静态方法的区别？什么是可见性?"></a>sychronied修饰普通方法和静态方法的区别？什么是可见性?</h4><p>sychronied是Java中并发编程的重要关键字之一。在并发编程中synchronized一直是解决线程安全问<br>题，它可以保证原子性，可见性，以及有序性。</p>
<ul>
<li>原子性：原子是构成物质的基本单位，所以原子的意思代表着—“不可分”。由不可分可知，具有原<br>子性的操作也就是拒绝线程调度器中断。</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到，称为可见性。</li>
<li>有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序中语句的顺序，但是不会影响最终的结果。有序性经典的例子就是利用DCL双重检查创建单例对象。</li>
</ul>
<p>synchronized可以修饰方法，也能够使用 synchronized(obj){} 定义同步代码块。修饰方法：</p>
<ol>
<li>实例方法也就是普通方法，作用于当前实例加锁，进入方法前需要获取当前实例的锁;</li>
<li>静态方法，作用于当前类对象加锁，进入方法前需要获取当前类对象的锁;修饰代码块，指定加锁对象，对给定对象加锁，进入代码块前要获得给定对象的锁。</li>
</ol>
<h4 id="Synchronized在JDK1-6之后做了哪些优化"><a href="#Synchronized在JDK1-6之后做了哪些优化" class="headerlink" title="Synchronized在JDK1.6之后做了哪些优化"></a>Synchronized在JDK1.6之后做了哪些优化</h4><p>jdk1.6以后为了减少获得锁和释放锁带来的性能消耗，对synchronized锁进行了优化，引入了偏向锁、轻量级锁、重量级锁;</p>
<p><strong>Java对象头</strong></p>
<p>对象在虚拟机内存中的布局分为三块区域：对象头、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里。对象头由：存储对象自身的运行时数据的Mark Word 32位系统中4 + 指向类的指针 kClass pointer ,如果是数组对象还会有数组长度 Array Length。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<ul>
<li><p><strong>「偏向锁」</strong>：</p>
<p>当一个线程第一个访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。<strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
</li>
<li><p><strong>「轻量级锁」：</strong></p>
</li>
</ul>
<p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<ul>
<li><strong>「重量级锁」：</strong>这时候的主要操作就在monitor了</li>
</ul>
<p>膨胀过程：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将Contention List中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h4 id="CAS无锁编程的原理"><a href="#CAS无锁编程的原理" class="headerlink" title="CAS无锁编程的原理"></a>CAS无锁编程的原理</h4><p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<ol>
<li><p>在内存地址V当中，存储着值为10的变量</p>
</li>
<li><p>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11。</p>
</li>
<li><p>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
</li>
<li><p>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交<br>失败。因为线程2已经将内存地址V的变量值修改为了11</p>
</li>
<li><p>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A&#x3D;11，B&#x3D;12。<br>这个重新尝试的过程被称为自旋。</p>
</li>
<li><p>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相<br>等的。</p>
</li>
<li><p>线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
</li>
</ol>
<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>ABA问题：CAS 设计机制就是获取某两个时刻(初始预期值和当前内存值)变量值，并进行比较更新，所以说如果<strong>在获取初始预期值和当前内存值这段时间间隔内，变量值由 A 变为 B 再变为 A，那么对于 CAS 来说是不可感知的</strong>，但实际上变量已经发生了变化；解决办法是在每次获取时加版本号，并且每次更新对版本号 +1，这样当发生 ABA 问题时通过版本号可以得知变量被改动过。</p>
<h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>是一个用于构建锁和同步器的框架。它能降低构建锁和同步器的工作量，还可以避免处理多个位置上发生的竞争问题。在基于AQS构建的同步器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS支持独占锁（exclusive）和共享锁(share)两种模式。</p>
<ol>
<li>独占锁：只能被一个线程获取到(Reentrantlock)。</li>
<li>共享锁：可以被多个线程同时获取(CountDownLatch,ReadWriteLock)。</li>
</ol>
<blockquote>
<p>​	无论是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取。state是一个原子的int变量，用来表示锁状态、资源数等</p>
</blockquote>
<p><strong>公平锁的实现</strong></p>
<p>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，<strong>如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</strong>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大</p>
<p><strong>非公平锁的实现</strong></p>
<p><strong>直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h4 id="Synchronized的原理以及与ReentrantLock的区别。"><a href="#Synchronized的原理以及与ReentrantLock的区别。" class="headerlink" title="Synchronized的原理以及与ReentrantLock的区别。"></a>Synchronized的原理以及与ReentrantLock的区别。</h4><p>Synchronized <strong>的原理</strong></p>
<p><code>synchronized</code> 是 Java 中的一个关键字，用于实现线程同步，保证多线线程访问共享资源时的线程安全。<code>synchronized</code> 可以用来修饰方法或代码块。</p>
<ul>
<li><strong>修饰方法</strong>：当一个线程访问某个对象的 synchronized 方法时，该线程会自动获取该对象的锁，其他线程如果也想访问这个对象的 synchronized 方法，就必须等待当前线程释放锁后才能继续执行。</li>
<li><strong>修饰代码块</strong>：可以指定加锁的对象，只有获取到指定对象的锁的线程才能执行这个代码块。</li>
</ul>
<p><code>synchronized</code> 的底层实现主要依赖于 JVM 中的 Monitor（监视器锁）。当一个线程进入 synchronized 修饰的方法或代码块时，它会自动获取 Monitor 的所有权，退出时自动释放 Monitor 的所有权。如果其他线程也想获取这个 Monitor 的所有权，就必须等待当前线程释放。</p>
<p><strong>ReentrantLock</strong></p>
<p><code>ReentrantLock</code> 是 Java 并发包 <code>java.util.concurrent.locks</code> 中的一个类，提供了比 <code>synchronized</code> 更加灵活的锁定机制。<code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，并提供了丰富的功能，如可中断的锁获取、公平锁、锁绑定多个条件等。</p>
<p><strong>Synchronized 与 ReentrantLock 的区别</strong></p>
<ol>
<li><strong>锁的实现方式</strong>：<code>synchronized</code> 是基于 JVM 实现的内置锁机制，而 <code>ReentrantLock</code> 是基于 Java 代码实现的。</li>
<li><strong>锁的获取和释放</strong>：<code>synchronized</code> 自动管理锁的获取和释放，而 <code>ReentrantLock</code> 需要手动获取和释放锁，通常使用 <code>try-finally</code> 语句块确保锁的释放。</li>
<li><strong>等待可中断</strong>：<code>ReentrantLock</code> 提供了一个可以响应中断的锁获取方法（<code>lockInterruptibly()</code>），而 <code>synchronized</code> 不具备这一特性。</li>
<li><strong>公平性</strong>：<code>ReentrantLock</code> 可以设置为公平锁，即按照线程请求锁的顺序来获取锁，而 <code>synchronized</code> 则不保证公平性。</li>
<li><strong>条件变量支持</strong>：<code>ReentrantLock</code> 提供了 <code>Condition</code> 类，支持更加灵活的线程间协调，相当于 Object 类的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法的高级版本。</li>
</ol>
<h4 id="volatile关键字干了什么？（什么叫指令重排）"><a href="#volatile关键字干了什么？（什么叫指令重排）" class="headerlink" title="volatile关键字干了什么？（什么叫指令重排）"></a>volatile关键字干了什么？（什么叫指令重排）</h4><p>volatile是java提供的可以声明在成员属性前的一个关键字。在声明中包含此关键字的作用有：<br><strong>保证内存可见性</strong><br>可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。</p>
<p><strong>禁止指令重排</strong></p>
<p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。</p>
<p>volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，<strong>指令重排序时不能把后面的指令重排序到内存屏障之前，也不能把前面的指令重排序到内存屏障之后。</strong>这样确保了在一个线程修改了 <code>volatile</code> 变量的值后，其他线程能够看到这个修改。</p>
<p><strong>禁止指令重排的原理</strong><br>volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JVM内存屏障插入策略：<br>在每个volatile写操作的前面插入一个StoreStore屏障；<br>在每个volatile写操作的后面插入一个StoreLoad屏障；<br>在每个volatile读操作的后面插入一个LoadLoad屏障；<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<p>代码使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instance&#x3D; new Singleton()并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br><span class="line">instance =memory; <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2。所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">instance =memory; <span class="comment">//3：instance指向刚分配的内存地址，此时对象还未初始化</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br></pre></td></tr></table></figure>

<p>指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</p>
<p>优化后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile-能否保证线程安全？在DCL上的作用是什么？"><a href="#volatile-能否保证线程安全？在DCL上的作用是什么？" class="headerlink" title="volatile 能否保证线程安全？在DCL上的作用是什么？"></a>volatile 能否保证线程安全？在DCL上的作用是什么？</h4><p>volatile无法保证线程安全，只能保证变量的可见性，并不能保证变量操作的原子性。原子性指的是一个或者多个操作在 CPU 执行的过程中不被中断的特性。</p>
<p>因为volatile不能保证变量操作的原子性，所以试图通过volatile来保证线程安全性是不靠谱的。<br>volatile在DCL上的作用是防止对象发生指令重排而引起的异常问题。</p>
<h4 id="volatile和synchronize有什么区别？"><a href="#volatile和synchronize有什么区别？" class="headerlink" title="volatile和synchronize有什么区别？"></a>volatile和synchronize有什么区别？</h4><ul>
<li>volatile 只能作用于变量，synchronized 可以作用于变量、方法、对象。</li>
<li>volatile 只保证了可见性和有序性，无法保证原子性，synchronized 可以保证线程间的有序性（个人猜测是无法保证线程内的有序性，即线程内的代码可能被 CPU 指令重排序）、原子性和可见性。</li>
<li>volatile 线程不阻塞，synchronized 线程阻塞。</li>
<li>volatile 本质是告诉 jvm 当前变量在寄存器中的值是不安全的需要从内存中读取；sychronized 则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞。</li>
<li>volatile标记的变量不会被编译器优化， synchronized标记的变量可以被编译器优化</li>
</ul>
<h4 id="死锁的场景和解决方案"><a href="#死锁的场景和解决方案" class="headerlink" title="死锁的场景和解决方案"></a>死锁的场景和解决方案</h4><p><strong>死锁的定义</strong><br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<p>死锁的发生必须具备以下四个必要条件。</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<h4 id="锁分哪几类？"><a href="#锁分哪几类？" class="headerlink" title="锁分哪几类？"></a>锁分哪几类？</h4><ul>
<li>乐观锁&#x2F;悲观锁</li>
</ul>
<blockquote>
<p>乐观锁：获取数据时认为不会被其他线程修改，所以不会上锁，但是在更新的时候会判断其他线程是否修改此数据，如果被其他线程修改，则会发生自旋。<br>悲观锁：总是假设最坏的情况，获取数据时都认为其他线程会修改，因此在获取数据时都会上锁，<br>这样保证其他线程需要等待获取锁的线程处理完成并且释放锁</p>
</blockquote>
<ul>
<li>独享锁&#x2F;共享锁</li>
</ul>
<blockquote>
<p>独享锁是指该锁一次只能被一个线程所持有。</p>
<p>共享锁是指该锁可被多个线程所持有。</p>
</blockquote>
<ul>
<li>互斥锁&#x2F;读写锁</li>
</ul>
<blockquote>
<p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</p>
<p>互斥锁在Java中的具体实现就是ReentrantLock。<br>读写锁在Java中的具体实现就是ReadWriteLock。</p>
</blockquote>
<ul>
<li>可重入锁</li>
</ul>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。synchronized与ReetrantLock都是可重入锁。可重入锁的一个好处就是可以在一定程度避免死锁。</p>
<p>就是同一个线程内一个加锁方法内部调用另一个加锁方法，内层方法会自动获取锁。</p>
<ul>
<li>公平锁&#x2F;非公平锁</li>
</ul>
<blockquote>
<p>公平锁是指多个线程按照申请锁的顺序获取锁，非公平锁则是指多个线程获取锁的顺序并不是按照申请<br>锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</p>
</blockquote>
<ul>
<li>分段锁</li>
</ul>
<blockquote>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁。</p>
</blockquote>
<ul>
<li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</li>
</ul>
<blockquote>
<p>这三种锁是指锁的状态，偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。<br>降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通<br>过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定<br>次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入<br>阻塞，性能降低。</p>
</blockquote>
<ul>
<li>自旋锁</li>
</ul>
<blockquote>
<p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好<br>处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
</blockquote>
<h4 id="Java多线程对同一个对象进行操作"><a href="#Java多线程对同一个对象进行操作" class="headerlink" title="Java多线程对同一个对象进行操作"></a>Java多线程对同一个对象进行操作</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int tickets = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sellTicket()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟卖票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> synchronized boolean sellTicket() &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tickets--;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出一张票，剩余票数：&quot;</span> + tickets);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 票已售罄！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSelling</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        TicketSeller ticketSeller = new TicketSeller();</span><br><span class="line">        Thread w1 = new Thread(ticketSeller, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread w2 = new Thread(ticketSeller, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread w3 = new Thread(ticketSeller, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？"><a href="#线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？" class="headerlink" title="线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？"></a>线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？</h4><p>不能 会抛异常 start后由创建进入就绪状态，不可逆</p>
<h4 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h4><p>守护线程，也叫Daemon线程，它是一种支持型、服务型线程，主要被用作程序中后台调度以及支持性工作，跟上层业务逻辑基本不挂钩。Java中垃圾回收线程就是一个典型的Daemon线程。</p>
<p><strong>使用标志位退出线程</strong><br>正常情况下线程的run方法执行完之后就会正常退出，如果想要中断执行的话可以在线程执行run方法过程中，通过一个自定义变量来决定是否还需要退出线程，若满足条件，则退出线程，反之继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 定义标志位，使用volatile，保证内存可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">				<span class="comment">// 循环打印运行日志</span></span><br><span class="line">                <span class="keyword">while</span> (!stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; isrunning&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 退出后，打印退出日志</span></span><br><span class="line">                <span class="keyword">if</span> (stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; is stop&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">		<span class="comment">// 让子线程执行100ms后，将stopFlag置为true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stopFlag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？"><a href="#sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？" class="headerlink" title="sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？"></a>sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？</h4><p>sleep、yield与join是线程方法，而wait则是Object方法：</p>
<ul>
<li>sleep ，释放cpu资源，不释放锁资源，如果线程进入sleep的话，释放cpu资源，如果外层包有Synchronize，那么此锁并没有释放掉。</li>
<li>wait，释放cpu资源，也释放锁资源，一般用于锁机制中 肯定是要释放掉锁的，因为notify并不会立即调起此线程，因此cpu是不会为其分配时间片的，也就是说wait 线程进入等待池，cpu不分时间片给它，锁释放掉。</li>
<li>yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li>
<li>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另<br>一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</li>
</ul>
<h4 id="sleep是可中断的么"><a href="#sleep是可中断的么" class="headerlink" title="sleep是可中断的么"></a>sleep是可中断的么</h4><p>sleep是可中断的</p>
<h4 id="怎么保证线程按顺序执行？如何实现线程排队"><a href="#怎么保证线程按顺序执行？如何实现线程排队" class="headerlink" title="怎么保证线程按顺序执行？如何实现线程排队 ?"></a>怎么保证线程按顺序执行？如何实现线程排队 ?</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>, <span class="keyword">private</span> <span class="keyword">val</span> nextLetter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentLetter != letter) &#123;</span><br><span class="line">                    (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).wait()</span><br><span class="line">                &#125;</span><br><span class="line">                print(letter)</span><br><span class="line">                currentLetter = nextLetter</span><br><span class="line">                (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).notifyAll()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = PrintABC(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> b = PrintABC(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> c = PrintABC(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> threadA = Thread(a)</span><br><span class="line">    <span class="keyword">val</span> threadB = Thread(b)</span><br><span class="line">    <span class="keyword">val</span> threadC = Thread(c)</span><br><span class="line"></span><br><span class="line">    threadA.start()</span><br><span class="line">    threadB.start()</span><br><span class="line">    threadC.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kotlin协程实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.Mutex</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.withLock</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printLetter</span><span class="params">(lock: <span class="type">Mutex</span>, condition: <span class="type">Condition</span>, letter: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    lock.withLock &#123;</span><br><span class="line">        <span class="keyword">while</span> (PrintABC.currentLetter != letter) &#123;</span><br><span class="line">            condition.await()</span><br><span class="line">        &#125;</span><br><span class="line">        print(letter)</span><br><span class="line">        PrintABC.currentLetter = <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">            <span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&#x27;B&#x27;</span></span><br><span class="line">            <span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&#x27;C&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> lock: Mutex, <span class="keyword">private</span> <span class="keyword">val</span> conditionA: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionB: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionC: Condition, <span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">                <span class="string">&#x27;A&#x27;</span> -&gt; printLetter(lock, conditionA, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;B&#x27;</span> -&gt; printLetter(lock, conditionB, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;C&#x27;</span> -&gt; printLetter(lock, conditionC, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> lock = Mutex()</span><br><span class="line">    <span class="keyword">val</span> conditionA = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionB = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionC = Condition(lock)</span><br><span class="line"></span><br><span class="line">    launch &#123; PrintABC(lock, conditionA, conditionB, conditionC, <span class="string">&#x27;A&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionB, conditionA, conditionC, <span class="string">&#x27;B&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionC, conditionA, conditionB, <span class="string">&#x27;C&#x27;</span>).run() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="非阻塞式生产者消费者如何实现"><a href="#非阻塞式生产者消费者如何实现" class="headerlink" title="非阻塞式生产者消费者如何实现"></a>非阻塞式生产者消费者如何实现</h4><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>七大参数</p>
<ol>
<li>corePoolSize<br>线程池中的常驻核心线程数</li>
<li>maximumPoolSize<br>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime<br>空闲线程的存活时间。</li>
<li>unit<br>keepAliveTime的单位</li>
<li>workQueue<br>任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory<br>表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</li>
<li>handler：<br>拒绝策略，表示当队列满了并且工作线程大于等于线程池最大线程数（maximumPoolSize）时如<br>何处理</li>
</ol>
<p>使用JDK中自带的线程池可以通过创建ThreadPoolExecutor线程池对象，也能够通过Executors中定义的静态方法。其中Executors静态方法创建的线程池主要有以下类型：</p>
<p>1.newSingleThreadExecutor<br>        创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)<br>适用：一个任务一个任务执行的场景<br>2.newCachedThreadPool<br>        当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。<br>适用:执行很多短期异步的场景</p>
<p>3.newFixedThreadPool<br>        创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)，但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。<br>适用:长期执行的场景</p>
<p>4.NewScheduledThreadPool</p>
<p>​		创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构<br>适用:周期性执行的场景</p>
<h4 id="如何开启一个线程，开启大量线程会有什么问题，如何优化？"><a href="#如何开启一个线程，开启大量线程会有什么问题，如何优化？" class="headerlink" title="如何开启一个线程，开启大量线程会有什么问题，如何优化？"></a>如何开启一个线程，开启大量线程会有什么问题，如何优化？</h4><p>开启线程的方式：</p>
<p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyThread run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口，并实现内部run方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyRunnable run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程内存<br>在Java中每个线程需要分配线程内存，用来存储自身的线程变量。在JDK 1.4中每个线程是256K的内存，<br>在JDK 1.5之后每个线程是1M的内存。</p>
<h4 id="Java有什么锁"><a href="#Java有什么锁" class="headerlink" title="Java有什么锁"></a>Java有什么锁</h4><ol>
<li><strong>内置锁（Intrinsic Locks）</strong>:<ul>
<li>也称为监视器锁，是 Java 中最基本的同步机制。</li>
<li>使用 <code>synchronized</code> 关键字来实现，可以用于同步方法或同步代码块。</li>
<li>每个 Java 对象都有一个内置锁，当一个线程进入 <code>synchronized</code> 方法或代码块时，它会自动获取该锁，并在退出时释放锁。</li>
</ul>
</li>
<li><strong>显式锁（Explicit Locks）</strong>:<ul>
<li>提供了比内置锁更丰富的锁操作，通过 <code>java.util.concurrent.locks.Lock</code> 接口及其实现类（如 <code>ReentrantLock</code>）来实现。</li>
<li>显式锁提供了更灵活的锁定和解锁操作，支持尝试获取锁、定时锁等高级功能。</li>
</ul>
</li>
<li><strong>读写锁（Read-Write Locks）</strong>:<ul>
<li>通过 <code>java.util.concurrent.locks.ReadWriteLock</code> 接口及其实现类（如 <code>ReentrantReadWriteLock</code>）来实现。</li>
<li>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入。</li>
<li>适用于读多写少的场景，可以提高并发性能。</li>
</ul>
</li>
<li><strong>自旋锁（Spin Locks）</strong>:<ul>
<li>不是 Java 标准库中的一部分，但可以在 Java 中实现。</li>
<li>自旋锁通过循环检查锁是否可用来实现，如果锁不可用，则线程会一直忙等待，直到锁变为可用。</li>
<li>适用于锁持有时间非常短的场景。</li>
</ul>
</li>
<li><strong>乐观锁（Optimistic Locks）</strong>:<ul>
<li>基于冲突检测和重试机制，不是通过阻塞来实现同步。</li>
<li>Java 中的 <code>Atomic</code> 类（如 <code>AtomicInteger</code>）使用了乐观锁机制。</li>
<li>适用于冲突发生概率较低的场景。</li>
</ul>
</li>
<li><strong>公平锁和非公平锁（Fair and Unfair Locks）</strong>:<ul>
<li>公平锁指的是等待时间最长的线程将获得锁。</li>
<li>非公平锁则不保证这一点，可能导致某些线程饥饿。</li>
<li><code>ReentrantLock</code> 构造函数可以指定公平性，但公平锁通常会降低性能。</li>
</ul>
</li>
</ol>
<h4 id="线程和进程有什么区别？"><a href="#线程和进程有什么区别？" class="headerlink" title="线程和进程有什么区别？"></a>线程和进程有什么区别？</h4><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。</p>
<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。</p>
<p>不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。</p>
<p>每个线程都拥有单独的栈内存用来存储本地数据。	</p>
<h4 id="继承Thread类或者实现Runnable接口来创建线程，有何区别？"><a href="#继承Thread类或者实现Runnable接口来创建线程，有何区别？" class="headerlink" title="继承Thread类或者实现Runnable接口来创建线程，有何区别？"></a>继承Thread类或者实现Runnable接口来创建线程，有何区别？</h4><p>实现Runnable()可以更好的体现共享的概念</p>
<h4 id="Java中Runnable和Callable有什么不同？"><a href="#Java中Runnable和Callable有什么不同？" class="headerlink" title="Java中Runnable和Callable有什么不同？"></a>Java中Runnable和Callable有什么不同？</h4><p>Runnable的run方法没有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code> 任务中的异常被内部捕获处理，因为 <code>Runnable</code> 的 <code>run()</code> 方法不能抛出已检查的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnableTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Runnable task is running.&quot;</span>);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Exception from Runnable&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Caught exception in Runnable: &quot;</span> + e.getMessage());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"> <span class="comment">// 执行 Runnable 任务</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">runnableThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableTask);</span><br><span class="line"> runnableThread.start();</span><br></pre></td></tr></table></figure>



<p>Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception ——如果无法计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable</code> 任务中的异常可以被抛出，并且会被封装在 <code>Future</code> 的 <code>get()</code> 方法抛出的 <code>ExecutionException</code> 中。我们可以通过捕获这个异常并检查其原因（<code>cause</code>）来处理 <code>Callable</code> 任务中的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Callable，抛出异常</span></span><br><span class="line">Callable&lt;String&gt; callableTask = () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Callable task is running.&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Exception from Callable&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 Callable 任务并获取结果</span></span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableTask);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">callableThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">callableThread.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught exception from Callable: &quot;</span> + e.getCause().getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</p>
</li>
<li><p>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</p>
</li>
</ul>
<blockquote>
<p>Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
</blockquote>
<h4 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h4><ol>
<li>**start()**：启动线程，使其开始执行。线程的 <code>run()</code> 方法会在新的线程中调用。</li>
<li>**run()**：定义线程执行的任务。当通过 <code>start()</code> 方法启动线程时，<code>run()</code> 方法会自动调用。</li>
<li>**join()**：使当前线程等待调用 <code>join()</code> 方法的线程结束。例如，如果线程 B执行在线程 A 在上，调用 <code>B.join()</code>，那么线程 A 将等待线程 B 结束后再继续执行。</li>
<li>**sleep(long millis)**：使当前线程暂停执行指定的毫秒数。这是一个静态方法，通常用于模拟延时或等待某个条件发生。</li>
<li>**interrupt()**：中断线程。如果线程处于阻塞状态（例如，正在 sleep 或 wait），它会抛出 <code>InterruptedException</code> 异常。线程可以通过检查中断状态来响应中断。</li>
<li>**isAlive()**：检查线程是否仍然活动。如果线程已经启动且尚未终止，则返回 <code>true</code>。</li>
<li>**setName(String name)**：设置线程的名称。线程名称可以在调试时提供有用的信息。</li>
<li>**getName()**：获取线程的名称。</li>
<li>**setPriority(int priority)**：设置线程的优先级。优先级较高的线程更有可能被线程调度器选择执行。</li>
<li>**getPriority()**：获取线程的优先级。</li>
<li>**setDaemon(boolean on)**：将线程标记为守护线程或用户线程。守护线程在后台运行，主要用于服务任务，当只剩下守护线程时，JVM 将退出。</li>
<li>**isDaemon()**：检查线程是否是守护线程。</li>
</ol>
<h4 id="线程join-方法原理"><a href="#线程join-方法原理" class="headerlink" title="线程join()方法原理"></a>线程join()方法原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;子线程执行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//主线程开始等待子线程thread1，thread2</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待两个线程都执行完（不活动）了，才执行下行打印</span></span><br><span class="line">  System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最外层的主线程会等子线程thread1，thread2执行完毕后再执行后面的逻辑。</p>
<p>实现原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键实现在此行，通过wait方法永久等待。</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                lock.wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>等价写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(thread1))&#123;</span><br><span class="line">    thread1.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		可以发现，外层线程会在thread1.wait();这行代码进入wait阻塞状态。在java中，Thread类线程执行完run()方法后，一定会自动执行notifyAll()方法。</p>
<p>​		所以再thread1线程执行完之后外层线程会被唤醒。</p>
<p>自定义join方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个简化版的 join() 方法实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.isAlive()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 在当前线程对象（即this）上调用wait()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查线程是否存活</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实际的实现会检查线程的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程完成运行时会调用的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyThreadCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            notifyAll(); <span class="comment">// 唤醒在此对象上等待的所有线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 is running.&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟一些工作</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 让线程1休眠2秒</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1 is completed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main thread is waiting for Thread 1 to complete.&quot;</span>);</span><br><span class="line">            thread1.join(); <span class="comment">// 主线程调用 thread1 的 join 方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Main thread continues after Thread 1 completes.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>主线程启动了 <code>thread1</code>。</li>
<li>然后，主线程调用 <code>thread1.join()</code>。由于 <code>join()</code> 方法在 <code>thread1</code> 的实例上同步，主线程现在实际上持有 <code>thread1</code> 的锁。</li>
<li>在 <code>join()</code> 方法内部，主线程检查 <code>thread1</code> 是否存活（即还在运行）。如果存活，主线程会在 <code>thread1</code> 对象上调用 <code>wait()</code>，导致主线程等待并释放 <code>thread1</code> 对象的锁。</li>
<li>一旦 <code>thread1</code> 完成执行（即 <code>run()</code> 方法执行完毕），假设的 <code>notifyThreadCompletion()</code> 方法会被线程系统调用，从而在 <code>thread1</code> 对象上调用 <code>notifyAll()</code>。这会唤醒所有等待在 <code>thread1</code> 对象上的线程，包括主线程。</li>
<li>主线程从 <code>wait()</code> 返回，继续执行 <code>join()</code> 方法后面的代码。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109549244">Java中join()方法原理及使用教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109322537">Java多线程中notifyAll()方法使用教程</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/x541211190/article/details/109258676">Java多线程wait()和notify()系列方法使用教程（内涵故事）</a></p>
<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>​		它定义了线程如何以及何时可以看到其他线程修改过的共享变量的值，以及如何在需要时同步访问共享变量。JMM 解决了多线程环境中的可见性、原子性和有序性问题，确保程序在多线程环境下的正确执行。</p>
<p><strong>可见性</strong></p>
<p>​		可见性是指一个线程对共享变量的修改，能够被其他线程立即看到。在没有适当同步的情况下，一个线程对共享变量的修改可能对其他线程不可见，导致不一致的结果。</p>
<p><strong>原子性</strong></p>
<p>​		原子性是指一个操作或者一系列操作要么全部执行，要么全部不执行，不会出现部分执行的情况。在 Java 中，原子性通常通过同步机制（如 <code>synchronized</code> 关键字或 <code>Atomic</code> 类）来保证。</p>
<p><strong>有序性</strong></p>
<p>​		有序性是指程序执行的顺序按照代码的先后顺序执行。在多线程环境中，由于编译器优化和处理器优化，代码的执行顺序可能会被重排，导致执行结果与预期不符。</p>
<p><strong>如何保证</strong></p>
<p>JMM 通过内存屏障（Memory Barrier）、锁（Locks）、volatile 关键字等机制来保证多线程环境中的可见性、原子性和有序性：</p>
<ul>
<li><strong>内存屏障</strong>：一种指令，用于防止编译器或处理器对指令进行重排序。</li>
<li><strong>锁</strong>：通过锁机制保证同一时刻只有一个线程可以访问共享资源，从而保证原子性和可见性。</li>
<li><strong>volatile 关键字</strong>：用于声明一个变量是易变的，确保对该变量的读写直接影响到主内存，从而保证可见性和一定程度的有序性。</li>
</ul>
<h4 id="如何中断一个线程"><a href="#如何中断一个线程" class="headerlink" title="如何中断一个线程"></a>如何中断一个线程</h4><ul>
<li>使用 <code>interrupt()</code> 方法</li>
</ul>
<p>​		<code>interrupt()</code> 方法是 <code>Thread</code> 类的一个方法，用于中断线程。当一个线程被中断时，它的中断状态将被设置为 <code>true</code>。线程可以通过调用 <code>Thread.interrupted()</code> 或 <code>Thread.isInterrupted()</code> 方法来检查自己是否被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread is interrupted&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时刻中断线程</span></span><br><span class="line">thread.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>volatile</code> 关键字</li>
</ul>
<p>​		可以使用一个 <code>volatile</code> 布尔变量来控制线程的运行。当需要中断线程时，可以改变这个变量的值，线程可以定期检查这个变量的值来决定是否退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在某个时刻停止线程</span></span><br><span class="line">myRunnable.stop();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>线程中断是一种协作机制。一个线程不能强制中断另一个线程，而是提出中断请求，被中断的线程可以决定如何响应中断。</p>
</li>
<li><p>如果线程处于阻塞状态（例如，正在 <code>sleep</code>、<code>wait</code> 或 <code>join</code>），那么中断请求会导致线程抛出 <code>InterruptedException</code>，并清除中断状态。线程需要捕获这个异常并决定如何继续执行。</p>
<p>比如恢复中断状态或者直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">thread</span> <span class="operator">=</span> Thread &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟线程阻塞，比如调用 sleep 方法</span></span><br><span class="line">            println(<span class="string">&quot;Thread is going to sleep.&quot;</span>)</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>) <span class="comment">// 使线程睡眠 5 秒</span></span><br><span class="line">            println(<span class="string">&quot;Thread woke up.&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            <span class="comment">// 捕获 InterruptedException 异常</span></span><br><span class="line">            println(<span class="string">&quot;Thread was interrupted during sleep.&quot;</span>)</span><br><span class="line">            <span class="comment">// 可以在这里决定如何处理中断</span></span><br><span class="line">            <span class="comment">// 例如，可以选择立即结束线程</span></span><br><span class="line"><span class="comment">//            return@Thread</span></span><br><span class="line">            <span class="comment">// 或者维持中断状态 不写这行等价于立即结束线程，下面的逻辑不会执行</span></span><br><span class="line">            Thread.currentThread().interrupt()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查中断状态并做出相应处理</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            println(<span class="string">&quot;Thread is interrupted after waking up.&quot;</span>)</span><br><span class="line">            <span class="comment">// 可以在这里决定如何处理中断</span></span><br><span class="line">            <span class="comment">// 例如，可以选择结束线程的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>中断一个已经终止的线程不会产生任何效果。</p>
</li>
</ul>
<h4 id="interrupted和isInterrupted的区别"><a href="#interrupted和isInterrupted的区别" class="headerlink" title="interrupted和isInterrupted的区别"></a>interrupted和isInterrupted的区别</h4><ol>
<li><code>interrupted()</code></li>
</ol>
<ul>
<li><strong>静态方法</strong>：<code>interrupted()</code> 是一个静态方法，可以通过 <code>Thread.interrupted()</code> 来调用。</li>
<li><strong>重置中断状态</strong>：当调用 <code>interrupted()</code> 方法时，如果线程的中断状态为 <code>true</code>，则此方法会清除中断状态，即将中断状态重置为 <code>false</code>。</li>
<li><strong>检查当前线程</strong>：<code>interrupted()</code> 方法总是检查当前执行的线程的中断状态，而不是调用该方法的线程对象的中断状态。</li>
</ul>
<ol start="2">
<li><code>isInterrupted()</code></li>
</ol>
<ul>
<li><strong>实例方法</strong>：<code>isInterrupted()</code> 是一个实例方法，需要通过线程对象来调用，例如 <code>thread.isInterrupted()</code>。</li>
<li><strong>不重置中断状态</strong>：调用 <code>isInterrupted()</code> 方法不会改变线程的中断状态，只是简单地返回当前的中断状态。</li>
<li><strong>检查指定线程</strong>：<code>isInterrupted()</code> 方法检查调用它的线程对象的中断状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟长时间任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread was interrupted, stopping.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 中断时退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread.start();</span><br><span class="line">thread.interrupt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Thread interrupted status (after calling interrupted()): &quot;</span> + thread.isInterrupted());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>interrupted()</code> 方法用于检查并响应中断请求，同时清除中断状态。</li>
<li><code>isInterrupted()</code> 方法用于在主线程中查询 <code>thread</code> 对象的中断状态，注意到中断状态已被 <code>interrupted()</code> 方法清除，所以此时输出的中断状态为 <code>false</code>。</li>
</ul>
<h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><p>死锁的发生必须满足以下四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个线程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>​		避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockAvoidanceExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 使用顺序加锁 就是获取ock1和lock2的先后顺序一致</span></span><br><span class="line">            lock1.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 acquired lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟工作</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用锁超时</span></span><br><span class="line">                <span class="keyword">if</span> (lock2.tryLock(<span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 1 acquired lock2&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 1 could not acquire lock2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 使用顺序加锁</span></span><br><span class="line">            lock1.lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 acquired lock1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟工作</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用锁超时</span></span><br><span class="line">                <span class="keyword">if</span> (lock2.tryLock(<span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread 2 acquired lock2&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread 2 could not acquire lock2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>避免嵌套锁</strong>：虽然代码中有嵌套锁的情况，但通过其他策略来避免死锁。</li>
<li><strong>使用顺序加锁</strong>：两个线程都按照相同的顺序获取锁（先获取 <code>lock1</code>，然后尝试获取 <code>lock2</code>），这样可以防止循环等待的发生。</li>
<li><strong>使用锁超时</strong>：通过 <code>tryLock</code> 方法尝试获取锁，并设置超时时间。如果在指定时间内无法获取锁，<code>tryLock</code> 会返回 <code>false</code>，线程可以决定放弃或执行其他操作，从而避免死锁。</li>
</ul>
<h4 id="怎么检测一个线程是否拥有锁？"><a href="#怎么检测一个线程是否拥有锁？" class="headerlink" title="怎么检测一个线程是否拥有锁？"></a>怎么检测一个线程是否拥有锁？</h4><p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h4 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><p><strong>1. 使用 join 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialThreadExecution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;T1 is running&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;T2 is running&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;T3 is running&quot;</span>));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join(); <span class="comment">// 等待 t1 结束</span></span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join(); <span class="comment">// 等待 t2 结束</span></span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t3.join(); <span class="comment">// 等待 t3 结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 synchronized 和 wait&#x2F;notify</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialThreadExecution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">currentThread</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">2</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runThread</span><span class="params">(<span class="type">int</span> threadNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (currentThread != threadNumber) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T&quot;</span> + threadNumber + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            currentThread++;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用 Lock 和 Condition</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialThreadExecution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">currentThread</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">1</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">2</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; runThread(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runThread</span><span class="params">(<span class="type">int</span> threadNumber)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (currentThread != threadNumber) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T&quot;</span> + threadNumber + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            currentThread++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h4><p>​		<code>Thread.yield()</code> 方法是一个静态方法，它的作用是暂停当前正在执行的线程对象，并执行其他线程。调用 <code>yield()</code> 方法的目的是让当前线程让出 CPU 使用权，给其他具有相同优先级的线程或更高优先级的线程执行机会。</p>
<ul>
<li><strong>不保证线程切换</strong>：调用 <code>yield()</code> 并不保证导致线程切换。调度器可能会忽略 <code>yield()</code> 请求，当前线程仍然继续执行。</li>
<li><strong>优先级影响</strong>：<code>yield()</code> 方法通常用于让出 CPU 给相同优先级或更高优先级的线程。如果没有其他具有相同优先级的线程在等待 CPU，那么同一个线程可能会在下一次调度时继续执行。</li>
<li><strong>用途</strong>：<code>yield()</code> 方法通常用于调试或测试目的，或者在需要提高程序响应性或性能时作为一种优化手段。</li>
</ul>
<h4 id="Java线程池中submit-和-execute-方法有什么区别？"><a href="#Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="Java线程池中submit() 和 execute()方法有什么区别？"></a>Java线程池中submit() 和 execute()方法有什么区别？</h4><ol>
<li>返回值</li>
</ol>
<ul>
<li>**execute()**：该方法没有返回值。它用于执行实现了 <code>Runnable</code> 接口的任务。</li>
<li>**submit()**：该方法返回一个 <code>Future</code> 对象。它用于执行实现了 <code>Runnable</code> 或 <code>Callable</code> 接口的任务。对于 <code>Runnable</code> 任务，返回的 <code>Future</code> 用于检查任务是否完成；对于 <code>Callable</code> 任务，<code>Future</code> 可用于获取计算结果。</li>
</ul>
<ol start="2">
<li>异常处理</li>
</ol>
<ul>
<li>**execute()**：如果在任务执行过程中抛出异常，该异常将被传递给未捕获异常处理器（如果有的话），否则异常可能被线程池忽略。</li>
<li>**submit()**：如果任务执行过程中抛出异常，该异常将被封装在返回的 <code>Future</code> 对象中。调用 <code>Future.get()</code> 方法时，可以通过捕获 <code>ExecutionException</code> 来处理异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 execute() 方法执行 Runnable 任务</span></span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Running task with execute()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 submit() 方法执行 Runnable 任务</span></span><br><span class="line">Future&lt;?&gt; futureRunnable = executor.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Running task with submit()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 submit() 方法执行 Callable 任务</span></span><br><span class="line">Future&lt;String&gt; futureCallable = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result from Callable task&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 Callable 任务的结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureCallable.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>



<h4 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h4><p><code>volatile</code> 变量和 <code>atomic</code> 变量都是在多线程编程中使用的，用于确保线程安全地访问和修改变量。然而，它们在用途和行为上有一些重要的区别：</p>
<ol>
<li><code>volatile</code> 变量</li>
</ol>
<ul>
<li><strong>可见性</strong>：<code>volatile</code> 关键字确保对一个变量的修改对其他线程立即可见。当一个线程修改了一个 <code>volatile</code> 变量的值，该值对其他线程是立即可见的。</li>
<li><strong>非原子性</strong>：<code>volatile</code> 不能保证复合操作（如自增 <code>i++</code>）的原子性。如果需要原子性操作，需要额外的同步机制（如 <code>synchronized</code> 或 <code>Atomic</code> 类）。</li>
<li><strong>用途</strong>：<code>volatile</code> 主要用于确保变量的可见性，以及防止指令重排序。</li>
</ul>
<ol start="2">
<li><code>atomic</code> 变量</li>
</ol>
<ul>
<li><strong>原子性</strong>：<code>atomic</code> 变量（如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等）提供了一种无锁的方式来执行原子操作，如自增、自减、加法、减法等。</li>
<li><strong>可见性</strong>：<code>atomic</code> 变量的更新操作也具有可见性，因为它们内部使用了 <code>volatile</code> 变量。</li>
<li><strong>性能</strong>：相比于使用锁的同步机制，<code>atomic</code> 变量通常提供了更好的性能，特别是在高竞争的情况下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// volatile 变量示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;  <span class="comment">// 注意：这个操作不是原子的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic 变量示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();  <span class="comment">// 原子操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		如果需要确保变量的可见性，可以使用 <code>volatile</code>。如果需要执行原子操作，应该使用 <code>atomic</code> 变量。在某些情况下，可能需要同时确保可见性和原子性，这时可以结合使用 <code>volatile</code> 和 <code>atomic</code> 变量。</p>
<h4 id="如果同步块内的线程抛出异常会发生什么？"><a href="#如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="如果同步块内的线程抛出异常会发生什么？"></a>如果同步块内的线程抛出异常会发生什么？</h4><ol>
<li><strong>异常传播</strong>：如果异常没有在同步块内被捕获，它会传播到同步块外部，可能会被更高层的代码捕获处理，或者导致线程终止。</li>
<li><strong>锁释放</strong>：当异常发生时，Java 虚拟机（JVM）会确保持有的锁被释放。也就是说，当线程离开同步块（无论是正常退出还是由于异常退出）时，它持有的锁都会被释放。这样其他线程就可以获得该锁并进入同步块。</li>
<li><strong>资源可能未正确释放</strong>：如果同步块内的代码在抛出异常之前负责释放一些资源（例如关闭文件或数据库连接），那么这些资源可能不会被正确释放。为了确保资源始终被正确释放，可以使用 <code>try-finally</code> 块来包裹资源释放代码。</li>
</ol>
<h4 id="Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>Java多线程中调用wait() 和 sleep()方法有什么不同？</h4><ol>
<li>锁的释放</li>
</ol>
<ul>
<li>**wait()**：当线程调用一个对象的 <code>wait()</code> 方法时，它必须持有该对象的锁。调用 <code>wait()</code> 会导致当前线程释放该对象的锁，并进入等待状态，直到其他线程调用同一个对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。在 <code>wait()</code> 返回后，线程需要重新获取锁才能继续执行。</li>
<li>**sleep()**：当线程调用 <code>sleep()</code> 方法时，它不会释放任何锁。线程仍然保持在其身上的所有锁，直到睡眠时间结束或线程被中断。</li>
</ul>
<ol start="2">
<li>所属类</li>
</ol>
<ul>
<li>**wait()**：是 <code>Object</code> 类的方法，因此它适用于所有 Java 对象。</li>
<li>**sleep()**：是 <code>Thread</code> 类的静态方法，因此它适用于任何线程。</li>
</ul>
<ol start="3">
<li>唤醒方式</li>
</ol>
<ul>
<li>**wait()**：线程可以通过 <code>notify()</code>、<code>notifyAll()</code> 方法或 <code>wait()</code> 方法的超时（如果指定了超时）来被唤醒。</li>
<li>**sleep()**：线程可以在指定的睡眠时间结束后自动唤醒，也可以通过中断来提前唤醒。</li>
</ul>
<ol start="4">
<li>异常处理</li>
</ol>
<ul>
<li>**wait()**：调用 <code>wait()</code> 方法的线程必须处于同步块或同步方法中，否则会抛出 <code>IllegalMonitorStateException</code>。</li>
<li>**sleep()**：可以在任何上下文中调用，不需要特定的同步块或方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitSleepExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread is going to wait.&quot;</span>);</span><br><span class="line">                    lock.wait(<span class="number">3000</span>); <span class="comment">// Wait for 3 seconds or until notified</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread is awakened.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Main thread sleeps for 1 second</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            lock.notify(); <span class="comment">// Notify the waiting thread</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程之间是如何通信的？"><a href="#线程之间是如何通信的？" class="headerlink" title="线程之间是如何通信的？"></a>线程之间是如何通信的？</h4><ol>
<li>共享变量</li>
</ol>
<p>​		线程可以通过访问共享变量来进行通信。为了确保线程安全，通常需要使用同步机制（如 <code>synchronized</code> 关键字或 <code>Lock</code> 接口）来控制对共享变量的访问。</p>
<ol start="2">
<li><code>wait()</code>, <code>notify()</code>, 和 <code>notifyAll()</code> 方法</li>
</ol>
<p>这些方法是 <code>Object</code> 类的一部分，用于实现等待&#x2F;通知机制。</p>
<ul>
<li><code>wait()</code>: 使当前线程等待，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</li>
<li><code>notify()</code>: 唤醒在此对象监视器上等待的单个线程。</li>
<li><code>notifyAll()</code>: 唤醒在此对象监视器上等待的所有线程。</li>
</ul>
<p>这些方法必须在同步块或同步方法中调用。</p>
<ol start="3">
<li><code>join()</code> 方法</li>
</ol>
<p>​		当一个线程需要等待另一个线程完成时，它可以调用该线程的 <code>join()</code> 方法。调用线程将被阻塞，直到被 <code>join()</code> 的线程终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">thread.join();  <span class="comment">// 等待 thread 完成</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>BlockingQueue</code> 和其他并发集合</li>
</ol>
<p><code>java.util.concurrent</code> 包提供了一些并发集合，如 <code>BlockingQueue</code>，它们支持线程之间的通信和协作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        queue.put(<span class="number">1</span>);  <span class="comment">// 将元素放入队列</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> queue.take();  <span class="comment">// 从队列中取出元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h4 id="Java线程的6种状态及切换"><a href="#Java线程的6种状态及切换" class="headerlink" title="Java线程的6种状态及切换"></a>Java线程的6种状态及切换</h4><p>在 Java 中，线程可以处于以下几种状态之一：</p>
<ol>
<li>新建（New）</li>
</ol>
<p>线程刚被创建，但还没有开始执行。这是使用 <code>new Thread()</code> 创建线程对象后的初始状态。</p>
<ol start="2">
<li>可运行（Runnable）</li>
</ol>
<p>​		线程已经启动，并且可以被调度器选中执行。处于此状态的线程可能正在运行，也可能正在等待 CPU 资源。<strong>在 Java 中，<code>Runnable</code> 状态包括了传统操作系统线程状态中的就绪（Ready）和运行（Running）状态。</strong></p>
<ol start="3">
<li>阻塞（Blocked）</li>
</ol>
<p>​		线程因为试图获取一个锁（synchronized 锁）而被阻塞，且锁被其他线程持有。当其他线程释放锁，且当前线程获取到锁时，它会重新进入可运行状态。</p>
<ol start="4">
<li>等待（Waiting）</li>
</ol>
<p>​		线程因为调用了 <code>Object.wait()</code>、<code>Thread.join()</code> 或 <code>LockSupport.park()</code> 而处于等待状态。处于等待状态的线程需要等待其他线程做出特定动作（比如通知或中断）才能继续执行。</p>
<ol start="5">
<li>超时等待（Timed Waiting）</li>
</ol>
<p>​		线程因为调用了带有超时参数的方法，如 <code>Thread.sleep(long millis)</code>、<code>Object.wait(long timeout)</code>、<code>Thread.join(long millis)</code> 或 <code>LockSupport.parkNanos()/parkUntil()</code> 而处于超时等待状态。线程会等待直到超时或其他线程做出特定动作。</p>
<ol start="6">
<li>终止（Terminated）</li>
</ol>
<p>线程已经结束执行。线程的 <code>run()</code> 方法执行完毕或者因为异常退出了 <code>run()</code> 方法。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新建 (New)</span><br><span class="line">       |</span><br><span class="line">       v</span><br><span class="line">    可运行 (Runnable) &lt;------------&gt; 阻塞 (Blocked)</span><br><span class="line">       |                                |</span><br><span class="line">       v                                v</span><br><span class="line">    等待 (Waiting) -----&gt; 超时等待 (Timed Waiting)</span><br><span class="line">       |</span><br><span class="line">       v</span><br><span class="line">    终止 (Terminated)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404070958535.jpeg" alt="img"></p>
<h4 id="synchronized能修饰类级别-静态-代码块吗？"><a href="#synchronized能修饰类级别-静态-代码块吗？" class="headerlink" title="synchronized能修饰类级别(静态)代码块吗？"></a>synchronized能修饰<strong>类级别(静态)代码块</strong>吗？</h4><p>​		synchronized不能用在<strong>类级别的(静态)代码块</strong>，这个要从加载顺序上考虑。类级别的代码块在加载顺序上是要优先于任何方法的，其执行顺序只跟代码位置先后有关。没人跟你抢，自然不需要同步。</p>
<h4 id="说说对多线程的理解？"><a href="#说说对多线程的理解？" class="headerlink" title="说说对多线程的理解？"></a>说说对多线程的理解？</h4><p>​		多线程是一种并发编程技术，允许程序同时执行多个线程，每个线程独立执行不同的任务。多线程有助于充分利用多核处理器和提高程序性能。然而，多线程编程也引入了一些挑战，如竞态条件、死锁等，需要仔细处理。</p>
<p>​		多线程是指在一个程序中同时运行多个线程（thread），每个线程独立执行不同的任务或代码段。多线程的好处是可以提高程序的并发性和响应性，即在同一时间内执行多个任务或操作，从而提高程序的执行效率和用户体验。</p>
<p>多线程的实现方式通常包括以下步骤：</p>
<ol>
<li>创建线程：程序需要创建多个线程来并发执行不同的任务或操作。</li>
<li>线程同步：多个线程之间需要协调执行顺序、共享资源等，因此需要使用同步机制来保证线程之间的正确性。常用的同步机制包括互斥锁、条件变量、信号量等。</li>
<li>线程调度：操作系统会根据一定的调度策略来分配CPU时间片给不同的线程执行。线程调度的策略通常包括抢占式调度和协作式调度两种方式。</li>
<li>线程结束：线程执行完任务后需要结束，释放占用的资源。线程结束的方式通常有两种，一种是线程自动结束，另一种是线程被其他线程或主线程强制结束。</li>
</ol>
<p>多线程的优点包括：</p>
<ol>
<li>提高程序的响应速度和并发性，能够同时处理多个任务或操作。</li>
<li>提高程序的效率，能够利用多核处理器的并行计算能力。</li>
<li>提高用户体验，能够快速响应用户的操作。</li>
</ol>
<p>多线程的缺点包括：</p>
<ol>
<li>线程之间的同步和数据共享会增加程序的复杂性和难度。</li>
<li>线程的创建、销毁和切换会消耗系统资源，需要考虑线程的数量和调度策略。</li>
<li>线程之间的竞争和死锁等问题容易出现，需要设计合理的同步机制和调度策略。</li>
</ol>
<h4 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全?"></a><strong>怎么保证线程安全?</strong></h4><p>​		保证线程安全的方法包括使用锁（如 synchronized、ReentrantLock）、使用线程安全的数据结构（如 ConcurrentHashMap）、使用原子操作等。这些方法可以防止多个线程同时访</p>
<p>​		问共享数据而导致的竞态条件和数据不一致的问题。线程安全的实现方式取决于具体的应用场景和需求。</p>
<h4 id="保证安全之后，怎么避免出现死锁？"><a href="#保证安全之后，怎么避免出现死锁？" class="headerlink" title="保证安全之后，怎么避免出现死锁？"></a><strong>保证安全之后，怎么避免出现死锁？</strong></h4><p>避免死锁的方法包括：</p>
<ol>
<li><strong>锁的顺序</strong>：确保多个线程获取锁的顺序一致，以减少死锁的可能性。</li>
<li><strong>超时机制</strong>：为获取锁设置超时时间，避免长时间等待。</li>
<li><strong>死锁检测</strong>：定期检测系统中是否存在死锁，并采取措施解除死锁。</li>
<li><strong>使用高级锁</strong>：某些高级锁（如 <code>ReentrantLock</code>）提供了更灵活的控制，可以更容易地避免死锁。</li>
</ol>
<h4 id="除了锁之外，还有什么方法实现多线程的同步问题？"><a href="#除了锁之外，还有什么方法实现多线程的同步问题？" class="headerlink" title="除了锁之外，还有什么方法实现多线程的同步问题？"></a><strong>除了锁之外，还有什么方法实现多线程的同步问题？</strong></h4><p>​		除了锁，还可以使用信号量、条件变量、原子操作、并发数据结构等方法来实现多线程的同步问题。这些方法可以根据具体的场景选择，以提供更好的性能和可维护性。</p>
<h4 id="同时访问synchronized的静态和非静态方法，能保证线程安全吗？"><a href="#同时访问synchronized的静态和非静态方法，能保证线程安全吗？" class="headerlink" title="同时访问synchronized的静态和非静态方法，能保证线程安全吗？"></a>同时访问synchronized的静态和非静态方法，能保证线程安全吗？</h4><blockquote>
<p>结论：不能，两者的锁对象不一样。前者是类锁(XXX.class),后者是this</p>
</blockquote>
<h4 id="同时访问synchronized方法和非同步方法，能保证线程安全吗？"><a href="#同时访问synchronized方法和非同步方法，能保证线程安全吗？" class="headerlink" title="同时访问synchronized方法和非同步方法，能保证线程安全吗？"></a>同时访问synchronized方法和非同步方法，能保证线程安全吗？</h4><blockquote>
<p>结论：不能，因为synchronized只会对被修饰的方法起作用。</p>
</blockquote>
<h4 id="两个线程同时访问两个对象的非静态同步方法能保证线程安全吗？"><a href="#两个线程同时访问两个对象的非静态同步方法能保证线程安全吗？" class="headerlink" title="两个线程同时访问两个对象的非静态同步方法能保证线程安全吗？"></a>两个线程同时访问两个对象的非静态同步方法能保证线程安全吗？</h4><blockquote>
<p>结论：不能，每个对象都拥有一把锁。两个对象相当于有两把锁，导致锁对象不一致。(PS：如果是类锁，则所有对象共用一把锁)</p>
</blockquote>
<h4 id="若synchronized方法抛出异常，会导致死锁吗？"><a href="#若synchronized方法抛出异常，会导致死锁吗？" class="headerlink" title="若synchronized方法抛出异常，会导致死锁吗？"></a>若synchronized方法抛出异常，会导致死锁吗？</h4><blockquote>
<p>JVM会自动释放锁，不会导致死锁问题</p>
</blockquote>
<h4 id="若synchronized的锁对象能为空吗？会出现什么情况？"><a href="#若synchronized的锁对象能为空吗？会出现什么情况？" class="headerlink" title="若synchronized的锁对象能为空吗？会出现什么情况？"></a>若synchronized的锁对象能为空吗？会出现什么情况？</h4><blockquote>
<p>锁对象不能为空，否则抛出NPE(NullPointerException)</p>
</blockquote>
<h4 id="若synchronized的锁对象能为空吗？会出现什么情况？-1"><a href="#若synchronized的锁对象能为空吗？会出现什么情况？-1" class="headerlink" title="若synchronized的锁对象能为空吗？会出现什么情况？"></a>若synchronized的锁对象能为空吗？会出现什么情况？</h4><blockquote>
<p>锁对象不能为空，否则抛出NPE(NullPointerException)</p>
</blockquote>
<h4 id="在开发过程中，经常使用synchronized方法多还是synchronized代码块？and-why"><a href="#在开发过程中，经常使用synchronized方法多还是synchronized代码块？and-why" class="headerlink" title="在开发过程中，经常使用synchronized方法多还是synchronized代码块？and why?"></a><strong>在开发过程中，经常使用synchronized方法多还是synchronized代码块？and why?</strong></h4><p>​		synchronized同步的范围是越小越好。因为若该方法耗时很久，那其它线程必须等到该持锁线程执行完才能运行。(黄花菜都凉了都…)<br>而synchronized代码块部分只有这一部分是同步的，其它的照样可以异步执行，提高运行效率。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/14655412.html">多线程面试题（史上最全、持续更新、吐血推荐）</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/Java%E9%9D%A2%E8%AF%95%E9%A2%98/" title="java 面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java 面试题</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/JavaJVM/" title="Java JVM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java JVM</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%9E%E6%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">竞态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">线程调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.6.</span> <span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronize"><span class="toc-number">1.7.</span> <span class="toc-text">synchronize</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">synchronize使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E5%90%84%E8%87%AA%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">synchronize各自的锁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">synchronize的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%86%85%E5%AD%98%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.4.</span> <span class="toc-text">synchronized内存特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.5.</span> <span class="toc-text">synchronize原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronize%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.6.</span> <span class="toc-text">synchronize锁状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%94%81"><span class="toc-number">1.7.6.1.</span> <span class="toc-text">无锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%EF%BC%88JDK15%E8%A2%AB%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="toc-number">1.7.6.2.</span> <span class="toc-text">偏向锁（JDK15被废弃）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.7.6.3.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.7.6.4.</span> <span class="toc-text">重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">1.7.6.4.1.</span> <span class="toc-text">获取锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B"><span class="toc-number">1.7.6.4.1.1.</span> <span class="toc-text">自旋</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.7.6.4.1.2.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%80%BB%E8%BE%91%EF%BC%9AtrySpin"><span class="toc-number">1.7.6.4.1.3.</span> <span class="toc-text">自旋逻辑：trySpin</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.6.4.1.4.</span> <span class="toc-text">死循环</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.7.6.4.2.</span> <span class="toc-text">释放锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%B0%8F%E7%BB%93"><span class="toc-number">1.7.7.</span> <span class="toc-text">重量级锁小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-notify%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">wait&#x2F;notify底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">wait方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">notify方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">1.9.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.10.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.11.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.11.2.</span> <span class="toc-text">公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-VS-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.11.3.</span> <span class="toc-text">可重入锁 VS 非可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">1.11.4.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E4%B8%8EAQS%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.11.5.</span> <span class="toc-text">ReentrantLock与AQS的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.6.</span> <span class="toc-text">Synchronized和ReentrantLock的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.12.</span> <span class="toc-text">Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.12.1.</span> <span class="toc-text">AtomicInteger线程安全源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%93%8D%E9%A2%98"><span class="toc-number">1.13.</span> <span class="toc-text">多线程代码实操题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0ABC-100%E6%AC%A1"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">三个线程循环打印ABC 100次</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized"><span class="toc-number">1.13.0.1.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicInteger"><span class="toc-number">1.13.0.1.2.</span> <span class="toc-text">AtomicInteger</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.14.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E5%A6%82%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcpu%EF%BC%8C%E5%8D%95%E6%A0%B8%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%9C%89%E7%94%A8%E5%90%97-%EF%BC%9F"><span class="toc-number">1.14.0.1.</span> <span class="toc-text">假如只有一个cpu，单核，多线程还有用吗 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sychronied%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.14.0.2.</span> <span class="toc-text">sychronied修饰普通方法和静态方法的区别？什么是可见性?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E5%9C%A8JDK1-6%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.0.3.</span> <span class="toc-text">Synchronized在JDK1.6之后做了哪些优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.0.4.</span> <span class="toc-text">CAS无锁编程的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.0.5.</span> <span class="toc-text">AQS原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%B8%8EReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.14.0.6.</span> <span class="toc-text">Synchronized的原理以及与ReentrantLock的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E4%BB%80%E4%B9%88%E5%8F%AB%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%89"><span class="toc-number">1.14.0.7.</span> <span class="toc-text">volatile关键字干了什么？（什么叫指令重排）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E8%83%BD%E5%90%A6%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%9C%A8DCL%E4%B8%8A%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.14.0.8.</span> <span class="toc-text">volatile 能否保证线程安全？在DCL上的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%92%8Csynchronize%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.0.9.</span> <span class="toc-text">volatile和synchronize有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9C%BA%E6%99%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.14.0.10.</span> <span class="toc-text">死锁的场景和解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%88%86%E5%93%AA%E5%87%A0%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.14.0.11.</span> <span class="toc-text">锁分哪几类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.14.0.12.</span> <span class="toc-text">Java多线程对同一个对象进行操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8start%E5%90%97%EF%BC%9F-%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8start%EF%BC%9F"><span class="toc-number">1.14.0.13.</span> <span class="toc-text">线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">1.14.0.14.</span> <span class="toc-text">什么是守护线程？你是如何退出一个线程的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E3%80%81wait%E3%80%81yield%E4%B8%8Ejoin%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cwait-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%94%A4%E9%86%92%E5%AE%83%EF%BC%9F"><span class="toc-number">1.14.0.15.</span> <span class="toc-text">sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B9%88"><span class="toc-number">1.14.0.16.</span> <span class="toc-text">sleep是可中断的么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%8E%92%E9%98%9F"><span class="toc-number">1.14.0.17.</span> <span class="toc-text">怎么保证线程按顺序执行？如何实现线程排队 ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.14.0.18.</span> <span class="toc-text">非阻塞式生产者消费者如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.14.0.19.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BC%80%E5%90%AF%E5%A4%A7%E9%87%8F%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.14.0.20.</span> <span class="toc-text">如何开启一个线程，开启大量线程会有什么问题，如何优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%9C%89%E4%BB%80%E4%B9%88%E9%94%81"><span class="toc-number">1.14.0.21.</span> <span class="toc-text">Java有什么锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.0.22.</span> <span class="toc-text">线程和进程有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E6%88%96%E8%80%85%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.0.23.</span> <span class="toc-text">继承Thread类或者实现Runnable接口来创建线程，有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%ADRunnable%E5%92%8CCallable%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.14.0.24.</span> <span class="toc-text">Java中Runnable和Callable有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.0.25.</span> <span class="toc-text">线程的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8Bjoin-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.0.26.</span> <span class="toc-text">线程join()方法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.14.0.27.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.14.0.28.</span> <span class="toc-text">如何中断一个线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupted%E5%92%8CisInterrupted%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.0.29.</span> <span class="toc-text">interrupted和isInterrupted的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">1.14.0.30.</span> <span class="toc-text">如何避免死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%8B%A5%E6%9C%89%E9%94%81%EF%BC%9F"><span class="toc-number">1.14.0.31.</span> <span class="toc-text">怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1%EF%BC%8CT2%EF%BC%8CT3%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E5%AE%83%E4%BB%AC%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.14.0.32.</span> <span class="toc-text">有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.14.0.33.</span> <span class="toc-text">Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADsubmit-%E5%92%8C-execute-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.0.34.</span> <span class="toc-text">Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%8F%98%E9%87%8F%E5%92%8C-atomic-%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.14.0.35.</span> <span class="toc-text">volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%AD%A5%E5%9D%97%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.14.0.36.</span> <span class="toc-text">如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.14.0.37.</span> <span class="toc-text">Java多线程中调用wait() 和 sleep()方法有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">1.14.0.38.</span> <span class="toc-text">线程之间是如何通信的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2"><span class="toc-number">1.14.0.39.</span> <span class="toc-text">Java线程的6种状态及切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E8%83%BD%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%BA%A7%E5%88%AB-%E9%9D%99%E6%80%81-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.0.40.</span> <span class="toc-text">synchronized能修饰类级别(静态)代码块吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.14.0.41.</span> <span class="toc-text">说说对多线程的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.14.0.42.</span> <span class="toc-text">怎么保证线程安全?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">1.14.0.43.</span> <span class="toc-text">保证安全之后，怎么避免出现死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E9%94%81%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.14.0.44.</span> <span class="toc-text">除了锁之外，还有什么方法实现多线程的同步问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AEsynchronized%E7%9A%84%E9%9D%99%E6%80%81%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.0.45.</span> <span class="toc-text">同时访问synchronized的静态和非静态方法，能保证线程安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AEsynchronized%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.0.46.</span> <span class="toc-text">同时访问synchronized方法和非同步方法，能保证线程安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%83%BD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.0.47.</span> <span class="toc-text">两个线程同时访问两个对象的非静态同步方法能保证线程安全吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5synchronized%E6%96%B9%E6%B3%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-number">1.14.0.48.</span> <span class="toc-text">若synchronized方法抛出异常，会导致死锁吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5synchronized%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1%E8%83%BD%E4%B8%BA%E7%A9%BA%E5%90%97%EF%BC%9F%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">1.14.0.49.</span> <span class="toc-text">若synchronized的锁对象能为空吗？会出现什么情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5synchronized%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1%E8%83%BD%E4%B8%BA%E7%A9%BA%E5%90%97%EF%BC%9F%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F-1"><span class="toc-number">1.14.0.50.</span> <span class="toc-text">若synchronized的锁对象能为空吗？会出现什么情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8synchronized%E6%96%B9%E6%B3%95%E5%A4%9A%E8%BF%98%E6%98%AFsynchronized%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9Fand-why"><span class="toc-number">1.14.0.51.</span> <span class="toc-text">在开发过程中，经常使用synchronized方法多还是synchronized代码块？and why?</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>