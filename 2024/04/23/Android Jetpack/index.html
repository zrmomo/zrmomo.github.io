<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android JetPack | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android JetPackLifecycle简介​			Lifecycle是Google推出的一个可以感知（Activity&#x2F;Fragment）等组件生命周期的一个组件。使用Lifecycle，，可以避免在（Activity&#x2F;Fragment）生命周期函数里写过多的逻辑代码，可以使我们的业务逻辑更加的解耦。 源码1234567891011121314151617181920">
<meta property="og:type" content="article">
<meta property="og:title" content="Android JetPack">
<meta property="og:url" content="https://zrmomo.github.io/2024/04/23/Android%20Jetpack/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="Android JetPackLifecycle简介​			Lifecycle是Google推出的一个可以感知（Activity&#x2F;Fragment）等组件生命周期的一个组件。使用Lifecycle，，可以避免在（Activity&#x2F;Fragment）生命周期函数里写过多的逻辑代码，可以使我们的业务逻辑更加的解耦。 源码1234567891011121314151617181920">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-04-23T14:33:30.726Z">
<meta property="article:modified_time" content="2024-04-22T15:07:37.940Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/04/23/Android%20Jetpack/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android JetPack',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-22 23:07:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android JetPack</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-23T14:33:30.726Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-22T15:07:37.940Z" title="更新于 2024-04-22 23:07:37">2024-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android JetPack"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Android-JetPack"><a href="#Android-JetPack" class="headerlink" title="Android JetPack"></a>Android JetPack</h1><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​			Lifecycle是Google推出的一个可以感知（Activity&#x2F;Fragment）等组件生命周期的一个组件。使用Lifecycle，，可以避免在（Activity&#x2F;Fragment）生命周期函数里写过多的逻辑代码，可以使我们的业务逻辑更加的解耦。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">    <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line">    <span class="comment">//移除观察者</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line">    <span class="comment">//获取当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title function_">getCurrentState</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生命周期事件，对应Activity生命周期方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY  <span class="comment">//可以响应任意一个事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生命周期状态. （Event是进入这种状态的事件）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断至少是某一状态</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p>
<ol>
<li>Event，生命周期事件，这些事件对应Activity&#x2F;Fragment生命周期方法。</li>
<li>State，生命周期状态，而Event是指进入一种状态的事件。 Event触发的时机：</li>
</ol>
<ul>
<li>ON_CREATE、ON_START、ON_RESUME事件，是在LifecycleOwner对应的方法执行 之后 分发。</li>
<li>ON_PAUSE、ON_STOP、ON_DESTROY事件，是在LifecycleOwner对应的方法调用 之前 分发。 这保证了LifecycleOwner是在这个状态内。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202404082309767.webp" alt="event与state关系图.png"></p>
<p><code>Event</code> 代表生命周期发生变化那个瞬间点，而 <code>State</code> 则表示生命周期的一个阶段。</p>
<ul>
<li><code>INITIALIZED</code>：在 <code>ON_CREATE</code> 事件触发前。</li>
<li><code>CREATED</code>：在 <code>ON_CREATE</code> 事件触发后以及 <code>ON_START</code> 事件触发前；或者在 <code>ON_STOP</code> 事件触发后以及 <code>ON_DESTROY</code> 事件触发前。</li>
<li><code>STARTED</code>：在 <code>ON_START</code> 事件触发后以及 <code>ON_RESUME</code> 事件触发前；或者在 <code>ON_PAUSE</code> 事件触发后以及 <code>ON_STOP</code> 事件触发前。</li>
<li><code>RESUMED</code>：在 <code>ON_RESUME</code> 事件触发后以及 <code>ON_PAUSE</code> 事件触发前。</li>
<li><code>DESTROYED</code>：在 <code>ON_DESTROY</code> 事件触发之后。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​		AppComponentActivity和FragmentActivity都是继承了ComponentActivity。ComponentActivity实现了LifecycleOwner接口。在ComponentActivity的onCreate生命周期回调中会添加一个Fragment，所以我们就是借助Fragment来实现生命周期的观察的。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>1.Lifecycle是怎样感知生命周期的？</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmStatic</span>  <span class="comment">// 表明这个方法是一个静态方法，可以在 Java 代码中直接通过类名调用</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">injectIfNeededIn</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;  <span class="comment">// 定义一个方法，接受一个 Activity 参数</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;  <span class="comment">// 检查设备的 API 级别是否大于等于 29（Android 10）</span></span><br><span class="line">        <span class="comment">// 在 API 29+（Android 10+）上，可以直接注册正确的生命周期回调</span></span><br><span class="line">        LifecycleCallbacks.registerIn(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于 API 29 以下的版本，为了保持与旧版本的 ProcessLifecycleOwner 兼容性</span></span><br><span class="line">    <span class="comment">// （这可能在 lifecycle-runtime 更新时不会更新，并且需要支持不继承自 support 库中的 FragmentActivity 的活动），</span></span><br><span class="line">    <span class="comment">// 使用 framework fragment 来获取正确的生命周期事件时序</span></span><br><span class="line">    <span class="keyword">val</span> manager = activity.fragmentManager  <span class="comment">// 获取 Activity 的 FragmentManager</span></span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="literal">null</span>) &#123;  <span class="comment">// 检查是否已经添加了 ReportFragment</span></span><br><span class="line">        <span class="comment">// 如果没有找到 ReportFragment，则添加一个新的 ReportFragment 实例</span></span><br><span class="line">        manager.beginTransaction().add(ReportFragment(), REPORT_FRAGMENT_TAG).commit()</span><br><span class="line">        <span class="comment">// 提交事务，希望我们是第一个进行事务提交的</span></span><br><span class="line">        manager.executePendingTransactions()  <span class="comment">// 执行所有挂起的事务，确保 ReportFragment 被立即添加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在 Android 10 及以上版本，直接使用 <code>LifecycleCallbacks</code> 注册生命周期回调；在 Android 10 以下版本，通过添加一个 <code>ReportFragment</code> 来监听生命周期事件。这样做是为了确保在不同版本的 Android 设备上都能正确地管理和跟踪 Activity 的生命周期。</p>
<p><strong>2.Lifecycle是如何处理生命周期的？</strong></p>
<p>​		通过调用了<code>((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</code>方法，也就是LifecycleRegistry 类来处理这些生命周期。</p>
<p><strong>3.LifecycleObserver的方法是怎么回调是的呢？</strong></p>
<p>​		LifecycleRegistry 的 handleLifecycleEvent方法，然后会通过层层调用最后通过反射到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解值，来调用对应的方法</p>
<p><strong>4.为什么LifecycleObserver可以感知到Activity的生命周期</strong></p>
<p>​		LifecycleRegistry调用handleLifecycleEvent方法时会传递Event类型，然后会通过层层调用，最后是通过反射获取注解的值，到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解上对应的Event的值，注意这个值是和Activity&#x2F;Fragment的生命周期的一一对应的，所以就可以感知Activity、Fragment的生命周期了。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6893870636733890574?searchId=20240326213943242B524B2C94BE2B8654#heading-13">“终于懂了“系列：Jetpack AAC完整解析（一）Lifecycle 完全掌握！</a></p>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>​		<a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 类是一种<a target="_blank" rel="noopener" href="https://developer.android.com/topic/architecture/ui-layer/stateholders?hl=zh-cn">业务逻辑或屏幕级状态容器</a>。它用于将状态公开给界面，以及封装相关的业务逻辑。 它的主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态。这意味着在 activity 之间导航时或进行配置更改后（例如旋转屏幕时），界面将无需重新提取数据。</p>
<p>​		<code>ViewModel</code> 可以做到在配置变更后依然持有状态。所以，在现在的开发中，我们开始将 <strong>View数据</strong> 与 逻辑 藏于 <code>ViewModel</code> 中，然后对外部暴漏观察者，比如我们常常会搭配 <code>LiveData</code> 一起使用，以此更容易的保持状态同步。</p>
<p>​		<code>ViewModel</code> 也不是万能，其只能避免配置变更时避免状态丢失。比如如果我们的App是因为 <strong>内存不足</strong> 而被系统<strong>kill</strong> 掉，此时 <code>ViewModel</code> 也会被清除 🔺 。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>原生手动创建ViewModel</li>
</ul>
<p>在 Activity 或 Fragment 中获取 ViewModel 对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p><code>ViewModelStore</code>: 负责存储ViewModel.</p>
<p><code>Factory</code>: 负责实例化具体的ViewModel类型.</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>​		ViewModel类自己的代码没多少，要看ViewModelProvider是怎么把它创建出来的。</p>
<p>​		ViewModelProvider的构造方法传入了this也就是当前作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 owner 获取 ViewModelStore，用于存储 ViewModel 实例</span></span><br><span class="line">    <span class="built_in">this</span>(owner.getViewModelStore(),</span><br><span class="line">        <span class="comment">// 检查 owner 是否实现了 HasDefaultViewModelProviderFactory 接口</span></span><br><span class="line">        <span class="comment">// 如果实现了，则使用 owner 提供的默认 ViewModelProvider.Factory</span></span><br><span class="line">        <span class="comment">// 否则，使用 NewInstanceFactory 的实例</span></span><br><span class="line">        owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h4><p>​		<code>ViewModelStore</code> 是负责维护我们 <code>ViewModel</code> 实例的具体类，内部有一个 <strong>map</strong> 的合集，用于保存我们创建的所有 <code>ViewModel</code> ，并对外提供了 <code>clear()</code> 方法，以 <strong>便于非配置变更时清除缓存</strong> 。</p>
<p>看下getViewModelStore的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># FragmentActivity</span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FragmentActivity.<span class="built_in">this</span>.getViewModelStore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureViewModelStore();</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 NonConfigurationInstances 对象。这个对象包含了上一次配置变更时的一些状态信息，也就包括之前创建的ViewModelStore,原理是以静态类的形式存储在内存中</span></span><br><span class="line">            <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                    (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从 NonConfigurationInstances 恢复 ViewModelStore</span></span><br><span class="line">                mViewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">                mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		这个方法是ViewModelStoreOwner接口的方法，拥有ViewModelStore的范围。此接口的实现的责任是在配置更改期间保留拥有的 ViewModelStore 并在该作用域将要销毁时调用ViewModelStore.clear() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewModelStore的数据结构也非常简单，里面是一个HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概括下上面的逻辑：</p>
<p>​		获取ViewModeStore时首先会判断能不能从之前的配置中获得，没有的话再直接创建一个新的ViewModeStore对象。</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>第二个参数Factory，它的获取有个判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance()</span><br></pre></td></tr></table></figure>

<p>​		这个owner是Fragment和FragmentActivity对象的话一定是实现了HasDefaultViewModelProviderFactory这个接口的。看下它两个在getDefaultViewModelProviderFactory这个方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># ComponentActivity</span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 Activity 是否已经附加到 Application 实例</span></span><br><span class="line">    <span class="comment">// 如果没有，抛出 IllegalStateException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否已经有一个默认的 Factory 实例</span></span><br><span class="line">    <span class="comment">// 如果没有，创建一个新的 SavedStateViewModelFactory 实例</span></span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                <span class="comment">// 提供 Application 实例</span></span><br><span class="line">                getApplication(),</span><br><span class="line">                <span class="comment">// 提供 ViewModelStoreOwner，通常是 Activity 或 Fragment 本身</span></span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                <span class="comment">// 提供 Intent 中的额外数据作为初始状态，如果 Intent 为 null，则传递 null</span></span><br><span class="line">                getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回默认的 Factory 实例</span></span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		可见最终返回时是一个SavedStateViewModelFactory对象的实例。</p>
<p>下面继续看ViewModelProvider的get方法，ViewModelProvider这个名字一看就知道是来用于创建和管理 <code>ViewModel</code> 实例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># ViewModelProvider</span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的规范名称，这是一种更易读的形式。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">    <span class="comment">// 如果类是局部的或匿名的，它将没有规范名称，我们不能将其用作ViewModel。</span></span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用默认键和类的规范名称作为键来获取ViewModel实例。</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 从ViewModel存储中获取与键关联的ViewModel。</span></span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取的ViewModel是请求的类的实例，则返回它。</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">// 如果工厂实现了OnRequeryFactory接口，调用onRequery方法。</span></span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取到的ViewModel不为空，但不是请求的类型，则记录警告。</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工厂是KeyedFactory的实例，则使用键和类类型创建新的ViewModel。</span></span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，使用类类型创建新的ViewModel。</span></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新创建的ViewModel存储到ViewModel存储中。</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="comment">// 返回新创建的ViewModel实例。</span></span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		首先根据类名创建唯一的key，然后先从ViewModelStore的那个map里用key寻找有没有对应的实例。</p>
<p><strong>寻找到对应的实例</strong></p>
<p>​		如果有的话会调用mFactory的onRequery方法。上面说了mFactory是SavedStateViewModelFactory对象的实例。那么看它这个方法的具体实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># SavedStateViewModelFactory</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onRequery</span><span class="params">(<span class="meta">@NonNull</span> ViewModel viewModel)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 ViewModel 尚未附加 SavedStateHandleController，则附加一个</span></span><br><span class="line">    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attachHandleIfNeeded</span><span class="params">(ViewModel viewModel, SavedStateRegistry registry,</span></span><br><span class="line"><span class="params">        Lifecycle lifecycle)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取与 ViewModel 关联的 SavedStateHandleController</span></span><br><span class="line">    <span class="type">SavedStateHandleController</span> <span class="variable">controller</span> <span class="operator">=</span> viewModel.getTag(</span><br><span class="line">            TAG_SAVED_STATE_HANDLE_CONTROLLER);</span><br><span class="line">    <span class="comment">// 检查控制器是否存在且尚未附加</span></span><br><span class="line">    <span class="keyword">if</span> (controller != <span class="literal">null</span> &amp;&amp; !controller.isAttached()) &#123;</span><br><span class="line">        <span class="comment">// 将控制器附加到生命周期和 SavedStateRegistry</span></span><br><span class="line">        controller.attachToLifecycle(registry, lifecycle);</span><br><span class="line">        <span class="comment">// 尝试在生命周期中添加 Recreator 以在进程死亡后重建 ViewModel</span></span><br><span class="line">        tryToAddRecreator(registry, lifecycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码的主要目的是确保 <code>ViewModel</code> 关联的 <code>SavedStateHandleController</code> 被正确地附加到生命周期和状态保存机制中，以便在进程死亡后能够恢复 <code>ViewModel</code> 的状态。也就是处理SavedStateHandle的情况。</p>
<p>​		SavedStateHandle就是为了处理App被杀死后Activity重建后，也能获取到之前保存的状态。本质也是基于<strong>onSaveInstanceState()</strong> 与 <strong>onRestoreInstanceState()</strong> 这两个方法，onSaveInstanceState()方法中调用<code>savedStateRegistry.performSave()</code> 去保存状态。该方法内部会创建一个新的 <strong>Bundle</strong> 对象，用于保存所有状态,然后再调用所有缓存的状态提供者(SavedStateProvider)的 <code>saveState()</code> 方法，从而将所有需要需要保存的状态以 <strong>key-value</strong> 的方式存到 <strong>Bundle</strong> 中去。最后再将这个整体的 <strong>bundle</strong> 存入 <code>onSaveInstanceState()</code> 方法参数提供的 <strong>bundle</strong> 中。然后在创建ViewModel时再取出来。</p>
<p><strong>没有寻找到对应的实例</strong></p>
<p>则调用mFactory的也就是SavedStateViewModelFactory的Create方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 AndroidViewModel 的子类</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAndroidViewModel</span> <span class="operator">=</span> AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 根据 ViewModel 类型选择合适的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到合适的构造函数，则使用默认的工厂方法创建 ViewModel</span></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SavedStateHandleController</span></span><br><span class="line">    <span class="type">SavedStateHandleController</span> <span class="variable">controller</span> <span class="operator">=</span> SavedStateHandleController.create(</span><br><span class="line">            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T viewmodel;</span><br><span class="line">        <span class="comment">// 根据 ViewModel 类型使用合适的构造函数创建 ViewModel 实例</span></span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为 ViewModel 设置 SavedStateHandleController 标签</span></span><br><span class="line">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A &quot;</span> + modelClass + <span class="string">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An exception happened in constructor of &quot;</span></span><br><span class="line">                + modelClass, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	  判断当前构造函数是不是带 <code>application</code> 或者 <code>SaveStateHandle</code> ，从而调用合适的 <code>newInstance()</code> 方法，最后再将创建好的 <code>ViewModel</code> 添加到 <code>ViewModelStore</code> 的 <strong>缓存</strong> 中。</p>
<h3 id="ViewModel销毁"><a href="#ViewModel销毁" class="headerlink" title="ViewModel销毁"></a>ViewModel销毁</h3><p>​		在初始化Activity时，内部会使用 <code>lifecycle</code> 添加一个生命周期观察者，并监听 <strong>onDestory()</strong> 通知(Act销毁)，如果当前销毁的原因非配置更改导致，则调用 <strong>ViewModeltore.clear()</strong> ，即清空我们的ViewModel缓存列表，从而这也是为什么 <code>ViewModel</code> 不支持非配置更改的实例保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">	getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">                    <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    <span class="comment">// Clear out the available context</span></span><br><span class="line">                    mContextAwareHelper.clearAvailableContext();</span><br><span class="line">                    <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">                    <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                        <span class="comment">// 这里清理ViewModelStore</span></span><br><span class="line">                        getViewModelStore().clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mReportFullyDrawnExecutor.activityDestroyed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    fun <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (vm in map.values) &#123;</span><br><span class="line">            vm.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7186680109384859706?searchId=20240301103914DB08362B8704C36291BF#heading-22">https://juejin.cn/post/7186680109384859706?searchId=20240301103914DB08362B8704C36291BF#heading-22</a></p>
<h3 id="ViewModel怎么实现的配置更改后持久保留相应状态"><a href="#ViewModel怎么实现的配置更改后持久保留相应状态" class="headerlink" title="ViewModel怎么实现的配置更改后持久保留相应状态"></a>ViewModel怎么实现的配置更改后持久保留相应状态</h3><ol>
<li><strong>创建 <code>ViewModel</code> 实例</strong>：当你第一次请求一个 <code>ViewModel</code> 实例时，<code>ViewModelProvider</code>会为你的 <code>Activity</code> 或 <code>Fragment</code> 创建一个新的 <code>ViewModel</code> 实例。这通常是通过调用 ViewModelProvider(this).get(MyViewModel::class.java)实现的。</li>
<li>**关联 <code>ViewModel</code> 实例与 <code>ViewModelStore</code>**：创建的 <code>ViewModel</code> 实例会被存储在与当前 <code>Activity</code> 或 <code>Fragment</code> 相关联的 <code>ViewModelStore</code> 中。这个 <code>ViewModelStore</code> 是 <code>ViewModelStoreOwner</code>（例如 <code>ComponentActivity</code> 或 <code>Fragment</code>）持有的，它负责管理 <code>ViewModel</code> 实例的生命周期。</li>
<li><strong>配置更改发生</strong>：当配置更改（如屏幕旋转）发生时，<code>Activity</code> 会被销毁并重新创建。然而，<code>ViewModelStore</code> 不会随 <code>Activity</code> 一起销毁，而是会被保留下来。</li>
<li><strong>重新获取 <code>ViewModel</code> 实例</strong>：在新创建的 <code>Activity</code> 或 <code>Fragment</code> 中，当再次通过 <code>ViewModelProviders.of(this).get(MyViewModel.class)</code> 请求相同类型的 <code>ViewModel</code> 实例时，<code>ViewModelProviders</code> 会检查当前 <code>ViewModelStore</code> 中是否已经存在该类型的 <code>ViewModel</code> 实例。如果存在，它会返回已经存在的实例，而不是创建一个新的。这样，你就可以继续使用之前的 <code>ViewModel</code> 实例，其中保存的状态也会得到保留。</li>
</ol>
<p>​		通过这种方式，<code>ViewModel</code> 能够在配置更改后持久保留相应状态，从而实现数据的持久性和管理。这也是为什么推荐在 <code>ViewModel</code> 中存储 UI 相关的数据和逻辑，而不是在 <code>Activity</code> 或 <code>Fragment</code> 中直接存储，因为 <code>Activity</code> 和 <code>Fragment</code> 在配置更改时可能会被销毁和重新创建，而 <code>ViewModel</code> 可以跨这些配置更改保持存活。</p>
<h3 id="ViewModelStore-不会随-Activity-一起销毁，而是会被保留下来。怎么做到的？"><a href="#ViewModelStore-不会随-Activity-一起销毁，而是会被保留下来。怎么做到的？" class="headerlink" title="ViewModelStore 不会随 Activity 一起销毁，而是会被保留下来。怎么做到的？"></a><code>ViewModelStore</code> 不会随 <code>Activity</code> 一起销毁，而是会被保留下来。怎么做到的？</h3><p>​		当 <code>Activity</code> 第一次创建时，它会创建一个新的 <code>ViewModelStore</code>。当配置更改发生时，<code>Activity</code> 会通过 <code>onRetainNonConfigurationInstance</code> 方法保留这个 <code>ViewModelStore</code>。然后，当 <code>Activity</code> 被重新创建时，它会检查是否有保留的 <code>ViewModelStore</code>，如果有，它会使用这个保留的 <code>ViewModelStore</code> 而不是创建一个新的。这样，<code>ViewModel</code> 就可以在配置更改后继续存在，而不会随 <code>Activity</code> 的销毁而销毁。</p>
<ol>
<li><strong>对于 Activity</strong>：<ul>
<li>在配置更改发生时，<code>Activity</code> 的 <code>onRetainNonConfigurationInstance</code> 方法会被调用，<code>Activity</code> 可以通过这个方法来保留一个对象。<code>Activity</code> 的实现会将其 <code>ViewModelStore</code> 作为这个保留的对象。</li>
<li>当 <code>Activity</code> 被重新创建时，它会通过 <code>getLastNonConfigurationInstance</code> 方法来获取之前保留的对象，从而恢复 <code>ViewModelStore</code>。</li>
</ul>
</li>
<li><strong>对于 Fragment</strong>：<ul>
<li><code>Fragment</code> 的保留机制稍有不同。<code>Fragment</code> 可以通过设置 <code>setRetainInstance(true)</code> 来指示系统在配置更改时保留 <code>Fragment</code> 实例。这样，<code>Fragment</code> 的 <code>ViewModelStore</code> 也会随之保留。</li>
<li>当 <code>Fragment</code> 被重新创建时，它会附加到新的 <code>Activity</code> 上，但其 <code>ViewModelStore</code> 会保持不变，从而保留了其中的 <code>ViewModel</code> 实例。</li>
</ul>
</li>
</ol>
<h3 id="onRetainNonConfigurationInstance-和onSaveInstanceState-的区别"><a href="#onRetainNonConfigurationInstance-和onSaveInstanceState-的区别" class="headerlink" title="onRetainNonConfigurationInstance() 和onSaveInstanceState()的区别"></a><code>onRetainNonConfigurationInstance()</code> 和onSaveInstanceState()的区别</h3><ol>
<li>颗粒度不一样。<strong>onSaveInstanceState()<strong>是保存到Bundle</strong>中，只能保存</strong>Bundle<strong>能接受的数据类型，比如一些基本类型的数据。而</strong>onRetainNonConfigurationInstance() 可以保存任何类型的数据，数据类型是<strong>Object</strong></li>
<li><strong>onSaveInstanceState()数据最终存储到ActivityManagerService</strong>的ActivityRecord中了，也就是存到<strong>系统进程</strong>中去了。而<strong>onRetainNonConfigurationInstance()</strong> 数据是存储到<strong>ActivityClientRecord</strong>中（ActivityClientRecord是一个静态类），也就是存到<strong>应用本身的进程</strong>中了</li>
<li><strong>onSaveInstanceState</strong>存到系统进程中，所以App被杀之后还是能恢复的。而<strong>onRetainNonConfigurationInstance</strong>存到本身进程中，App被杀是没法恢复的。</li>
</ol>
<h3 id="activity被销毁ViewModel怎么监听的？"><a href="#activity被销毁ViewModel怎么监听的？" class="headerlink" title="activity被销毁ViewModel怎么监听的？"></a>activity被销毁ViewModel怎么监听的？</h3><p>​		<code>ViewModel</code> 并不直接监听 <code>Activity</code> 的销毁事件。相反，<code>ViewModel</code> 的生命周期是通过 <code>ViewModelStore</code> 和 <code>ViewModelProvider</code> 来管理的。当 <code>Activity</code> 被销毁时，<code>Activity</code> 的 <code>ViewModelStore</code> 会被清理，这会导致存储在其中的所有 <code>ViewModel</code> 实例被清除。</p>
<p>​		<code>ViewModel</code> 不直接监听 <code>Activity</code> 的销毁，而是通过 <code>ViewModelStore</code> 的清理机制来响应 <code>Activity</code> 生命周期的结束，从而在适当的时候执行清理操作。</p>
<h3 id="ViewModelStore什么时候会被销毁？"><a href="#ViewModelStore什么时候会被销毁？" class="headerlink" title="ViewModelStore什么时候会被销毁？"></a>ViewModelStore什么时候会被销毁？</h3><p><code>ViewModelStore</code> 会在以下情况下被清理：</p>
<ol>
<li><strong>非配置更改的销毁</strong>：当 <code>Activity</code> 或 <code>Fragment</code> 被永久销毁（而不是由于配置更改，如屏幕旋转）时，例如当用户按下返回键或者调用了 <code>finish()</code> 方法，<code>ViewModelStore</code> 会被清理。这意味着存储在 <code>ViewModelStore</code> 中的所有 <code>ViewModel</code> 实例都会被清除，它们的 <code>onCleared()</code> 方法会被调用。</li>
<li><strong>显式调用清理方法</strong>：在一些特殊情况下，开发者可以通过调用 <code>ViewModelStore</code> 的 <code>clear()</code> 方法来显式清理 <code>ViewModelStore</code>。这通常用于特定的清理逻辑，比如在单元测试中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ComponentActivity</span><br><span class="line"><span class="title function_">getLifecycle</span><span class="params">()</span>.addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">                    <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    <span class="comment">// Clear out the available context</span></span><br><span class="line">                    mContextAwareHelper.clearAvailableContext();</span><br><span class="line">                    <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">                    <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                        getViewModelStore().clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mReportFullyDrawnExecutor.activityDestroyed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="一个Activity有多个ViewModel，怎么单独删除其中一个"><a href="#一个Activity有多个ViewModel，怎么单独删除其中一个" class="headerlink" title="一个Activity有多个ViewModel，怎么单独删除其中一个"></a>一个Activity有多个ViewModel，怎么单独删除其中一个</h3><p>首先看下ViewModelStorez怎么管理的ViewModel对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> map = mutableMapOf&lt;String, ViewModel&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">String</span>, viewModel: <span class="type">ViewModel</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> oldViewModel = map.put(key, viewModel)</span><br><span class="line">        oldViewModel?.onCleared()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the `ViewModel` mapped to the given `key` or null if none exists.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(key: <span class="type">String</span>)</span></span>: ViewModel? &#123;</span><br><span class="line">        <span class="keyword">return</span> map[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">keys</span><span class="params">()</span></span>: Set&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> HashSet(map.keys)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (vm <span class="keyword">in</span> map.values) &#123;</span><br><span class="line">            <span class="comment">// 此处的clear是ViewModel的clear方法</span></span><br><span class="line">            vm.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        map.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果真的要删除的话只能从map入手，通过反射来删除对应的ViewModel对象。</p>
<p>首先获取key</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> DEFAULT_KEY = <span class="string">&quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">get</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">    	<span class="comment">// 类的完全限定名</span></span><br><span class="line">        <span class="keyword">val</span> canonicalName = modelClass.canonicalName</span><br><span class="line">            ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">get</span>(<span class="string">&quot;<span class="variable">$DEFAULT_KEY</span>:<span class="variable">$canonicalName</span>&quot;</span>, modelClass)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		在 Java 和 Kotlin 中，<code>canonicalName</code> 是一个类的完全限定名（fully qualified name），它包括包名和类名，但不包括内部类的外部类名。使用 <code>canonicalName</code> 的主要目的是确保获取的类名是全局唯一的，这样可以在不同的上下文中准确地引用到这个类。</p>
<p>反射删除源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过反射获取 ViewModelProvider 的 DEFAULT_KEY</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDefaultKeyViaReflection</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用反射访问 ViewModelProvider 类中名为 &quot;DEFAULT_KEY&quot; 的静态字段</span></span><br><span class="line">        <span class="keyword">val</span> field: Field = ViewModelProvider::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;DEFAULT_KEY&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置字段为可访问，允许读取私有和受保护字段</span></span><br><span class="line">        field.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 获取静态字段的值，这里传递 &#x27;null&#x27; 因为静态字段不需要对象实例</span></span><br><span class="line">        field.<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span>? String</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NoSuchFieldException) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，如果没有找到字段，则打印异常并返回 null</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，如果字段不可访问，则打印异常并返回 null</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 DEFAULT_KEY 和 ViewModel 类名来构建 key，并尝试从 ViewModelStore 中移除对应的 ViewModel 实例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ViewModelStore.<span class="title">removeViewModel</span><span class="params">(viewModelClass: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">ViewModel</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过之前定义的函数获取 DEFAULT_KEY</span></span><br><span class="line">    <span class="keyword">val</span> defaultKey = getDefaultKeyViaReflection() ?: <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 获取 ViewModel 类的规范名，如果为空则抛出异常</span></span><br><span class="line">    <span class="keyword">val</span> viewModelKey = viewModelClass.canonicalName ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Class name is null&quot;</span>)</span><br><span class="line">    <span class="comment">// 构建用于标识 ViewModel 实例的完整 key</span></span><br><span class="line">    <span class="keyword">val</span> fullKey = <span class="string">&quot;<span class="variable">$defaultKey</span>:<span class="variable">$viewModelKey</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用反射访问 ViewModelStore 类中名为 &quot;mMap&quot; 的私有字段</span></span><br><span class="line">        <span class="keyword">val</span> mapField = ViewModelStore::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置字段为可访问</span></span><br><span class="line">        mapField.isAccessible = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 获取该实例的 mMap 属性，它是一个存储 ViewModel 的 HashMap</span></span><br><span class="line">        <span class="keyword">val</span> map = mapField.<span class="keyword">get</span>(<span class="keyword">this</span>) <span class="keyword">as</span>? HashMap&lt;String, ViewModel&gt;</span><br><span class="line">        <span class="comment">// 如果 HashMap 存在，尝试移除对应 key 的 ViewModel 实例</span></span><br><span class="line">        map?.remove(fullKey)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NoSuchFieldException) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，如果没有找到字段，则打印异常</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IllegalAccessException) &#123;</span><br><span class="line">        <span class="comment">// 捕获异常，如果字段不可访问，则打印异常</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		<code>ViewModel</code> 的设计初衷是为了存储和管理与 UI 相关的数据，其生命周期是自动管理的。如果你需要在逻辑上“删除”一个 <code>ViewModel</code>，最好是重构你的数据管理策略，使其符合 <code>ViewModel</code> 的生命周期管理方式。</p>
<h3 id="使用ViewModel进行界面间的数据传递"><a href="#使用ViewModel进行界面间的数据传递" class="headerlink" title="使用ViewModel进行界面间的数据传递"></a>使用ViewModel进行界面间的数据传递</h3><h4 id="同一个Activity的fragment-之间共享数据"><a href="#同一个Activity的fragment-之间共享数据" class="headerlink" title="同一个Activity的fragment 之间共享数据"></a>同一个Activity的fragment 之间共享数据</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> sharedData = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ViewModel被Activity引用的话，它的对象就会被保存到这个Activity的ViewModelStore中。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentA</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: SharedViewModel <span class="keyword">by</span> viewModels(&#123; requireActivity() &#125;)</span><br><span class="line">    <span class="comment">// 这两种创建方式等价</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> activityViewModels&lt;SharedViewModel&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentB</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: SharedViewModel <span class="keyword">by</span> viewModels(&#123; requireActivity() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Activity与其内部的Fragment进行数据"><a href="#Activity与其内部的Fragment进行数据" class="headerlink" title="Activity与其内部的Fragment进行数据"></a>Activity与其内部的Fragment进行数据</h4><p>与上面同理</p>
<h4 id="不同Activity的fragment-之间共享数据"><a href="#不同Activity的fragment-之间共享数据" class="headerlink" title="不同Activity的fragment 之间共享数据"></a>不同Activity的fragment 之间共享数据</h4><ol>
<li>使用 Application 级别的 ViewModel：<br>你可以创建一个 Application 级别的 ViewModel，这样不同的 Activity 和它们的 Fragment 都可以访问同一个 ViewModel 实例。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class="line">    <span class="keyword">val</span> sharedData = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> sharedViewModel: SharedViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>, ViewModelProvider.AndroidViewModelFactory.getInstance(<span class="keyword">this</span>))</span><br><span class="line">            .<span class="keyword">get</span>(SharedViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Fragment 中获取 Application 级别的 ViewModel</span></span><br><span class="line"><span class="keyword">val</span> sharedViewModel = (activity?.application <span class="keyword">as</span>? MyApplication)?.sharedViewModel</span><br></pre></td></tr></table></figure>

<h4 id="Activity之间共享数据"><a href="#Activity之间共享数据" class="headerlink" title="Activity之间共享数据"></a>Activity之间共享数据</h4><ol>
<li>两个 Activity 想要共享同一个 ViewModel，就必须从一个 ViewModelStore 中获取。</li>
<li>ViewModel 被两个 Activity 持有，那么一个 Activity 销毁时，ViewModel 并不能销毁，如果销毁掉 ViewModel，那么另一个 Activity 就无法使用 ViewModel。因此要考虑好资源释放的问题，防止内存泄漏。解决方案是：当持有 ViewModel 的所有 Activity 都销毁时，才销毁该 ViewModel，同时销毁创建该 ViewModel 的 ViewModelStore。</li>
<li>每个共享的ViewModel对应一个唯一的ViewModelStore，然后将这个ViewModelStore通过静态map存储为全局的</li>
<li>当这个ViewModel的使用者都销毁后就将对应的ViewModelStore也销毁，可以通过监听activity的lifecycle实现</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 HashMap，key 为 scopeName，value 为 ViewModelStoreOwner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cache: HashMap&lt;String, ShareViewModelStoreOwner&gt; = hashMapOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义StoreOwner类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareViewModelStoreOwner</span> : <span class="type">ViewModelStoreOwner</span> &#123;</span><br><span class="line">	<span class="comment">// 创建使用activit集合</span></span><br><span class="line">    <span class="keyword">var</span> activityList = arrayListOf&lt;ComponentActivity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bindHost</span><span class="params">(componentActivity: <span class="type">ComponentActivity</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activityList.contains(componentActivity)) &#123;</span><br><span class="line">            activityList.add(componentActivity)</span><br><span class="line">        &#125;</span><br><span class="line">        componentActivity.lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    activityList.remove(componentActivity)</span><br><span class="line">                    <span class="keyword">if</span> (activityList.isEmpty()) &#123;</span><br><span class="line">                        cache.entries.find &#123; it.value == <span class="keyword">this</span><span class="symbol">@ShareViewModelStoreOwner</span> &#125;?.also &#123;</span><br><span class="line">                            viewModelStore.clear()</span><br><span class="line">                            cache.remove(it.key)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> viewModelStore: ViewModelStore</span><br><span class="line">        <span class="keyword">get</span>() = ViewModelStore()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> shareViewModel: ShareViewModel =</span><br><span class="line">						ViewModelProvider(cache[<span class="string">&quot;share&quot;</span>]!!)[ShareViewModel::<span class="keyword">class</span>.java]</span><br></pre></td></tr></table></figure>

<p>​			ViewModel使用ViewModelProvider创建，然后需要传入一个 ViewModelStore，这个ViewModelStore就是存储ViewMode的。</p>
<p>多个activity使用同一个ViewModel就需要是从同一个ViewModelStore中创建的对象。</p>
<p>上面可以再优化使用</p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​		<strong>LiveData 是可感知生命周期的，可观察的，数据持有者</strong>。LiveData 可以和生命周期绑定，当 Activity 和 Fragment 处于活跃状态时才进行数据回调，并在 Lifecycle 处于销毁状态（DESTROYED）时自动移除数据监听行为，从而避免了常见的内存泄露和 NPE 问题</p>
<p>​		<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/lifecycle/LiveData"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，<code>LiveData</code> 具有生命周期感知能力，意指它遵循其他应用组件（如 <code>activity</code>、<code>fragment</code> 或 <code>service</code>）的生命周期。这种感知能力可确保 <code>LiveData</code> 仅更新处于活跃生命周期状态的应用组件观察者</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData = MutableLiveData&lt;String&gt;()</span><br><span class="line">liveData.value = <span class="string">&quot;新的值&quot;</span></span><br><span class="line"></span><br><span class="line">liveData.observe(<span class="keyword">this</span>, Observer &#123; value -&gt;</span><br><span class="line">    <span class="comment">// 更新界面</span></span><br><span class="line">    textView.text = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h4><p>看注册监听的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="comment">//限定只能在主线程调用 observe 方法</span></span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//当 Lifecycle 已经处于 DESTROYED 状态时，此时进行 observe 是没有意义的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据传入参数构建一个新的代理 Observer</span></span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//observer 之前已经和同个 owner 一起传进来过了，此处直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将观察者和Lifecycle持有者绑定起来</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个方法有两个参数LifecycleOwner和Observer，LifecycleOwner的实现类有ComponentActivity和Fragment,Observer是一个接口,里面就一个方法onChanged。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Observer<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在observe方法中owner是观察者的生命周期所有者，observer是观察者对象。两者一起被封装为一个LifecycleBoundObserver对象，LifecycleBoundObserver是抽象类 ObserverWrapper 的实现类。ObserverWrapper 用于包装外部传进来的 Observer 对象，为子类定义好特定的抽象方法和共用逻辑，主要是提供了共用的状态分发方法。</p>
<h4 id="状态回调"><a href="#状态回调" class="headerlink" title="状态回调"></a>状态回调</h4><p>状态的定义在抽象类Lifecycle的一个枚举类中，共五种</p>
<ul>
<li><code>DESTROYED</code>：销毁状态。此状态后，不会再派发任何事件。</li>
<li><code>INITIALIZED</code>：初始化状态。此状态下，<code>LifecycleOwner</code> 已构造但尚未到 <code>onCreate</code>方法执行。</li>
<li><code>CREATED</code>：创建状态。此状态在两种情况下达到：<code>onCreate</code> 调用后；<code>onStop</code> 调用前。</li>
<li><code>STARTED</code>：启动状态。此状态在两种情况下达到：<code>onStart</code> 调用后；<code>onPause</code> 调用前。</li>
<li><code>RESUMED</code>：恢复状态。此状态在 <code>onResume</code> 调用后达到。</li>
</ul>
<p>​		LifecycleBoundObserver 也实现了 LifecycleEventObserver 接口，从而可以收到 Lifecycle 的每次生命周期事件切换时的事件回调。其整个事件流程是这样的：</p>
<ol>
<li>Lifecycle 的生命周期发生变化，从而回调 onStateChanged 方法</li>
<li>onStateChanged 方法首先判断 Lifecycle 是否已处于 DESTROYED 状态，是的话则直接移除 Observer，整个回调流程结束，否则继续以下流程</li>
<li>onStateChanged 通过 activeStateChanged 方法来判断 Lifecycle 是否从非活跃状态切换到了活跃状态，是的话则调用 dispatchingValue 方法来分发值，dispatchingValue 方法会根据 ObserverWrapper 内部的 mLastVersion 来判断是否有新值需要向外部 Observer 进行回调，是的话则向其回调新值，否则结束流程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有当 Lifecycle 的当前状态是 STARTED 或者 RESUMED 时</span></span><br><span class="line">        <span class="comment">// 而STARTED 和 RESUMED对应的生命周期为onStart到onStop之前</span></span><br><span class="line">        <span class="comment">// 才认为 Lifecycle 是处于活跃状态</span></span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//感知生命周期变化</span></span><br><span class="line">    <span class="comment">//当 Lifecycle 的生命周期状态发生变化时就会调用此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Lifecycle 已经处于 DESTROYED 状态了,则主动移除 mObserver</span></span><br><span class="line">        <span class="comment">// 这就是 LiveData 可以避免内存泄露最重要的一个点</span></span><br><span class="line">        Lifecycle.<span class="type">State</span> <span class="variable">currentState</span> <span class="operator">=</span> mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        <span class="keyword">if</span> (currentState == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	Lifecycle.<span class="type">State</span> <span class="variable">prevState</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        	<span class="comment">// 此处使用循环，为了保证在处理当前状态过程中状态又发生了改变。</span></span><br><span class="line">        	<span class="comment">// 循环确保捕获并处理这些变化，直到没有更多的状态变化发生。 </span></span><br><span class="line">            <span class="keyword">while</span> (prevState != currentState) &#123;</span><br><span class="line">                prevState = currentState;</span><br><span class="line">                activeStateChanged(shouldBeActive());</span><br><span class="line">                currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//移除 mObserver</span></span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>当owner的生命周期发生改变会回调到LifecycleBoundObserver的onStateChanged方法</strong>,这个方法里会判断owner是否走到了<code>DESTROYED</code>，走到了会移除这个owner的观察者。不是<code>DESTROYED</code>的话会对状态进行分类处理，当前状态是 STARTED 或者 RESUMED 时认为 Lifecycle 是处于活跃状态，否则是不活跃状态。然后将活跃还是不活跃传入activeStateChanged方法。		</p>
<p>​		activeStateChanged 方法的实现在抽象类ObserverWrapper中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># ObserverWrapper</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="comment">//判断当前 LiveData 所有的 Observer 是否都处于非活跃状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新 LiveData 当前所有处于活跃状态的 Observer 的数量</span></span><br><span class="line">        LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 LiveData 处于活跃状态的 Observer 数量从 0 变成了 1,</span></span><br><span class="line">            <span class="comment">//则回调 onActive 方法</span></span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 LiveData 处于活跃状态的 Observer 数量从 1 变成了 0,</span></span><br><span class="line">            <span class="comment">//则回调 onInactive 方法</span></span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 mObserver 变成了活跃状态，则向其回调新值，走到这里说明之前一定是非活跃状态</span></span><br><span class="line">            dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		上面的onStateChanged方法和activeStateChanged是关于LifecycleOwner 的生命周期发生变化后LiveData的回调处理，在observe这个方法中将观察者observer和观察者的生命周期所有者owner封装了一个LifecycleBoundObserver对象，在方法的最后通过<code>owner.getLifecycle().addObserver(wrapper)</code>将这个对象加入到了owner的观察者列表中。</p>
<blockquote>
<p>状态有三种：</p>
<ul>
<li>销毁：DESTROYED</li>
<li>非活跃：INITIALIZED、CREATED</li>
<li>活跃：STARTED、RESUMED</li>
</ul>
</blockquote>
<p>​		activeStateChanged方法首先会进行判断该状态是否改变，如果是活跃态会调用 dispatchingValue 方法来分发值，dispatchingValue 方法会根据 ObserverWrapper 内部的 mLastVersion 来判断是否有新值需要向外部 Observer 进行回调，是的话则向其回调新值，否则结束流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果是观察者首次订阅会走到这里</span></span><br><span class="line">            <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// LiveData执行了setValue会通知所有观察者</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="comment">//如果 observer 处于非活跃状态，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处判断主要是为了照顾 LifecycleBoundObserver</span></span><br><span class="line">    <span class="comment">//由于 Lifecycle 有可能状态值 State 已经切换到了非活跃状态，但 LifecycleBoundObserver 还未收到事件通知</span></span><br><span class="line">    <span class="comment">//所以为了避免意外情况，此处主动检查 observer 的活跃状态并判断是否需要更新其活跃状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 observer 本部的 value 版本号 mLastVersion 来决定是否需要向其进行回调</span></span><br><span class="line">    <span class="comment">//为了避免重复向某个 observer 回调值，所以此处需要判断下</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个mLastVersion是每个观察者自身维护的在ObserverWrapper内，然后LiveData自身也有一个计数mVersion来标志状态，对比的mLastVersion和mVersion来判断是否需要发送消息。</p>
<p>从dispatchingValue和considerNotify这两个方法的逻辑可以看出LiveData的特点：</p>
<ul>
<li><p>LiveData 只会在 LifecycleOwner 处于活跃状态的时候才进行事件分发。</p>
</li>
<li><p>自主解绑逻辑</p>
<blockquote>
<p>Activity走到DESTORY状态LiveData会通过mOwner.getLifecycle().removeObserver(this)解绑监听</p>
</blockquote>
</li>
<li><p>LiveData会保证订阅者总能在值变化的时候观察到最新的值，并且每个<strong>初次订阅的观察者</strong>都会执行一次回调方法。</p>
<blockquote>
<p>这个特点会导致一个粘性事件的问题：数据倒灌</p>
<p>由于 <code>LiveData</code> 会在观察者活跃时将最新的数据通知给观察者，则会产生「<strong>粘性事件</strong>」的情况。</p>
<p>如点击 button 弹出一个 Snackbar，在屏幕旋转时，<code>lifecycleOwner</code> 重建，新的观察者会再次调用 <code>Livedata#observe()</code>，因此 Snackbar 会再次弹出。</p>
</blockquote>
</li>
<li><p>LiveData的合并策略将最新一条之前的事件全部丢弃。</p>
<blockquote>
<p>默认不防抖，<code>setValue()/postValue()</code> 传入相同的值多次调用，观察者的 <code>onChanged()</code> 会被多次调用。</p>
</blockquote>
</li>
<li><p>同一个状态在一个UI刷新周期之内发生两次变动，LiveData只会展示最后一个。</p>
<blockquote>
<p>存在仅有部分 Observer 收到了回调，其它 Observer 又没有的可能性。当单线程连续传值或者多线程同时传值时，假设是先后传 valueA 和 valueB，最终可能只有部分 Observer 接收到了 valueA，所有 Observer 都接收到了 valueB</p>
</blockquote>
</li>
</ul>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> postTask;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            postTask = mPendingData == NOT_SET;</span><br><span class="line">            mPendingData = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mPostValueRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeOnMainThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postToMainThread(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postToMainThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mMainHandler = createAsync(Looper.getMainLooper());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Handler抛回了主线程</span></span><br><span class="line">        mMainHandler.post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// UI线程</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发送消息最后还是调用dispatchingValue，这部分逻辑看上一节。</p>
<h4 id="LiveData-数据重放原因分析"><a href="#LiveData-数据重放原因分析" class="headerlink" title="LiveData 数据重放原因分析"></a>LiveData 数据重放原因分析</h4><p>LiveData 的数据重放问题也叫作数据倒灌、粘性事件，核心源码在 LiveData#considerNotify(Observer) 中：</p>
<ul>
<li>首先，LiveData 和观察者各自会持有一个版本号 version，每次 LiveData#setValue 或 postValue 后，LiveData 持有的版本号会自增 1。在 LiveData#considerNotify(Observer) 尝试分发数据时，会判断观察者持有版本号是否小于 LiveData 的版本号（Observer#mLastVersion &gt;&#x3D; LiveData#mVersion 是否成立），如果成立则说明这个观察者还没有消费最新的数据版本。</li>
<li>而观察者的持有的初始版本号是 -1，因此当注册新观察者并且正好宿主的生命周期是大于等于可见状态（STARTED）时，就会尝试分发数据，这就是数据重放。</li>
</ul>
<p>为什么 Google 要把 LiveData 设计为粘性呢？LiveData 重放问题需要区分场景来看 —— 状态适合重放，而事件不适合重放：</p>
<ul>
<li>当 LiveData 作为一个状态使用时，在注册新观察者时重放已有状态是合理的；</li>
<li>当 LiveData 作为一个事件使用时，在注册新观察者时重放已经分发过的事件就是不合理的。</li>
</ul>
<h4 id="LiveData-数据重放问题的解决方案"><a href="#LiveData-数据重放问题的解决方案" class="headerlink" title="LiveData 数据重放问题的解决方案"></a>LiveData 数据重放问题的解决方案</h4><p><strong>Event 事件包装器：</strong></p>
<p>​		内部使用一个标志位标记事件是否已经被消费过。这样的话，当观察者收到重放的数据时，由于其中的标记位已经显示被消费，因此会抛弃该事件。</p>
<p>​		Google 官方的方案SingeLiveData 就是基于这种思路。不过，虽然这个方法能够解决数据倒灌问题，但是会有副作用：对于多个观察者的情况，只允许第一个观察者消费，而后续的观察者无法消费实现，这一般是不能满足需求的。</p>
<p><strong>反射修改观察者版本号：</strong></p>
<p>​		实现方法是在注册新观察者时，通过反射的手段将观察者持有的版本号（Observer#mLastVersion）同步为 LiveData 的版本号。缺点是使用反射，但确实能够解决多观察者问题。</p>
<p>思路：本质上LiveData观察者应该接收的最新的数据，而不应该接收旧的数据。根据上面&lt;LiveData 数据重放原因分析&gt;可知，通过修改观察者版本号为LiveData的版本号来避免初次订阅的回调。</p>
<p><strong>使用ShareFlow：</strong></p>
<p>将可重放参数设置为0。</p>
<h4 id="使用优势"><a href="#使用优势" class="headerlink" title="使用优势"></a>使用优势</h4><p>LiveData被推荐使用的优势 ：</p>
<ol>
<li><strong>数据符合页面状态</strong>：LiveData 遵循观察者的生命周期，确保数据状态与页面状态相符。</li>
<li><strong>不会发生内存泄露</strong>：Observers 是绑定到 Lifecycle 对象上的，当Lifecycle 被销毁时所有与之关联的观察者都会自动被清理。</li>
<li><strong>防止因 Activity 停止而导致崩溃</strong>：在观察者非活跃状态下不会消费事件。当 Observer 所绑定的 Lifecycle 处于非活跃状态时，比如处于返回栈中的 Activity，它将不会收到任何 LiveData 事件。</li>
<li><strong>简化生命周期处理</strong>：自动处理生命周期，无需手动管理。UI 组件只需要对相关的数据进行监听，不需要关心是否应该暂停或者恢复监听。LiveData 具有生命周期感知能力，它会自动对这些进行管理。</li>
<li><strong>数据始终保持最新状态</strong>：LiveData 仅持有单个且最新的数据。如果一个 Lifecycle 处于非活跃状态，那当它由非活跃状态变为活跃状态的时候，它将收到最新的数据。比如一个 Activity 由后台转为前台，这时候它将立即收到最新的数据</li>
<li><strong>资源共享</strong>：可用于不同组件间的数据共享。我们可以使用单例模式来扩展 LiveData，这样就能达到数据变化的时候，通知所有的观察者。</li>
<li>提供「可读可写」和「仅可读」两个版本收缩权限</li>
</ol>
<h4 id="LiveData-存在的局限"><a href="#LiveData-存在的局限" class="headerlink" title="LiveData 存在的局限"></a>LiveData 存在的局限</h4><ol>
<li><strong>LiveData 数据重放问题：</strong> 注册新的订阅者，会重新收到 LiveData 存储的数据，这在有些情况下不符合预期</li>
<li><strong>LiveData 不防抖问题：</strong> 重复 setValue 相同的值，订阅者会收到多次 <code>onChanged()</code> 回调</li>
<li><strong>LiveData 只能在主线程更新数据：</strong> 只能在主线程 setValue，即使 postValue 内部也是切换到主线程执行；</li>
<li><strong>LiveData 丢失数据问题：</strong> 在数据生产速度 &gt; 数据消费速度时，LiveData 无法观察者能够接收到全部数据。比如在子线程大量 <code>postValue</code> 数据但主线程消费跟不上时，中间就会有一部分数据被忽略。</li>
</ol>
<h4 id="LiveDataBus"><a href="#LiveDataBus" class="headerlink" title="LiveDataBus"></a>LiveDataBus</h4><p>用LiveDataBus替代EventBus和RxBus，实现全局通信，使用LiveData的理由：</p>
<ul>
<li><strong>LiveData具有的这种可观察性和生命周期感知的能力，使其非常适合作为Android通信总线的基础构件。</strong></li>
<li><strong>使用者不用显示调用反注册方法。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LiveDataBus</span> &#123;</span><br><span class="line">	<span class="comment">// 使用哈希表保存事件名到 LiveData 的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MutableLiveData&lt;Object&gt;&gt; bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LiveDataBus</span><span class="params">()</span> &#123;</span><br><span class="line">        bus = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LiveDataBus</span> <span class="variable">DATA_BUS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveDataBus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LiveDataBus <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.DATA_BUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; MutableLiveData&lt;T&gt; <span class="title function_">getChannel</span><span class="params">(String target, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bus.containsKey(target)) &#123;</span><br><span class="line">            bus.put(target, <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (MutableLiveData&lt;T&gt;) bus.get(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Object&gt; <span class="title function_">getChannel</span><span class="params">(String target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getChannel(target, Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册订阅：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LiveDataBus.get().getChannel(<span class="string">&quot;key_test&quot;</span>, Boolean.class)</span><br><span class="line">        .observe(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Observer</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> Boolean aBoolean)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LiveDataBus.get().getChannel(<span class="string">&quot;key_test&quot;</span>).setValue(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>解决数据倒灌问题：</p>
<p>使用反射hook观察者的version</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pengxurui/p/16490951.html">LiveData 还有学习的必要吗？—— Jetpack 系列（2）</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/07/26/android-livedatabus.html">Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7173494700081414181?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-9">由浅入深，详解 LiveData 的那些事</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7049147565815627789?searchId=20240311223609A4D4BE3FD45BCBFD2D76">Jetpack MVVM 七宗罪之五: 在 Repository 中使用 LiveData</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7007602776502960165?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-2">不做跟风党，LiveData，StateFlow，SharedFlow 使用场景对比</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6847902222345633806?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-3">从源码看 Jetpack（3）- LiveData 源码详解</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6903143273737814029?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-14">“终于懂了“系列：Jetpack AAC完整解析（二）LiveData 完全掌握！</a></p>
<p>LiveDataBus完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LiveDataBus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 LiveData 对象的容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BusMutableLiveData&lt;Object&gt;&gt; bus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，确保单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LiveDataBus</span><span class="params">()</span> &#123;</span><br><span class="line">        bus = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类实现单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LiveDataBus</span> <span class="variable">DEFAULT_BUS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiveDataBus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 LiveDataBus 实例的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LiveDataBus <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.DEFAULT_BUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定 key 的 LiveData 实例，如果不存在则创建一个新的 LiveData</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; MutableLiveData&lt;T&gt; <span class="title function_">with</span><span class="params">(String key, Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bus.containsKey(key)) &#123;</span><br><span class="line">            bus.put(key, <span class="keyword">new</span> <span class="title class_">BusMutableLiveData</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (MutableLiveData&lt;T&gt;) bus.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定 key 的 LiveData 实例，如果不存在则创建一个新的 LiveData，默认为 Object 类型</span></span><br><span class="line">    <span class="keyword">public</span> MutableLiveData&lt;Object&gt; <span class="title function_">with</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> with(key, Object.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observer 包装类，用于 hook observeForever 方法，避免内存泄漏</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObserverWrapper</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Observer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Observer&lt;T&gt; observer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ObserverWrapper</span><span class="params">(Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChanged</span><span class="params">(<span class="meta">@Nullable</span> T t)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isCallOnObserve()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                observer.onChanged(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是从 observeForever 方法调用的，如果是则返回 true</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCallOnObserve</span><span class="params">()</span> &#123;</span><br><span class="line">            StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (stackTrace != <span class="literal">null</span> &amp;&amp; stackTrace.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (StackTraceElement element : stackTrace) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;android.arch.lifecycle.LiveData&quot;</span>.equals(element.getClassName()) &amp;&amp;</span><br><span class="line">                            <span class="string">&quot;observeForever&quot;</span>.equals(element.getMethodName())) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的 MutableLiveData 类，用于 hook observeForever 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BusMutableLiveData</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">MutableLiveData</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察者的映射表，用于保存 ObserverWrapper 对象</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;Observer, Observer&gt; observerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.observe(owner, observer);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hook(observer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observeForever</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!observerMap.containsKey(observer)) &#123;</span><br><span class="line">                observerMap.put(observer, <span class="keyword">new</span> <span class="title class_">ObserverWrapper</span>(observer));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">super</span>.observeForever(observerMap.get(observer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> &#123;</span><br><span class="line">            <span class="type">Observer</span> <span class="variable">realObserver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observerMap.containsKey(observer)) &#123;</span><br><span class="line">                realObserver = observerMap.remove(observer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                realObserver = observer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">super</span>.removeObserver(realObserver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过反射修改 ObserverWrapper 的 mLastVersion 字段，避免内存泄漏</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;T&gt; observer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取 LiveData 的 Class 对象</span></span><br><span class="line">    Class&lt;LiveData&gt; classLiveData = LiveData.class;</span><br><span class="line">    <span class="comment">// 获取 LiveData 的 mObservers 字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldObservers</span> <span class="operator">=</span> classLiveData.getDeclaredField(<span class="string">&quot;mObservers&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置 mObservers 字段可访问</span></span><br><span class="line">    fieldObservers.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取 mObservers 字段的值，即 Observer 对象的映射表</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objectObservers</span> <span class="operator">=</span> fieldObservers.get(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 获取 mObservers 对象的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; classObservers = objectObservers.getClass();</span><br><span class="line">    <span class="comment">// 获取 mObservers 对象的 get 方法，用于获取 ObserverWrapper 对象</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">methodGet</span> <span class="operator">=</span> classObservers.getDeclaredMethod(<span class="string">&quot;get&quot;</span>, Object.class);</span><br><span class="line">    <span class="comment">// 设置 get 方法可访问</span></span><br><span class="line">    methodGet.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 调用 get 方法获取指定 Observer 对象对应的 ObserverWrapper 对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objectWrapperEntry</span> <span class="operator">=</span> methodGet.invoke(objectObservers, observer);</span><br><span class="line">    <span class="comment">// 初始化 objectWrapper 变量</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objectWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果 objectWrapperEntry 是 Map.Entry 对象，则获取其值作为 ObserverWrapper 对象</span></span><br><span class="line">    <span class="keyword">if</span> (objectWrapperEntry <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">        objectWrapper = ((Map.Entry) objectWrapperEntry).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 objectWrapper 为 null，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (objectWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Wrapper can not be bull!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 ObserverWrapper 的父类，即 LiveData$LifecycleBoundObserver 类</span></span><br><span class="line">    Class&lt;?&gt; classObserverWrapper = objectWrapper.getClass().getSuperclass();</span><br><span class="line">    <span class="comment">// 获取 ObserverWrapper 的 mLastVersion 字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldLastVersion</span> <span class="operator">=</span> classObserverWrapper.getDeclaredField(<span class="string">&quot;mLastVersion&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置 mLastVersion 字段可访问</span></span><br><span class="line">    fieldLastVersion.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取 LiveData 的 mVersion 字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldVersion</span> <span class="operator">=</span> classLiveData.getDeclaredField(<span class="string">&quot;mVersion&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置 mVersion 字段可访问</span></span><br><span class="line">    fieldVersion.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取 LiveData 的版本号</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objectVersion</span> <span class="operator">=</span> fieldVersion.get(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 修改 ObserverWrapper 的 mLastVersion 字段为 LiveData 的 mVersion 字段的值</span></span><br><span class="line">    fieldLastVersion.set(objectWrapper, objectVersion);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AppStartup"><a href="#AppStartup" class="headerlink" title="AppStartup"></a>AppStartup</h2><h3 id="三方库初始化"><a href="#三方库初始化" class="headerlink" title="三方库初始化"></a>三方库初始化</h3><p>一般是在Application的onCreate方法中调用三方库的初始化方法传入当前的context。</p>
<h3 id="ContentProvider-的启动过程"><a href="#ContentProvider-的启动过程" class="headerlink" title="ContentProvider 的启动过程"></a>ContentProvider 的启动过程</h3><p>​		<strong>ContentProvider 通常的用法是为当前进程 &#x2F; 远程进程提供内容服务，它们会在应用启动的时候初始化</strong>，正因如此，我们可以利用 ContentProvider 来获得 Context 。</p>
<p>​		ContentProvider#onCreate() 是早于 Application#onCreate() 执行的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    Log.e(<span class="string">&quot;ContextProvider&quot;</span>,<span class="string">&quot;初始化 <span class="variable">$context</span> -- <span class="subst">$&#123;application&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果每个第三方库都自己创建了一个ContentProvider，那么最终我们App的启动速度就会受到比较大的影响。</strong></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将所有用于初始化的ContentProvider合并成一个，从而使App的启动速度变得更快。在组件化中用于初始化组件的application</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>引入App Startup的库。</p>
</li>
<li><p>自定义一个用于初始化的Initializer。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LitePalInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取application执行 三方库的初始化逻辑</span></span><br><span class="line">        LitePal.initialize(context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>将自定义Initializer配置到AndroidManifest.xml当中。定义的顺序就是初始化的顺序</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;com.example.LitePalInitializer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">applicationContext</span> <span class="operator">=</span> context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">                AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StartupLogger.w(<span class="string">&quot;Deferring initialization because `applicationContext` is null.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StartupException</span>(<span class="string">&quot;Context cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存每个组件的初始化结果</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; mInitialized = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化此组件</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">doInitialize</span><span class="params">(Class&lt;? extends Initializer&lt;?&gt;&gt; component, Set&lt;Class&lt;?&gt;&gt; initializing)</span></span><br><span class="line">           <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (sLock) &#123; <span class="comment">// 1、对 sLock 加锁</span></span><br><span class="line">           Object result;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2、判断 initializing 中存在当前组件，说明存在循环依赖</span></span><br><span class="line">           <span class="keyword">if</span> (initializing.contains(component)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Cannot initialize %s. Cycle detected.&quot;</span>, component.getName());</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3、检查当前组件是否已初始化</span></span><br><span class="line">           <span class="keyword">if</span> (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">               <span class="comment">// 当前组件未初始化</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.1 记录正在初始化</span></span><br><span class="line">               initializing.add(component);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.2 通过反射实例化 Initializer 接口实现类</span></span><br><span class="line">               <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> component.getDeclaredConstructor().newInstance();</span><br><span class="line">               Initializer&lt;?&gt; initializer = (Initializer&lt;?&gt;) instance;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.3 遍历所依赖的组件</span></span><br><span class="line">               List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt;&gt; dependencies = initializer.dependencies();</span><br><span class="line">               <span class="keyword">if</span> (!dependencies.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                       <span class="comment">// 如果所依赖的组件未初始化，递归执行初始化</span></span><br><span class="line">                       <span class="keyword">if</span> (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                           doInitialize(clazz, initializing); <span class="comment">// 注意：这里将 initializing 作为参数传入</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.4 （到这里，所依赖的组件已经初始化完成）初始化当前组件</span></span><br><span class="line">               result = initializer.create(); <span class="comment">// 假设create方法不需要参数</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.5 移除正在初始化记录</span></span><br><span class="line">               initializing.remove(component);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3.1.6 缓存初始化结果</span></span><br><span class="line">               mInitialized.put(component, result);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 当前组件已经初始化，直接返回</span></span><br><span class="line">               result = mInitialized.get(component);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> (T) result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射实例化 Initializer 接口实现类，遍历所依赖的组件，如果所依赖的组件未初始化，递归执行初始化。</p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol>
<li>依赖</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation(libs.androidx.room.runtime)</span><br><span class="line">implementation(libs.androidx.room.ktx)</span><br><span class="line">kapt(libs.androidx.room.compiler)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建实体类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;user_entity&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Dao</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 设置主键冲突之后的策略，这里选择直接覆盖原数据</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除某条数据</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新某条数据</span></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查找数据</span></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;select * from user_entity where id=:id&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findUser</span><span class="params">(id: <span class="type">Int</span>)</span></span>: List&lt;UserEntity&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建DataBase</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [UserEntity::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RoomDb</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> sInstance: RoomDb? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATA_BASE_NAME = <span class="string">&quot;User.db&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: RoomDb? &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                synchronized(RoomDb::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        sInstance = createInstance(context)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: RoomDb? &#123;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(</span><br><span class="line">                context.applicationContext, RoomDb::<span class="keyword">class</span>.java, DATA_BASE_NAME</span><br><span class="line">            ).build()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoomViewModel</span>(<span class="keyword">val</span> application: Application) : AndroidViewModel(application) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testRoom</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> db = RoomDb.getInstance(application)</span><br><span class="line">        db?.getUserDao()?.findUser(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>数据库抽象层</strong>：Room是在SQLite之上的一个抽象层，它提供了更简洁的数据库访问机制，并减少了样板代码的编写。</li>
<li><strong>编译时SQL检查</strong>：Room在编译时会检查你的SQL查询语句，这有助于在早期发现潜在的问题和错误。</li>
<li><strong>LiveData和协程支持</strong>：Room天然支持LiveData和Kotlin协程，flow，这使得在Android应用中实现响应式编程和异步操作变得更加简单和直接。</li>
<li><strong>易用性和减少错误</strong>：通过使用注解和DAO（数据访问对象）模式，Room使得数据库的操作更加简洁明了，同时减少了因手动编写SQL而引入的错误。</li>
<li><strong>简单的数据库升级和迁移：</strong>Room 提供了一个直观的方式来处理数据库版本升级和迁移，通过定义数据库版本和迁移路径，可以轻松管理数据库结构的变化。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/23/Android%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/" title="Android本地存储"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android本地存储</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/23/Android%20Handler%E6%9C%BA%E5%88%B6/" title="Android Handler消息机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android Handler消息机制</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-JetPack"><span class="toc-number">1.</span> <span class="toc-text">Android JetPack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lifecycle"><span class="toc-number">1.1.</span> <span class="toc-text">Lifecycle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewModel"><span class="toc-number">1.2.</span> <span class="toc-text">ViewModel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewModelStore"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">ViewModelStore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Factory"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Factory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewModel%E9%94%80%E6%AF%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">ViewModel销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewModel%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%94%B9%E5%90%8E%E6%8C%81%E4%B9%85%E4%BF%9D%E7%95%99%E7%9B%B8%E5%BA%94%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.5.</span> <span class="toc-text">ViewModel怎么实现的配置更改后持久保留相应状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewModelStore-%E4%B8%8D%E4%BC%9A%E9%9A%8F-Activity-%E4%B8%80%E8%B5%B7%E9%94%80%E6%AF%81%EF%BC%8C%E8%80%8C%E6%98%AF%E4%BC%9A%E8%A2%AB%E4%BF%9D%E7%95%99%E4%B8%8B%E6%9D%A5%E3%80%82%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">ViewModelStore 不会随 Activity 一起销毁，而是会被保留下来。怎么做到的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onRetainNonConfigurationInstance-%E5%92%8ConSaveInstanceState-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.7.</span> <span class="toc-text">onRetainNonConfigurationInstance() 和onSaveInstanceState()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activity%E8%A2%AB%E9%94%80%E6%AF%81ViewModel%E6%80%8E%E4%B9%88%E7%9B%91%E5%90%AC%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.8.</span> <span class="toc-text">activity被销毁ViewModel怎么监听的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewModelStore%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%9F"><span class="toc-number">1.2.9.</span> <span class="toc-text">ViewModelStore什么时候会被销毁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAActivity%E6%9C%89%E5%A4%9A%E4%B8%AAViewModel%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8D%95%E7%8B%AC%E5%88%A0%E9%99%A4%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA"><span class="toc-number">1.2.10.</span> <span class="toc-text">一个Activity有多个ViewModel，怎么单独删除其中一个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ViewModel%E8%BF%9B%E8%A1%8C%E7%95%8C%E9%9D%A2%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.11.</span> <span class="toc-text">使用ViewModel进行界面间的数据传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AAActivity%E7%9A%84fragment-%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">同一个Activity的fragment 之间共享数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity%E4%B8%8E%E5%85%B6%E5%86%85%E9%83%A8%E7%9A%84Fragment%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.11.2.</span> <span class="toc-text">Activity与其内部的Fragment进行数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8CActivity%E7%9A%84fragment-%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.11.3.</span> <span class="toc-text">不同Activity的fragment 之间共享数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.11.4.</span> <span class="toc-text">Activity之间共享数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LiveData"><span class="toc-number">1.3.</span> <span class="toc-text">LiveData</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">注册监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%9E%E8%B0%83"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">状态回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LiveData-%E6%95%B0%E6%8D%AE%E9%87%8D%E6%94%BE%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">LiveData 数据重放原因分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LiveData-%E6%95%B0%E6%8D%AE%E9%87%8D%E6%94%BE%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">LiveData 数据重放问题的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">使用优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LiveData-%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">LiveData 存在的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LiveDataBus"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">LiveDataBus</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AppStartup"><span class="toc-number">1.4.</span> <span class="toc-text">AppStartup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%96%B9%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">三方库初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider-%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">ContentProvider 的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="toc-number">1.4.4.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Room"><span class="toc-number">1.5.</span> <span class="toc-text">Room</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.5.2.</span> <span class="toc-text">优势</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2024-04-23T14:33:30.774Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" title="网络面试题">网络面试题</a><time datetime="2024-04-23T14:33:30.773Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a><time datetime="2024-04-23T14:33:30.771Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E6%A3%80%E7%B4%A2/" title="检索">检索</a><time datetime="2024-04-23T14:33:30.768Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/23/%E9%B8%BF%E8%92%99/" title="鸿蒙">鸿蒙</a><time datetime="2024-04-23T14:33:30.767Z" title="发表于 2024-04-23 22:33:30">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>