<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Glide | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GlideGlide 默认内存缓存用的是弱引用+LruCache 取的顺序是：弱引用、LruCache、磁盘  存的顺序是：磁盘、弱引用、LruCache 内存缓存Glide设计了一个弱引用缓存，当从内存里面加载时，会先从弱引用里面获取图片资源； 为什么要多设计一层弱引用的缓存呢？ 这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！">
<meta property="og:type" content="article">
<meta property="og:title" content="Glide">
<meta property="og:url" content="https://zrmomo.github.io/2024/03/26/Glide/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="GlideGlide 默认内存缓存用的是弱引用+LruCache 取的顺序是：弱引用、LruCache、磁盘  存的顺序是：磁盘、弱引用、LruCache 内存缓存Glide设计了一个弱引用缓存，当从内存里面加载时，会先从弱引用里面获取图片资源； 为什么要多设计一层弱引用的缓存呢？ 这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-03-26T11:10:09.226Z">
<meta property="article:modified_time" content="2024-03-15T06:52:41.950Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/03/26/Glide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Glide',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-15 14:52:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Glide</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-26T11:10:09.226Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-15T06:52:41.950Z" title="更新于 2024-03-15 14:52:41">2024-03-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Glide"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h1><p>Glide 默认内存缓存用的是弱引用+LruCache</p>
<p>取的顺序是：弱引用、LruCache、磁盘 </p>
<p>存的顺序是：磁盘、弱引用、LruCache</p>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>Glide设计了一个弱引用缓存，当从内存里面加载时，会先从弱引用里面获取图片资源；</p>
<p>为什么要多设计一层弱引用的缓存呢？</p>
<p>这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！</p>
<p>那么设计了一个弱引用缓存的好处在于，没有触发GC的这段时间，可以重复的利用图片资源，减少从LruCache里的操作；</p>
<p>用弱引用保存正在使用的图片数据（正在使用的不能放在LRU内存缓存中，LRU有可能触发超过内存最大限制导致回收），当触发GC弱引用缓存被回收（说明此时不是正在使用的图片了）后又会被加到LRU缓存中。</p>
<p><strong>LruCache：</strong></p>
<p>LruCache 采用<strong>最近最少使用算法</strong>，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致OOM。</p>
<p><strong>LruCache底层实现：</strong></p>
<p>LruCache 构造方法里创建一个<strong>LinkedHashMap</strong>，accessOrder 参数传true，表示按照访问顺序排序，数据存储基于LinkedHashMap。</p>
<p>LinkedHashMap 的原理：LinkedHashMap 定义了一个全空的节点<strong>header</strong>拥有两个指针，after  和before。在添加新元素时在hashmap的的基础上再维护了一个双向链表。且最新添加的元素都在header的前面就是before的位置。从而<strong>链表头节点header的before是最新访问的数据，header的after则是最旧的数据。</strong></p>
<p><strong>LruCache 重写了LinkedHashMap 的trimToSize方法，判断内存如果超过一定大小，则移除最老的数据</strong></p>
<p><strong>小结：</strong>LinkHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（<strong>从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的</strong>）。</p>
<p>LruCache 内部用LinkHashMap存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面put数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。</p>
<h2 id="磁盘缓存-DiskLruCache"><a href="#磁盘缓存-DiskLruCache" class="headerlink" title="磁盘缓存 DiskLruCache"></a>磁盘缓存 DiskLruCache</h2><p>DiskLruCache 跟 LruCache 实现思路是差不多的，一样是设置一个总大小，每次往硬盘写文件，总大小超过阈值，就会将旧的文件删除。</p>
<h2 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h2><p>Glide缓存分为 弱引用+ LruCache+ DiskLruCache ，其中读取数据的顺序是：弱引用 &gt; LruCache &gt; DiskLruCache&gt;<br>网络；写入缓存的顺序是：网络 –&gt; DiskLruCache–&gt; LruCache–&gt;弱引用</p>
<h2 id="防止OOM"><a href="#防止OOM" class="headerlink" title="防止OOM"></a>防止OOM</h2><p>1.LruCache缓存大小设置</p>
<p>2.软引用：在发生OOM之前，垃圾回收器会回收SoftReference引用的对象。</p>
<p>3.onLowMemory：<strong>Activity、Fragment会调用<code>onLowMemory</code>方法，可以在这个方法里去清除缓存</strong></p>
<p>4.从Bitmap 像素存储位置考虑</p>
<p>Bitmap 之所以占内存大不是因为对象本身大，而是因为Bitmap的像素数据， <strong>Bitmap的像素数据大小 &#x3D; 宽 * 高 * 1像素占用的内存。</strong></p>
<h1 id="Glide-1"><a href="#Glide-1" class="headerlink" title="Glide"></a>Glide</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>添加依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.github.bumptech.glide:glide:5.0.0-rc01&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:5.0.0-rc01&#x27;</span></span><br></pre></td></tr></table></figure>

<p>代码使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="built_in">this</span>).load(URL).into(ivGlide)</span><br></pre></td></tr></table></figure>

<h2 id="with方法"><a href="#with方法" class="headerlink" title="with方法"></a>with方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中getRetriever 是单例的形式来向外提供唯一对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Glide</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title function_">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (glide == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">GeneratedAppGlideModule</span> <span class="variable">annotationGeneratedModule</span> <span class="operator">=</span></span><br><span class="line">          getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">      <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (glide == <span class="literal">null</span>) &#123;</span><br><span class="line">          checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​		传入的context又被传入了checkAndInitializeGlide方法，同时传入的还有一个GeneratedAppGlideModule对象，这个对象是由 Glide 的注解处理器在编译时生成的，包含了 Glide 配置的信息。然后里面又调用到了initializeGlide方法，这个方法的大致逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeGlide</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> GlideBuilder builder,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> GeneratedAppGlideModule annotationGeneratedModule)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Context</span> <span class="variable">applicationContext</span> <span class="operator">=</span> context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析清单文件中的 GlideModule</span></span><br><span class="line">  List&lt;GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule == <span class="literal">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">    manifestModules = <span class="keyword">new</span> <span class="title class_">ManifestParser</span>(applicationContext).parse();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排除指定的 GlideModule</span></span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="literal">null</span></span><br><span class="line">      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">    manifestModules.removeIf(<span class="keyword">module</span> -&gt; excludedModuleClasses.contains(<span class="keyword">module</span>.getClass()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用 GlideModule 的配置</span></span><br><span class="line">  <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">    <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="literal">null</span>) &#123;</span><br><span class="line">    annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建并注册 Glide 实例 这里也是用了构建者模式</span></span><br><span class="line">  <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> builder.build(applicationContext, manifestModules, annotationGeneratedModule);</span><br><span class="line">  applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">  Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法负责初始化 Glide，包括解析配置、应用配置选项，并构建 <code>Glide</code> 实例。</p>
<p>这个讲一下自定义配置的方式</p>
<p>想配置 Glide 的内存缓存大小，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyAppGlideModule</span> <span class="keyword">extends</span> <span class="title class_">AppGlideModule</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyOptions</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> GlideBuilder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置内存缓存大小为 20MB</span></span><br><span class="line">        builder.setMemoryCache(<span class="keyword">new</span> <span class="title class_">LruResourceCache</span>(<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在这个例子中，<code>MyAppGlideModule</code> 就是自定义的 Glide 模块，Glide 的注解处理器会根据它生成 <code>GeneratedAppGlideModule</code>，并在运行时使用它来配置 Glide。也可以进行其他自定义配置的操作具体可以参考<a target="_blank" rel="noopener" href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#%E9%81%BF%E5%85%8D%E5%9C%A8%E7%A8%8B%E5%BA%8F%E5%BA%93%E4%B8%AD%E4%BD%BF%E7%94%A8-appglidemodule">官网</a></p>
<p>​		上面通过单例的形式获取了Glide对象后通过getRequestManagerRetriever方法获取了RequestManagerRetriever对象，而RequestManagerRetriever是用来管理RequestManager的。具体来说，<code>RequestManagerRetriever</code> 的作用包括：</p>
<ol>
<li>**检索 <code>RequestManager</code>**：<code>RequestManagerRetriever</code> 提供了方法来获取不同上下文（如 <code>Activity</code>、<code>Fragment</code>、<code>ApplicationContext</code> 等）对应的 <code>RequestManager</code> 实例。这些 <code>RequestManager</code> 实例会根据它们所在的上下文来自动处理图像加载请求的暂停和恢复。</li>
<li><strong>管理 <code>RequestManager</code> 实例</strong>：<code>RequestManagerRetriever</code> 负责创建新的 <code>RequestManager</code> 实例（如果还不存在）并将它们与对应的上下文关联起来。它还确保同一个上下文使用同一个 <code>RequestManager</code> 实例，以避免不必要的资源消耗。</li>
<li><strong>处理生命周期事件</strong>：<code>RequestManagerRetriever</code> 与上下文的生命周期事件（如 <code>Activity</code> 的 <code>onStart</code>、<code>onStop</code>、<code>onDestroy</code> 等）相结合，以确保图像加载请求在适当的时间被暂停或恢复。这有助于优化资源使用和提高应用性能。</li>
</ol>
<p>根据上面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRetriever(activity).get(activity);</span><br></pre></td></tr></table></figure>

<p>最后返回的是一个RequestManager对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">          &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据上述规则可以得出以下几个结论：</p>
<ol>
<li>同一个 Activity 对应一个 FragmentManager，一个 FragmentManager 对应一个 RequestManagerFragment，一个 RequestManagerFragment 对应一个 RequestManager，所以<strong>一个 Activity 对应 一个 RequestManager</strong>；</li>
<li>同一个 Fragment 同样可得出上述结论；</li>
<li>但如果 Fragment 属于 Activity，或者 Fragment 属于 Fragment，在 Activity、Framgnent 中分别创建 Glide 请求是并不会只创建一个 RequestManager；</li>
<li><strong>子线程</strong>发起 Glide 请求或传入对象为 ApplicationContext，则使用全局单例的 RequestManager。</li>
</ol>
<p>上面代码中看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>看具体的重载逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># RequestManagerRetriever</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line">  assertNotDestroyed(activity);</span><br><span class="line">  frameWaiter.registerSelf(activity);</span><br><span class="line">  <span class="comment">// 判断Activity是否可见</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isActivityVisible</span> <span class="operator">=</span> isActivityVisible(activity);</span><br><span class="line">  <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(activity.getApplicationContext());</span><br><span class="line">  <span class="keyword">return</span> lifecycleRequestManagerRetriever.getOrCreate(</span><br><span class="line">      activity,</span><br><span class="line">      glide,</span><br><span class="line">      activity.getLifecycle(),</span><br><span class="line">      activity.getSupportFragmentManager(),</span><br><span class="line">      isActivityVisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后调用了getOrCreate方法，看到传入的几个参数应该知道是咋回事了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># LifecycleRequestManagerRetriever</span><br><span class="line">RequestManager <span class="title function_">getOrCreate</span><span class="params">(Context context,Glide glide,<span class="keyword">final</span> Lifecycle lifecycle,FragmentManager childFragmentManager,<span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">  Util.assertMainThread(); <span class="comment">// 确保在主线程中执行</span></span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">result</span> <span class="operator">=</span> getOnly(lifecycle); <span class="comment">// 尝试获取已存在的RequestManager实例</span></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123; <span class="comment">// 如果不存在，则创建新的实例</span></span><br><span class="line">    <span class="type">LifecycleLifecycle</span> <span class="variable">glideLifecycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleLifecycle</span>(lifecycle); <span class="comment">// 创建Glide的生命周期对象</span></span><br><span class="line">    result =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide,</span><br><span class="line">            glideLifecycle,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SupportRequestManagerTreeNode</span>(childFragmentManager),</span><br><span class="line">            context); <span class="comment">// 使用工厂方法创建RequestManager实例</span></span><br><span class="line">    lifecycleToRequestManager.put(lifecycle, result); <span class="comment">// 将新创建的实例与生命周期对象关联</span></span><br><span class="line">    glideLifecycle.addListener(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LifecycleListener</span>() &#123; <span class="comment">// 为Glide的生命周期对象添加监听器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;&#125; <span class="comment">// 生命周期开始时的回调（空实现）</span></span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;&#125; <span class="comment">// 生命周期停止时的回调（空实现）</span></span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123; <span class="comment">// 生命周期销毁时的回调</span></span><br><span class="line">            lifecycleToRequestManager.remove(lifecycle); <span class="comment">// 从映射中移除对应的RequestManager实例</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isParentVisible) &#123; <span class="comment">// 如果父组件可见</span></span><br><span class="line">      result.onStart(); <span class="comment">// 启动RequestManager，开始处理图片加载请求</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回RequestManager实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方法逻辑：</strong></p>
<ol>
<li>首先，调用<code>Util.assertMainThread()</code>确保方法在主线程中调用。</li>
<li>然后，尝试通过<code>getOnly(lifecycle)</code>从<code>lifecycleToRequestManager</code>映射中获取已存在的<code>RequestManager</code>实例。</li>
<li>如果不存在，就创建一个新的RequestManager实例：<ul>
<li>创建一个<code>LifecycleLifecycle</code>实例，它是一个自定义的生命周期对象，用于将Glide的生命周期与外部组件的生命周期同步。</li>
<li>使用<code>factory.build(...)</code>方法创建一个新的<code>RequestManager</code>实例，传入Glide实例、生命周期对象、一个用于支持请求管理的<code>SupportRequestManagerTreeNode</code>实例和上下文对象。</li>
<li>将新创建的<code>RequestManager</code>实例与对应的生命周期对象关联起来，存储在<code>lifecycleToRequestManager</code>映射中。</li>
<li>为<code>glideLifecycle</code>添加一个<code>LifecycleListener</code>监听器，当外部组件销毁时，从映射中移除对应的<code>RequestManager</code>实例。</li>
</ul>
</li>
<li>如果<code>isParentVisible</code>为<code>true</code>，表示父组件可见，那么调用<code>result.onStart()</code>使<code>RequestManager</code>开始处理图片加载请求。</li>
<li>最后，返回<code>RequestManager</code>实例。</li>
</ol>
<p>总的来说，这个方法的作用是确保每个生命周期对象关联一个唯一的<code>RequestManager</code>实例，用于管理该生命周期内的图片加载请求，并且确保在生命周期结束时正确地清理资源。</p>
<p>RequestManager 主要由两个作用：</p>
<ol>
<li>创建 RequestBuilder ；</li>
<li>通过生命周期管理请求的启动结束等。</li>
</ol>
<p>RequestBuilder的职责很明确，用于创建获取图片的请求，例如设置 RequestOption、缩略图、加载失败占位图等等；这个类使用了建造者模式来构建参数，这样有一个好处就是，可以很方便的添加各种各样复杂的参数</p>
<p>总结上面的逻辑：</p>
<p>​		首先获取单例glide对象，这个代码逻辑是在一个叫做initializeGlide的方法里面，这里面会解析应用GlideModule 的配置，然后通过构建者模式获取对象。然后通过获取的Glide对象获取了RequestManagerRetriever对象，这个对象是用来管理 <code>RequestManager</code> 实例的，然后根据传入的context类型返回对应的RequestManager。如果context是Fragment Activity的子类会注册进Fragment Activity的Lifecycle观察者队列里面，以此完成生命周期的控制。RequestManager会创建RequestBuilder。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>load方法最终的返回值是创建一个RequestBuilder<Drawable>，下面来看看创建的具体过程。</p>
<p>load方法传入的是一个字符串，最终会被传入SingleRequest这个类的构造中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># RequestBuilder</span><br><span class="line">RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">        <span class="comment">//只是简单地赋值</span></span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        isModelSet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只是简单的赋值，将url传递给RequestBuilder的成员。</p>
<h2 id="into方法"><a href="#into方法" class="headerlink" title="into方法"></a>into方法</h2><p>into方法开启了真正的资源查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(URL).into(ivGlide)</span><br></pre></td></tr></table></figure>

<p>into有好几个重载方法，这里以ivGlide为ImageView为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># RequestBuilder</span><br><span class="line"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title function_">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> &#123;</span><br><span class="line">  Util.assertMainThread(); <span class="comment">// 确保在主线程中执行</span></span><br><span class="line">  Preconditions.checkNotNull(view); <span class="comment">// 检查view是否为null</span></span><br><span class="line"></span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="built_in">this</span>; <span class="comment">// 获取当前的请求选项</span></span><br><span class="line">  <span class="comment">// 检查是否需要根据ImageView的ScaleType设置转换</span></span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet() <span class="comment">// 检查是否已设置转换</span></span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed() <span class="comment">// 检查是否允许转换</span></span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="literal">null</span>) &#123; <span class="comment">// 检查ImageView的ScaleType是否为null</span></span><br><span class="line">    <span class="comment">// 根据ImageView的ScaleType设置相应的转换</span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop(); <span class="comment">// 设置居中裁剪</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside(); <span class="comment">// 设置居中内部</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter(); <span class="comment">// 设置适应中心</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside(); <span class="comment">// 设置适应XY</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 不做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并返回ViewTarget对象，用于加载图片到ImageView</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass), <span class="comment">// 创建ImageViewTarget，transcodeClass是泛型的类型</span></span><br><span class="line">      <span class="comment">/* targetListener= */</span> <span class="literal">null</span>, <span class="comment">// 不设置目标监听器</span></span><br><span class="line">      requestOptions, <span class="comment">// 使用设置好的请求选项</span></span><br><span class="line">      Executors.mainThreadExecutor()); <span class="comment">// 使用主线程执行器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面最终调用还是在下面这个方法，也就是多个重载方法的最终调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span><br><span class="line"><span class="params">    Executor callbackExecutor)</span> &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 创建图片请求</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前图片控件是否已经有设置图片请求了，如果有且还没有加载完成，</span></span><br><span class="line">  <span class="comment">// 或者加载完成但是加载失败了，那么就将这个请求再重新调用begin，再一次进行请求；</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest(); <span class="comment">// 获取target上一个关联的请求</span></span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous) <span class="comment">// 检查新请求是否与旧请求等价</span></span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123; <span class="comment">// 检查是否需要跳过内存缓存</span></span><br><span class="line">    <span class="comment">// 如果请求已完成，重新开始将确保结果重新传递，触发RequestListeners和Targets。</span></span><br><span class="line">    <span class="comment">// 如果请求失败，重新开始将重新启动请求，给予另一次完成的机会。</span></span><br><span class="line">    <span class="comment">// 如果请求已经在运行，我们可以让它继续运行而不受干扰。</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123; <span class="comment">// 检查旧请求是否正在运行</span></span><br><span class="line">      <span class="comment">// 使用旧请求而不是新请求，以允许优化，如跳过设置占位符、跟踪和取消跟踪Targets、获取View尺寸等。</span></span><br><span class="line">      previous.begin(); <span class="comment">// 开始旧请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target; <span class="comment">// 返回target</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//清除当前图片控件的图片请求</span></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  <span class="comment">// 设置请求给控件</span></span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  <span class="comment">// 再将请求添加到requestManager中</span></span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码的主要作用是将构建好的图片加载请求与目标<code>Target</code>关联，并根据请求的状态决定是否重新开始请求或使用旧请求。</p>
<p><strong>将请求设置给了封装了图片控件的target，这样做有什么好处呢？</strong></p>
<p>​		我们的页面大多数都是列表页，那么基本上会使用RecycleView这种列表控件来加载数据，而这种列表在加载图片的时候，快速滑动时会出现加载错乱的问题，其原因是RecycleView的Item复用的问题；</p>
<p>而Glide就是在这里通过这样的操作来避免这样的问题；</p>
<p>在调用setRequest的时候，将当前的Request作为tag设置给了View，那么在获取Request进行加载的时候，就不会出现错乱的问题；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setTag</span><span class="params">(<span class="meta">@Nullable</span> Object tag)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  view.setTag(tagId, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，无论是重新开始请求或使用旧请求，都是从<code>request.begin()</code>开始的。</p>
<p>下面这张图片总结一下上面的流程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281707881.png" alt="img"></p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Request 主要的实现类有三个：</p>
<ol>
<li>SingleRequest</li>
<li>ThumbnailRequestCoordinator</li>
<li>ErrorRequestCoordinator</li>
</ol>
<p><strong>SingleRequest</strong></p>
<p>​		这个类负责执行请求并将结果反映到 Target 上。<br>        当我们使用 Glide 加载图片时，会先根据 Target 类型创建不同的 Target，然后 RequestBuilder 将这个 target 当做参数创建 Request 对象，Request 与 Target 就是这样关联起来的。</p>
<p>​		这里就会先创建一个包含 Target 的 SingleRequest 对象。考虑到性能问题，可能会连续创建很多个 SingleRequest 对象，所以使用了对象池来做缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># SingleRequest</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123; <span class="comment">// 同步锁，保证请求的线程安全</span></span><br><span class="line">    assertNotCallingCallbacks(); <span class="comment">// 检查是否在回调方法中调用</span></span><br><span class="line">    stateVerifier.throwIfRecycled(); <span class="comment">// 检查请求是否已经被回收</span></span><br><span class="line">    startTime = LogTime.getLogTime(); <span class="comment">// 记录开始时间，用于日志记录</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="literal">null</span>) &#123; <span class="comment">// 这里就是load设置的那个url</span></span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; <span class="comment">// 检查是否有有效的尺寸覆盖</span></span><br><span class="line">        width = overrideWidth; <span class="comment">// 设置宽度</span></span><br><span class="line">        height = overrideHeight; <span class="comment">// 设置高度</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">logLevel</span> <span class="operator">=</span> getFallbackDrawable() == <span class="literal">null</span> ? Log.WARN : Log.DEBUG; <span class="comment">// 设置日志级别</span></span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> <span class="title class_">GlideException</span>(<span class="string">&quot;Received null model&quot;</span>), logLevel); <span class="comment">// 加载失败，模型为空</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123; <span class="comment">// 如果请求已经在运行</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot restart a running request&quot;</span>); <span class="comment">// 抛出异常，不能重启正在运行的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123; <span class="comment">// 如果请求已经完成</span></span><br><span class="line">      onResourceReady(</span><br><span class="line">          resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>); <span class="comment">// 直接使用上次的资源</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记请求开始</span></span><br><span class="line">    experimentalNotifyRequestStarted(model); <span class="comment">// 通知请求开始</span></span><br><span class="line"></span><br><span class="line">    cookie = GlideTrace.beginSectionAsync(TAG); <span class="comment">// 开始异步跟踪部分</span></span><br><span class="line">    status = Status.WAITING_FOR_SIZE; <span class="comment">// 设置状态为等待尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; <span class="comment">// 如果有有效的尺寸覆盖</span></span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight); <span class="comment">// 如果已经有了明确的尺寸，开始加载</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.getSize(<span class="built_in">this</span>); <span class="comment">// 没有的话先去获取尺寸，最终还是走onSizeReady</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) <span class="comment">// 如果状态为运行中或等待尺寸</span></span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123; <span class="comment">// 并且可以通知状态改变</span></span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable()); <span class="comment">// 通知目标加载开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录完成时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>begin()</code>方法是用于开始图片加载请求的。它首先检查模型是否为<code>null</code>，如果是，则直接失败并返回。接着，它会检查请求的状态，如果请求已经在运行中，则抛出异常。如果请求已经完成，则直接使用上一次的资源和尺寸。如果请求既不是完成状态也不是运行状态，则视为新请求，从头开始执行。最后，它会根据需要更新目标的加载状态，并记录日志。</p>
<p>​		最终都是会调用到onSizeReady方法，然后通过Engine的load方法来开启请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># SingleRequest</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">  stateVerifier.throwIfRecycled(); <span class="comment">// 检查请求是否已经被回收</span></span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123; <span class="comment">// 同步锁，保证请求的线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;Got onSizeReady in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录尺寸准备好的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123; <span class="comment">// 如果状态不是等待尺寸</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING; <span class="comment">// 设置状态为运行中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">sizeMultiplier</span> <span class="operator">=</span> requestOptions.getSizeMultiplier(); <span class="comment">// 获取尺寸乘数</span></span><br><span class="line">    <span class="built_in">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier); <span class="comment">// 应用尺寸乘数到宽度</span></span><br><span class="line">    <span class="built_in">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier); <span class="comment">// 应用尺寸乘数到高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished setup for calling load in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录完成设置的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始加载图片</span></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            requestOptions.getSignature(),</span><br><span class="line">            <span class="built_in">this</span>.width,</span><br><span class="line">            <span class="built_in">this</span>.height,</span><br><span class="line">            requestOptions.getResourceClass(),</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            requestOptions.getDiskCacheStrategy(),</span><br><span class="line">            requestOptions.getTransformations(),</span><br><span class="line">            requestOptions.isTransformationRequired(),</span><br><span class="line">            requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">            requestOptions.getOptions(),</span><br><span class="line">            requestOptions.isMemoryCacheable(),</span><br><span class="line">            requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">            requestOptions.getUseAnimationPool(),</span><br><span class="line">            requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">            <span class="built_in">this</span>,</span><br><span class="line">            callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果状态不是运行中，设置加载状态为null</span></span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">      loadStatus = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished onSizeReady in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录尺寸准备完成的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>onSizeReady()</code>方法是在目标尺寸准备好时被调用的。它会设置请求的状态为运行中，应用尺寸乘数到宽度和高度，然后开始加载图片。如果加载完成或状态改变，会进行相应的处理。</p>
<p>​		最终的请求还是来到了Engine类的load方法，下面看下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; LoadStatus <span class="title function_">load</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">/* 参数 */</span>)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>; <span class="comment">// 记录开始时间，用于日志记录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建用于缓存的键</span></span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span></span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource; <span class="comment">// 声明内存资源变量</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 同步锁，保证线程安全</span></span><br><span class="line">    <span class="comment">// 尝试从内存缓存中加载资源</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="literal">null</span>) &#123; <span class="comment">// 如果内存中没有资源</span></span><br><span class="line">      <span class="comment">// 等待现有的加载完成或开始新的加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果内存中有资源，回调资源准备好的方法</span></span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null，表示不需要等待新的加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的参数占地比较多我就先省略了，具体可以看<a target="_blank" rel="noopener" href="https://github.com/bumptech/glide/blob/193cf61354cc01f38b15bf1605905b49a19e6b7a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java#L155">源代码</a>。</p>
<p>​		<code>load()</code>方法负责一个图片加载的过程。它首先构建一个用于缓存的键，然后尝试从内存缓存中加载资源。如果内存缓存中没有资源，它将等待现有的加载完成或开始新的加载。如果找到了资源就通过cb回调回去，这个cb就是前面的SingleRequest，然后回调给了它的onResourceReady方法。最后通过层层回调传递数据，然后设置到View上。</p>
<h3 id="从缓存查找资源"><a href="#从缓存查找资源" class="headerlink" title="从缓存查找资源"></a>从缓存查找资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br></pre></td></tr></table></figure>

<p>看下这个方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">rivate EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, <span class="type">boolean</span> isMemoryCacheable, <span class="type">long</span> startTime) &#123;</span><br><span class="line">  ...</span><br><span class="line">      <span class="comment">// 构建用于缓存的键</span></span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span></span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从弱引用里获取图片资源</span></span><br><span class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从LRU缓存里面获取图片资源</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从弱引用里获取图片资源"><a href="#从弱引用里获取图片资源" class="headerlink" title="从弱引用里获取图片资源"></a>从弱引用里获取图片资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从弱引用里获取图片资源    get的具体实现在下面</span></span><br><span class="line">  EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="literal">null</span>) &#123; <span class="comment">// 如果资源存在</span></span><br><span class="line">    active.acquire(); <span class="comment">// 增加资源的引用计数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> active; <span class="comment">// 返回资源，如果不存在则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ActiveResources</span><br><span class="line">   </span><br><span class="line"><span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从映射中获取对应的弱引用</span></span><br><span class="line">  <span class="type">ResourceWeakReference</span> <span class="variable">activeRef</span> <span class="operator">=</span> activeEngineResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (activeRef == <span class="literal">null</span>) &#123; <span class="comment">// 如果弱引用不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 直接返回null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从弱引用队列中获取EngineResource对象</span></span><br><span class="line">  EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">  <span class="keyword">if</span> (active == <span class="literal">null</span>) &#123; <span class="comment">// 如果EngineResource对象已被回收</span></span><br><span class="line">    cleanupActiveReference(activeRef); <span class="comment">// 清理弱引用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> active; <span class="comment">// 返回EngineResource对象，如果已被回收则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！</p>
<p>​		那么设计了一个弱引用缓存的好处在于，没有触发GC的这段时间，可以重复的利用图片资源，减少从LruCache里的操作；</p>
<p>​		用弱引用保存正在使用的图片数据（正在使用的不能放在LRU内存缓存中，LRU有可能触发超过内存最大限制导致回收），当触发GC弱引用缓存被回收（说明此时不是正在使用的图片了）后又会被加到LRU缓存中。</p>
<h4 id="从LRU缓存里面获取图片资源"><a href="#从LRU缓存里面获取图片资源" class="headerlink" title="从LRU缓存里面获取图片资源"></a>从LRU缓存里面获取图片资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中获取EngineResource对象</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中存在资源</span></span><br><span class="line">    cached.acquire(); <span class="comment">// 增加资源的引用计数</span></span><br><span class="line">    activeResources.activate(key, cached); <span class="comment">// 将资源添加到弱引用队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cached; <span class="comment">// 返回缓存中的资源，如果不存在则为null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中移除并获取资源</span></span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中没有资源</span></span><br><span class="line">    result = <span class="literal">null</span>; <span class="comment">// 结果为null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123; <span class="comment">// 如果缓存的是EngineResource对象</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached; <span class="comment">// 直接转换为EngineResource对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果缓存的是其他类型的资源，创建一个新的EngineResource对象</span></span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EngineResource</span>&lt;&gt;(</span><br><span class="line">            cached,</span><br><span class="line">            <span class="comment">/* isMemoryCacheable= */</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">/* isRecyclable= */</span> <span class="literal">true</span>,</span><br><span class="line">            key,</span><br><span class="line">            <span class="comment">/* listener= */</span> <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回从缓存中获取的EngineResource对象，如果没有则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有个细节就是从LRU缓存里面获取图片资源后加入到了弱引用队列中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activeResources.activate(key, cached);</span><br></pre></td></tr></table></figure>

<p>极致的压榨性能</p>
<h3 id="从磁盘和网络查找资源"><a href="#从磁盘和网络查找资源" class="headerlink" title="从磁盘和网络查找资源"></a>从磁盘和网络查找资源</h3><p>从磁盘或者网络读取，必然是一个耗时的任务，那么肯定是要放在子线程里面执行，而Glide里也正是这样实现的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="title function_">if</span> <span class="params">(memoryResource == <span class="literal">null</span>)</span> &#123; <span class="comment">// 如果内存中没有资源</span></span><br><span class="line">      <span class="comment">// 等待现有的加载完成或开始新的加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看具体代码，还是省略参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; LoadStatus <span class="title function_">waitForExistingOrStartNewJob</span><span class="params">(。。。)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试获取当前正在执行的任务</span></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">  <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123; <span class="comment">// 如果任务已存在</span></span><br><span class="line">    current.addCallback(cb, callbackExecutor); <span class="comment">// 为任务添加回调</span></span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">      logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key); <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, current); <span class="comment">// 返回加载状态</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的EngineJob</span></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的DecodeJob</span></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      。。。);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将新的EngineJob添加到任务映射中</span></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加回调，这个cb就是SingleRequest自己，todo1</span></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">    logWithTimeAndKey(<span class="string">&quot;Started new load&quot;</span>, startTime, key); <span class="comment">// 记录日志</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, engineJob); <span class="comment">// 返回新的加载状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		run方法里面主要有一个runWrapped方法，这个方法才是最终执行的地方；</p>
<p>​		在这个com.bumptech.glide.load.engine.DecodeJob#getNextGenerator方法里面，会获取内存生产者Generator，这几个内容生产者分别对应着不同的缓存数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># DecodeJob</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runWrapped</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123; <span class="comment">// 根据运行原因执行不同的操作</span></span><br><span class="line">    <span class="keyword">case</span> INITIALIZE: <span class="comment">// 初始化</span></span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE); <span class="comment">// 获取下一个阶段</span></span><br><span class="line">      currentGenerator = getNextGenerator(); <span class="comment">// 获取下一个数据生成器</span></span><br><span class="line">      runGenerators(); <span class="comment">// 运行数据生成器</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE: <span class="comment">// 切换到源服务</span></span><br><span class="line">      runGenerators(); <span class="comment">// 运行数据生成器</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA: <span class="comment">// 解码数据</span></span><br><span class="line">      decodeFromRetrievedData(); <span class="comment">// 从检索到的数据中解码</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 未识别的运行原因</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason); <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title function_">getNextGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123; <span class="comment">// 根据当前阶段获取相应的数据生成器</span></span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE: <span class="comment">// 资源缓存</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建资源缓存生成器</span></span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE: <span class="comment">// 数据缓存</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建数据缓存生成器</span></span><br><span class="line">    <span class="keyword">case</span> SOURCE: <span class="comment">// 源数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建源数据生成器</span></span><br><span class="line">    <span class="keyword">case</span> FINISHED: <span class="comment">// 完成</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null，表示没有更多的生成器</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		<code>runWrapped()</code>方法根据不同的运行原因执行相应的操作，如初始化、切换到源服务、解码数据等。<code>getNextGenerator()</code>方法根据当前的阶段返回相应的数据生成器，用于获取数据。这些生成器负责从不同的数据源（如资源缓存、数据缓存、源数据）获取数据，并在数据准备好后进行解码处理。</p>
<p>ResourceCacheGenerator：对应转化后的图片资源生产者；</p>
<p>DataCacheGenerator：对应没有转化的原生图片资源生产者；</p>
<p>SourceGenerator：对应着网络资源内容生产者；</p>
<p>那么则对应着这个ResourceCacheGenerator和这个DataCacheGenerator的生产者；</p>
<p>这两个方法的实现差不多，都是通过获取一个File对象，然后再根据File对象来加载对应的图片数据；</p>
<p>在上面的runWrapped方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentGenerator = getNextGenerator(); <span class="comment">// 获取下一个数据生成器</span></span><br><span class="line">runGenerators(); <span class="comment">// 运行数据生成器</span></span><br></pre></td></tr></table></figure>

<p>runGenerators方法里面就执行了生成器的startNext方法。</p>
<p>从上面我们可以知道，Glide的磁盘缓存，是从DiskLruCache里面获取的；</p>
<h4 id="从磁盘缓存获取资源"><a href="#从磁盘缓存获取资源" class="headerlink" title="从磁盘缓存获取资源"></a><strong>从磁盘缓存获取资源</strong></h4><h5 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h5><p>下面我们来看一下这个DataCacheGenerator的startNext方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># ResourceCacheGenerator</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">  GlideTrace.beginSection(<span class="string">&quot;ResourceCacheGenerator.startNext&quot;</span>); <span class="comment">// 开始追踪此方法的执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;Key&gt; sourceIds = helper.getCacheKeys(); <span class="comment">// 获取缓存的键列表</span></span><br><span class="line">    <span class="keyword">if</span> (sourceIds.isEmpty()) &#123; <span class="comment">// 如果键列表为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses(); <span class="comment">// 获取注册的资源类列表</span></span><br><span class="line">    <span class="keyword">if</span> (resourceClasses.isEmpty()) &#123; <span class="comment">// 如果资源类列表为空</span></span><br><span class="line">      <span class="keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123; <span class="comment">// 如果转码类是File</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>( <span class="comment">// 抛出异常，表示找不到加载路径</span></span><br><span class="line">          <span class="string">&quot;Failed to find any load path from &quot;</span></span><br><span class="line">              + helper.getModelClass()</span><br><span class="line">              + <span class="string">&quot; to &quot;</span></span><br><span class="line">              + helper.getTranscodeClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (modelLoaders == <span class="literal">null</span> || !hasNextModelLoader()) &#123; <span class="comment">// 如果没有模型加载器或没有下一个模型加载器</span></span><br><span class="line">      resourceClassIndex++; <span class="comment">// 增加资源类索引</span></span><br><span class="line">      <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123; <span class="comment">// 如果资源类索引超出范围</span></span><br><span class="line">        sourceIdIndex++; <span class="comment">// 增加源ID索引</span></span><br><span class="line">        <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123; <span class="comment">// 如果源ID索引超出范围</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        resourceClassIndex = <span class="number">0</span>; <span class="comment">// 重置资源类索引</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Key</span> <span class="variable">sourceId</span> <span class="operator">=</span> sourceIds.get(sourceIdIndex); <span class="comment">// 获取当前源ID</span></span><br><span class="line">      Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex); <span class="comment">// 获取当前资源类</span></span><br><span class="line">      Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass); <span class="comment">// 获取转换器</span></span><br><span class="line">      <span class="comment">// 创建资源缓存键</span></span><br><span class="line">      currentKey =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ResourceCacheKey</span>(</span><br><span class="line">              helper.getArrayPool(),</span><br><span class="line">              sourceId,</span><br><span class="line">              helper.getSignature(),</span><br><span class="line">              helper.getWidth(),</span><br><span class="line">              helper.getHeight(),</span><br><span class="line">              transformation,</span><br><span class="line">              resourceClass,</span><br><span class="line">              helper.getOptions());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(currentKey); <span class="comment">// 从磁盘缓存获取文件</span></span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123; <span class="comment">// 如果文件存在</span></span><br><span class="line">        sourceKey = sourceId; <span class="comment">// 设置源键</span></span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile); <span class="comment">// 获取模型加载器列表</span></span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>; <span class="comment">// 重置模型加载器索引</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadData = <span class="literal">null</span>; <span class="comment">// 重置加载数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标记是否开始加载</span></span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123; <span class="comment">// 如果尚未开始且有下一个模型加载器</span></span><br><span class="line">      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); <span class="comment">// 获取模型加载器</span></span><br><span class="line">      <span class="comment">// 构建加载数据</span></span><br><span class="line">      loadData =</span><br><span class="line">          modelLoader.buildLoadData(</span><br><span class="line">              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; <span class="comment">// 如果加载数据有效且有加载路径</span></span><br><span class="line">        started = <span class="literal">true</span>; <span class="comment">// 标记开始加载</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>); <span class="comment">// 加载数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> started; <span class="comment">// 返回是否开始加载</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    GlideTrace.endSection(); <span class="comment">// 结束追踪此方法的执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里主要分为两步：</p>
<p>第一步是通过生成的key从DiskLruCache里面获取File对象；</p>
<p>第二步是将File对象，通过LoadData将File对象转化为Bitmap对象；</p>
<p>Glide在加载DiskLruCache的时候，会将所有图片对应的路径信息加载到内存中，当调用DiskLruCache的get方法时，其实是从DiskLruCache里面维护的一个Lru内存缓存里直接获取的；</p>
<p>所以第一步的get方法，其实是从LruCache内存缓存里面获取File对象的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheFile = helper.getDiskCache().get(currentKey);</span><br></pre></td></tr></table></figure>

<p>从这行代码开始，跟踪helper.getDiskCache()这个方法，最终会创建一个DiskLruCacheWrapper对象，然后调用它的get方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># DiskLruCacheWrapper</span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">get</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">safeKey</span> <span class="operator">=</span> safeKeyGenerator.getSafeKey(key); <span class="comment">// 获取安全的键</span></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;Get: Obtained: &quot;</span> + safeKey + <span class="string">&quot; for for Key: &quot;</span> + key); <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">File</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 初始化结果为null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;								<span class="comment">// get的具体逻辑在下面</span></span><br><span class="line">        <span class="keyword">final</span> DiskLruCache.<span class="type">Value</span> <span class="variable">value</span> <span class="operator">=</span> getDiskCache().get(safeKey); <span class="comment">// 从磁盘缓存中获取值</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            result = value.getFile(<span class="number">0</span>); <span class="comment">// 获取文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Unable to get from disk cache&quot;</span>, e); <span class="comment">// 记录警告日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"># DiskLruCache   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Value <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    checkNotClosed(); <span class="comment">// 检查缓存是否未关闭</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key); <span class="comment">// 从映射中获取条目</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果未找到条目，则返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果条目不可读，则返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : entry.cleanFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果条目中的任何文件丢失，则返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++; <span class="comment">// 增加冗余操作计数</span></span><br><span class="line">    journalWriter.append(READ); <span class="comment">// 将 READ 操作追加到日志中</span></span><br><span class="line">    journalWriter.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    journalWriter.append(key); <span class="comment">// 将键追加到日志中</span></span><br><span class="line">    journalWriter.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable); <span class="comment">// 如果需要，提交清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Value</span>(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths); <span class="comment">// 返回一个新的 Value 对象</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>​		如果是首次初始化DiskLruCache的时候，上面的代码中getDiskCache()方法最终走到了DiskLruCache类的readJournalLine方法，这里面会创建一个Entry对象，在Entry对象的构造方法里面创建了File对象；</p>
<p>​		DiskLruCache初始化之后下载的图片，文件在存入本地的时候也会将其加入到DiskLruCache的Lru内存里，其实现是在DiskLruCache的edit()方法；这里先把生成的Entry对象加入到内存中，然后通过IO操作Editor将图片文件写入到本地，</p>
<p>总结上面的逻辑</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281833248.webp" alt="image.png"></p>
<h5 id="将File对象转化为Bitmap对象"><a href="#将File对象转化为Bitmap对象" class="headerlink" title="将File对象转化为Bitmap对象"></a>将File对象转化为Bitmap对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123; <span class="comment">// 如果尚未开始且有下一个模型加载器</span></span><br><span class="line">      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); <span class="comment">// 获取模型加载器</span></span><br><span class="line">      <span class="comment">// 构建加载数据</span></span><br><span class="line">      loadData =</span><br><span class="line">          modelLoader.buildLoadData(</span><br><span class="line">              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; <span class="comment">// 如果加载数据有效且有加载路径</span></span><br><span class="line">        started = <span class="literal">true</span>; <span class="comment">// 标记开始加载</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>); <span class="comment">// 加载数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281834833.webp" alt="image.png"></p>
<p>上面获取到的字节数据ByteBuffer，最终会回调到DecodeJob这个类，在这里面实现了解码的逻辑；</p>
<p>看一下DecodeJob的onDataFetcherReady方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataFetcherReady</span><span class="params">(</span></span><br><span class="line"><span class="params">    Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了decodeFromRetrievedData方法来解码图片流数据；</p>
<p>这里通过LoadPath类来实现解码的功能</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281837384.webp" alt="image.png"></p>
<p>至此从磁盘获取数据就解析完了</p>
<h4 id="从网络获取资源"><a href="#从网络获取资源" class="headerlink" title="从网络获取资源"></a>从网络获取资源</h4><p>加载网络缓存的地方是在SourceGenerator类的startNext方法，我们来看一下大致的实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># SourceGenerator</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否有数据需要缓存</span></span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> dataToCache;</span><br><span class="line">        dataToCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试缓存数据</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isDataInCache</span> <span class="operator">=</span> cacheData(data);</span><br><span class="line">            <span class="comment">// 如果缓存失败，直接返回 true，表示本次加载任务结束</span></span><br><span class="line">            <span class="keyword">if</span> (!isDataInCache) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果缓存成功，继续执行后续逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 处理缓存过程中可能出现的 IOException</span></span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Failed to properly rewind or write data to cache&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从源缓存生成器加载数据</span></span><br><span class="line">    <span class="keyword">if</span> (sourceCacheGenerator != <span class="literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置源缓存生成器</span></span><br><span class="line">    sourceCacheGenerator = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化加载数据</span></span><br><span class="line">    loadData = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历模型加载器，尝试启动下一个加载任务</span></span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">        loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">        <span class="keyword">if</span> (loadData != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">                || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">            startNextLoad(loadData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否成功启动加载任务</span></span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> &#123;</span><br><span class="line">    loadData.fetcher.loadData(</span><br><span class="line">        helper.getPriority(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这个方法做了两步，第一步是缓存数据，第二步就是从网络下载图片资源了；</p>
<p>​		下面这个实现看起来是不是很熟悉，和磁盘缓存的逻辑一样，也是通过ModelLoader来加载数据；</p>
<p>​		而这个ModelLoader也是通过Registry来获取的，创建的地方也是通过Registry在Glide的构造方法里进行创建，并缓存到缓存里；</p>
<p>​		而这里最终调用的ModelLoader是HttpGlideUrlLoader，加载网络数据的地方是在HttpUrlFetcher的loadData方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="literal">null</span>, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;Failed to load data for url&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Finished http url fetcher fetch in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>loadDataWithRedirects方法里面实就是Android原生的网络请求，通过创建HttpURLConnection来从网络获取图片数据；</p>
<p>回去成功后通过callback回调了回去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>​		onDataReadyInternal(toStart, data);方法里面只是对当前类SourceGenerator的成员dataToCache进行赋值。</p>
<p>​		然后回头看startNext方法，一开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否有数据需要缓存</span></span><br><span class="line">   <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 尝试缓存数据</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isDataInCache</span> <span class="operator">=</span> cacheData(data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>cacheData方法就是将数据写进了磁盘缓存中，具体的代码就不看了。</p>
<h2 id="内存缓存的具体实现"><a href="#内存缓存的具体实现" class="headerlink" title="内存缓存的具体实现"></a>内存缓存的具体实现</h2><p>回顾上面的代码 “从LRU缓存里面获取图片资源” 这一节，里面调用了getEngineResourceFromCache这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中移除并获取资源</span></span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中没有资源</span></span><br><span class="line">    result = <span class="literal">null</span>; <span class="comment">// 结果为null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123; <span class="comment">// 如果缓存的是EngineResource对象</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached; <span class="comment">// 直接转换为EngineResource对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果缓存的是其他类型的资源，创建一个新的EngineResource对象</span></span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EngineResource</span>&lt;&gt;(</span><br><span class="line">            cached,</span><br><span class="line">            <span class="comment">/* isMemoryCacheable= */</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">/* isRecyclable= */</span> <span class="literal">true</span>,</span><br><span class="line">            key,</span><br><span class="line">            <span class="comment">/* listener= */</span> <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回从缓存中获取的EngineResource对象，如果没有则为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的cache的具体实现类是LruResourceCache</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruResourceCache</span> <span class="keyword">extends</span> <span class="title class_">LruCache</span>&lt;Key, Resource&lt;?&gt;&gt; <span class="keyword">implements</span> <span class="title class_">MemoryCache</span></span><br></pre></td></tr></table></figure>

<p>这里的LruCache类就是实现的Lru算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruCache</span>&lt;T, Y&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, Entry&lt;Y&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">100</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> initialMaxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> maxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> currentSize;</span><br><span class="line">    ......</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">    Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last; <span class="comment">// 用于存储最后一个条目的变量</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator; <span class="comment">// 缓存的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直到缓存的当前大小小于或等于期望的大小</span></span><br><span class="line">    <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">        cacheIterator = cache.entrySet().iterator(); <span class="comment">// 获取缓存条目的迭代器</span></span><br><span class="line">        last = cacheIterator.next(); <span class="comment">// 获取第一个条目（由于访问顺序，这是最近最少使用的条目）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Entry&lt;Y&gt; toRemove = last.getValue(); <span class="comment">// 获取要移除的条目</span></span><br><span class="line">        currentSize -= toRemove.size; <span class="comment">// 从当前大小中减去被移除条目的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">T</span> <span class="variable">key</span> <span class="operator">=</span> last.getKey(); <span class="comment">// 获取被移除条目的键</span></span><br><span class="line">        cacheIterator.remove(); <span class="comment">// 从缓存中移除该条目</span></span><br><span class="line"></span><br><span class="line">        onItemEvicted(key, toRemove.value); <span class="comment">// 调用回调方法来处理条目的逐出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中LinkedHashMap的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;T, Entry&lt;Y&gt;&gt; cache = new LinkedHashMap&lt;&gt;(100, 0.75f, true);</span><br></pre></td></tr></table></figure>

<p>​		这个 <code>LinkedHashMap</code> 被初始化为一个具有 100 的初始容量，0.75 的加载因子，并且按照访问顺序来维护键值对，这使得它适合用作缓存的底层实现。</p>
<p>这个类中最重要的一个方法trimToSize，它实现了缓存的移除逻辑：</p>
<p>​		移除条目，直到缓存的总大小小于或等于期望的大小。对于每个被移除的条目，它会更新缓存的当前大小，并调用一个回调方法（<code>onItemEvicted</code>）来执行在缓存中逐出条目时所需的任何额外操作。</p>
<p><strong>这里还涉及到一个知识点就是在移除条目的时候如何判断条目有没有被引用</strong></p>
<p>继续看上面的trimToSize方法，它里面的onItemEvicted(key, toRemove.value);被实现在LruResourceCache中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># LruResourceCache</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onItemEvicted</span><span class="params">(<span class="meta">@NonNull</span> Key key, <span class="meta">@Nullable</span> Resource&lt;?&gt; item)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (listener != <span class="literal">null</span> &amp;&amp; item != <span class="literal">null</span>) &#123;</span><br><span class="line">     listener.onResourceRemoved(item);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个回调的最终实现是在EngineResource类的recycle方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># EngineResource</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (acquired &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot recycle a resource while it is still acquired&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRecycled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot recycle a resource that has already been recycled&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  isRecycled = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRecyclable) &#123;</span><br><span class="line">    resource.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里有个判读就是在acquired大于0时会抛异常，acquired是当前资源的引用计数。每当资源被引用的时候会加一，当资源不再被需要时（例如，当图片从屏幕上移除时），<code>acquired</code> 的值会减一。</p>
<p>获取图片时，会首先从软引用寻找，没有的话从Lru缓存里寻找，找到的话会返回资源，同时将资源添加到弱引用队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      <span class="comment">// 添加到弱引用队列中</span></span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​		下次再要被引用时可以直接从弱引用队列中获得资源，当图片不再使用的时候，比如说暂停请求或者加载完毕或者清除资源时，就会将其从弱引用中转移到LruCache缓存池中。总结一下，就是正在使用中的图片使用弱引用来进行缓存，暂时不用的图片使用LruCache来进行缓存的功能;同一张图片只会出现在弱引用和LruCache中的一个。</p>
<h2 id="磁盘缓存的具体实现"><a href="#磁盘缓存的具体实现" class="headerlink" title="磁盘缓存的具体实现"></a>磁盘缓存的具体实现</h2><p>​		磁盘缓存是通过DiskLruCache来管理的,根据缓存策略，会有2种类型的图片，DATA(原始图片)和 RESOURCE（转换后的图片）。磁盘缓存依次通过ResourcesCacheGenerator、SourceGenerator、DataCacheGenerator来获取缓存数据。ResourcesCacheGenerator获取的是转换过的缓存数据；SourceGenerator获取的是未经转换的原始的缓存数据；DataCacheGenerator是通过网络获取图片数据再按照按照缓存策略的不同去缓存不同的图片到磁盘上。</p>
<p>​		根据缓存策略的不同会获取到不同类型的缓存图片。它的逻辑是：先从转换后的缓存中取；没有的话再从原始的（没有转换过的）缓存中拿数据；再没有的话就从网络加载图片数据，获取到数据之后，再依次缓存到磁盘和弱引用。</p>
<h2 id="缓存读取顺序"><a href="#缓存读取顺序" class="headerlink" title="缓存读取顺序"></a>缓存读取顺序</h2><p>弱引用缓存 -&gt; LruCache -&gt; DiskLruCache</p>
<p>Engine类的load方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; LoadStatus <span class="title function_">load</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">/* 参数 */</span>)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>; </span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span> keyFactory.buildKey();</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; </span><br><span class="line">    <span class="comment">// 尝试从内存缓存中加载资源</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="comment">// 从硬盘搜索或者网络加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调资源</span></span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存得写入顺序"><a href="#缓存得写入顺序" class="headerlink" title="缓存得写入顺序"></a>缓存得写入顺序</h2><p>网络获取  -&gt; DiskLruCache 缓存原图  -&gt;  弱引用缓存  -&gt;  LruCache  -&gt;  DiskLruCache 缓存编码后的图片</p>
<p>加载网络数据的地方是在HttpUrlFetcher的loadData方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//进行网络请求</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="literal">null</span>, glideUrl.getHeaders()); </span><br><span class="line">      callback.onDataReady(result); <span class="comment">//调用 SourceGenerator的onDataReady()方法</span></span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后看回调的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> &#123;</span><br><span class="line">    loadData.fetcher.loadData(</span><br><span class="line">        helper.getPriority(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDataReadyInternal</span><span class="params">(LoadData&lt;?&gt; loadData, Object data)</span> &#123;</span><br><span class="line">    <span class="type">DiskCacheStrategy</span> <span class="variable">diskCacheStrategy</span> <span class="operator">=</span> helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data; <span class="comment">//关注点1</span></span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher, </span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey); <span class="comment">//关注点2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从网络请求图片资源，请求完成后将请求结果传给了 SourceGenerator 的 onDataReday()：</p>
<p>​		看关注点1，如果请求返回的数据 data 不为空且需要缓存原始数据，就将 data 赋值给我们刚才提到的 dataToCache，接着调用 cb.reschedule() 会再一次进入到 SourceGenerator 的 startNext() 方法，这个时候 dataToCache 已经不为空就可以写入磁盘缓存了，然后进入cacheData方法进行写内存的操作。注意这里是缓存的原始未经过任何修改的图片，如果不需要缓存原始数据，直接调用 DecodeJob.onDataFetcherReady()。</p>
<p>​	</p>
<p>​		关注点2，最终会回调到EngineJob的onResourceReady方法，接着再封装后回调到Engine的onEngineJobComplete方法，里面调用了ActiveResources的activate方法将资源存入弱引用队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># EngineJob</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(</span></span><br><span class="line"><span class="params">      Resource&lt;R&gt; resource, DataSource dataSource, <span class="type">boolean</span> isLoadedFromAlternateCacheKey)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resource = resource;</span><br><span class="line">      <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">      <span class="built_in">this</span>.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyCallbacksOfResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">onEngineJobComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">      EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; resource.isMemoryCacheable()) &#123;</span><br><span class="line">      activeResources.activate(key, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.removeIfCurrent(key, engineJob);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># ActiveResources</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">    <span class="type">ResourceWeakReference</span> <span class="variable">toPut</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourceWeakReference</span>(</span><br><span class="line">            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="type">ResourceWeakReference</span> <span class="variable">removed</span> <span class="operator">=</span> activeEngineResources.put(key, toPut);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>​	进入弱引用队列后就可以开始它和LRU缓存的逻辑了。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/171793326b94">https://www.jianshu.com/p/171793326b94</a></p>
<p><a href="">Glide的缓存源码分析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6970683481127043085?searchId=202403012037006E1E0D02801CA59E3EF8#heading-4">【带着问题学】Glide做了哪些优化?</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6891307560557608967?searchId=202403012037006E1E0D02801CA59E3EF8#heading-7">#</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6951585628890857480?searchId=202403012037006E1E0D02801CA59E3EF8">BitmapPool 了解吗？Glide 是如何实现 Bitmap 复用的？</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7014041490439536654?searchId=202403111637516D0024166BE83DC9A93A#heading-13">Glide源码解析</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="Glide从Lru内存里移除得图片-是咋处理的？"><a href="#Glide从Lru内存里移除得图片-是咋处理的？" class="headerlink" title="Glide从Lru内存里移除得图片 是咋处理的？"></a>Glide从Lru内存里移除得图片 是咋处理的？</h4><p>Glide 处理从 LRU（Least Recently Used，最近最少使用）内存缓存中移除图片的流程大致如下：</p>
<ol>
<li><strong>缓存策略</strong>:<ul>
<li>Glide 使用 LRU 算法作为其内存缓存的管理策略。这意味着当内存缓存达到预设的最大容量时，最近最少使用的图片会被移除以腾出空间给新的图片。</li>
</ul>
</li>
<li><strong>触发条件</strong>:<ul>
<li>当新的图片需要被加载并缓存时，如果内存缓存已满，Glide 会根据 LRU 算法选择要移除的图片。</li>
</ul>
</li>
<li><strong>移除流程</strong>:<ul>
<li>Glide 会从内存缓存中移除选定的图片，并确保相关的资源被适当地回收。这通常涉及到减少图片引用计数，并在没有其他引用时释放图片占用的内存。</li>
</ul>
</li>
<li><strong>资源回收</strong>:<ul>
<li>如果移除的图片没有其他地方在使用，Glide 会负责回收这些图片占用的资源，比如 Bitmap 对象。这是通过调用 Bitmap 的 <code>recycle()</code> 方法来实现的，该方法会释放 Bitmap 占用的内存。</li>
</ul>
</li>
<li><strong>监听和回调</strong>:<ul>
<li>Glide 提供了监听器和回调机制，允许开发者在图片被缓存、移除或加载时执行自定义操作。这可以用于监控缓存的使用情况或处理特定的缓存事件。</li>
</ul>
</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/26/ARouter/" title="路由框架原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">路由框架原理</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/26/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线程池</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Glide"><span class="toc-number">1.</span> <span class="toc-text">Glide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">内存缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98-DiskLruCache"><span class="toc-number">1.2.</span> <span class="toc-text">磁盘缓存 DiskLruCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">缓存总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2OOM"><span class="toc-number">1.4.</span> <span class="toc-text">防止OOM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Glide-1"><span class="toc-number">2.</span> <span class="toc-text">Glide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">with方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#load%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">load方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#into%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">into方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Request"><span class="toc-number">2.4.1.</span> <span class="toc-text">Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%BC%93%E5%AD%98%E6%9F%A5%E6%89%BE%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.2.</span> <span class="toc-text">从缓存查找资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%BC%B1%E5%BC%95%E7%94%A8%E9%87%8C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">从弱引用里获取图片资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8ELRU%E7%BC%93%E5%AD%98%E9%87%8C%E9%9D%A2%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">从LRU缓存里面获取图片资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%A3%81%E7%9B%98%E5%92%8C%E7%BD%91%E7%BB%9C%E6%9F%A5%E6%89%BE%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.3.</span> <span class="toc-text">从磁盘和网络查找资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">从磁盘缓存获取资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.3.1.1.</span> <span class="toc-text">获取文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86File%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BABitmap%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.3.1.2.</span> <span class="toc-text">将File对象转化为Bitmap对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">从网络获取资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">内存缓存的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">磁盘缓存的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%8F%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.7.</span> <span class="toc-text">缓存读取顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%BE%97%E5%86%99%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.8.</span> <span class="toc-text">缓存得写入顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.9.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Glide%E4%BB%8ELru%E5%86%85%E5%AD%98%E9%87%8C%E7%A7%BB%E9%99%A4%E5%BE%97%E5%9B%BE%E7%89%87-%E6%98%AF%E5%92%8B%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-number">2.9.0.1.</span> <span class="toc-text">Glide从Lru内存里移除得图片 是咋处理的？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20ANR/" title="Android ANR">Android ANR</a><time datetime="2024-03-26T11:10:09.254Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Fragment/" title="Fragment相关">Fragment相关</a><time datetime="2024-03-26T11:10:09.252Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Handler%E6%9C%BA%E5%88%B6/" title="Android Handler消息机制">Android Handler消息机制</a><time datetime="2024-03-26T11:10:09.250Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Jetpack/" title="Android JetPack">Android JetPack</a><time datetime="2024-03-26T11:10:09.249Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/" title="Android编译流程">Android编译流程</a><time datetime="2024-03-26T11:10:09.242Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>