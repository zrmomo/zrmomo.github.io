<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kotlin协程 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介​		协程是一种更高效和更简单的方式管理并发的框架，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。 ​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。  协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K  减少了线程切换的成本，协程">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin协程">
<meta property="og:url" content="https://zrmomo.github.io/2024/03/26/kotlin%E5%8D%8F%E7%A8%8B2/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="简介​		协程是一种更高效和更简单的方式管理并发的框架，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。 ​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。  协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K  减少了线程切换的成本，协程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-03-26T11:10:09.207Z">
<meta property="article:modified_time" content="2024-03-25T05:41:20.229Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/03/26/kotlin%E5%8D%8F%E7%A8%8B2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kotlin协程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-25 13:41:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">kotlin协程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-26T11:10:09.207Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-25T05:41:20.229Z" title="更新于 2024-03-25 13:41:20">2024-03-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="kotlin协程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		协程是一种<strong>更高效和更简单的方式管理并发的框架</strong>，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。</p>
<p>​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。</p>
<ul>
<li><p>协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K</p>
</li>
<li><p>减少了线程切换的成本，协程可以挂起和恢复，它不会产生额外的开销，由程序自身控制</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>​	协程的作用是使用同步的方式写出异步的代码消灭了回调，然后将运行在不同线程的代码写在一个代码块里。协程让之前的并发代码写起来更简单。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispather.main)&#123;</span><br><span class="line">	<span class="keyword">val</span> user =  api.getUser()</span><br><span class="line">	nameTv.text = user.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p>协程框架大致有如下部分组成：</p>
<ul>
<li>协程作用域(<em>CoroutineScope</em>)</li>
<li>协程上下文(<em>CoroutineContext</em>)</li>
<li>协程调度器(<em>CoroutineDispatcher</em>)</li>
<li>作业(<em>Job</em>)</li>
</ul>
<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>​		<em>CoroutineScope</em>是一种用于启动协程的盒子。可以同时对盒子里的所有协程执行操作，比如一次性取消盒子里的所有子协程。<strong>每个任务都会对应一个盒子，但是可以同时对所有的盒子进行操作。</strong></p>
<p>比如在Activity中通过lifecycleScope创建一个作用域</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycleScope.launchWhenXXX &#123;</span><br><span class="line">   <span class="keyword">val</span> user = fetchUser()         </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看下它的定义</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># LifecycleOwner</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> LifecycleOwner.lifecycleScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() = lifecycle.coroutineScope</span><br><span class="line">    </span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="comment">// CoroutineScope与此Lifecycle绑定。当Lifecycle被销毁时，这个范围将被取消。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> Lifecycle.coroutineScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> existing = internalScopeRef.<span class="keyword">get</span>() <span class="keyword">as</span> LifecycleCoroutineScopeImpl?</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> existing</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> newScope = LifecycleCoroutineScopeImpl(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                SupervisorJob() + Dispatchers.Main.immediate</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (internalScopeRef.compareAndSet(<span class="literal">null</span>, newScope)) &#123;</span><br><span class="line">                newScope.register()</span><br><span class="line">                <span class="keyword">return</span> newScope</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleCoroutineScope</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>() : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">val</span> lifecycle: Lifecycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 activity created 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenCreated</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenCreated(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity started 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenStarted</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenStarted(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity resumed 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenResumed</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenResumed(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lifecycleScope</code> 是与 Android Jetpack Lifecycle 库集成的协程作用域，与组件（如 Activity 或 Fragment）的生命周期相关联。</li>
<li>当使用 <code>lifecycleScope.launch</code> 启动协程时，协程会在组件的生命周期内执行，并且会根据组件的生命周期自动取消。例如，如果在一个 Fragment 中启动了一个协程，当 Fragment 被销毁时，该协程也会被自动取消。</li>
</ul>
<p>ViewModel中的协程作用域通过viewModelScope来创建</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> user = fetchUser()</span><br><span class="line">            <span class="comment">// show user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">// fetch user</span></span><br><span class="line">            <span class="comment">// return user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>ViewModelStore</code>:</strong> 负责存储 <code>ViewModel</code> 实例，并与 <code>Activity</code> 或 <code>Fragment</code> 的生命周期绑定。当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，<code>ViewModelStore</code> 也会清除所有存储的 <code>ViewModel</code> 实例。</p>
<p>​		<strong><code>CloseableCoroutineScope</code>:</strong> 实现了 <code>Closeable</code> 接口，并在 <code>ViewModel</code> 实例中被 <code>setTag</code> 保存。当 <code>ViewModel</code> 被清除时，<code>ViewModelStore</code> 会调用 <code>ViewModel</code> 的 <code>onCleared()</code> 方法，在此方法中会自动关闭 <code>viewModelScope</code>，即调用 <code>CloseableCoroutineScope.close()</code> 方法。</p>
<p>作用域还有GlobalScope，MainScope等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>



<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>​		Job, CoroutineDispatcher, ContinuationInterceptor 等都是 CoroutineContext 的子类，即它们都是协程上下文。CoroutineContext 中有一个重载了(+)操作符的plus方法，可以将 Job 和 CoroutineDispatcher 等元素集合起来，代表一个协程的场景。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">// 重载 [] 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		它是一个包含了用户定义的一些各种不同元素的<code>Element</code>对象集合。其中主要元素是<code>Job</code>、协程调度器<code>CoroutineDispatcher</code>、还有包含协程异常<code>CoroutineExceptionHandler</code>、拦截器<code>ContinuationInterceptor</code>、协程名<code>CoroutineName</code>等。这些数据都是和协程密切相关的，每一个<code>Element</code>都有一个唯一key。</p>
<h3 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h3><p>​		它是在特定线程或线程组上执行协程的必要步骤。它们作为调度员负责将协程”分派“到底层线程，它决定着协程内部的代码将在哪个线程上执行。</p>
<p><strong>在主线程执行：</strong></p>
<ul>
<li>Dispatchers.Main</li>
<li>Dispatchers.Main.immediate</li>
</ul>
<p>​		两者不同点，Dispatchers.Main.immediate 的行为类似于Activity.runOnUiThread(…)，而Dispatchers.Main的行为就类似于Handler(Looper.getMainLooper()).post(…)</p>
<p>​		runOnUiThread在UI线程上运行指定的操作，如果当前线程是UI线程的话，该操作会立即执行，否则相关操作会被投递到UI线程的事件队列中去。</p>
<p>​		<code>Handler(Looper.getMainLooper()).post(...)</code>: 无论当前线程是否是主线程，都会被投递到UI线程的事件队列中去。</p>
<p><strong>后台线程执行：</strong></p>
<ul>
<li><em>Dispatchers.Default</em></li>
<li><em>Dispatchers.IO</em></li>
</ul>
<p><em>Dispatchers.Default</em>和<em>Dispatchers.IO</em>都可以允许在后台执行任务</p>
<p>​		<code>Dispatchers.Default</code> 通常用于执行计算密集型任务，比如处理大量数据或进行复杂计算。它 使用的线程池是一个固定大小的线程池，大小通常等于 CPU 核心的数量。这使得它适合并行执行计算密集型任务，而不会因为创建过多线程而导致资源耗尽。</p>
<p>​		<code>Dispatchers.IO</code> 专门用于执行 I&#x2F;O 密集型任务，比如读写文件、网络通信、数据库操作等。它使用的线程池则是一个可扩展的线程池，线程数量可以根据需要增长。这使得它适合 I&#x2F;O 密集型任务，因为这些任务可能会阻塞线程，而扩展的线程池可以提供更多线程来处理其他任务，从而保持应用的响应性。，但这个线程池被优化以适应 I&#x2F;O 操作的特性。</p>
<p><strong>其他</strong></p>
<p><em>Dispatchers.unconfined</em></p>
<p>简单来说，它只是在调用启动函数的线程上执行代码，并且它会立即执行。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>​		每个协程都与一个作业相关联。每当启动新协程时，它都会返回对作业的引用。协程的作业是可取消的，取消它会取消协程本身。但是如果我们想处理范围内的所有协程，就不再需要通过单独的作业来完成，我们可以使用<em>CoroutineScope</em>。</p>
<p>​		Job是继承自CoroutineContext的Element接口</p>
<p>再回头看ViewModel的作用域方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>launch返回的就是一个Job对象，然后机会所有的作用域都是通过launch来开启的。</p>
<p>常用方法：</p>
<ul>
<li>start() 开始</li>
</ul>
<p>​	<em>start</em>函数很直接，就是用来启动协程，这里就不过多描述</p>
<ul>
<li>join() 加入</li>
</ul>
<p>​		<em>join</em>函数是一个挂起函数，即它可以从协程或另一个挂起函数中调用。作业阻塞所有线程，直到写入它的协程或上下		完成其工作。只有当协程完成时，才会执行<strong>join()函数之后的行</strong>。</p>
<ul>
<li>cancel() 关闭</li>
</ul>
<p>​		<em>cancel</em>方法用于取消协程，而不用等待它完成它的工作。可以说它与<em>join</em>方法正好相反，在某种意义上，<em>join</em>方法等待协程完成其全部工作并阻塞所有其他线程，而<em>cancel</em> 方法在遇到时杀死协程协程（即停止协程）。</p>
<p>SupervisorJob是Job的一个子分支，它有一个作用就是如果子协程出现了异常，不会导致父协程以及其他兄弟协程取消关闭。</p>
<p>先看下使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">supervisorJob</span> <span class="operator">=</span> SupervisorJob()</span><br><span class="line"><span class="type">val</span> <span class="variable">scope</span> <span class="operator">=</span> CoroutineScope(Dispatchers.IO + supervisorJob)</span><br></pre></td></tr></table></figure>

<p>使用supervisorJob为context创建的作用域，不会因为一个子协程的异常导致全部协程取消。</p>
<p>​		综上所述，<em>SupervisorJob</em>更适合干一些独立互相不影响的任务，这样一旦某个任务出现了问题，对其他任务是没有任何影响的，比如说日常开发中一些UI需求，如果我点击的一个按钮出现了异常，但并不会影响手机状态栏的刷新</p>
<h2 id="suspend挂起"><a href="#suspend挂起" class="headerlink" title="suspend挂起"></a>suspend挂起</h2><p>​		被suspend修饰的函数叫做挂起函数，它们只能从另一个挂起函数或在协程中调用，它们可以在不阻塞当前线程的情况下挂起协程执行。</p>
<p>​		<strong>挂起是什么意思？</strong></p>
<p>​		挂起就是稍后会自动切回来的线程切换，切回来的动作在协程里叫做resume恢复。如果没有挂起的话suspend修饰没有意义。</p>
<p>​		下面是一个用来演示的伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">   <span class="keyword">val</span> image = suspendingGetImage(<span class="string">&quot;https://example.com/image.jpg&quot;</span>)</span><br><span class="line">   avatarIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendingGetImage</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getImage(s)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​			上面讲到Dispatchers.Main相当与将<strong>代码块的代码这部分就是协程</strong>通过Handler.post到主线程消息队列执行，然后<strong>主线程可以继续执行自己的任务。</strong>协程在执行到suspendingGetImage时会遇到<code>withContext(Dispatchers.IO)</code>会进行线程切换，在子线程执行完代码之后会自动的再次被post到主线程，然后继续执行后面的<code>avatarIv.setImageBitmap(image)</code>。</p>
<p>​		上面的主动让出线程然后自动恢复继续执行后面逻辑的这个过程叫做挂起。</p>
<p>​		挂起不一定必须有线程切换，如果将上面示例中的withContext(Dispatchers.IO)换成delay函数的话依然会挂起，但是不会切线程。所以说挂起和线程切换没有必然的联系。</p>
<p>​		在 Kotlin 协程中，挂起（Suspension）是一种特殊的状态，它允许协程在不阻塞线程的情况下暂停执行，并在条件满足时恢复执行。具体来说，挂起包含以下几个关键点：</p>
<ol>
<li><strong>非阻塞：</strong> 当协程挂起时，它不会阻塞底层的线程。这意味着线程可以用来执行其他任务，从而提高应用程序的并发性能。</li>
<li><strong>挂起点：</strong> 挂起发生在所谓的挂起点（Suspension Point）。挂起点通常是对挂起函数的调用。挂起函数是使用 <code>suspend</code> 关键字标记的函数，它们可以在执行过程中暂停协程，并在适当的时候恢复。</li>
<li><strong>恢复执行：</strong> 当挂起的条件（例如异步操作完成、延时结束等）得到满足时，协程会被恢复。恢复后，协程会从上次挂起的地方继续执行。</li>
<li><strong>调度器和线程：</strong> 挂起和恢复协程的执行可能伴随着线程的切换，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。调度器负责将协程的执行分派到合适的线程上。</li>
</ol>
<p><strong>suspend关键字的作用？</strong></p>
<p>​		suspend用来标志当前函数是一个挂起函数，需要在协程或者另外一个挂起函数中被调用。真正的挂起操作靠的是挂起函数里面的实际切换线程的代码，suspend作为函数使用者的提醒。</p>
<p><strong>怎么实现一个挂起函数？</strong></p>
<ul>
<li><p>什么时候定义？</p>
<p>原则：耗时</p>
</li>
<li><p>怎么写？</p>
<p>通常使用withContext这个挂起函数实现，它的功能最简单就是把线程切走又切回来。</p>
</li>
</ul>
<p><strong>非阻塞式挂起？</strong></p>
<p>​		非阻塞指的是不阻塞主线程，挂起的话一定是切到子线程了当然不会阻塞主线程。这个子线程会承载耗时操作，在等待的过程中就是阻塞的了。</p>
<h2 id="协程恢复"><a href="#协程恢复" class="headerlink" title="协程恢复"></a>协程恢复</h2><p>协程恢复时不一定会切回原线程，因为可能它的父协程是基于线程池的，在回调回父协程时可能换了个线程执行任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;主协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">&quot;协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;挂起并切换到 IO 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;恢复并继续在 Default 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;主协程结束 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">主协程开始 - 线程：main</span><br><span class="line">协程开始 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">挂起并切换到 IO 线程 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">恢复并继续在 Default 线程 - 线程：DefaultDispatcher-worker-<span class="number">3</span></span><br><span class="line">主协程结束 - 线程：main</span><br></pre></td></tr></table></figure>



<h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><p>Kotlin 协程的启动方式主要有以下几种，每种方式都有其特定的用途和行为：</p>
<ol>
<li><p>**<code>launch</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Job</code> 实例，用于管理协程的生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用，通过 CoroutineContext 参数去管理和控制协程的生命周期</span></span><br><span class="line"><span class="comment">// 例如：context = Dispatchers.Default + EmptyCoroutineContext</span></span><br><span class="line"><span class="keyword">val</span> coroutineScope = CoroutineScope(context)</span><br><span class="line"><span class="keyword">val</span> job = coroutineScope.launch &#123; </span><br><span class="line">    getName(id) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>async</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Deferred</code> 实例，用于获取协程的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async启动的Job是Deferred类型，它可以有返回结果，通过await方法获取</span></span><br><span class="line"><span class="comment">// public suspend fun await(): T</span></span><br><span class="line"><span class="keyword">val</span> id = coroutineScope.async &#123; getName(id) &#125;</span><br><span class="line">id.await()</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>runBlocking</code>**：创建一个新的协程并阻塞当前线程，直到协程完成。通常用于桥接协程和非协程代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>withContext</code>**：在指定的调度器上下文中执行协程代码块，并返回结果。用于在不同的调度器之间切换协程的执行上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 在 IO 调度器上执行的协程体，返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>launch() 和 async()之间的主要区别在于 :</p>
<ul>
<li><em>launch()</em> 将创建一个新的协程并立即启动它</li>
<li><em>async()</em> 将创建一个新的协程但不会启动它直到某些东西在结果<em>Deferred</em> 上调用 <em>await()</em></li>
</ul>
<p>​		launch 更多是用来发起一个无需结果的耗时任务（如批量文件删除、创建），这个工作不需要返回结果。<em>async</em> 函数则是更进一步，用于异步执行耗时任务，并且需要返回值（如网络请求、数据库读写、文件读写），在执行完毕通过<em>await()</em> 函数获取返回值。</p>
<p>启动协程需要三样东西，分别是上下文(CoroutineContext)、启动模式(CoroutineStart)、协程体。</p>
<p>看源码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT, <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上下文可以看上面章节，启动模式一共有四种：</p>
<ul>
<li><strong>DEFAULT:</strong> 默认启动模式。协程会在被调度的第一时间开始执行。</li>
<li><strong>LAZY:</strong> 懒启动模式。协程只有在需要的时候才会开始执行，比如调用 <code>start</code>、<code>join</code> 或 <code>await</code> 方法时。</li>
<li><strong>ATOMIC:</strong> 原子启动模式。协程会立即开始执行，但如果协程在启动后立即被取消，它将不会执行任何操作。</li>
<li><strong>UNDISPATCHED:</strong> 立即启动模式。协程会在当前线程立即开始执行，直到遇到第一个挂起点。之后，它将根据其上下文恢复执行。</li>
</ul>
<p>协程体就是launch大括号里的代码内容了。</p>
<h2 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h2><p><strong>kotlin编译器</strong> 会对带有 <code>suspend</code> 的方法在最终的字节码生成上进行额外更改，这个过程又被称作 <strong>CPS转换</strong> (下面会再解释)，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend fun <span class="title function_">xx</span><span class="params">()</span></span><br><span class="line">-&gt;</span><br><span class="line">Object <span class="title function_">xx</span><span class="params">(Continuation c)</span></span><br></pre></td></tr></table></figure>

<p>在字节码中，我们原有的函数方法参数中会再增加一个 <code>Continuation</code> ，而 <code>Continuation</code> 就相当于一个参数传递的纽带(或者你也可以理解其就是一个 <code>CallBack</code> )，负责保存函数的执行状态、执行 挂起与恢复 操作，具体如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 参数类似于 <code>Android</code> 开发中的 <code>context</code> 一样，其代表了当前的配置，对使用协程的同学而言，context就相当于<strong>当前协程所运行的环境与参数</strong> ，而 <code>resumeWith()</code> 则是负责对我们函数方法进行挂起与恢复</p>
<h2 id="协程源码解读"><a href="#协程源码解读" class="headerlink" title="协程源码解读"></a>协程源码解读</h2><h3 id="协程的创建和启动"><a href="#协程的创建和启动" class="headerlink" title="协程的创建和启动"></a>协程的创建和启动</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">	<span class="comment">// 协程体</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​	回看launch的代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job</span><br></pre></td></tr></table></figure>

<p>​		block就是对应的协程体，在经过编译后这部分内容会被编译成SuspendLambda 的子类。</p>
<p>​		<strong>SuspendLambda 实现了 Continuation 续体接口，其 resume 方法可以恢复协程的执行；另外它将协程体封装成 SuspendLambda 对象，其内以状态机的形式消除回调地狱，并实现逻辑的顺序执行</strong>。</p>
<p>SuspendLambda 的继承关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Continuation: 续体，恢复协程的执行</span><br><span class="line">    - BaseContinuationImpl: 实现 resumeWith(Result) 方法，控制状态机的执行，定义了 invokeSuspend 抽象方法</span><br><span class="line">        - ContinuationImpl: 增加 intercepted 拦截器，实现线程调度等</span><br><span class="line">            - SuspendLambda: 封装协程体代码块</span><br><span class="line">                - 协程体代码块生成的子类: 实现 invokeSuspend 方法，其内实现状态机流转逻辑</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7137905800504148004#heading-8">https://juejin.cn/post/7137905800504148004#heading-8</a></p>
<ol>
<li>协程和语言级别</li>
</ol>
<p>协程确实是 Kotlin 提供的一种并发框架，它允许以同步的方式编写异步代码。不过，协程不仅仅是 Kotlin 特有的，其他语言也有类似的概念，如 Python 的异步 IO (asyncio)、JavaScript 的 async&#x2F;await 等。</p>
<ol start="2">
<li>挂起和线程切换</li>
</ol>
<p>挂起并不总是意味着线程切换。挂起函数可以释放当前线程，使其可供其他任务使用，但协程在恢复时可能在相同的线程或不同的线程上继续执行，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。</p>
<ol start="3">
<li>CPS 转换和回调</li>
</ol>
<p>CPS（Continuation-Passing Style）转换是协程实现中的一个关键技术。它将协程的代码转换为一系列连续的回调。每当协程遇到挂起点时，它都会保存当前的状态（包括局部变量等）并暂停执行。恢复协程时，会从上次挂起的地方继续执行。这个过程是由 Kotlin 编译器和协程库自动处理的，对开发者来说是透明的。</p>
<ol start="4">
<li>挂起函数</li>
</ol>
<p>挂起函数是通过 <code>suspend</code> 关键字标记的函数，它们可以在不阻塞线程的情况下暂停和恢复协程的执行。挂起函数可以调用其他挂起函数，形成一个挂起函数的调用链。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6">https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6</a></p>
<p>​		协程是 Kotlin 提供的一种语言级别的并发框架，它允许以编写同步代码的方式来实现异步操作。在协程中，挂起机制可以实现线程的非阻塞切换。挂起允许协程在某个挂起点暂停执行，并在满足条件时自动恢复，这个过程可能伴随着线程的切换。</p>
<p>​		具体实现逻辑是，首先通过 <code>suspend</code> 关键字定义挂起函数，然后在协程作用域内调用这些挂起函数。这些函数在执行过程中可能会挂起协程，并在适当的时候恢复。挂起和恢复的过程由协程框架管理，涉及到 Continuation-Passing Style (CPS) 转换，这个转换过程会将协程的执行逻辑转换为一系列连续的回调，<strong>这些回调封装了协程在恢复后要执行的逻辑</strong>。</p>
<p>​		协程是kotlin语言级别的并发框架，它可以通过同步代码的方式实现异步的操作。在协程中通过挂起实现的线程切换。挂起就是可以在切换线程之后可以自己再切回来。具体的实现逻辑是，首先通过Suspend定义挂起函数，然后在协程作用域内启动。这个函数经过cps转换会添加一个回调。这个回调封装的是协程挂起恢复后要执行的逻辑。</p>
<h4 id="在工具类中创建协程进行耗时操作"><a href="#在工具类中创建协程进行耗时操作" class="headerlink" title="在工具类中创建协程进行耗时操作"></a>在工具类中创建协程进行耗时操作</h4><p>非单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNonContextClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = SupervisorJob()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default + job)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行异步操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> AudioPlayerImpl : AudioPlayer, CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceAll</span><span class="params">(songList: <span class="type">List</span>&lt;<span class="type">SongEntity</span>&gt;, song: <span class="type">SongEntity</span>)</span></span> &#123;</span><br><span class="line">        launch(Dispatchers.Main.immediate) &#123;</span><br><span class="line">            withContext(Dispatchers.IO) &#123;</span><br><span class="line">                <span class="comment">// 这里执行异步操作</span></span><br><span class="line">                db.playlistDao().clear()</span><br><span class="line">                db.playlistDao().insertAll(songList)</span><br><span class="line">            &#125;</span><br><span class="line">            _playlist.value = songList</span><br><span class="line">            _currentSong.value = song</span><br><span class="line">            play(song)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MainScope()</code> 是绑定到主线程的生命周期的，通常在应用程序终止时，这个作用域会自动被取消。</p>
<h4 id="Dispatchers-Default和Dispatchers-IO的线程池"><a href="#Dispatchers-Default和Dispatchers-IO的线程池" class="headerlink" title="Dispatchers.Default和Dispatchers.IO的线程池"></a>Dispatchers.Default和Dispatchers.IO的线程池</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7114968347325759501#heading-11">Kotlin 协程之线程池探索之旅(与Java线程池PK)</a></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403201859132.webp" alt="image.png"></p>
<p>Dispatchers.IO 侧重于任务本身是阻塞型的，比如文件、数据库、网络等操作，此时是不怎么占用CPU的。而Dispatchers.Default 侧重于计算型的任务，可能会长时间占用CPU。</p>
<p><em>Dispatchers.Default</em> 由线程池支持，最大线程数为 2 或 CPU 核心数。它可以用于计算密集型任务。</p>
<p><em>Dispatchers.IO</em> 类似于<em>Default</em>，但最大线程数为 64 或 CPU 核心数。通过调整系统属性可以进一步增加最大线程数。用于 IO 任务，例如大部分时间都处于等待的工作，而非密集型</p>
<h4 id="协程线程池原理"><a href="#协程线程池原理" class="headerlink" title="协程线程池原理"></a>协程线程池原理</h4><ul>
<li>全局队列（阻塞+非阻塞）+ 本地队列。</li>
<li>IO 任务分发还有个缓存队列。</li>
<li>线程从队列里寻找任务（包括偷）并执行，若是使用IO 分发器，则超出限制的任务将会放到缓存队列里。</li>
</ul>
<h4 id="协程线程池和Java线程池的区别"><a href="#协程线程池和Java线程池的区别" class="headerlink" title="协程线程池和Java线程池的区别"></a>协程线程池和Java线程池的区别</h4><ul>
<li>Java 线程池开放API，比较灵活，调用者可以根据不同的需求组合不同形式的线程池，没有区分任务的特点（阻塞&#x2F;非阻塞）。</li>
<li>协程线程池专供协程使用，区分任务特点，进而进行更加合理的调度。</li>
</ul>
<h4 id="coroutineScope和CoroutineScope-launch的区别"><a href="#coroutineScope和CoroutineScope-launch的区别" class="headerlink" title="coroutineScope和CoroutineScope.launch的区别"></a>coroutineScope和CoroutineScope.launch的区别</h4><p><code>coroutineScope</code></p>
<ul>
<li><strong>类型</strong>：<code>coroutineScope</code>是一个挂起函数，可以在其他挂起函数或协程中调用。</li>
<li><strong>作用域继承</strong>：它创建一个新的协程作用域，并继承外部的协程作用域（包括协程上下文和取消状态）。</li>
<li><strong>等待子协程</strong>：在<code>coroutineScope</code>块内启动的所有协程都完成之前，<code>coroutineScope</code>会挂起当前协程。这意味着<code>coroutineScope</code>块之后的代码会等待块内的所有协程完成后才执行。</li>
<li><strong>使用场景</strong>：当你需要在某个挂起函数中启动多个协程，并且要等待这些协程全部完成时，<code>coroutineScope</code>是一个好的选择。</li>
</ul>
<p><code>CoroutineScope.launch</code></p>
<ul>
<li><strong>类型</strong>：<code>launch</code>是一个扩展函数，用于在给定的<code>CoroutineScope</code>上启动新的协程。</li>
<li><strong>作用域创建</strong>：它需要一个<code>CoroutineScope</code>实例来调用，并在这个实例的作用域内启动新的协程。这个作用域通常由外部提供，比如通过<code>Activity</code>的<code>lifecycleScope</code>、<code>viewModelScope</code>或自定义的<code>CoroutineScope</code>。</li>
<li><strong>不等待子协程</strong>：<code>launch</code>会立即返回一个<code>Job</code>对象，并且不会等待协程内部的代码执行完毕。调用<code>launch</code>的代码会继续执行，而不会阻塞等待<code>launch</code>块内的协程完成。</li>
<li><strong>使用场景</strong>：当你需要在协程作用域内启动一个新的协程，并且不需要等待这个新启动的协程完成时，<code>launch</code>是合适的选择。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用coroutineScope</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUserData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123; <span class="comment">/* 加载并处理用户数据 */</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123; <span class="comment">/* 加载用户的其他信息 */</span> &#125;</span><br><span class="line">        <span class="comment">// 等待job1和job2完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// coroutineScope块外的代码会等待所有内部协程完成后才执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CoroutineScope.launch</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">startJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 在CoroutineScope的作用域内启动新的协程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的代码不会等待launch块内的协程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>使用<code>coroutineScope</code>可以确保在其代码块内启动的所有协程都完成之后，才继续执行后续代码，适合控制一组协程的执行。</li>
<li>使用<code>CoroutineScope.launch</code>可以在指定的协程作用域内启动一个新的协程，适合无需等待协程完成的场景。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7212311942613385253?searchId=20240313204055C36AC19ED84D47206D72#heading-30">写给Android工程师的协程指南</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7137905800504148004">Kotlin协程之再次读懂协程工作原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6890348438873964551">Kotlin协程之深入理解协程工作原理</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7220235452292137019#heading-8">谱写Kotlin面试指南三部曲-协程篇</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901956626324914184#heading-2">Kotlin协程之基础使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JE411R7hp/?spm_id_from=333.788.recommend_more_video.-1&vd_source=214b10aedbc4bde847f4f4260b4d4787">扔物线协程视频</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/26/kotlin%20flow/" title="Kotlin flow"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kotlin flow</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/26/Retrofit/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">2.</span> <span class="toc-text">成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">协程作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.2.</span> <span class="toc-text">协程上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">协程调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Job"><span class="toc-number">2.4.</span> <span class="toc-text">Job</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suspend%E6%8C%82%E8%B5%B7"><span class="toc-number">3.</span> <span class="toc-text">suspend挂起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%81%A2%E5%A4%8D"><span class="toc-number">4.</span> <span class="toc-text">协程恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-number">5.</span> <span class="toc-text">协程启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Continuation"><span class="toc-number">6.</span> <span class="toc-text">Continuation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">7.</span> <span class="toc-text">协程源码解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-number">7.1.</span> <span class="toc-text">协程的创建和启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B%E8%BF%9B%E8%A1%8C%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.1.</span> <span class="toc-text">在工具类中创建协程进行耗时操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatchers-Default%E5%92%8CDispatchers-IO%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.0.2.</span> <span class="toc-text">Dispatchers.Default和Dispatchers.IO的线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">8.0.3.</span> <span class="toc-text">协程线程池原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.4.</span> <span class="toc-text">协程线程池和Java线程池的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#coroutineScope%E5%92%8CCoroutineScope-launch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.5.</span> <span class="toc-text">coroutineScope和CoroutineScope.launch的区别</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Activity%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="无题">无题</a><time datetime="2024-03-26T11:10:09.256Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20ANR/" title="Android ANR">Android ANR</a><time datetime="2024-03-26T11:10:09.254Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Fragment/" title="无题">无题</a><time datetime="2024-03-26T11:10:09.252Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Handler%E6%9C%BA%E5%88%B6/" title="Android Handler消息机制">Android Handler消息机制</a><time datetime="2024-03-26T11:10:09.250Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Jetpack/" title="Android JetPack">Android JetPack</a><time datetime="2024-03-26T11:10:09.249Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>