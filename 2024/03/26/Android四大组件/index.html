<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android四大组件 | 敲写拾遗</title><meta name="author" content="狂奔的馒头"><meta name="copyright" content="狂奔的馒头"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Activity生命周期方法 onCreate(Bundle savedInstanceState)   这是Activity被创建时系统调用的第一个方法。在这里，你应该做所有的静态设置：创建视图，绑定数据到列表等操作。如果有保存的状态，系统会传递给这个方法一个Bundle。   onStart()   当Activity对用户可见时，系统会调用这个方法。这可以发生在onCreate()方法结束后">
<meta property="og:type" content="article">
<meta property="og:title" content="Android四大组件">
<meta property="og:url" content="https://zrmomo.github.io/2024/03/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="敲写拾遗">
<meta property="og:description" content="Activity生命周期方法 onCreate(Bundle savedInstanceState)   这是Activity被创建时系统调用的第一个方法。在这里，你应该做所有的静态设置：创建视图，绑定数据到列表等操作。如果有保存的状态，系统会传递给这个方法一个Bundle。   onStart()   当Activity对用户可见时，系统会调用这个方法。这可以发生在onCreate()方法结束后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png">
<meta property="article:published_time" content="2024-03-26T11:10:09.234Z">
<meta property="article:modified_time" content="2024-03-26T08:13:09.416Z">
<meta property="article:author" content="狂奔的馒头">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zrmomo.github.io/2024/03/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android四大组件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-26 16:13:09'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="敲写拾遗"><img class="site-icon" src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png"/><span class="site-name">敲写拾遗</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Android四大组件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-26T11:10:09.234Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-26T08:13:09.416Z" title="更新于 2024-03-26 16:13:09">2024-03-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android四大组件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><ol>
<li>onCreate(Bundle savedInstanceState)</li>
</ol>
<ul>
<li>这是Activity被创建时系统调用的第一个方法。在这里，你应该做所有的静态设置：创建视图，绑定数据到列表等操作。如果有保存的状态，系统会传递给这个方法一个<code>Bundle</code>。</li>
</ul>
<ol start="2">
<li>onStart()</li>
</ol>
<ul>
<li>当Activity对用户可见时，系统会调用这个方法。这可以发生在<code>onCreate()</code>方法结束后，或者在Activity从不可见状态恢复时。</li>
</ul>
<ol start="3">
<li>onRestart()</li>
</ol>
<ul>
<li>如果Activity从停止状态重新开始，就会调用这个方法。它在<code>onStop()</code>之后和<code>onStart()</code>之前调用。</li>
</ul>
<ol start="4">
<li>onResume()</li>
</ol>
<ul>
<li>当Activity准备好与用户互动时，系统会调用这个方法。这时，Activity位于Activity堆栈的顶部，并捕获所有用户输入。大部分的核心功能都在这个方法中实现。</li>
</ul>
<ol start="5">
<li>onPause()</li>
</ol>
<ul>
<li>当系统准备启动或恢复另一个Activity时，系统会调用这个方法。这通常是因为用户正在离开这个Activity，但这个Activity还没有被完全停止或隐藏。在这个方法中，你应该释放或调整那些不需要的资源。</li>
</ul>
<ol start="6">
<li>onStop()</li>
</ol>
<ul>
<li>当Activity不再对用户可见时，系统会调用这个方法。这可能发生因为一个新的Activity启动，或者是这个Activity正在被销毁。</li>
</ul>
<ol start="7">
<li>onDestroy()</li>
</ol>
<ul>
<li>在Activity被销毁之前，系统会调用这个方法。这可以由用户完全结束（例如按下Back键）或系统临时销毁以节省空间引起。在这个方法中，你应该释放所有资源。</li>
</ul>
<ol start="8">
<li>onSaveInstanceState(Bundle outState)</li>
</ol>
<ul>
<li>在Activity开始停止的过程中，系统调用这个方法，以便你可以保存当前Activity的状态。这个状态之后可以在<code>onCreate(Bundle)</code>或<code>onRestoreInstanceState(Bundle)</code>（见下文）中恢复。</li>
</ul>
<ol start="9">
<li>onRestoreInstanceState(Bundle savedInstanceState)</li>
</ol>
<ul>
<li>当Activity在被销毁和重新创建时，系统会调用这个方法。你可以在这个方法中恢复由<code>onSaveInstanceState(Bundle)</code>方法保存的状态。</li>
</ul>
<h3 id="其他的生命周期方法"><a href="#其他的生命周期方法" class="headerlink" title="其他的生命周期方法"></a>其他的生命周期方法</h3><p>运行时权限回调</p>
<ul>
<li>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)<ul>
<li>用户响应权限请求时调用。</li>
</ul>
</li>
</ul>
<p>Activity结果回调</p>
<ul>
<li>onActivityResult(int requestCode, int resultCode, Intent data)<ul>
<li>从另一个Activity返回结果时调用。</li>
</ul>
</li>
</ul>
<p>配置更改</p>
<ul>
<li>onConfigurationChanged(Configuration newConfig)<ul>
<li>设备配置更改（如屏幕方向、键盘可用性等）时调用。</li>
</ul>
</li>
</ul>
<p>键盘快捷键</p>
<ul>
<li>onKeyDown(int keyCode, KeyEvent event)<ul>
<li>按下键盘按键时调用。</li>
</ul>
</li>
<li>onKeyUp(int keyCode, KeyEvent event)<ul>
<li>释放键盘按键时调用。</li>
</ul>
</li>
<li>onKeyLongPress(int keyCode, KeyEvent event)<ul>
<li>长按键盘按键时调用。</li>
</ul>
</li>
</ul>
<p>触摸屏事件</p>
<ul>
<li>onTouchEvent(MotionEvent event)<ul>
<li>触摸屏事件发生时调用。</li>
</ul>
</li>
</ul>
<h3 id="Activity的启动模式以及它们的作用？"><a href="#Activity的启动模式以及它们的作用？" class="headerlink" title="Activity的启动模式以及它们的作用？"></a>Activity的启动模式以及它们的作用？</h3><p><strong>standard（标准）</strong></p>
<ul>
<li><strong>行为</strong>：每次启动 <code>Activity</code> 时都会创建一个新的实例，无论这个 <code>Activity</code> 是否已经存在于任务中。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。</li>
<li><strong>用途</strong>：适用于大多数标准的 <code>Activity</code> 行为。如果你的 <code>Activity</code> 需要多次实例化（例如，一个显示列表项详细信息的 <code>Activity</code>），那么标准模式很适合。</li>
</ul>
<p><strong>singleTop（栈顶复用）</strong></p>
<ul>
<li><strong>行为</strong>：如果新的 <code>Activity</code> 已经位于任务栈的顶部，那么不会创建新的实例，而是重用栈顶的实例，并调用其 <code>onNewIntent()</code> 方法。如果不在栈顶，将创建新的实例。</li>
<li><strong>用途</strong>：适用于需要保持最上层实例唯一，但在其他位置可以有多个实例的 <code>Activity</code>。例如，用于处理从多个地方发送的通知，但希望打开的通知详情 <code>Activity</code> 在顶部时不重复创建。</li>
<li><strong>场景：</strong><ol>
<li>要打开的Activity处于栈顶，点击通知栏打开栈顶的Activity</li>
<li>Activity需要启动一个Service，最后Service对栈顶Activity进行操作</li>
</ol>
</li>
</ul>
<p><strong>singleTask（栈内复用）</strong></p>
<ul>
<li><p><strong>行为</strong>：新的 <code>Activity</code> 实例将在单独的任务中启动。如果已存在这样的 <code>Activity</code> 实例，系统会将其调到栈顶而不是创建新的实例，并调用 <code>onNewIntent()</code> 方法。<strong>当一个具有singleTask模式的Activity请求启动后，比如Activity A，首先会根据taskAffinity:去寻找当前是否存在一个对应名字的任务栈。如果不存在，则会创建一个新的Task。如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例。如果有实例存在，那么系统就会把A调到栈顶（将上面的Activity依次出栈）并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中</strong>。</p>
</li>
<li><p><strong>用途</strong>：适用于作为应用中单一入口点的 <code>Activity</code>，如主页。当应用从多个入口点跳转到这个 <code>Activity</code> 时，它保证实例的唯一性。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>登录页面</li>
<li>首页</li>
</ol>
</li>
</ul>
<p><strong>singleInstance（单实例模式）</strong></p>
<ul>
<li><p><strong>行为</strong>：与 <code>singleTask</code> 相似，但保证这个 <code>Activity</code> 实例是全系统唯一的，即它在自己的任务中，不与其他 <code>Activity</code> 共享任务。创建新实例时，会在新的任务栈中。</p>
</li>
<li><p><strong>用途</strong>：适用于那些与应用其余部分彼此独立的模块，例如，一个浮动窗口或者一个启动其他应用的 <code>Activity</code>。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>外部App调用自己客户端程序的Activity</li>
</ol>
</li>
</ul>
<h3 id="Activity横竖屏切换"><a href="#Activity横竖屏切换" class="headerlink" title="Activity横竖屏切换"></a>Activity横竖屏切换</h3><p>竖屏切横屏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onPause </span><br><span class="line">onStop </span><br><span class="line">onSaveInstanceState </span><br><span class="line">onDestroy </span><br><span class="line">onCreate </span><br><span class="line">onStart </span><br><span class="line">onRestoreInstanceState</span><br><span class="line">onResume </span><br></pre></td></tr></table></figure>

<p><strong>设置configChanges这个值可以避免Activity生命周期被回到。</strong>在清单文件中设置configChanges属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges=&quot;orientation|screenSize&quot;</span><br></pre></td></tr></table></figure>

<p>横竖屏切换的生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onConfigurationChanged</span><br></pre></td></tr></table></figure>

<p>​		只走onConfigurationChanged这一个方法，在横竖屏切换时会命中orientation和screenSize这两个属性。添加后可以避免生命周期回调而只走onConfigurationChanged方法。其他的属性在下面可以查看。</p>
<ul>
<li>orientation：屏幕在纵向和横向间旋转</li>
<li>keyboardHidden：键盘显示或隐藏</li>
<li>screenSize：屏幕大小改变</li>
<li>fontScale：用户变更了首选字母大小</li>
<li>locale：用户选择了不同的语言设定</li>
<li>keyboard：键盘类型变更，如手机从九宫格键盘变为全键盘</li>
<li>touchscreen或navigation：键盘或导航方向变换，一般不会发生这种情况。</li>
</ul>
<p> 参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsgxeva/p/13414171.html">Activity横竖屏切换生命周期</a></p>
<h3 id="Activity跳转生命周期"><a href="#Activity跳转生命周期" class="headerlink" title="Activity跳转生命周期"></a>Activity跳转生命周期</h3><p>当从Activity A跳转到Activity B时：</p>
<ol>
<li><strong>Activity A</strong>:<ul>
<li><code>onPause()</code>：当用户即将离开Activity A时调用。在这个方法中，应停止与用户界面交互的操作，如动画和音乐播放。</li>
</ul>
</li>
<li><strong>Activity B</strong>:<ul>
<li><code>onCreate(Bundle savedInstanceState)</code>：如果Activity B之前没有被创建，系统会调用此方法。</li>
<li><code>onStart()</code>：当Activity B对用户可见时调用。</li>
<li><code>onResume()</code>：当Activity B准备好与用户交互时调用，此时Activity B位于栈顶，并且捕获所有用户输入。</li>
</ul>
</li>
<li><strong>Activity A</strong>:<ul>
<li><code>onStop()</code>：如果Activity B覆盖了Activity A，则在Activity B变得对用户可见之后，系统会调用此方法。如果Activity A不再可见，可以在这里释放或调整资源。</li>
</ul>
</li>
</ol>
<p>当用户按下返回键从Activity B返回到Activity A时：</p>
<ol>
<li><strong>Activity B</strong>:<ul>
<li><code>onPause()</code>：用户即将离开Activity B时调用。</li>
<li><code>onStop()</code>：当Activity B不再对用户可见时调用。</li>
<li><code>onDestroy()</code>：当Activity B即将被销毁时调用。这是释放Activity B占用资源的好时机。</li>
</ul>
</li>
<li><strong>Activity A</strong>:<ul>
<li><code>onRestart()</code>：只有在Activity A由停止状态变为运行状态时才会调用此方法。</li>
<li><code>onStart()</code>：当Activity A再次对用户可见时调用。</li>
<li><code>onResume()</code>：当Activity A准备好与用户交互时调用，此时Activity A位于栈顶，并且捕获所有用户输入。</li>
</ul>
</li>
</ol>
<p>当B无实例，且为透明或半透明时：</p>
<p>​		A.onPause() &gt; B.onCreate() &gt; B.onStart() &gt; B.onResume()。此时从B返回A：B.onPause() &gt; A.onResume() &gt; B.onStop() &gt; B.onDestroy()。</p>
<p>​		透明的B将导致A被B覆盖时不执行A.onStop()方法，B返回A时也不执行A.onRestart() &gt; A.onStart()这两个方法。</p>
<h3 id="Activity之间进行数据传递"><a href="#Activity之间进行数据传递" class="headerlink" title="Activity之间进行数据传递"></a>Activity之间进行数据传递</h3><p><strong>使用Intent</strong></p>
<ul>
<li><p><strong>基本数据类型</strong>：可以通过Intent在Activity之间传递基本数据类型和字符串数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ActivityA.<span class="built_in">this</span>, ActivityB.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可序列化对象</strong>：如果需要传递自定义对象，对象需要实现<code>Serializable</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.putExtra(<span class="string">&quot;myObject&quot;</span>, mySerializableObject);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Parcelable对象</strong>：比Serializable更高效。自定义对象需要实现<code>Parcelable</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.putExtra(<span class="string">&quot;myObject&quot;</span>, myParcelableObject);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用Bundle</strong></p>
<ul>
<li><p>将数据打包在Bundle中，然后通过Intent传递Bundle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ActivityA.<span class="built_in">this</span>, ActivityB.class);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用静态变量</strong></p>
<ul>
<li>将需要传递的数据设置为静态变量。这种方式简单但风险较高，因为静态变量的生命周期很长，可能会导致内存泄露。</li>
</ul>
<p><strong>使用全局变量（Application类）</strong></p>
<ul>
<li><p>在自定义Application类中定义全局变量，通过Application实例在Activity之间共享数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((MyApplication) getApplication()).setSomeVariable(<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用单例模式</strong></p>
<ul>
<li>通过单例类在不同Activity间共享数据，这种方式对于共享复杂的数据结构或对象非常有用。</li>
</ul>
<p><strong>使用数据库</strong></p>
<ul>
<li>将数据保存到SQLite数据库或者使用Room数据库，然后在另一个Activity中查询数据。</li>
</ul>
<p><strong>使用文件存储</strong></p>
<ul>
<li>将数据写入内部或外部存储的文件中，然后在另一个Activity中读取这些文件。</li>
</ul>
<p><strong>使用SharedPreferences</strong></p>
<ul>
<li><p>对于需要持久化的少量简单数据，可以使用SharedPreferences在Activity之间共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sharedPref</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;AppName&quot;</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sharedPref.edit();</span><br><span class="line">editor.putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">editor.apply();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用ContentProvider</strong></p>
<ul>
<li>如果数据被不同的应用或不同的Activity共享，可以使用ContentProvider作为数据的中心存储方案。</li>
</ul>
<p><strong>使用ActivityResult</strong></p>
<ul>
<li><p>当一个Activity需要从另一个Activity获取结果时，可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult()</span><br></pre></td></tr></table></figure>

<p>启动该Activity，并在后者关闭时返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ActivityB中设置返回结果</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">returnIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">returnIntent.putExtra(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">setResult(Activity.RESULT_OK, returnIntent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用EventBus或其他消息传递库</strong></p>
<ul>
<li>使用EventBus等库在Activity之间异步传递消息或数据。</li>
</ul>
<p><strong>使用Activity Results API</strong></p>
<ol>
<li>注册Activity结果回调</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> startForResult = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">    <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理返回结果</span></span><br><span class="line">        <span class="keyword">val</span> intent = result.<span class="keyword">data</span></span><br><span class="line">        <span class="comment">// 从Intent中获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>启动目标Activity</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TargetActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">// 可以添加额外的数据到Intent中</span></span><br><span class="line">startForResult.launch(intent)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.在目标Activity中设置返回结果</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> returnIntent = Intent()</span><br><span class="line"><span class="comment">// 添加数据到Intent</span></span><br><span class="line">setResult(Activity.RESULT_OK, returnIntent)</span><br><span class="line">finish() <span class="comment">// 结束当前Activity，返回到调用者</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="onSaveInstanceState-原理"><a href="#onSaveInstanceState-原理" class="headerlink" title="onSaveInstanceState 原理"></a>onSaveInstanceState 原理</h3><p>当Activity未被允许被系统自动销毁时会调用这个方法，用户主动销毁不会调用。</p>
<p>Activity调用了<code>onStop</code>后，会调用到<code>ActivityThread</code>的<code>callActivityOnSaveInstanceState()</code>方法，把Activity需要保存的数据放入<code>Bundle</code>对象中。然后通过IPC（进程间通信）机制，调用<code>ActivityManagerService</code>的<code>activityStopped</code>方法，将<code>Bundle</code>对象保存到AMS端的<code>ActivityRecord</code>中。</p>
<p>​		安卓3.0之后至9.0之前，OnSaveInstanceState方法在onPause之后onStop之前调用</p>
<p>​		安卓9.0之后OnSaveInstanceState方法在onStop之后调用</p>
<p>​		onRestoreInstanceState的执行时机在onStart之后</p>
<h3 id="onSaveInstanceState-默认保存的数据有哪些"><a href="#onSaveInstanceState-默认保存的数据有哪些" class="headerlink" title="onSaveInstanceState 默认保存的数据有哪些"></a>onSaveInstanceState 默认保存的数据有哪些</h3><p>ui状态(view中都各自重写了保存状态的方法)和fragment的信息</p>
<ul>
<li>Activity 的布局信息，例如 View 的大小、位置、可见性、滚动位置等。</li>
<li>Activity 的视图状态，例如 EditText 中的文本、CheckBox 的选中状态等。</li>
<li>Activity 的系统状态，例如屏幕亮度、音量等。</li>
</ul>
<h3 id="taskaffinity-属性"><a href="#taskaffinity-属性" class="headerlink" title="taskaffinity 属性"></a>taskaffinity 属性</h3><p>作用</p>
<ol>
<li><strong>指定任务栈</strong>：<code>taskAffinity</code> 允许开发者指定一个 Activity 应该位于特定的任务栈中。这对于在同一个应用中创建多个独立的任务栈很有用，每个任务栈可以包含一组相关的 Activity，从而实现不同的用户任务。</li>
<li><strong>处理 Intent Flags</strong>：<code>taskAffinity</code> 在处理具有特定 Intent 标志（如 <code>FLAG_ACTIVITY_NEW_TASK</code> 和 <code>FLAG_ACTIVITY_CLEAR_TOP</code>）的 Intent 时起到关键作用。例如，当启动一个新的 Activity 时，如果设置了 <code>FLAG_ACTIVITY_NEW_TASK</code> 标志，并且该 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统将会在一个新的任务栈中启动该 Activity。</li>
<li><strong>分割应用逻辑</strong>：通过使用不同的 <code>taskAffinity</code>，开发者可以将应用的不同部分分割到不同的任务栈中，从而使用户在使用多任务切换功能时能够更清晰地区分应用的不同功能模块。</li>
</ol>
<h3 id="Intent-flag"><a href="#Intent-flag" class="headerlink" title="Intent flag"></a>Intent flag</h3><ol>
<li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，如果这个 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统会在一个新的任务栈中启动该 Activity。如果已经存在一个与该 Activity 具有相同 <code>taskAffinity</code> 的任务栈，那么该 Activity 会被启动到那个任务栈中。</li>
<li>这个标志通常用于从非 Activity 上下文（如 Service 或 BroadcastReceiver）中启动 Activity。</li>
</ul>
<ol start="2">
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
</ol>
<ul>
<li>如果启动的 Activity 已经在当前任务栈中运行，则系统会将该 Activity 上面的所有其他 Activity 出栈。这样，被启动的 Activity 就位于栈顶，成为当前可见的 Activity。</li>
<li>这个标志经常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用，用于清理任务栈并将某个 Activity 置于栈顶。</li>
</ul>
<ol start="3">
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ol>
<ul>
<li>如果被启动的 Activity 已经位于任务栈的顶部，则系统不会创建该 Activity 的新实例。相反，系统会调用该 Activity 的 <code>onNewIntent()</code> 方法，并传入新的 Intent。</li>
<li>这个标志用于避免在任务栈顶部重复创建相同的 Activity。</li>
</ul>
<ol start="4">
<li><code>FLAG_ACTIVITY_CLEAR_TASK</code></li>
</ol>
<ul>
<li>这个标志会清除当前任务栈中的所有 Activity，并创建一个新的任务栈启动指定的 Activity。</li>
<li>通常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用。</li>
</ul>
<ol start="5">
<li><code>FLAG_ACTIVITY_NO_HISTORY</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，该 Activity 不会被添加到任务栈中。一旦用户离开该 Activity，它就会被销毁，无法通过后退按钮回到这个 Activity。</li>
</ul>
<p>上面五个是常用的，下面是不常用的。</p>
<ul>
<li><code>FLAG_ACTIVITY_BROUGHT_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其带到前台，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code>：启动的 Activity 不会出现在最近任务列表中。</li>
<li><code>FLAG_ACTIVITY_FORWARD_RESULT</code>：将当前 Activity 的结果转发给下一个 Activity。</li>
<li><code>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</code>：如果 Activity 是从历史记录中启动的，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_MULTIPLE_TASK</code>：与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用时，允许同一个应用中的多个任务栈拥有相同的 <code>taskAffinity</code>。</li>
<li><code>FLAG_ACTIVITY_NO_ANIMATION</code>：启动 Activity 时不显示动画效果。</li>
<li><code>FLAG_ACTIVITY_NO_USER_ACTION</code>：表明用户没有直接启动这个 Activity，可能是由另一个程序或者系统自动启动的。</li>
<li><code>FLAG_ACTIVITY_PREVIOUS_IS_TOP</code>：如果当前任务栈中的前一个 Activity 应该保持在顶部，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_REORDER_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其移动到栈顶，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</code>：如果 Activity 是从历史记录中启动的，且与当前任务栈不匹配，则重置任务栈以适应该 Activity。</li>
</ul>
<h3 id="taskaffinity-Intent-flag-launchMode"><a href="#taskaffinity-Intent-flag-launchMode" class="headerlink" title="taskaffinity + Intent flag + launchMode"></a>taskaffinity + Intent flag + launchMode</h3><p>FLAG_ACTIVITY_NEW_TASK 和 standard 模式的组合情况可以总结为：</p>
<ul>
<li>standard 没有设置 taskAffinity。此时系统就会去复用或者创建一个默认任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>standard 有设置 taskAffinity。此时又可以分为当前系统是否存在 taskAffinity 关联的任务栈两种情况<ul>
<li>不存在目标任务栈。此时系统就会创建目标任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>存在目标任务栈。此时系统会判断任务栈中是否已经存在目标 Activity 的实例，如果不存在的话则新建一个 Activity 实例入栈。如果存在目标实例的话，则只是将该任务栈转到前台而已，既不会新建 Activity 实例，也不会回调 <code>onNewIntent</code>方法，甚至也不管该 Activity 实例是否处于栈顶，总之只要存在相同实例就不做任何响应。</li>
</ul>
</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​		Service是Android程序中四大基础组件之一，它和Activity一样都是Context的子类，只不过它没有U界面，是在后台运行的组件。Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在U川线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251549636.jpeg" alt="215302_BuU9_661133"></p>
<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p><strong>启动</strong></p>
<p>Service的启动方式有两种：startService()&#x2F;stopService和bindService()&#x2F;unBindService。</p>
<ol>
<li><p>使用startService()方法启动Service，调用者与Service之间没有关系，即使调用者退出了，Service仍然运行。Service不会自动销毁，需要外部调用stopService()方法或在Service内部调用stopSelf()方法，此时Service的onDestroy()方法被调用。</p>
<p><strong>startService调用一次 startCommand就会调用一次。</strong></p>
<p>首先，定义一个Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理启动Service的请求</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY; <span class="comment">// 根据需要返回适当的标志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 本示例中不提供绑定功能，所以返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity中启动Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">serviceIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>

<p>当你想停止Service时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(serviceIntent);</span><br></pre></td></tr></table></figure>

<p>或者在Service内部自我停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopSelf();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用bindService()方法启动Service，调用者与Service绑定在了一起，调用者一旦销毁，Service也就终止了，调用者需要解绑时可调用unBindService()方法。Service被解绑或调用者销毁时，Service经历onUnbind() &gt; onDestroy()的过程。</p>
</li>
</ol>
<p>​	 定义Service与上面类似，但需要实现<code>onBind()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBoundService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalBinder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">        MyBoundService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 返回Service实例供客户端调用</span></span><br><span class="line">            <span class="keyword">return</span> MyBoundService.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onUnbind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端解绑时调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onUnbind(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Service中的方法，Activity会调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getServiceData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回服务的数据</span></span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity中绑定Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyBoundService myBoundService;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isBound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> &#123;</span><br><span class="line">        <span class="type">LocalBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (MyBoundService.LocalBinder) service;</span><br><span class="line">        myBoundService = binder.getService();</span><br><span class="line">        isBound = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在你可以调用Service中的方法了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> myService.getServiceData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName arg0)</span> &#123;</span><br><span class="line">        isBound = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在 Activity 的 onStart() 或 onResume() 方法中调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bindMyService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">bindIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyBoundService.class);</span><br><span class="line">    bindService(bindIntent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 onPause() 或 onStop() 方法中调用。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unbindMyService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBound) &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        isBound = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		同一个服务可以用两种方式一同开启，没有先后顺序的要求，MyService的onCreate只会执行一次。 关闭服务需要stopService和unbindService都被调用，也没有先后顺序的影响，MyService的onDestroy也只执行一次。但是如果只用一种方式关闭服务，不论是哪种关闭方式，onDestroy都不会被执行，服务也不会被关闭。</p>
<h3 id="服务的特征"><a href="#服务的特征" class="headerlink" title="服务的特征"></a>服务的特征</h3><ol>
<li>服务在应用进程的<code>主线程执行</code>，启动或绑定服务并不会创建自己的线程，也不会在单独的进程中执行（除非另行指定）。因此，耗时操作应当在服务中创建新的线程来完成，否则容易ANR</li>
<li>启动服务一旦启动，就会<code>无限期运行</code>，直到其调用<code>stopSelf()</code>自行停止或其他组件调用<code>stopServicec()</code>将其停止</li>
<li>在系统资源不足时，系统会根据优先级主动停止服务。其中<code>前台服务</code>拥有较高优先级，一般不会被停止，而<code>后台服务</code>的优先级则与运行时间有关，长时间运行的服务被停止的概率更高。同时，如果服务是由于资源不足而被系统停止，那么在系统资源满足的情况下，服务将被系统重启</li>
<li><code>stopSelf()</code>和<code>stopServicec()</code>并不是将服务立即结束，仅是通知系统尽快销毁而已</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://codyi96.github.io/2020/08/02/android-service/#%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1">Android前台服务 - Foreground Service</a></p>
<h3 id="前后台服务的区别"><a href="#前后台服务的区别" class="headerlink" title="前后台服务的区别"></a>前后台服务的区别</h3><p><strong>前台服务：</strong></p>
<ul>
<li><strong>用户可见性</strong>：前台服务必须显示一个持续的通知，用户可以在系统的状态栏中看到这个通知。这意味着用户随时都知道服务正在运行。</li>
<li><strong>优先级</strong>：前台服务被视为对用户或系统有明显好处的操作，因此拥有较高的进程优先级，系统不太可能因为需要内存而终止它们。</li>
<li><strong>用例</strong>：前台服务通常用于用户积极参与的操作，如音乐播放、文件下载或GPS导航。</li>
</ul>
<p><strong>后台服务：</strong></p>
<ul>
<li><strong>用户可见性</strong>：后台服务不会有任何可见的用户界面或通知（除非在Android 8.0及以上版本，后台服务也需要发出通知）。用户可能完全不知道服务正在运行。</li>
<li><strong>优先级</strong>：后台服务的优先级较低，当系统需要释放资源时，它们可能是首先被终止的进程。</li>
<li><strong>用例</strong>：后台服务用于不需要用户即时了解进展的任务，如应用数据的同步或处理任务。</li>
</ul>
<p>​		从Android 8.0（API级别26）开始，对后台执行有了新的限制，后台应用无法随意启动服务。如果应用在后台需要执行操作，必须使用JobScheduler、WorkManager或者将服务转为前台服务。这些限制主要是为了优化应用的性能和手机的电池使用时长</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251645677.png" alt="image-20240325164553638"></p>
<h3 id="后台应用不允许默默启动后台服务"><a href="#后台应用不允许默默启动后台服务" class="headerlink" title="后台应用不允许默默启动后台服务"></a>后台应用不允许默默启动后台服务</h3><p>​		自Android 8.0（API 26）开始，Android系统开始执行严格的<a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/oreo/background">后台执行限制</a>，后台应用不允许默默启动后台服务，只能启动前台服务，而前台应用则可以自由创建前台服务和后台服务。应用进入后台时，有一个持续数分钟的窗口期，在窗口期内仍然可以创建和使用前台&#x2F;后台Service。窗口期结束后，应用被视为处于空闲状态，系统将停止应用的后台Service，就像服务调用了自己的<code>stopSelf()</code>方法一样。</p>
<blockquote>
<p>如果满足以下任意条件，应用将被视为处于前台：</p>
<ul>
<li>具有可见 Activity（不管该 Activity 已启动还是已暂停）</li>
<li>具有前台 Service</li>
<li>另一个前台应用已关联到该应用（不管是通过绑定到其中一个 Service，还是通过使用其中一个内容提供程序）。例如，如果另一个应用绑定到该应用的 Service，那么该应用处于前台：<ul>
<li>IME</li>
<li>壁纸 Service</li>
<li>通知侦听器</li>
<li>语音或文本 Service</li>
</ul>
</li>
</ul>
<p>如果以上条件均不满足，应用将被视为处于后台。</p>
</blockquote>
<h3 id="创建一个前台服务"><a href="#创建一个前台服务" class="headerlink" title="创建一个前台服务"></a>创建一个前台服务</h3><p>​		前台服务一般需要先通过<code>startForegroundService()</code>启动一个后台服务，同时该方法向系统发送信号，表明服务将会自行提升前台。启动服务后，该服务需要在<code>五秒内</code>调用自己的<code>startForeground()</code>方法显式提升服务至前台。而正是这个<code>startForeground()</code>方法，唤起了本文开头的那个烦人的系统通知。</p>
<p><strong>通知栏权限</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>动态请求权限</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> manager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">    <span class="comment">// 检测该应用是否有通知权限</span></span><br><span class="line">    <span class="keyword">when</span> (manager.areNotificationsEnabled()) &#123;</span><br><span class="line">        <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">            showNotification()</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;点击了通知按钮&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">false</span> -&gt; &#123;</span><br><span class="line">            requestPermissionLauncher.launch(</span><br><span class="line">                Manifest.permission.POST_NOTIFICATIONS)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		一些特定类型的应用即使没有显式地获取通知权限（<code>POST_NOTIFICATIONS</code>，这个权限在Android 13（API级别 33）引入），也能在通知栏显示内容，主要因为它们使用的是<strong>媒体播放控制通知</strong>（通常称为媒体通知），这种通知由系统的媒体会话（Media Session）管理。</p>
<p>​		这里的关键是<strong>媒体会话</strong>和<strong>音频焦点</strong>。当应用播放媒体内容并正确地使用了<code>MediaSession</code> API时，Android系统会自动处理媒体播放通知，即使应用没有被授予通知权限。这是因为媒体播放控制被视为系统级别的功能，它允许用户在锁屏界面、通知栏、甚至是其他设备（如连接的智能手表）上控制媒体播放。</p>
<p><strong>步骤 1: 创建服务类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleForegroundService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NOTIFICATION_ID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHANNEL_ID</span> <span class="operator">=</span> <span class="string">&quot;ForegroundServiceChannel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        createNotificationChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里你可以执行你的任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建通知</span></span><br><span class="line">        <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(<span class="built_in">this</span>, CHANNEL_ID)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;Example Foreground Service&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;This is a running foreground service.&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">            <span class="comment">// 可以设置通知点击事件等</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始让服务运行在前台</span></span><br><span class="line">        startForeground(NOTIFICATION_ID, notification);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 前台服务通常不提供绑定，但是如果要提供，则返回一个接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通知渠道（对于API级别26+是必需的）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createNotificationChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="type">NotificationChannel</span> <span class="variable">serviceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(</span><br><span class="line">                CHANNEL_ID,</span><br><span class="line">                <span class="string">&quot;Foreground Service Channel&quot;</span>,</span><br><span class="line">                NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> getSystemService(NotificationManager.class);</span><br><span class="line">            manager.createNotificationChannel(serviceChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源（如果有的话）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保替换<code>R.drawable.ic_notification</code>为你实际的图标资源ID。</p>
<p><strong>步骤 2: 在AndroidManifest.xml中声明服务</strong></p>
<p>在<code>&lt;application&gt;</code>标签内，添加对服务的声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.ExampleForegroundService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 启动服务</strong></p>
<p>在你的Activity或其他组件中，启动前台服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">serviceIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ExampleForegroundService.class);</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(serviceIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(serviceIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		从Android 8.0开始，你必须在应用组件（如Activity）调用<code>startService()</code>后的几秒内通过调用<code>startForeground()</code>将服务提升为前台状态。</p>
<h3 id="如何提高service的优先级？"><a href="#如何提高service的优先级？" class="headerlink" title="如何提高service的优先级？"></a>如何提高service的优先级？</h3><ol>
<li><p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时实用于广播。</p>
</li>
<li><p>使用前台服务（Foreground Service）</p>
<p>将服务转变为前台服务是提高服务优先级的最有效方式。前台服务必须显示一个持续的通知，这意味着用户始终能够看到该服务正在运行。因为前台服务对用户来说是可见的，系统会赋予它们更高的优先级，以减少它们被杀死的机会</p>
</li>
</ol>
<h3 id="Service-的-onStartCommand-方法有几种返回值-各代表什么意思"><a href="#Service-的-onStartCommand-方法有几种返回值-各代表什么意思" class="headerlink" title="Service 的 onStartCommand 方法有几种返回值?各代表什么意思?"></a>Service 的 onStartCommand 方法有几种返回值?各代表什么意思?</h3><p>有四种返回值,不同值代表的意思如下:</p>
<ul>
<li>**START_STICKY:**如果 service 进程被 kill 掉,保留 service 的状态为开始状态,但不保留递送的 intent 对象。随 后系统会尝试重新创建 service,由于服务状态为开始状态,所以创建服务后一定会调用 onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到 service,那么参数 Intent 将为 null。</li>
<li>**START_NOT_STICKY:**“非粘性的”。使用这个返回值时,如果在执行完 onStartCommand 后,服务被异常 kill 掉,系统不会自动重启该服务。</li>
<li>**START_REDELIVER_INTENT:**重传 Intent。使用这个返回值时,如果在执行完 onStartCommand 后,服务被异 常 kill 掉,系统会自动重启该服务,并将 Intent 的值传入。</li>
<li><strong>START_STICKY_COMPATIBILITY:</strong> START_STICKY 的兼容版本,但不保证服务被 kill 后一定能重启。</li>
</ul>
<h3 id="Service里面可以弹Toast"><a href="#Service里面可以弹Toast" class="headerlink" title="Service里面可以弹Toast"></a>Service里面可以弹Toast</h3><h3 id="Service里面显示Dialog"><a href="#Service里面显示Dialog" class="headerlink" title="Service里面显示Dialog"></a>Service里面显示Dialog</h3><p>Dialog通常需要一个有效的Activity上下文才能显示。尝试在Service中直接创建和显示Dialog会遇到问题，因为Service没有属于自己的窗口。如果你尝试这样做，很可能会导致应用崩溃，抛出一个<code>android.view.WindowManager$BadTokenException</code>。</p>
<p>要从Service中安全地显示Dialog，可以采取以下策略之一：</p>
<ol>
<li><p><strong>通过发送广播或使用回调将显示Dialog的任务传递给一个Activity。</strong> 这是最安全的方法，因为Dialog将在正确的上下文中显示。</p>
</li>
<li><p><strong>使用系统级别的Alert Dialog。</strong> 如果你确实需要从Service中直接显示Dialog，你可以使用<code>SYSTEM_ALERT_WINDOW</code>权限来创建一个系统级别的Alert Dialog。从Android 6.0（API级别23）开始，用户必须在应用设置中手动为应用授予这一权限。</p>
<ul>
<li><p>首先，在<code>AndroidManifest.xml</code>中声明权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntentService</span> <span class="keyword">extends</span> <span class="title class_">IntentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyIntentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;MyIntentService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理传入的Intent</span></span><br><span class="line">        <span class="comment">// 这个方法在单独的工作线程上执行，可以执行耗时任务</span></span><br><span class="line">        <span class="comment">// 这里执行后台任务</span></span><br><span class="line">        <span class="comment">// 例如：下载文件、上传数据、处理数据等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ACTION_DOWNLOAD&quot;</span>.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// 执行下载操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在实现上，IntentService封装了HandlerThread和Handler。当IntentService被第一次启动时，它的onCreate()方法会被调用，onCreat()方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。</p>
<p>​		<a target="_blank" rel="noopener" href="https://www.cnblogs.com/DMingO/p/13391435.html">看完这一篇，再也不怕被问IntentService的原理</a></p>
<h3 id="JobIntentService"><a href="#JobIntentService" class="headerlink" title="JobIntentService"></a>JobIntentService</h3><p>​		<code>JobIntentService</code> 是 Android 开发中用于执行后台任务的一个类，它是 <code>Service</code> 的一个抽象子类。在 Android O（API 级别 26）引入后台执行限制之后，<code>JobIntentService</code> 成为了实现兼容旧版 Android 设备并且遵循新版系统后台服务限制的一个好方法。</p>
<p>​		JobIntentService是Android 8.0 新加入的类，它也是继承自Service。JobIntentService用于执行加入到队列中的任务。对Android 8.0及以上的系统，JobIntentService的任务将被分发到JobScheduler.enqueue执行，对于8.0以下的系统，任务仍旧会使用Context.startService执行。</p>
<p>主要特点</p>
<ul>
<li><strong>向后兼容</strong>：<code>JobIntentService</code> 可以在 Android O 之前的版本上作为普通的 <code>Service</code> 运行，在 Android O 及以后的版本上，则通过 <code>JobScheduler</code> 来安排任务。</li>
<li><strong>简化任务调度</strong>：通过封装 <code>JobScheduler</code> 的使用细节，<code>JobIntentService</code> 使得调度和执行后台任务变得更简单。</li>
</ul>
<p><strong><code>JobScheduler</code> 模式（API 级别 &gt;&#x3D; 26，即 Android O 及以后）</strong></p>
<p>​		从 Android O 开始，为了降低后台服务对电池寿命的影响，系统对后台服务的启动施加了严格的限制。<code>JobIntentService</code> 针对这一变化，采用了 <code>JobScheduler</code> 来调度任务。在这种模式下：</p>
<ol>
<li>当调用 <code>enqueueWork()</code> 方法时，<code>JobIntentService</code> 不会直接启动服务，而是创建一个代表任务的 <code>JobInfo</code> 对象。</li>
<li><strong>这个 <code>JobInfo</code> 对象随后被提交给 <code>JobScheduler</code>，后者负责根据系统的调度策略来执行这个任务。</strong></li>
<li><code>JobScheduler</code> 考虑多个因素来决定什么时候执行任务，如设备充电状态、网络连接状态和系统闲置状态等，从而更高效地利用系统资源，并降低对电池寿命的影响。</li>
</ol>
<p><strong>核心思想</strong></p>
<p>​		<code>JobIntentService</code> 的设计思想是利用 <code>JobScheduler</code> 在 Android O 及以后版本上提供的新机制，同时保持与旧版本的兼容性。它通过内部判断当前运行的 Android 版本，自动选择最合适的方式来执行任务。这种设计允许开发者编写一套代码，就能在不同版本的 Android 设备上高效且合规地执行后台任务。</p>
<p><strong>总结</strong></p>
<p>​		<code>JobIntentService</code> 的实现原理体现了 Android 系统发展过程中对于后台服务使用的不断调整和优化。通过一个统一的接口，它在不同版本的 Android 上实现了任务执行的最佳实践，尽管如此，随着 <code>WorkManager</code> 的引入，Google 推荐使用更加灵活且功能强大的 <code>WorkManager</code> 来替代 <code>JobIntentService</code>，以满足现代 Android 应用对后台任务管理的需求。</p>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>​		BroadcastReceiver直译为”广播接收者”，主要用来接收来自系统和应用中的广播。在Android系统中，广播体现在方方面面，例如开机广播、网络状态广播、电池电量广播等等。</p>
<ul>
<li>Broadcast Receiver（广播接收器），属于Android四大组件之一</li>
<li>在Android开发中，Broadcast Receiver的应用场景非常多。广播，是一个全局的监听器，属于Android四大组件。</li>
</ul>
<p>　　Android 广播分为两个角色：广播发送者，广播接收者。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>用于监听&#x2F;接收应用发出的广播消息，并做出响应。</p>
</li>
<li><p>应用场景</p>
<p>a不同组件之间通信（包括应用内&#x2F;不同应用之间)</p>
<p>b.与Android系统在特定情况下的通信如当电话呼入时、网络可用时</p>
<p>c.多线程通信</p>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Android中的广播使用了设计模式中的观察者模式：基于消息的发布&#x2F;订阅事件模型。</p>
<p>　　因此，Android将广播的发送者和接收者解耦，使得系统方便集成，更易扩展。</p>
<p>　　模型中有3个角色：</p>
<p>　　i.消息订阅者（广播接收者）</p>
<p>　　ii.消息发布者（广播发布者）</p>
<p>　　iii.消息中心（AMS，即Activity Manager Service）</p>
<p>　　<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251854168.png" alt="img"></p>
<p> 原理描述：</p>
<ul>
<li>广播接收者 通过Binder机制在AMS注册</li>
<li>广播发送者通过Binder机制向AMS发送广播</li>
<li>AMS根据广播发送者要求，在已注册列表中，寻找合适的广播接收者。寻找依据：IntentFilter&#x2F;Permission</li>
<li>AMS将广播发送到合适的广播接收者相应的消息循环队列中</li>
<li>广播接收者通过消息循环拿到此广播，并回调onReceiver()</li>
</ul>
<p>特别注意：</p>
<p>　　广播发送者和广播接收者的执行是异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到；</p>
<p>　　</p>
<h3 id="静态广播和动态广播的区别"><a href="#静态广播和动态广播的区别" class="headerlink" title="静态广播和动态广播的区别"></a>静态广播和动态广播的区别</h3><p><strong>静态广播（Static Broadcast）</strong></p>
<ol>
<li>定义广播接收器</li>
</ol>
<p>首先，创建一个继承自 <code>BroadcastReceiver</code> 的类，并重写 <code>onReceive</code> 方法。这个方法将在接收到广播时被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic class MyStaticReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 在这里处理接收到的广播，例如，启动一个服务、显示通知等</span><br><span class="line">        Log.d(&quot;MyStaticReceiver&quot;, &quot;Received broadcast in MyStaticReceiver: &quot; + intent.getAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>AndroidManifest.xml</code> 中声明</li>
</ol>
<p>接下来，在应用的 <code>AndroidManifest.xml</code> 文件中声明这个广播接收器，并指定它应该接收的广播类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlCopy code&lt;application</span><br><span class="line">    ...&gt;</span><br><span class="line">    &lt;receiver android:name=&quot;.MyStaticReceiver&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>

<p>​		这个例子中，广播接收器将在设备完成启动后接收一个广播。当此 <code>App</code>首次启动时，系统会<strong>自动</strong>实例化<code>mBroadcastReceiver</code>类，并注册到系统中。</p>
<p><strong>动态广播（Dynamic Broadcast）</strong></p>
<ol>
<li>定义广播接收器</li>
</ol>
<p>动态广播接收器也是继承自 <code>BroadcastReceiver</code> 的类，实现方法与静态广播接收器相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDynamicReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理接收到的广播，例如，更新UI、启动服务等</span></span><br><span class="line">        Log.d(<span class="string">&quot;MyDynamicReceiver&quot;</span>, <span class="string">&quot;Received broadcast in MyDynamicReceiver: &quot;</span> + intent.getAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注册和注销广播接收器</li>
</ol>
<p>动态注册广播接收器通常在一个应用组件（如 <code>Activity</code>）中完成。需要注意的是，你应该在适当的时候注销广播接收器，避免造成内存泄露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyDynamicReceiver</span> <span class="variable">myDynamicReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDynamicReceiver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="comment">// 注册广播接收器</span></span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">        registerReceiver(myDynamicReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        <span class="comment">// 注销广播接收器</span></span><br><span class="line">        unregisterReceiver(myDynamicReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyDynamicReceiver</code> 会在 <code>MyActivity</code> 活跃时接收网络连接改变的广播。</p>
<p>​		通过这些代码示例可以看到静态和动态广播在定义、注册方式以及使用场景上的区别。<strong>静态广播主要用于应用需要在未运行时响应系统事件的情况，而动态广播则适用于应用在运行时根据特定事件执行操作。</strong></p>
<p><strong>总结：</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251906046.png" alt="示意图"></p>
<h3 id="广播的种类"><a href="#广播的种类" class="headerlink" title="广播的种类"></a>广播的种类</h3><ul>
<li>普通广播（<code>Normal Broadcast</code>）</li>
<li>系统广播（<code>System Broadcast</code>）</li>
<li>有序广播（<code>Ordered Broadcast</code>）</li>
<li>粘性广播（<code>Sticky Broadcast</code>）</li>
<li>App应用内广播（<code>Local Broadcast</code>）</li>
</ul>
<p><strong>标准广播</strong>（Normal Broadcast）</p>
<p>发送标准广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_STANDARD_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some data&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>接收标准广播，在 <code>AndroidManifest.xml</code> 中注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyStandardReceiver&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.example.broadcast.MY_STANDARD_BROADCAST&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>广播接收器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStandardReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;MyStandardReceiver&quot;</span>, <span class="string">&quot;Received standard broadcast with data: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态广播同理</p>
<p><strong>有序广播</strong>（Ordered Broadcast）</p>
<ul>
<li>定义<br> 发送出去的广播被广播接收者按照先后顺序接收</li>
</ul>
<blockquote>
<p>有序是针对广播接收者而言的</p>
</blockquote>
<ul>
<li>广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者）<ol>
<li>按照Priority属性值从大-小排序；</li>
<li>Priority属性相同者，动态注册的广播优先；</li>
</ol>
</li>
<li>特点<ol>
<li>接收广播按顺序接收</li>
<li>先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播；</li>
<li>先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</li>
</ol>
</li>
<li>具体使用<br> 有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>发送有序广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_ORDERED_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some data&quot;</span>);</span><br><span class="line">sendOrderedBroadcast(intent, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>接收有序广播：</p>
<p>注册和接收标准广播的方式类似，但可以在 <code>AndroidManifest.xml</code> 中为接收器指定优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyOrderedReceiver&quot;</span> android:priority=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.example.broadcast.MY_ORDERED_BROADCAST&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p><strong>系统广播</strong></p>
<p>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播</p>
<p><strong>粘性广播</strong>（Sticky Broadcast）</p>
<p>粘性广播因安全和性能问题，在Android 5.0（API 级别 21）及之后的版本中不再支持自定义使用。因此，这里不提供具体示例。对于需要此类功能的场景，建议使用其他通信方式，如使用 <code>ViewModel</code> 和 <code>LiveData</code> 或者 <code>EventBus</code>。</p>
<p><strong>本地广播</strong>（Local Broadcasts）</p>
<p>背景<br> Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）</p>
<p>冲突<br> 可能出现的问题：</p>
<ul>
<li>其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；</li>
<li>其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息；<br> 即会出现安全性 &amp; 效率性的问题。</li>
</ul>
<p>解决方案：<br> 使用App应用内广播（Local Broadcast）</p>
<ul>
<li><p>具体使用1 - 将全局广播设置成局部广播</p>
<ol>
<li>注册广播时将exported属性设置为<em>false</em>，使得非本App内部发出的此广播不被接收；</li>
<li>在广播发送和接收时，增设相应权限permission，用于权限验证；</li>
<li>发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。</li>
</ol>
<blockquote>
<p>通过**intent.setPackage(packageName)**指定报名</p>
</blockquote>
</li>
<li><p>具体使用2 - 使用封装好的LocalBroadcastManager类<br> 使用方式上与全局广播几乎相同，只是注册&#x2F;取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例</p>
</li>
</ul>
<blockquote>
<p>注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</p>
</blockquote>
<p>发送本地广播：</p>
<p>首先，确保项目中已经添加了 Support Library，因为 <code>LocalBroadcastManager</code> 是其中的一部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_LOCAL_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some local data&quot;</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="built_in">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>接收本地广播，注册本地广播接收器通常在 <code>Activity</code> 或 <code>Fragment</code> 的生命周期内完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStart();</span><br><span class="line">    <span class="comment">// 创建 IntentFilter</span></span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.example.broadcast.MY_LOCAL_BROADCAST&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册本地广播接收器</span></span><br><span class="line">    LocalBroadcastManager.getInstance(<span class="built_in">this</span>).registerReceiver(myLocalReceiver, filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br><span class="line">    <span class="comment">// 注销本地广播接收器</span></span><br><span class="line">    LocalBroadcastManager.getInstance(<span class="built_in">this</span>).unregisterReceiver(myLocalReceiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地广播接收器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">BroadcastReceiver</span> <span class="variable">myLocalReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;MyLocalReceiver&quot;</span>, <span class="string">&quot;Received local broadcast with data: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。"><a href="#LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。" class="headerlink" title="LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。"></a>LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。</h3><ul>
<li>使用了单例模式，并且将外部传入的Context转换成了Application的Context，避免造成内存泄露。</li>
<li>在构造方法中创建了Handler，实质是通过Handler进行发送和接受消息的。</li>
<li>创建Handler时，传入了主线程的Looper，说明这个Handler是在主线程创建的，即广播接收者是在主线程接收消息的，所以不能在onReceiver（）中做耗时操作。</li>
</ul>
<p>注意：对于LocalBroadcastManager发送的广播，只能通过LocalBroadcastManager动态注册，不能静态注册。</p>
<p><strong>特别注意：</strong></p>
<ul>
<li><p>如果BroadcastReceiver在onReceiver（）方法中在10秒内没有执行完成，会造成ANR异常。</p>
</li>
<li><p>对于不同注册方式的广播接收者回调方法onReceive（）返回的Context是不一样的：</p>
<p>  静态注册：context为ReceiverRestrictedContext。</p>
<p>  动态注册：context为Activity的Context。</p>
<p>  LocalBroadcastManager的动态注册：context为Application的Context。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/52973504">Carson带你学Android：手把手教你学会广播组件-BroadcastReceiver</a></p>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​		<code>ContentProvider</code> 是 Android 平台上的一个核心组件，用于在不同的应用之间共享数据。它提供了一种封装数据和数据源的机制，允许一个应用访问另一个应用的数据，同时还可以保证数据的安全性和隐私性。通过 <code>ContentProvider</code>，应用可以对外共享其数据，或从其他应用获取数据，而不需要直接访问其他应用的数据库或文件系统。</p>
<p><strong>启动</strong></p>
<p>①  启动入口为ActivityThread.main():创建ActivityThread实例并创建主线程消息队列</p>
<p>②  ActivityThread.attach():远程调用AMS.attachApplication并提供ApplicationThread用于和AMS通信</p>
<p>③  AMS.attschApplication()通过ActivityThread.bindApplication()方法和Handler H来调回ActivityThread.handleBindApplication()</p>
<p>④  ActivityThread.handleBindApplication():先创建Application、再去加载ContentProvider，最后回调Application.onCreate()</p>
<h3 id="ContentProvider是如何实现实现数据共享的？"><a href="#ContentProvider是如何实现实现数据共享的？" class="headerlink" title="ContentProvider是如何实现实现数据共享的？"></a><strong>ContentProvider是如何实现实现数据共享的？</strong></h3><p>​		自定义一个类继承ContentProvider然后覆写query、insert、update、delete等方法，还需要再清单文件中注册。把自己的数据通过uri的形式共享出去 。</p>
<p><strong>步骤 1: 创建自定义 <code>ContentProvider</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化你的数据源，这里仅作示例，实际应用中可能是数据库或其他存储形式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数据源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true 表示初始化成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span><br><span class="line"><span class="params">                        String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理查询请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 示例代码，实际开发中需要返回查询结果的 Cursor 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 URI 返回 MIME 类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理插入请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 示例代码，实际开发中需要返回新插入数据的 Uri</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理删除请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 示例代码，实际开发中需要返回删除的行数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span><br><span class="line"><span class="params">                      String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理更新请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 示例代码，实际开发中需要返回更新的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在 AndroidManifest.xml 中注册 <code>ContentProvider</code></strong></p>
<p>将自定义的 <code>ContentProvider</code> 注册到应用的 AndroidManifest.xml 文件中。你需要提供一个唯一的 <code>authorities</code> 属性来标识你的 <code>ContentProvider</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;your.package.name&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        ...&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;provider</span><br><span class="line">            android:name=<span class="string">&quot;.MyCustomProvider&quot;</span></span><br><span class="line">            android:authorities=<span class="string">&quot;your.package.name.myprovider&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;/provider&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>​		将 <code>your.package.name</code> 替换成自己的应用包名，<code>MyCustomProvider</code> 替换成你的 <code>ContentProvider</code> 类名。<code>authorities</code> 属性是 <code>ContentProvider</code> 的唯一标识符，用于构建访问数据的 URI。</p>
<p>数据访问示例</p>
<p>其他应用可以通过 <code>ContentResolver</code> 使用 URI 访问你的 <code>ContentProvider</code> 中的数据。例如，如果他们想查询你的提供者，他们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">contentUri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://your.package.name.myprovider/table_name&quot;</span>);</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> getContentResolver().query(contentUri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&quot;content://your.package.name.myprovider/table_name&quot;</code> 是访问数据的 URI。<code>&quot;table_name&quot;</code> 应该被你希望访问的数据表名或数据类型所替换。</p>
<h3 id="为什么要用ContentProvider？与sql的实现上有什么区别？"><a href="#为什么要用ContentProvider？与sql的实现上有什么区别？" class="headerlink" title="为什么要用ContentProvider？与sql的实现上有什么区别？"></a><strong>为什么要用ContentProvider？与sql的实现上有什么区别？</strong></h3><p>ContentProvider屏蔽了数据存储的细节，内部实现对数据用户完全透明，用户只需要关心操作数据的uri就行。ContentProvider实现了不同app是之间数据共享。ContentProvider可以对本地文件进行增删改查的操作。</p>
<p>Sql也有增删改查等方法，但是只能查询本应用下的数据库。</p>
<h3 id="ContentProvider运行在主线程，为什么不会影响主线程的UI操作？"><a href="#ContentProvider运行在主线程，为什么不会影响主线程的UI操作？" class="headerlink" title="ContentProvider运行在主线程，为什么不会影响主线程的UI操作？"></a><strong>ContentProvider运行在主线程，为什么不会影响主线程的UI操作？</strong></h3><p>ContentProvider的onCreate是运行在UI线程的，而增删改查是运行在线程池中的工作线程的，所以调用这几个操作并不会阻塞主线程，但可能会阻塞调用者所在的主线程。</p>
<p>所以调用ContentProvider的操作任然要放到子线程中去做。最然直接的增删改查是在工作线程，但系统会让你的调用线程等待这个异步的操作完成，才可以继续之后的工作。</p>
<h3 id="ContentProvider的好处、设计目的？"><a href="#ContentProvider的好处、设计目的？" class="headerlink" title="ContentProvider的好处、设计目的？"></a><strong>ContentProvider的好处、设计目的？</strong></h3><ol>
<li><p>隐藏了数据的实现方式，对外提供统一的数据访问接口</p>
</li>
<li><p>更好的数据访问权限管理。不同的URI对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。</p>
</li>
<li><p>ContentProvider封装了跨进程共享的逻辑，我们只需要URI即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问线程的分配，简化我们在应用间共享数据的方式，我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心他所在的进程是启动还是未启动</p>
</li>
</ol>
<h3 id="为什么要使用ContentResolver类与ContentProvider进行交互？"><a href="#为什么要使用ContentResolver类与ContentProvider进行交互？" class="headerlink" title="为什么要使用ContentResolver类与ContentProvider进行交互？"></a><strong>为什么要使用ContentResolver类与ContentProvider进行交互？</strong></h3><p>一般情况下，一个应用可能会使用多个ContentProvider，若要了解每个ContentProvider再进行不同的实现完成数据交互，操作成本大且难度高。</p>
<p>ContentResolver就是对素有的ContentProvider仅从统一管理，通过URI可操作不同的ContentProvider中的数据，外部进程通过COntentReslover类完成与ContentProvider交互</p>
<h3 id="ContentProvider访问媒体文件"><a href="#ContentProvider访问媒体文件" class="headerlink" title="ContentProvider访问媒体文件"></a>ContentProvider访问媒体文件</h3><p>​		要通过 <code>ContentProvider</code> 访问媒体文件（如图片、视频等），通常会使用 Android 系统提供的 <code>MediaStore</code>。<code>MediaStore</code> 是一个内置的 <code>ContentProvider</code>，用于管理媒体文件的共享存储。</p>
<p><strong>步骤 1: 添加必要的权限</strong></p>
<p>在 <code>AndroidManifest.xml</code> 中添加读取存储的权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>从 Android 6.0（API 级别 23）开始，<strong>还需要在运行时请求这个权限。</strong></p>
<p><strong>步骤 2: 运行时请求权限</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_EXTERNAL_STORAGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] PERMISSIONS_STORAGE = &#123;</span><br><span class="line">    Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verifyStoragePermissions</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">    <span class="comment">// Check if we have read permission</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">permission</span> <span class="operator">=</span> ActivityCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (permission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t have permission so prompt the user</span></span><br><span class="line">        ActivityCompat.requestPermissions(</span><br><span class="line">                activity,</span><br><span class="line">                PERMISSIONS_STORAGE,</span><br><span class="line">                REQUEST_EXTERNAL_STORAGE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 查询媒体文件</strong></p>
<p>使用 <code>ContentResolver</code> 查询 <code>MediaStore</code> 中的数据了。以下示例展示如何查询设备上的图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ImageInfo&gt; <span class="title function_">queryImages</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ImageInfo&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ContentResolver</span> <span class="variable">contentResolver</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">            MediaStore.Images.Media._ID,</span><br><span class="line">            MediaStore.Images.Media.DISPLAY_NAME,</span><br><span class="line">            MediaStore.Images.Media.SIZE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> contentResolver.query(uri, projection, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nameColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> cursor.getLong(idColumn);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(nameColumn);</span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> cursor.getLong(sizeColumn);</span><br><span class="line"></span><br><span class="line">            <span class="type">Uri</span> <span class="variable">contentUri</span> <span class="operator">=</span> ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id);</span><br><span class="line">            images.add(<span class="keyword">new</span> <span class="title class_">ImageInfo</span>(id, name, size, contentUri));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;QueryImages&quot;</span>, <span class="string">&quot;Error querying images&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>记得在适当的时机（如用户同意权限请求后）调用 <code>queryImages()</code> 方法。</li>
<li>由于这些操作可能涉及大量的数据查询，<strong>在后台线程中执行查询操作，以避免阻塞主线程。</strong></li>
<li>上面的代码示例没有处理运行时权限的用户响应。在实际应用中，应该在 <code>onRequestPermissionsResult</code> 中根据用户是否授权采取相应的行动。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/26/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/03/26/ARouter/" title="路由框架原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">路由框架原理</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">狂奔的馒头</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:imcoddo@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity"><span class="toc-number">1.</span> <span class="toc-text">Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">生命周期方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">其他的生命周期方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Activity的启动模式以及它们的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2"><span class="toc-number">1.4.</span> <span class="toc-text">Activity横竖屏切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E8%B7%B3%E8%BD%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.5.</span> <span class="toc-text">Activity跳转生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.</span> <span class="toc-text">Activity之间进行数据传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onSaveInstanceState-%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">onSaveInstanceState 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onSaveInstanceState-%E9%BB%98%E8%AE%A4%E4%BF%9D%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.8.</span> <span class="toc-text">onSaveInstanceState 默认保存的数据有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taskaffinity-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.</span> <span class="toc-text">taskaffinity 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent-flag"><span class="toc-number">1.10.</span> <span class="toc-text">Intent flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taskaffinity-Intent-flag-launchMode"><span class="toc-number">1.11.</span> <span class="toc-text">taskaffinity + Intent flag + launchMode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service"><span class="toc-number">2.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">启动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.</span> <span class="toc-text">服务的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">前后台服务的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%BA%94%E7%94%A8%E4%B8%8D%E5%85%81%E8%AE%B8%E9%BB%98%E9%BB%98%E5%90%AF%E5%8A%A8%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.6.</span> <span class="toc-text">后台应用不允许默默启动后台服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.7.</span> <span class="toc-text">创建一个前台服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98service%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">如何提高service的优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-%E7%9A%84-onStartCommand-%E6%96%B9%E6%B3%95%E6%9C%89%E5%87%A0%E7%A7%8D%E8%BF%94%E5%9B%9E%E5%80%BC-%E5%90%84%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">2.9.</span> <span class="toc-text">Service 的 onStartCommand 方法有几种返回值?各代表什么意思?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E9%87%8C%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%BC%B9Toast"><span class="toc-number">2.10.</span> <span class="toc-text">Service里面可以弹Toast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E9%87%8C%E9%9D%A2%E6%98%BE%E7%A4%BADialog"><span class="toc-number">2.11.</span> <span class="toc-text">Service里面显示Dialog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntentService"><span class="toc-number">2.12.</span> <span class="toc-text">IntentService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JobIntentService"><span class="toc-number">2.13.</span> <span class="toc-text">JobIntentService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BroadcastReceiver"><span class="toc-number">3.</span> <span class="toc-text">BroadcastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B9%BF%E6%92%AD%E5%92%8C%E5%8A%A8%E6%80%81%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.</span> <span class="toc-text">静态广播和动态广播的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">广播的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocalBroadcastManager%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A%E6%98%AF%E5%BA%94%E7%94%A8%E5%86%85%E5%B9%BF%E6%92%AD%EF%BC%8C%E5%88%A9%E7%94%A8Handler%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">3.6.</span> <span class="toc-text">LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ContentProvider"><span class="toc-number">4.</span> <span class="toc-text">ContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">ContentProvider是如何实现实现数据共享的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8ContentProvider%EF%BC%9F%E4%B8%8Esql%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">为什么要用ContentProvider？与sql的实现上有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84UI%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">ContentProvider运行在主线程，为什么不会影响主线程的UI操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">ContentProvider的好处、设计目的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8ContentResolver%E7%B1%BB%E4%B8%8EContentProvider%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">为什么要使用ContentResolver类与ContentProvider进行交互？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider%E8%AE%BF%E9%97%AE%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6"><span class="toc-number">4.7.</span> <span class="toc-text">ContentProvider访问媒体文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Activity%20%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" title="无题">无题</a><time datetime="2024-03-26T11:10:09.256Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20ANR/" title="Android ANR">Android ANR</a><time datetime="2024-03-26T11:10:09.254Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Fragment/" title="无题">无题</a><time datetime="2024-03-26T11:10:09.252Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Handler%E6%9C%BA%E5%88%B6/" title="Android Handler消息机制">Android Handler消息机制</a><time datetime="2024-03-26T11:10:09.250Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/26/Android%20Jetpack/" title="Android JetPack">Android JetPack</a><time datetime="2024-03-26T11:10:09.249Z" title="发表于 2024-03-26 19:10:09">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'zrmomo/comment',
      'data-repo-id': 'R_kgDOLFdqRA',
      'data-category-id': 'DIC_kwDOLFdqRM4CcdAM',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>