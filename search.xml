<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Recyclerview缓存机制</title>
    <url>/2023/12/15/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Recyclerview缓存机制"><a href="#Recyclerview缓存机制" class="headerlink" title="Recyclerview缓存机制"></a>Recyclerview缓存机制</h1><h2 id="Recyclerview基本使用"><a href="#Recyclerview基本使用" class="headerlink" title="Recyclerview基本使用"></a>Recyclerview基本使用</h2><p>xml中添加空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>item.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;测试&quot;</span> /&gt;</span></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<p>Adapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerView.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  OnItemClickListener itemClickListener;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShareBean&gt; mData = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecyclerAdapter</span><span class="params">(Context context, List&lt;ShareBean&gt; mData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mData = mData;</span><br><span class="line">        <span class="built_in">this</span>.mInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将布局转化为 View 并传递给 RecyclerView 封装好的 ViewHolder</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span>&#123;    </span><br><span class="line">        <span class="comment">// 实例化展示的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mInflater.inflate(R.layout.item_recyclerview, parent, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 实例化viewholder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemViewHolder</span>(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据与视图进行绑定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        ((ItemViewHolder) holder).mImageView.setImageResource(mData.get(position).getImage_id());</span><br><span class="line">        ((ItemViewHolder) holder).mTextView.setText(mData.get(position).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 Item 的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mData == <span class="literal">null</span> ? <span class="number">0</span> : mData.size();;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        CardView mCardView;</span><br><span class="line">        CircleImageView mImageView;</span><br><span class="line">        TextView mTextView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ItemViewHolder</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            mTextView = (TextView) itemView.findViewById(R.id.textView);</span><br><span class="line">            mCardView = (CardView) itemView.findViewById(R.id.cardView);</span><br><span class="line">            mImageView = (CircleImageView) itemView.findViewById(R.id.image);</span><br><span class="line">            mCardView.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (itemClickListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        itemClickListener.onItemClick(view, getPosition());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RecyclerView缓存的是什么？"><a href="#RecyclerView缓存的是什么？" class="headerlink" title="RecyclerView缓存的是什么？"></a>RecyclerView缓存的是什么？</h2><p>首先明确一点，Recyclerview缓存的是ViewHolder。</p>
<h2 id="RecyclerView缓存的目的？"><a href="#RecyclerView缓存的目的？" class="headerlink" title="RecyclerView缓存的目的？"></a>RecyclerView缓存的目的？</h2><ul>
<li>onCreateViewHolder：负责创建并初始化ViewHolder及其关联的视图，但不会填充视图内容。</li>
<li>onBindViewHolder：负责提取适当的数据，填充ViewHolder的视图内容。</li>
</ul>
<p>最优情况是——取得的缓存对象正好是原先的ViewHolder对象，这种情况下既不需要重新创建该对象，也不需要重新绑定数据，即拿即用。</p>
<p>次优情况是——取得的缓存对象虽然不是原先的ViewHolder对象，但由于二者的列表项类型(itemType)相同，其关联的视图可以复用，因此只需要重新绑定数据即可。</p>
<p>最后实在没办法了，才需要执行这2个方法的回调，即创建新的ViewHolder对象并绑定数据</p>
<p>应该通过对ViewHolder对象积极地缓存复用，来尽量减少对这2个方法的回调频次。</p>
<h2 id="RecyclerView缓存的实现"><a href="#RecyclerView缓存的实现" class="headerlink" title="RecyclerView缓存的实现"></a>RecyclerView缓存的实现</h2><h3 id="RecyclerView的滚动实现"><a href="#RecyclerView的滚动实现" class="headerlink" title="RecyclerView的滚动实现"></a>RecyclerView的滚动实现</h3><p>看源码分析从onTouchEvent方法的ACTION_MOVE事件开始，然后到scrollByInternal方法又到scrollStep方法最终又会调用到LayoutManager的方法来实现最终的滑动处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedX = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedY = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而LayoutManager中的这两个方法又分别交给了他的实现类去实现，这里以LinearLayoutManager类为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置回收标记，表示在布局过程中可以回收和复用视图</span></span><br><span class="line">    mLayoutState.mRecycle = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 根据滚动的方向，设置布局的方向。delta &gt; 0表示向结束方向滚动，否则向开始方向滚动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> delta &gt; <span class="number">0</span> ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">    <span class="comment">// 获取滚动距离的绝对值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absDelta</span> <span class="operator">=</span> Math.abs(delta);</span><br><span class="line">    <span class="comment">// 更新LayoutManager的状态，包括布局方向、滚动距离等</span></span><br><span class="line">    updateLayoutState(layoutDirection, absDelta, <span class="literal">true</span>, state);</span><br><span class="line">    <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">            + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">    。。。。</span><br><span class="line">    <span class="comment">//距离大于实际能够滚动的距离，就滚动实际能够滚动的距离，否则滚动请求的距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">scrolled</span> <span class="operator">=</span> absDelta &gt; consumed ? layoutDirection * consumed : delta;</span><br><span class="line">    <span class="comment">// 根据实际的滚动距离，移动所有的子视图</span></span><br><span class="line">    mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">    <span class="comment">// 保存实际的滚动距离，以便后续使用</span></span><br><span class="line">    mLayoutState.mLastScrollDelta = scrolled;</span><br><span class="line">    <span class="comment">// 返回实际的滚动距离</span></span><br><span class="line">    <span class="keyword">return</span> scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取填充项和进行回收项"><a href="#获取填充项和进行回收项" class="headerlink" title="获取填充项和进行回收项"></a>获取填充项和进行回收项</h3><p>这里又调用了fill方法，这个方法是用来获取填充项的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			...</span><br><span class="line">            <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">                <span class="comment">//在当前滚动偏移量基础上追加因新表项插入增加的像素（这句话对于“回收哪些表项”来说很关键）</span></span><br><span class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//回收表项</span></span><br><span class="line">                recycleByLayoutState(recycler, layoutState);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!layoutState.mRecycle || layoutState.mInfinite) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            <span class="comment">// 从列表头回收</span></span><br><span class="line">            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从列表尾回收</span></span><br><span class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="回收条件判断"><a href="#回收条件判断" class="headerlink" title="回收条件判断"></a>回收条件判断</h3><p>这里只看列表头回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向列表尾部滚动时回收滚出屏幕的表项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dt（该参数被用于检测滚出屏幕的表项）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="type">int</span> scrollingOffset,<span class="type">int</span> noRecycleSpace)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> scrollingOffset - noRecycleSpace;</span><br><span class="line">        <span class="comment">//从头开始遍历 LinearLayoutManager，以找出应该会回收的表项</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="comment">// 如果表项的下边界 &gt; limit 这个阈值</span></span><br><span class="line">            <span class="keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                    || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">                <span class="comment">//回收索引为 0 到 i-1 的表项</span></span><br><span class="line">                recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看上面代码中有一个判断条件<code>mOrientationHelper.getDecoratedEnd(child) &gt; limit</code>，***在纵向列表中，“表项底部纵坐标 &gt; 某个值”意味着表项位于某条线的下方，即 limit 是列表中隐形的线，所有在这条线上方的表项都应该被回收。</p>
<p><strong>limit 隐形线</strong>的初始值 &#x3D; 列表当前可见表项的底部到列表底部的距离，即列表在不填充新表项时，可以滑动的最大距离。每一个新填充表项消耗的像素值都会被追加到 limit 值之上，即<strong>limit 隐形线</strong>会随着新表项的填充而不断地下移。</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><h4 id="第一级mCachedViews"><a href="#第一级mCachedViews" class="headerlink" title="第一级mCachedViews"></a>第一级mCachedViews</h4><p>会看代码执行到了<code>recycleChildren(recycler, 0, i);</code>，跟代码最终会调用<code>recycler.recycleView(view);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Recycler </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycleView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取表项 ViewHolder </span></span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">            <span class="keyword">if</span> (holder.isTmpDetached()) &#123;</span><br><span class="line">                removeDetachedView(view, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                holder.unScrap();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                holder.clearReturnedFromScrapFlag();</span><br><span class="line">            &#125;</span><br><span class="line">            recycleViewHolderInternal(holder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>getChildViewHolderInt(view)获取的是滑出屏幕的项的ViewHolder，然后交给了recycleViewHolderInternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">mViewCacheMax</span> <span class="operator">=</span> DEFAULT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CACHE_SIZE</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">// mCachedViews的长度限制为2</span></span><br><span class="line">    	<span class="comment">// mCachedViews是一个ArrayList</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">                <span class="comment">//先存在mCachedViews里面</span></span><br><span class="line">                <span class="comment">//这里的判断条件决定了复用mViewCacheMax中的ViewHolder时不需要重新绑定数据</span></span><br><span class="line">                <span class="keyword">if</span> (mViewCacheMax &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">                        | ViewHolder.FLAG_REMOVED</span><br><span class="line">                        | ViewHolder.FLAG_UPDATE</span><br><span class="line">                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">                    <span class="comment">//如果mCachedViews大小超限了，则删掉最老的被缓存的ViewHolder</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">cachedViewSize</span> <span class="operator">=</span> mCachedViews.size();</span><br><span class="line">                    <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这里将索引为0的元素放入到回收池RecycledViewPool中  </span></span><br><span class="line">                        recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                        cachedViewSize--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">targetCacheIndex</span> <span class="operator">=</span> cachedViewSize;</span><br><span class="line">                    <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK</span><br><span class="line">                            &amp;&amp; cachedViewSize &gt; <span class="number">0</span></span><br><span class="line">                            &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> cachedViewSize - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> (cacheIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cachedPos</span> <span class="operator">=</span> mCachedViews.get(cacheIndex).mPosition;</span><br><span class="line">                            <span class="keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            cacheIndex--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        targetCacheIndex = cacheIndex + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//ViewHolder加到缓存中</span></span><br><span class="line">                    mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">                    cached = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若ViewHolder没有入缓存则存入回收池</span></span><br><span class="line">                <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">                    addViewHolderToRecycledViewPool(holder, <span class="literal">true</span>);</span><br><span class="line">                    recycled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码做了这么一件事，首先判断mCachedViews的元素数量，如果数量超过或者等于2就将最先添加到list的元素放到RecycledViewPool中，然后在mCachedViews中移除它。然后将传入的holder添加到mCachedViews中。</p>
<p>mCachedViews中的数量会限制为两个。移出屏幕的holder最先会添加到mCachedViews中，但是如果mViewCacheMax &lt;&#x3D; 0（setViewCacheSize方法可以修改这个值）或者holder有其中任何一个标识：</p>
<ul>
<li><code>ViewHolder.FLAG_INVALID</code>：表示这个视图是无效的，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_REMOVED</code>：表示这个视图已经被移除。</li>
<li><code>ViewHolder.FLAG_UPDATE</code>：表示这个视图的数据已经更新，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN</code>：表示这个视图的适配器位置未知</li>
</ul>
<p>都会将这个移出屏幕的holder越过mCachedViews直接放入RecycledViewPool中。<strong>所以从<code>mCachedViews</code>中复用的<code>ViewHolder</code>不需要重新绑定数据，从RecycledViewPool复用的<code>ViewHolder</code>需要重新绑定数据。</strong></p>
<h4 id="第二级RecycledViewPool"><a href="#第二级RecycledViewPool" class="headerlink" title="第二级RecycledViewPool"></a>第二级RecycledViewPool</h4><p>前面讲到会将mCachedViews中最老的元素放入RecycledViewPool中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存池实例</span></span><br><span class="line">        RecycledViewPool mRecyclerPool;</span><br><span class="line">        <span class="comment">// 将viewHolder存入缓存池</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">addViewHolderToRecycledViewPool</span><span class="params">(ViewHolder holder, <span class="type">boolean</span> dispatchRecycled)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            getRecycledViewPool().putRecycledView(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 RecycledViewPool 实例</span></span><br><span class="line">        RecycledViewPool <span class="title function_">getRecycledViewPool</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRecyclerPool == <span class="literal">null</span>) &#123;</span><br><span class="line">                mRecyclerPool = <span class="keyword">new</span> <span class="title class_">RecycledViewPool</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mRecyclerPool;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RecycledViewPool</span> &#123;</span><br><span class="line">        <span class="comment">// 单类型 ViewHolder 列表</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">            <span class="comment">// 最终存储 ViewHolder 实例的列表</span></span><br><span class="line">            ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//每种类型的 ViewHolder 最多存 5 个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//键值对:以 viewType 为键，ScrapData 为值，用以存储不同类型的 ViewHolder 列表</span></span><br><span class="line">        SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//ViewHolder 入池 按 viewType 分类入池，相同的 ViewType 存放在同一个列表中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putRecycledView</span><span class="params">(ViewHolder scrap)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> scrap.getItemViewType();</span><br><span class="line">            <span class="comment">// 获取viewType类型的ArrayList</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;</span><br><span class="line">            <span class="comment">//如果超限了，则放弃入池</span></span><br><span class="line">            <span class="keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 入回收池之前重置 ViewHolder</span></span><br><span class="line">            scrap.resetInternal();</span><br><span class="line">            <span class="comment">// 最终 ViewHolder 入池</span></span><br><span class="line">            scrapHeap.add(scrap);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ScrapData <span class="title function_">getScrapDataForType</span><span class="params">(<span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">     		<span class="comment">// 根据type获取ScrapData 这是个静态类</span></span><br><span class="line">            <span class="type">ScrapData</span> <span class="variable">scrapData</span> <span class="operator">=</span> mScrap.get(viewType);</span><br><span class="line">            <span class="keyword">if</span> (scrapData == <span class="literal">null</span>) &#123;</span><br><span class="line">                scrapData = <span class="keyword">new</span> <span class="title class_">ScrapData</span>();</span><br><span class="line">                mScrap.put(viewType, scrapData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> scrapData;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">    		<span class="comment">// 存放ViewHolder的list</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是RecycledViewPool的详细逻辑，首先呢RecycledViewPool中以 viewType 为键，ScrapData 为值使用SparseArray进行存储。且每种类型最多存储5个，多的直接抛弃掉了。	</p>
<h4 id="屏幕内的缓存项"><a href="#屏幕内的缓存项" class="headerlink" title="屏幕内的缓存项"></a>屏幕内的缓存项</h4><p>在RecyclerView的dispatchLayoutStep2方法中会调用LayoutManager的<em>onLayoutChildren</em>方法，这个方法也是子类实现的。还是看LinearLayoutManager 中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> <span class="keyword">implements</span> <span class="title class_">ScrollingView</span>, NestedScrollingChild2 &#123;</span><br><span class="line">    <span class="comment">// RecyclerView布局的第二步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchLayoutStep2</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#LinearLayoutManager </span><br><span class="line">		<span class="comment">// 布局所有子表项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在填充表项之前回收所有表项</span></span><br><span class="line">            detachAndScrapAttachedViews(recycler);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 填充表项</span></span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 暂时将当可见表项进行分离并回收</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detachAndScrapAttachedViews</span><span class="params">(Recycler recycler)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">            <span class="comment">// 遍历所有可见表项并回收他们</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">                scrapOrRecycleView(recycler, i, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在将表项一个个填充到列表之前会先将其先回收到<code>mAttachedScrap</code>中,下面看一下scrapOrRecycleView的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#RecyclerView</span><br><span class="line">	<span class="comment">// recycler是负责回收和复用视图的对象，index是需要处理的视图在当前布局中的位置，view是需要处理的视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="type">int</span> index, View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder应该被忽略（可能是因为它正在进行删除动画或者还没有绑定数据等原因），则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;ignoring view &quot;</span> + viewHolder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么从布局中移除这个视图，并将其回收</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">            removeViewAt(index);</span><br><span class="line">            <span class="comment">// 这里就是走的上面的一二级回收逻辑</span></span><br><span class="line">            recycler.recycleViewHolderInternal(viewHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，从布局中分离这个视图，但不回收它，而是将其添加到带复用视图列表中</span></span><br><span class="line">            detachViewAt(index);</span><br><span class="line">            recycler.scrapView(view);</span><br><span class="line">            <span class="comment">// 通知ViewInfoStore这个视图已经被分离，ViewInfoStore是用于存储视图信息的对象，例如视图的位置和大小等</span></span><br><span class="line">            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里会根据viewHolder的状态判断是放入回收池中还是调用scrapView方法放入mAttachedScrap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scrapView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder有任何指定的标志，或者没有更新，或者可以复用更新的ViewHolder</span></span><br><span class="line">        <span class="comment">// 那么将这个ViewHolder添加到已附加的废弃视图列表中</span></span><br><span class="line">        <span class="keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">            <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么抛出异常</span></span><br><span class="line">            <span class="comment">// 因为无效的视图不能从视图列表中复用，它们应该从回收池中重新绑定</span></span><br><span class="line">            <span class="keyword">if</span> (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Called scrap view with an invalid view.&quot;</span></span><br><span class="line">                        + <span class="string">&quot; Invalid views cannot be reused from scrap, they should rebound from&quot;</span></span><br><span class="line">                        + <span class="string">&quot; recycler pool.&quot;</span> + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已附加的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">            mAttachedScrap.add(holder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，如果已改变的废弃视图列表为空，那么创建这个列表</span></span><br><span class="line">            <span class="keyword">if</span> (mChangedScrap == <span class="literal">null</span>) &#123;</span><br><span class="line">                mChangedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已改变的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">            mChangedScrap.add(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>放入mAttachedScrap中还是放入mChangedScrap取决于ViewHolder的状态。</p>
<p>mChangedScrap主要的使用场景是：</p>
<ol>
<li>开启了列表项动画(itemAnimator)，并且列表项动画的<code>canReuseUpdatedViewHolder(ViewHolder viewHolder)</code>方法返回false的前提下；</li>
<li>调用了notifyItemChanged、notifyItemRangeChanged这一类方法，通知列表项数据发生变化；</li>
</ol>
<p><strong>mChangedScrap主要是为列表项数据发生变化时的动画效果服务的</strong>。</p>
<p><strong>mAttachedScrap应对的则是剩下的绝大部分场景</strong>，比如：</p>
<ul>
<li>像notifyItemMoved、notifyItemRemoved这种列表项发生移动，但列表项数据本身没有发生变化的场景。</li>
<li>关闭了列表项动画，或者列表项动画的canReuseUpdatedViewHolder方法返回true，即允许重用原先的ViewHolder对象的场景。</li>
</ul>
<p>最后在dispatchLayoutStep3方法也就是布局的最后一个阶段会将mChangedScrap和mAttachedScrap里的内容清空。</p>
<p>这2个缓存结构实际上更多是为了避免出现像<em><strong>局部刷新</strong></em>这一类的操作，导致所有的列表项都需要重绘的情形。在预布局会有解释。</p>
<p>结论：**<code>mAttachedScrap</code>用于屏幕中可见表项的回收和复用，生命周期起始于<code>RecyclerView</code>布局开始，终止于<code>RecyclerView</code>布局结束。**</p>
<p>回收部分到此为止</p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><h4 id="复用时机"><a href="#复用时机" class="headerlink" title="复用时机"></a>复用时机</h4><p><em><strong>当移出屏幕的项重新回到界面</strong></em></p>
<p>回顾上面LayoutManager类的scrollBy方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">                + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">        。。。。</span><br><span class="line">        <span class="keyword">return</span> scrolled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用fill方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutChunk方法就是填充新的项，看下一这个方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> &#123;</span><br><span class="line">        <span class="comment">//获得下一个表项</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> layoutState.next(recycler);</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将表项插入到列表中</span></span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                addView(view);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutState.next(recycler);就是用来获取下一项的，获取后将它添加到ViewGroup中。next最终就会调用到tryGetViewHolderForPositionByDeadline方法中这个方法真正实现的复用逻辑。</p>
<h4 id="复用逻辑"><a href="#复用逻辑" class="headerlink" title="复用逻辑"></a>复用逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获得指定位置的ViewHolder，要么从scrap，cache，RecycledViewPool中获取，要么直接重新创建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">fromScrapOrHiddenOrCache</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//0 从changed scrap集合中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1. 通过position从attach scrap或一级回收缓存中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                <span class="comment">//2. 通过id在attach scrap集合和一级回收缓存中查找viewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3. 从自定义缓存中获取ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; mViewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">                    <span class="comment">// know it.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.从缓存池中拿ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">                    ...</span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//所有缓存都没有命中，只能创建ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">bound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">                holder.mPreLayoutPosition = position;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有invalid的viewHolder才能绑定视图数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                <span class="comment">//获得ViewHolder后，绑定视图数据</span></span><br><span class="line">                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结上面代码：</p>
<p>上面设计到的数据结构有四个mChangedScrap、mAttachedScrap、mCachedViews、RecycledViewPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>代码检索总共会检索5次，第一次从mChangedScrap检索，第二次通过position从attach scrap或一级回收缓存中获取ViewHolder，第三次通过id在attach scrap集合和一级回收缓存中查找viewHolder，第四次从自定义缓存中获取ViewHolder，第五次从缓存池中拿ViewHolder，如果五次检索完都没有的画就会新创建一个viewHolder。</p>
<table>
<thead>
<tr>
<th>缓存结构</th>
<th>容器类型</th>
<th>容量限制</th>
<th>缓存用途</th>
<th>优先级顺序(数值越小，优先级越高)</th>
</tr>
</thead>
<tbody><tr>
<td>mChangedScrap&#x2F;mAttachedScrap</td>
<td>ArrayList</td>
<td>无，一般为屏幕内总的可见列表项数</td>
<td>临时存放仍在当前屏幕可见、但被标记为「移除」或「重用」的列表项</td>
<td>0</td>
</tr>
<tr>
<td>mCachedViews</td>
<td>ArrayList</td>
<td>默认为2</td>
<td>存放已被移出屏幕、但有可能很快重新进入屏幕的列表项</td>
<td>1</td>
</tr>
<tr>
<td>mViewCacheExtension</td>
<td>开发者自己定义</td>
<td>无</td>
<td>提供额外的可由开发人员自由控制的缓存层级</td>
<td>2</td>
</tr>
<tr>
<td>mRecyclerPool</td>
<td>SparseArray<ArrayList></td>
<td>每种itemType默认为5</td>
<td>按不同的itemType分别存放超出mCachedViews限制的、被移出屏幕的列表项</td>
<td>3</td>
</tr>
</tbody></table>
<h4 id="“mAttachedScrap用于屏幕中可见表项的回收和复用”"><a href="#“mAttachedScrap用于屏幕中可见表项的回收和复用”" class="headerlink" title="“mAttachedScrap用于屏幕中可见表项的回收和复用”"></a>“mAttachedScrap用于屏幕中可见表项的回收和复用”</h4><p>这是RecyclerView特殊的pre-layout &amp; post-layout 机制的产物。举个简单的例子，列表有1-4个表项，现删除了第3个表项，这会触发layout过程，RecyclerView的layout有好多个阶段，第一阶段列表的4个表项对应的ViewHolder都会被存入scrap列表，layout的最后阶段会去取用于用于展示的表项（1，2，4，5），此时1，2，4表项就可以从scap中获取，而5从recycler pool中获取</p>
<h3 id="预布局"><a href="#预布局" class="headerlink" title="预布局"></a>预布局</h3><p><a href="https://juejin.cn/post/6892809944702124045">https://juejin.cn/post/6892809944702124045</a></p>
<p><a href="https://juejin.cn/post/7181979065488769083">https://juejin.cn/post/7181979065488769083</a></p>
<p><a href="https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/6844903778303361038">https://juejin.cn/post/6844903778303361038</a></p>
]]></content>
  </entry>
  <entry>
    <title>kotlin泛型</title>
    <url>/2023/12/15/kotlin%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h3 id="泛型的基本声明方法"><a href="#泛型的基本声明方法" class="headerlink" title="泛型的基本声明方法"></a>泛型的基本声明方法</h3><p>函数声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span><span class="title">maxOf</span><span class="params">(a:<span class="type">T</span>,b:)</span></span>T</span><br></pre></td></tr></table></figure>

<p>类声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​                                                  </p>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = maxOf&lt;String&gt;(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = List.Cons(<span class="number">1.0</span>,ListNil)</span><br></pre></td></tr></table></figure>

<h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能将实现了Comparable接口的数据传进来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt;= b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的型变"><a href="#泛型的型变" class="headerlink" title="泛型的型变"></a>泛型的型变</h3><ul>
<li>不变</li>
</ul>
<p><strong>Nothing理论上是所有类型的子类</strong>，但这里的Lis<T>和Lis<Nothing>没有任何继承关系。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 此处会报错</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: List&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>协变</li>
</ul>
<p>协变点</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span>List<span class="type">&lt;T&gt;</span>.<span class="title">get</span><span class="params">(index:<span class="type">Int</span>)</span></span>:T</span><br></pre></td></tr></table></figure>

<p>函数返回值类型为泛型参数，这个返回值就叫做协变点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里不会报错了</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里对泛型添加out修饰  实现泛型的协变 Lis&lt;Nothing&gt;成为了Lis&lt;T&gt;的子类。</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">		<span class="comment">// 这里head的getter返回T 也是一个协变点</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: Lis&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>协变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>生产者Producer<Derived>兼容Producer<Base>.    <strong>能生产子类就能生产父类</strong></li>
<li>存在协变点的类的泛型参数必须声明为协变或不变</li>
<li>当泛型类作为泛型参数类实例的生产者时用协变</li>
</ol>
<p>生产者是要向外提供一些东西的，这里子类继承父类后会实现父类的方法。泛型如果是协变的，但是需要的地方是父类，又因为里氏替换原则子类可以代替父类（子类继承自父类），所以可以让Class<Son>成为Class<Father>的子类。</p>
<ul>
<li>逆变</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数参数类型为泛型参数。参数的位置就是逆变点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如</p>
<p>Int是Number的子类，但是能比较Int的不一定能比较Number，所以CompareTo<Number>是CompareTo<Int>的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垃圾</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Waste</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 干垃圾</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DryWaste</span> : <span class="type">Waste</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾桶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dustbin</span>&lt;<span class="type">in T : Waste</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 扔垃圾</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;put <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">contravariant</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dustbin: Dustbin&lt;Waste&gt; = Dustbin&lt;Waste&gt;()</span><br><span class="line">    <span class="comment">// 干垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dryWasteDustbin: Dustbin&lt;DryWaste&gt; = dustbin</span><br><span class="line">    <span class="comment">// 垃圾对象</span></span><br><span class="line">    <span class="keyword">val</span> waste = Waste()</span><br><span class="line">    <span class="comment">// 干垃圾对象 </span></span><br><span class="line">    <span class="keyword">val</span> dryWaste = DryWaste()</span><br><span class="line">    <span class="comment">// 扔垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(dryWaste)</span><br><span class="line">    <span class="comment">// 扔垃圾到干垃圾桶 这里报错：类型不匹配。要求:DryWaste实际:Waste</span></span><br><span class="line">    dryWasteDustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到干垃圾桶</span></span><br><span class="line">    dryWasteDustbin.put(dryWaste)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>逆变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>消费者Consumer.<Base>兼容Consumer<Derived>   <strong>能消费父类就能消费子类</strong></li>
<li>存在逆变点的类的泛型参数必须声明为逆变或不变</li>
<li>当泛型类作为泛型参数类实例的消费者时用逆变</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型协变的语法规则：<code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code>，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，协变的泛型变量只读，不可以写，可以添加 null ，但是没意义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 协变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">// 这里可以将SimpleData&lt;Student&gt;()赋值给SimpleData&lt;Person&gt;</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">    <span class="keyword">val</span> list1: ArrayList&lt;<span class="keyword">out</span> Person&gt; = ArrayList&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>泛型逆变的语法规则：<code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code>，它限定的类型是当前<strong>下边界类</strong>或者其父类，如果是接口的话就是当前下边界接口或者其父接口，逆变的泛型变量只能写，不建议读。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 逆变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">in T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1: Person = Student()</span><br><span class="line">  	<span class="comment">// 这里将SimpleData&lt;Person&gt;()赋值给SimpleData&lt;Student&gt; 必须是Student或Student的父类，比如Student的子类就会报错。</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric1: SimpleData&lt;Student&gt; = SimpleData&lt;Person&gt;()</span><br><span class="line">    <span class="keyword">val</span> list2: ArrayList&lt;<span class="keyword">in</span> Person&gt; = ArrayList&lt;Any&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不变的话就是没有对应的子父类关系</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">//编译器不允许</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型的出现是为了解决什么问题"><a href="#泛型的出现是为了解决什么问题" class="headerlink" title="泛型的出现是为了解决什么问题"></a>泛型的出现是为了解决什么问题</h3><ol>
<li>减少重复代码</li>
<li>增加编译时类型的检查，避免一些运行时的类型错误问题</li>
</ol>
<p>比如往集合中添加元素，可以添加任何类型。但是取得时候不知道类型会报错。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b1b5b02cad3adceb3514735733af8d14_720w.webp" alt="img"></p>
<p>如果一只猫是一只动物，那一群猫是一群动物吗？一群狗是一群动物吗？Java数组认为是的。如果Cat是Animal的子类型，那么<code>Cat[]</code>也是<code>Animal[]</code>的子类型，我们称这种性质为<strong>协变</strong>（covariance）。<strong>Java中，数组是协变的</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>okhttp详解</title>
    <url>/2023/12/15/OkHttp%20/</url>
    <content><![CDATA[<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:</span><br><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().xxx.build()</span><br></pre></td></tr></table></figure>

<p>创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">异步：</span><br><span class="line">		<span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">        LogCat.e( Thread.currentThread())</span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 这里还是在子线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">同步：</span><br><span class="line">				thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                loge(response)</span><br><span class="line">                <span class="comment">// 在这里处理同步响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>同步请求：</strong><ul>
<li><strong>同步请求是在当前线程上执行的。</strong>这意味着，如果在主线程上执行同步请求，它会阻塞主线程，直到请求完成。</li>
<li>同步请求通常用于后台线程或不涉及用户界面的操作，因为它们可能会导致应用界面冻结，用户体验差。</li>
<li>在同步请求中，您在代码中直接等待响应，只有在请求完成后才能继续执行后续代码。</li>
</ul>
</li>
<li><strong>异步请求：</strong><ul>
<li><strong>异步请求是在后台线程上执行的，不会阻塞当前线程。</strong>这允许在请求完成之前继续执行其他操作，包括更新用户界面。</li>
<li>异步请求通常用于与用户界面交互的操作，以确保用户界面保持响应性。</li>
<li>在异步请求中，通常提供一个回调函数，该回调函数将在请求完成时执行，允许处理响应数据。</li>
</ul>
</li>
</ol>
<h2 id="请求生成"><a href="#请求生成" class="headerlink" title="请求生成"></a>请求生成</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">client?.newCall(request)?.execute()</span><br><span class="line"></span><br><span class="line">#OkHttpClient::newCall:最终生成一个RealCall对象</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">#RealCall::execute()：开启同步请求</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">	<span class="comment">// 检查是否已经被执行</span></span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 将当前realcall加入到OkHttpClient的调度器中  因为是同步 不需要线程池开启子线程 所以直接return getResponseWithInterceptorChain()</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#Dispatcher::enqueue()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 call 是否为 WebSocket 请求</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">		<span class="comment">// 查找具有相同主机的已经存在的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 将符合条件的调用从readyAsyncCalls提升到runningAsyncCalls</span></span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 确保在多线程环境下，异步调用的执行数量不会超过预定的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#Dispatcher::promoteAndExecute():</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变列表用于存储将要执行的异步调用</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个标志变量用于表示是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 块，确保以下操作在互斥锁的保护下进行</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 readyAsyncCalls 队列的迭代器</span></span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 readyAsyncCalls 队列中的异步调用</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 runningAsyncCalls 中的异步调用数已经达到了最大请求数（maxRequests），则停止添加新的异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 asyncCall.callsPerHost（每个主机的并发请求数）已经达到了最大请求数（maxRequestsPerHost），则继续下一个异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 readyAsyncCalls 队列中移除该异步调用</span></span><br><span class="line">            i.remove()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加该异步调用所在主机的并发请求数</span></span><br><span class="line">            asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 executableCalls 列表中，准备执行</span></span><br><span class="line">            executableCalls.add(asyncCall)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 runningAsyncCalls 列表中，表示正在执行</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有异步调用正在执行，更新 isRunning 变量</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 executableCalls 列表，执行每个异步调用</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">			<span class="comment">// 这里开启了线程池调用</span></span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealCall::AsyncCall:: executeOn()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span> <span class="comment">// 用于跟踪执行是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用传入的 executorService 来执行当前异步调用（实际上是执行该异步任务）</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果执行成功，设置 success 为 true</span></span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="comment">// 如果执行被拒绝，创建一个 InterruptedIOException 异常，并将原始异常作为其原因</span></span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 noMoreExchanges 方法，通知没有更多的交换操作，同时调用 responseCallback 的 onFailure 方法传递异常</span></span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：无论执行是否成功，都会执行的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 如果执行不成功，调用 client.dispatcher.finished(this) 来表示该调用不再运行</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncCall::<span class="keyword">class</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AsyncCall继承了Runnable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 给当前线程命名，通常用于日志记录和调试</span></span><br><span class="line">    threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span> <span class="comment">// 用于标记回调是否已经触发</span></span><br><span class="line">        timeout.enter() <span class="comment">// 进入超时状态，启动计时器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 getResponseWithInterceptorChain() 获取响应对象</span></span><br><span class="line">            <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记回调已经触发</span></span><br><span class="line">            signalledCallback = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 responseCallback 的 onResponse() 方法，将响应传递给回调函数</span></span><br><span class="line">            responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 不要触发回调两次！如果回调已经触发，记录日志</span></span><br><span class="line">                Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 responseCallback 的 onFailure() 方法，将异常传递给回调函数</span></span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">            cancel() <span class="comment">// 取消当前调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 如果回调尚未触发，创建一个异常，将其作为取消原因传递给回调函数</span></span><br><span class="line">                <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">                canceledException.addSuppressed(t)</span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抛出异常以终止线程</span></span><br><span class="line">            <span class="keyword">throw</span> t</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何，都要通知客户端调度程序当前调用已完成</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器的通过责任链模式挨个执行每个拦截器的任务，最后将请求的response返回给最上层</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后的具体网络请求实现还是得看 getResponseWithInterceptorChain()</span></span><br><span class="line"></span><br><span class="line">RealCall:: getResponseWithInterceptorChain()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 构建拦截器链，创建一个拦截器列表</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加用户自定义的普通拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 重试、重定向拦截器</span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</span></span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 读取、写入缓存的拦截器</span></span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 与服务器建立连接的拦截器</span></span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 WebSocket 请求，添加用户自定义的网络拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最终真正执行网络请求的拦截器</span></span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有拦截器合并为链，并调用其proceed()开始处理本次请求</span></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用拦截器链的 proceed 方法，处理请求并获取响应</span></span><br><span class="line">				<span class="comment">// 主要还是得看这个方法</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求被取消，关闭响应并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 捕获 IOException 异常，标记已经调用 noMoreExchanges 方法，并重新抛出异常</span></span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：如果没有调用过 noMoreExchanges 方法，则调用它来释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealInterceptorChain:: proceed()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 检查当前拦截器索引是否小于拦截器列表的大小</span></span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加调用计数</span></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查新请求的 URL 是否与当前请求的 URL 主机和端口相同</span></span><br><span class="line">        check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器链中的下一个拦截器</span></span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">		<span class="comment">// 获取当前index的拦截器对象</span></span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器的 intercept 方法，获取响应对象，如果为 null，则抛出异常</span></span><br><span class="line">		<span class="comment">// 这里的intercept方法传入的是下一个拦截器，</span></span><br><span class="line">		<span class="comment">// 在当中回调用下一个拦截器的proceed方法response = realChain.proceed(request)</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查下一个拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应对象是否有响应体</span></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>对OKHttp有了解吗，拦截器这一块有了解吗？</li>
<li>有没有用到过，或则自定义拦截器，怎么用的</li>
<li>拦截器一定会被执行吗</li>
<li>责任链模式和策略模式有什么区别</li>
</ol>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/RetryAndFollowUpInterceptor%EF%BC%9A%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%20d608e513720d4f7e85d2a65cb9df191a.md"><strong>RetryAndFollowUpInterceptor：</strong>重试、重定向拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/BridgeInterceptor%EF%BC%9A%E5%B0%86%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%94%A8%E6%88%B7%E5%93%8D%E5%BA%94%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20536849dff4944c349e970fdc8ae1619b.md">BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%209e0ba47ba1524aafb889cf0008e1b86e.md">CacheInterceptor：读取、写入缓存的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/ConnectInterceptor%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20bd971853d1ed4038ba3426d485bf6af5.md">ConnectInterceptor 建立连接的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CallServerInterceptor%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20b4e0c43b2b424fa686714b168d39b7e1.md"><strong>CallServerInterceptor：</strong>最终真正执行网络请求的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%20a209e906006a4e67a7e39c2b1bebec7b.md">自定义拦截器</a></p>
<h2 id="RetryAndFollowUpInterceptor：重试、重定向拦截器"><a href="#RetryAndFollowUpInterceptor：重试、重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor：重试、重定向拦截器"></a>RetryAndFollowUpInterceptor：重试、重定向拦截器</h2><p>重定向:</p>
<p>重定向简单理解则是客户端请求服务端时，服务端让客户端请求别的网站，服务端会在响应中添加新的请求地址，客户端去请求这个新的地址。</p>
<p>问题一：重试的判断条件</p>
<p>问题二：怎么主动控制禁止网络请求重试</p>
<p>问题三：循环重试会不会走入死循环</p>
<p>问题四：重定向怎么实现的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 将传入的 Interceptor.Chain 强制转换为 RealInterceptorChain</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request <span class="comment">// 获取请求</span></span><br><span class="line">    <span class="keyword">val</span> call = realChain.call <span class="comment">// 获取调用</span></span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span> <span class="comment">// 跟随请求计数</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span> <span class="comment">// 之前的响应</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span> <span class="comment">// 是否是新的交换</span></span><br><span class="line">    <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;() <span class="comment">// 已恢复的失败列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 创建ExchangeFinder，此类用于创建和寻找Exchange，Exchange主要处理此次请求中的IO的连接管理和事件请，会在后续的拦截器中进行分析</span></span><br><span class="line">        call.enterNetworkInterceptorExchange(request, newExchangeFinder) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response: Response</span><br><span class="line">        <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">// 此处调用下一个拦截器获取respnse</span></span><br><span class="line">								<span class="comment">// 将Request交给给下个节点，此处的下个节点为BridgeInterceptor，若下层节点处理过程中扔出错误会被下面的catch捕获</span></span><br><span class="line">                response = realChain.proceed(request) </span><br><span class="line">                newExchangeFinder = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">                <span class="comment">// 尝试通过路由连接失败，请求尚未发送</span></span><br><span class="line">								<span class="comment">// 重点方法，决定能否重试的关键方法，此方法返回为true才可重试，看重试小节中的分析</span></span><br><span class="line">                <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">                <span class="comment">// 通过recover方法检测路由异常是否能重新连接</span></span><br><span class="line">                <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e.firstConnectException</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 走到这里，则一定拿到了服务器的响应</span></span><br><span class="line">						<span class="comment">// 若循环中的代码完整执行过，则priorResponse不为空，也就意味着需要重定向（不太严谨的说法），类似链表的结构保存下来整个响应路径</span></span><br><span class="line">            <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">					          response = response.newBuilder()</span><br><span class="line">								              .priorResponse(priorResponse.newBuilder()</span><br><span class="line">						                  .body(<span class="literal">null</span>)</span><br><span class="line">						                  .build())</span><br><span class="line">								              .build()</span><br><span class="line">				        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exchange为Exchange类，主要处理此次网络连接的IO操作</span></span><br><span class="line">            <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">            <span class="comment">// 处理重定向的重点方法，此方法会根据返回的response和连接管理器判断是否需要重定向，看下重定向小节</span></span><br><span class="line">            <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">                    call.timeoutEarlyExit()</span><br><span class="line">                &#125;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 没有跟随请求，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">            <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 跟随请求有请求体，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.body?.closeQuietly() <span class="comment">// 关闭响应体</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp <span class="comment">// 使用跟随请求作为新的请求</span></span><br><span class="line">            priorResponse = response</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题一：</p>
<p>首先确认代码体主要是一个while true 死循环，然后看下面这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果recover返回了false 则直接抛出异常 中断了重试</span></span><br><span class="line"><span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">          <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recoveredFailures += e.firstConnectException</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>出现异常的大部分情况都会返回false  从而抛出异常，如果命中了可以重试的异常则会走continue 停止当前循环开启下一次循环从而开启下一次的请求。</p>
<p>然后看看recover的具体实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">	**RetryAndFollowUpInterceptor::**recover()</span><br><span class="line"><span class="comment">// 定义一个名为recover的私有函数，用于处理异常情况并决定是否需要进行错误恢复。</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    e: <span class="type">IOException</span>,                 <span class="comment">// 传入的异常对象，通常是与网络请求相关的IOException。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">RealCall</span>,                 <span class="comment">// RealCall对象，用于执行HTTP请求的实际调用。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    userRequest: <span class="type">Request</span>,           <span class="comment">// 用户发起的请求对象。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    requestSendStarted: <span class="type">Boolean</span>     <span class="comment">// 标志位，表示请求是否已经开始发送。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 如果客户端配置禁止在连接失败时重试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经开始发送，并且该请求是一次性的（不能重新发送），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果异常是不可恢复的（例如，连接超时等），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有更多的路由可以尝试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于错误恢复，使用相同的路由选择器创建一个新的连接。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// 返回true表示需要进行错误恢复操作。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">**RetryAndFollowUpInterceptor::**requestIsOneShot</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestIsOneShot</span><span class="params">(e: <span class="type">IOException</span>, userRequest: <span class="type">Request</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBody = userRequest.body</span><br><span class="line">  <span class="keyword">return</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) ||  <span class="comment">//isOneShot()是需要程序员重写RequestBody的方法，不重写的情况下默认返回为false</span></span><br><span class="line">      e <span class="keyword">is</span> FileNotFoundException  <span class="comment">//若下层节点处理过程中抛出FileNotFoundException也不允许重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**RetryAndFollowUpInterceptor::**isRecoverable</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isRecoverable</span><span class="params">(e: <span class="type">IOException</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 协议异常则不许重试，举一个协议异常的例子，没有使用代理却返回响应码407需要代理验证，此类与协议规范冲突的错误大多数为ProtocolException</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 若产生中断异常，Socket超时或者在非IO异常（路由异常）时可能可以重试（requestSendStarted是catch中捕获的最初的异常决定的）</span></span><br><span class="line">    <span class="comment">// 若捕获异常为RouteException，requestSendStarted为false</span></span><br><span class="line">    <span class="comment">// 若捕获异常为IOException，且异常的具体类型为ConnectionShutdownException时，requestSendStarted也为false</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">is</span> SocketTimeoutException &amp;&amp; !requestSendStarted</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ssl握手异常，且具体错误属于是证书异常，则不允许重试，因为重试也肯定失败</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.cause <span class="keyword">is</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//证书校验失败 不匹配 也不允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="comment">// 翻译：如果产生连接代理出现问题，且是抛出IO异常，此时要返回true，尝试新的路由路线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上述中不可重试的情况，分为两种情况一种是<strong>程序员不希望重试</strong>一种是<strong>下层抛出异常</strong>。</p>
<p>问题二：</p>
<ul>
<li>配置<code>OkhttpClient</code>时设置<code>retryOnConnectionFailure</code>为<code>false</code>，所有请求将不可重试。</li>
<li>使用请求体请求时，<code>Body</code>继承自<code>RequestBody</code>并重写<code>isOneShot()</code>返回为<code>true</code>，可以做到过滤某些请求。</li>
</ul>
<p>问题三：</p>
<p>不会，首先重试的条件是苛刻的，绝大多数重试情况都只是网络波动，且在判断是否可重试时，有非常关键的一个条件，有没有可以重试的路线，一直重试必然会导致路线全部使用完，此时也一定会跳出循环。</p>
<p>问题四：</p>
<p>需要重定向说明之前的请求完成了然后需要再请求别的网址，看下面这段代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里将followup 赋值给了request 然后在下一个循环开启对应请求。		</span></span><br><span class="line">request = followUp</span><br><span class="line">priorResponse = response</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将之前的请求响应内容保存下来。 priorResponse是上次循环上面代码保存下来的</span></span><br><span class="line"><span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">		response = response.newBuilder()</span><br><span class="line">							.priorResponse(priorResponse.newBuilder()</span><br><span class="line">						  .body(<span class="literal">null</span>)</span><br><span class="line">						  .build())</span><br><span class="line">							.build()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"><a href="#BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器" class="headerlink" title="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"></a>BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取用户发起的请求</span></span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="comment">// 创建一个请求构建器，用于修改请求头信息</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求体</span></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取请求体的内容类型</span></span><br><span class="line">        <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Type字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体的内容长度</span></span><br><span class="line">        <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Length字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">            <span class="comment">// 移除Transfer-Encoding字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果内容长度为-1，设置Transfer-Encoding为chunked</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">            <span class="comment">// 移除Content-Length字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Host字段，添加Host字段，使用请求URL的主机名</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Connection字段，添加Connection字段为Keep-Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Accept-Encoding字段，并且没有Range字段，添加Accept-Encoding字段为gzip</span></span><br><span class="line">		<span class="comment">// Accept-Encoding用于提供客户端支持的压缩方式，与响应头的Content-Encoding对应</span></span><br><span class="line">    <span class="comment">// Range表示客户端想要此次请求资源的某一部分如：Range: bytes=0-50, 100-150，表示只要0-50和100-150字节两个部分</span></span><br><span class="line">    <span class="comment">// 若没有指定上述两个请求头属性，则压缩方式指定为gzip</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="literal">true</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CookieJar中加载Cookies，并添加到请求头中的Cookie字段</span></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有User-Agent字段，添加User-Agent字段为指定的userAgent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行网络请求，获取网络响应</span></span><br><span class="line">		<span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将网络响应的头部信息传递给CookieJar，以便处理和存储Cookies</span></span><br><span class="line">		cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个响应构建器，用于修改网络响应</span></span><br><span class="line">		<span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">	    .request(userRequest)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果需要进行透明的gzip解压缩，并且响应头中包含Content-Encoding字段为gzip，且响应允许有响应体</span></span><br><span class="line">		<span class="comment">// 若上述使用gzip，则需要进行解压</span></span><br><span class="line">    <span class="comment">// Content-Encoding代表此次响应体的编码</span></span><br><span class="line">		<span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">		    <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">		    networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="comment">// 获取网络响应体</span></span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个GzipSource，用于解压gzip压缩的响应体</span></span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="comment">// 移除响应头中的Content-Encoding和Content-Length字段</span></span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        <span class="comment">// 设置响应构建器的头部信息</span></span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="comment">// 获取响应体的Content-Type</span></span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置响应体为解压后的内容</span></span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回修改后的响应</span></span><br><span class="line">		<span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说这个拦截器并不复杂主要也就是封装请求头。重要的还是涉及计网的部分，这部分有关http的知识在<a href="https://www.notion.so/bbcad4bff70d4beb8269b08602dd95e8?pvs=21">计网</a>查询。</p>
<h2 id="CacheInterceptor：读取、写入缓存的拦截器"><a href="#CacheInterceptor：读取、写入缓存的拦截器" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h2><h3 id="CacheInterceptor：读取、写入缓存的拦截器-1"><a href="#CacheInterceptor：读取、写入缓存的拦截器-1" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h3><p>先来个图总结cache的路径：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled.png" alt="Untitled"></p>
<p>主要看下面这个博客的内容。</p>
<p>总结下一些主要的东西：</p>
<ol>
<li>cache默认是null如果需要缓存需要在构建的时候添加。</li>
<li>走缓存还是走网络请求是通过<code>CacheStrategy</code> 类来判断的，判断公式为：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%2055.png" alt="Untitled 1"></p>
<p>具体代码体现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">      <span class="comment">// 若该请求没有对应的缓存响应，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若该请求为HTTPS请求，但是缓存响应中没有保存TLS握手相关信息，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过cacheResponse的响应码来判断响应是否允许被缓存，若不允许则忽略缓存响应，需要网络请求 </span></span><br><span class="line">      <span class="comment">// (其实参与判断的还有noStore指令的值) </span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CacheControl类：包含来自服务端或客户端的缓存指令，这些指令表明了什么响应可以被存储，</span></span><br><span class="line">      <span class="comment">// 这些存储的响应可以满足哪些需求。</span></span><br><span class="line">      <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">      <span class="comment">// noCache指令说明：noCache指令可以出现在请求、响应当中。若出现在响应的位置，它表明在发布</span></span><br><span class="line">      <span class="comment">// 缓存副本之前，必须向源服务器验证缓存的有效性；若出现在请求中，它表明不要使用一个缓存来回应</span></span><br><span class="line">      <span class="comment">// 该需求。  </span></span><br><span class="line">      <span class="comment">// hasConditions方法：若Request包含If-Modified-Since或If-None-Match其中一个Header，</span></span><br><span class="line">      <span class="comment">// 则该方法返回true。</span></span><br><span class="line">      <span class="comment">// 这里If语句的意思：若请求不允许使用缓存响应，或者请求头有If-Modified-Since/If-None-Match，  	  // 则忽略缓存响应，需要网络请求。(客户端发送的请求自己就带有If-Modified-Since或If-None-Match</span></span><br><span class="line">      <span class="comment">// ，缓存响应也是不会被使用的，OkHttp在下面的代码中是有为请求添加If-Modified-Since或</span></span><br><span class="line">      <span class="comment">// If-None-Match的Header的逻辑的) </span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">      <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果cacheResponse没有noCache指令(发布缓存前不用向源服务器验证)，并且cacheResponse</span></span><br><span class="line">      <span class="comment">// 仍然在存活时间内，则不需要进行网络请求，直接使用缓存响应  </span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加 If-None-Match/If-Modified-Since 的Header到请求头中，服务器通过验证这些Header，</span></span><br><span class="line">      <span class="comment">// 来判断客户端的缓存是否还有效，若缓存仍然有效，则返回304，响应中不会包含Response Body  </span></span><br><span class="line">      <span class="keyword">val</span> conditionName: String</span><br><span class="line">      <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">          conditionValue = etag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = lastModifiedString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = servedDateString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 If-None-Match/If-Modified-Since 的Header可以添加，则忽略缓存响应，需要网络请求   </span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在原来的Request上面添加包含If-None-Match/If-Modified-Since的Header  </span></span><br><span class="line">      <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="comment">// 返回一个包含网络请求和缓存响应的策略  </span></span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码总结看下面的博客。这段代码是真正控制缓存的关键。</p>
<ol>
<li>cache类的主要作用是在本地对<code>Response</code>进行<code>CRUD</code>（增删改查四种数据库操作）的操作。</li>
<li>CacheStrategy类具体判断networkRequest、cacheResponse是在computeCandidate方法实现的。具体看下面的博客。</li>
</ol>
<p><a href="https://www.cnblogs.com/giagor/p/15706508.html">探索OkHttp系列 (四) 缓存机制 - Giagor - 博客园</a></p>
<p>首先这个缓存器只会缓存GET请求，其次如果需要缓存的话需要在构建Request的时候添加cache</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient.Builder().cache(Cache(File(<span class="keyword">this</span>.externalCacheDir, <span class="string">&quot;okhttpcache&quot;</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)).build()</span><br><span class="line"><span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">object</span> : Callback)</span><br></pre></td></tr></table></figure>

<p>其次在Request的构造中有一个cacheControl方法这个方法会传入<code>CacheControl</code> 类，这个类可以在request中定制缓存策略。在Cache的官方头注释中有对这个类各种策略的使用示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheControl = CacheControl.Builder()</span><br><span class="line">    .maxAge(<span class="number">1</span>, TimeUnit.HOURS) <span class="comment">// 缓存有效期为1小时</span></span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://example.com/api/data&quot;</span>)</span><br><span class="line">    .cacheControl(cacheControl)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Cache类解析</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">  directory: File,</span><br><span class="line">  maxSize: <span class="built_in">Long</span>,</span><br><span class="line">  fileSystem: FileSystem</span><br><span class="line">) : Closeable, Flushable &#123;</span><br><span class="line">	 <span class="comment">// 这里使用的是磁盘缓存</span></span><br><span class="line">  <span class="comment">// 缓存最最重要的属性，看名字也知道缓存策略为硬盘LRU缓存，下述分析DiskLruCache</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cache = DiskLruCache(</span><br><span class="line">        fileSystem = fileSystem,	      <span class="comment">// 主机的本地文件系统，内部使用OKIO实现IO操作</span></span><br><span class="line">        directory = directory,            <span class="comment">// 缓存目录</span></span><br><span class="line">        appVersion = VERSION,			  <span class="comment">// 版本</span></span><br><span class="line">        valueCount = ENTRY_COUNT,         <span class="comment">// 缓存文件的类型，此处是2，因为一条缓存映射两个实体文件头和体</span></span><br><span class="line">        maxSize = maxSize,				  <span class="comment">// 缓存大小</span></span><br><span class="line">        taskRunner = TaskRunner.INSTANCE  <span class="comment">// 日志追踪线程池</span></span><br><span class="line">    )</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存使用的是磁盘缓存，缓存目录是添加cache时加的目录。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%202.png" alt="Untitled 2"></p>
<p>先来看看cache缓存数据的时候</p>
<p>Cache::put()缓存的只是响应头数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Cache::put()</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(response: <span class="type">Response</span>)</span></span>: CacheRequest? &#123;</span><br><span class="line">    <span class="keyword">val</span> requestMethod = response.request.method</span><br><span class="line">	<span class="comment">// 如果请求方法为POST,PATCH,PUT,DELETE,MOVE,则移除此缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remove(response.request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只允许get方法缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestMethod != <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some</span></span><br><span class="line">        <span class="comment">// POST requests, but the complexity of doing so is high and the benefit is low.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果 Vary 响应头中包含星号，也无法缓存此响应</span></span><br><span class="line">    <span class="comment">// vary 详情请看https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary</span></span><br><span class="line">    <span class="comment">// vary简单理解则是记录下来需要缓存的响应头的值</span></span><br><span class="line">    <span class="keyword">if</span> (response.hasVaryAll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry是Cache.Entry 非 DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">val</span> entry = Entry(response)</span><br><span class="line">    <span class="keyword">var</span> editor: DiskLruCache.Editor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用DiskLruCache的edit(), 此方法则会根据传入的参数获取DiskLruCache.Entry, 看下述2.DiskLruCache#edit中的解析</span></span><br><span class="line">        editor = cache.edit(key(response.request.url)) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 执行写入操作,看下Cache.Entry#writeTo</span></span><br><span class="line">        entry.writeTo(editor)</span><br><span class="line">        <span class="comment">// 返回RealCacheRequest,此时会创建响应体文件, 看下RealCacheRequest</span></span><br><span class="line">        <span class="keyword">return</span> RealCacheRequest(editor)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        abortQuietly(editor)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面都是对这个方法中所调用方法的解析</strong></p>
<p>DiskLruCache::edit() 中的解析</p>
<p>这个方法主要是在journal文件中写入DIRTY 然后返回val editor &#x3D; Editor(entry)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">edit</span><span class="params">(key: <span class="type">String</span>, expectedSequenceNumber: <span class="type">Long</span> = ANY_SEQUENCE_NUMBER)</span></span>: Editor? &#123;</span><br><span class="line">	<span class="comment">// 初始化DiskLruCache</span></span><br><span class="line">    initialize()</span><br><span class="line">	<span class="comment">// 检测缓存有没有关闭,若关闭则抛出异常</span></span><br><span class="line">    checkNotClosed()</span><br><span class="line">    <span class="comment">// 判断key是否有效</span></span><br><span class="line">    validateKey(key)</span><br><span class="line">    <span class="comment">// 获取lruEntries中key的value, 第一次则一定为null</span></span><br><span class="line">    <span class="keyword">var</span> entry: Entry? = lruEntries[key]</span><br><span class="line">    <span class="comment">// 若是添加操作则expectedSequenceNumber使用默认值ANY_SEQUENCE_NUMBER,if不会命中</span></span><br><span class="line">    <span class="comment">// 若是更新操作才有可能命中此if</span></span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">        (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Snapshot is stale.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 若entry绑定了Editor则也返回null</span></span><br><span class="line">    <span class="keyword">if</span> (entry?.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Another edit is in progress.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次添加不会命中,因为entry为null, lockingSourceCount是当前正在打开的输入流的总数</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.lockingSourceCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 无法写入此文件，因为读者仍在阅读它</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在清理过程中, 超过设置的缓存大小且移除Entry失败时会使mostRecentTrimFailed = true, 若需要重建journal, 日志文件创建失败会使mostRecentRebuildFailed = true, 这两种情况下会命中if</span></span><br><span class="line">    <span class="keyword">if</span> (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">        <span class="comment">// The OS has become our enemy! If the trim job failed, it means we are storing more data than</span></span><br><span class="line">        <span class="comment">// requested by the user. Do not allow edits so we do not go over that limit any further. If</span></span><br><span class="line">        <span class="comment">// the journal rebuild failed, the journal writer will not be active, meaning we will not be</span></span><br><span class="line">        <span class="comment">// able to record the edit, causing file leaks. In both cases, we want to retry the clean up</span></span><br><span class="line">        <span class="comment">// so we can get out of this state!</span></span><br><span class="line">        <span class="comment">// 翻译如下: 操作系统已成为我们的敌人！如果修剪作业失败，则意味着我们存储的数据多于用户请求的数据。不允许编辑，因此我们不会进一步超出该限制。如果日志重建失败，日志写入器将不会处于活动状态，这意味着我们将无法记录编辑，从而导致文件泄漏。在这两种情况下，我们都想重试清理，以便摆脱这种状态！</span></span><br><span class="line">        cleanupQueue.schedule(cleanupTask)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">    <span class="comment">// 翻译:在创建文件之前刷新日志以防止文件泄漏</span></span><br><span class="line">    <span class="comment">// 先在journal文件中写入DIRTY</span></span><br><span class="line">    <span class="keyword">val</span> journalWriter = <span class="keyword">this</span>.journalWriter!!</span><br><span class="line">    journalWriter.writeUtf8(DIRTY)</span><br><span class="line">    .writeByte(<span class="string">&#x27; &#x27;</span>.toInt())</span><br><span class="line">    .writeUtf8(key)</span><br><span class="line">    .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    journalWriter.flush()</span><br><span class="line">	<span class="comment">// 若写入journal文件失败则hasJournalErrors = true</span></span><br><span class="line">    <span class="keyword">if</span> (hasJournalErrors) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Don&#x27;t edit; the journal can&#x27;t be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry为DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123; </span><br><span class="line">        entry = Entry(key)</span><br><span class="line">        lruEntries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Editor、作用就是具体的输入流和输出流的操作者</span></span><br><span class="line">    <span class="keyword">val</span> editor = Editor(entry)</span><br><span class="line">    entry.currentEditor = editor</span><br><span class="line">    <span class="keyword">return</span> editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>DiskLruCache.Entry 的解析</strong></strong></p>
<p><code>DiskLruCache</code>中存储的缓存实体对象，一个<code>Entry</code>对象代表一条缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> key: String</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度数组，下标0代表头文件大小，下标1代表响应体内容文件大小</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> lengths: LongArray = LongArray(valueCount) </span><br><span class="line">    <span class="comment">// 像日志一样，分为tmp和正式文件，真正的缓存也是如此</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cleanFiles = mutableListOf&lt;File&gt;() <span class="comment">//正式缓存文件集合</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> dirtyFiles = mutableListOf&lt;File&gt;()	<span class="comment">//脏缓存文件集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前缓存是否可用</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readable: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前编辑或读取完成时必须删除此条目，则为真。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> zombie: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在进行的编辑，如果此条目未被编辑，则为 null。将此设置为 null 时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> currentEditor: Editor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此条缓存打开的输入流的总数。当将此值递减为零时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> lockingSourceCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sequenceNumber: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">   		<span class="comment">// 以key为文件名创建File对象</span></span><br><span class="line">        <span class="keyword">val</span> fileBuilder = StringBuilder(key).append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">val</span> truncateTo = fileBuilder.length</span><br><span class="line">        <span class="comment">// valueCount为2 循环两次</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until valueCount) &#123;</span><br><span class="line">            fileBuilder.append(i)</span><br><span class="line">            cleanFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            fileBuilder.append(<span class="string">&quot;.tmp&quot;</span>)</span><br><span class="line">            dirtyFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            <span class="comment">// 删除后缀</span></span><br><span class="line">            fileBuilder.setLength(truncateTo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache.Entry#writeTo</p>
<p>这个方法就是将请求头信息写入文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeTo</span><span class="params">(editor: <span class="type">DiskLruCache</span>.<span class="type">Editor</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 按照响应头的报文格式写入文件</span></span><br><span class="line">  editor.newSink(ENTRY_METADATA).buffer().use &#123; sink -&gt;</span><br><span class="line">    sink.writeUtf8(url).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(requestMethod).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="comment">// 写入Vary</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until varyHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(varyHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong((responseHeaders.size + <span class="number">2</span>).toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until responseHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(responseHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(responseHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    sink.writeUtf8(SENT_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(sentRequestMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(RECEIVED_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(receivedResponseMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isHttps) &#123;</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      sink.writeUtf8(handshake!!.cipherSuite.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      writeCertList(sink, handshake.peerCertificates)</span><br><span class="line">      writeCertList(sink, handshake.localCertificates)</span><br><span class="line">      sink.writeUtf8(handshake.tlsVersion.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheInterceptor</span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取当前的HTTP请求</span></span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取之前的缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前时间、请求和缓存响应计算缓存策略</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存策略中的网络请求和缓存响应</span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪缓存策略的结果</span></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HTTP请求的事件监听器</span></span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存候选项存在但不适用于当前请求，则关闭它。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果禁止使用网络且缓存不足，则返回一个响应表示无法满足请求</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.satisfactionFailure(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不需要网络请求，则直接返回缓存响应</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.cacheHit(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有缓存响应，通知监听器</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发起网络请求并获取网络响应</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果出现I/O错误或其他异常，确保不会泄漏缓存响应的主体（body）</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果同时有缓存响应和网络响应，表示进行条件获取（conditional get）操作</span></span><br><span class="line">		<span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 状态码给了304 说明服务器的Last-Modified字段对比一致 资源未修改可以使用缓存</span></span><br><span class="line">		    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应状态码为304（未修改），则合并两个响应</span></span><br><span class="line">		        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 关闭网络响应的主体</span></span><br><span class="line">		        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 更新缓存，将合并后的响应存储到缓存中</span></span><br><span class="line">		        cache!!.trackConditionalCacheHit()</span><br><span class="line">		        cache.update(cacheResponse, response)</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 返回合并后的响应，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">	        &#125;</span><br><span class="line">			    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应不是304，关闭缓存响应的主体</span></span><br><span class="line">			        cacheResponse.body?.closeQuietly()</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">// 走到这里说明缓存失效需要处理返回的数据</span></span><br><span class="line">			<span class="comment">// 创建网络响应对象，同时处理缓存响应和网络响应的主体</span></span><br><span class="line">			<span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">				    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">				    .networkResponse(stripBody(networkResponse))</span><br><span class="line">				    .build()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">		        <span class="comment">// 如果响应需要缓存并且满足缓存条件，将请求提供给缓存</span></span><br><span class="line">		        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        </span><br><span class="line">		        <span class="comment">// 返回一个响应，同时执行缓存写入操作，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">		            <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这会记录条件缓存未命中</span></span><br><span class="line">                listener.cacheMiss(call)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的HTTP方法会使缓存无效，尝试从缓存中删除相应的项</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// 缓存无法删除，忽略异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终的响应</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheWritingResponse</span><span class="params">(cacheRequest: <span class="type">CacheRequest</span>?, response: <span class="type">Response</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 如果缓存请求为空，或者响应的主体为空，则直接返回响应</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="literal">null</span> || response.body == <span class="literal">null</span>) <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存请求的未缓冲主体</span></span><br><span class="line">    <span class="keyword">val</span> cacheBodyUnbuffered = cacheRequest.body()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的主体源</span></span><br><span class="line">    <span class="keyword">val</span> source = response.body!!.source()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建缓存主体，使用缓冲</span></span><br><span class="line">    <span class="keyword">val</span> cacheBody = cacheBodyUnbuffered.buffer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于写入缓存的主体源</span></span><br><span class="line">    <span class="keyword">val</span> cacheWritingSource = <span class="keyword">object</span> : Source &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cacheRequestClosed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> bytesRead: <span class="built_in">Long</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bytesRead = source.read(sink, byteCount)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheRequest.abort() <span class="comment">// 写入缓存响应失败，中止缓存请求。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheBody.close() <span class="comment">// 缓存响应已完整写入！</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据写入缓存主体</span></span><br><span class="line">            sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)</span><br><span class="line">            cacheBody.emitCompleteSegments()</span><br><span class="line">            <span class="keyword">return</span> bytesRead</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span> = source.timeout()</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheRequestClosed &amp;&amp;</span><br><span class="line">                !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                cacheRequest.abort()</span><br><span class="line">            &#125;</span><br><span class="line">            source.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的Content-Type和Content-Length</span></span><br><span class="line">    <span class="keyword">val</span> contentType = response.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> contentLength = response.body.contentLength()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的响应，使用缓存写入的主体</span></span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OKHttp的缓存设计"><a href="#OKHttp的缓存设计" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h3><p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制。它允许客户端缓存请求的响应数据，减少不必要的网络请求，从而提高应用的性能和响应速度。下面是OkHttp缓存设计的关键点：</p>
<ol>
<li><p><strong>缓存存储</strong>：</p>
<ul>
<li>OkHttp使用<code>Cache</code>类管理缓存。该类负责存储、检索和清除缓存响应。</li>
</ul>
</li>
<li><p><strong>可缓存性</strong>：</p>
<ul>
<li>OkHttp中决定一个响应是否可以被缓存是基于HTTP头部信息，如<code>Cache-Control</code>、<code>Last-Modified</code>和<code>ETag</code>。</li>
</ul>
</li>
<li><p><strong>缓存策略</strong>：</p>
<ul>
<li>通过<code>CacheStrategy</code>类确定是返回缓存的响应还是发起网络请求。该策略考虑请求头中的缓存指令和响应头中的验证器（如ETag或者Last-Modified）。</li>
</ul>
</li>
<li><p><strong>缓存验证</strong>：</p>
<ul>
<li>当缓存的响应被认为是过时的，OkHttp会在新的请求中添加条件头部（例如<code>If-None-Match</code>或<code>If-Modified-Since</code>）去验证缓存。如果服务器返回304（Not Modified），表明缓存仍然有效，客户端可以继续使用缓存的数据。否则，使用新的响应数据。</li>
</ul>
</li>
<li><p><strong>缓存拦截器</strong>：</p>
<ul>
<li><code>CacheInterceptor</code>是OkHttp中管理缓存逻辑的拦截器。它会检查请求的缓存指令，根据现有的缓存响应和请求条件，选择是从缓存返回数据还是发起新的网络请求。</li>
</ul>
</li>
<li><p><strong>新鲜度和过期</strong>：</p>
<ul>
<li>缓存的响应要在一定时间内被认定为新鲜的，基于<code>Cache-Control</code>的<code>max-age</code>指令、<code>Expires</code>头部或者启发式的计算。如果响应不再新鲜，OkHttp将尝试重新验证缓存。</li>
</ul>
</li>
<li><p><strong>同步和异步请求</strong>：</p>
<ul>
<li>OkHttp的缓存策略对于同步和异步请求都适用。但它会确保在异步请求中，缓存操作和网络调用都是在后台线程中执行，不会阻塞主线程。</li>
</ul>
</li>
<li><p><strong>透明处理</strong>：</p>
<ul>
<li>对于OkHttp的使用者来说，缓存大部分时间是透明的，只需要配置好<code>Cache</code>对象，并附着到OkHttp客户端即可。实际的缓存逻辑由库内部管理。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>OkHttp的缓存策略和逻辑遵循HTTP协议，但它也提供了一定程度的自定义，应用开发者可以通过设置请求头部来影响缓存的行为。</li>
</ul>
</li>
<li><p><strong>缓存持久性</strong>：</p>
<ul>
<li>OkHttp的缓存把响应数据存储在文件系统中，即使应用被杀死，这些缓存数据仍然可以在下次应用启动时被访问。</li>
</ul>
</li>
</ol>
<p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p><code>Http</code>的缓存规则分为两大类：<strong>强制缓存，对比缓存</strong>，与缓存规则相关的信息，均包含在报文的<code>Header</code>中。</p>
<p><strong>强制缓存</strong></p>
<p>强制缓存的实现依靠于<code>Expires</code>和<code>Cache-Control</code>这两个字段。<code>Expires</code> 通过这个 Header ，服务端可以告诉客户端缓存的过期时间，表示在过期时间内该资源都不会被更改，可以不用再向自己请求了。但因为客户端时间和服务器时间的差异，在在 HTTP&#x2F;1.1 协议中引入了 <code>Cache-Control</code> 机制，通过这个 Header 可以在服务端与客户端之间沟通缓存信息。常见的缓存指令如下</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center"><strong>客户端</strong>可以缓存</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center"><strong>客户端</strong>和<strong>代理服务器</strong>都可以缓存</td>
</tr>
<tr>
<td align="center">max-age&#x3D;xxx</td>
<td align="center">缓存数据在xxx秒后过期</td>
</tr>
<tr>
<td align="center">no-cache</td>
<td align="center">需要使用对比缓存来验证缓存数据</td>
</tr>
</tbody></table>
<p><strong>对比缓存</strong></p>
<p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。<br>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若缓存资源仍有效，服务器会返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>通过Last-Modified &#x2F; If-Modified-Since与Cache-Control配合判断，<code>Last-Modified</code> 位于响应头，<code>If-Modified-Since</code> 位于请求头。</p>
<ul>
<li><p><code>Last-Modified</code>：该响应资源最后的修改时间，服务器在响应请求的时候可以填入该字段。</p>
</li>
<li><p>If-Modified-Since：客户端缓存过期时（<code>max-age</code> 到达），发现该资源具有 <code>Last-Modified</code> 字段，可以在 Header 中填入 <code>If-Modified-Since</code> 字段，并填入<code>Last-Modified</code>记录的时间。服务端收到该时间后会与该资源的最后修改时间进行比较。</p>
<ul>
<li><p>若该资源已经被修改 ，则会返回状态码200，并对整个资源响应。</p>
</li>
<li><p>否则说明该资源在访问时未被修改，则会响应状态码 304，告知客户端可以使用缓存的资源</p>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>强制缓存和对比缓存可以同时存在，<strong>强制缓存优先级高于对比缓存</strong>，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p>当强制缓存和对比缓存同时存在时：</p>
<ol>
<li>对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。</li>
<li>对于比较缓存，客户端将缓存信息中的<code>Etag</code>和<code>Last-Modified</code>通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。</li>
</ol>
<h2 id="ConnectInterceptor-建立连接的拦截器"><a href="#ConnectInterceptor-建立连接的拦截器" class="headerlink" title="ConnectInterceptor 建立连接的拦截器"></a>ConnectInterceptor 建立连接的拦截器</h2><p>该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。</p>
<p><a href="https://www.cnblogs.com/giagor/p/15706524.html">探索OkHttp系列 (五) 连接建立与复用 - Giagor - 博客园</a></p>
<h3 id="HTTP中的连接复用机制"><a href="#HTTP中的连接复用机制" class="headerlink" title="HTTP中的连接复用机制"></a><strong><strong>HTTP中的连接复用机制</strong></strong></h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Http协议需要首先建立Socket连接（即TCP&#x2F;IP连接），同时我们了解到TCP&#x2F;IP连接需要进行三次握手，断开连接需要完成四次挥手。在完成了对某一域名的Socket连接之后，借助此Socket来进行Http数据的交互。那么第一次交互完成之后，如果需要进行与此域名的第二次交互，就可以利用前一次的Socket连接进行。因此OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。</p>
<h3 id="okHttp如何复用TCP连接？"><a href="#okHttp如何复用TCP连接？" class="headerlink" title="okHttp如何复用TCP连接？"></a><strong>okHttp如何复用TCP连接？</strong></h3><p>这个其实主要说的是 <code>ConnectInterceptor</code> 拦截器中初始化 <code>Exchange</code> 时内部做的事，具体如下：</p>
<p><code>OkHttp</code> 使用连接池 <code>RealConnectionPool</code> 管理所有连接，连接池将所有活动的连接存储在池中，并维护了一个空闲的链接列表(<code>TaskQueue</code>)，当需要新的连接时，<strong>优先尝试从这个池中找</strong>，如果没找到，则 <strong>重新创建</strong> 一个 <code>RealConnection</code> 连接对象，并将其添加到连接池中。在具体的寻找连接的过程中，一共进行了下面5次尝试：</p>
<ol>
<li>尝试重连 <code>RealCall</code> 中的 <code>connection</code>，此时不需要重新获取连接；</li>
<li>尝试从连接池中获取一个连接，不带路由与多路复用；</li>
<li>再次尝试从连接池中获取一个连接，带路由，不带多路复用；</li>
<li>手动创建一个新连接；</li>
<li>再次尝试从连接池中获取一个连接，带路由与多路复用；</li>
</ol>
<p>当然 <code>OkHttp</code> 也支持自定义连接池，具体如下：</p>
<p><img src="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png" alt="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png"></p>
<p>上述代码中，创建了一个新的连接池，并设置其保留最多 <code>maxIdleConnections</code> 个空闲连接，并且连接的存活期为 <code>keepAliveDuration</code> 分钟。</p>
<h3 id="okhttp连接池使用流程"><a href="#okhttp连接池使用流程" class="headerlink" title="okhttp连接池使用流程"></a>okhttp连接池使用流程</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20211209161223068.png" alt="image-20211209161223068"></p>
<h3 id="从连接池中获取可用连接部分代码分析"><a href="#从连接池中获取可用连接部分代码分析" class="headerlink" title="从连接池中获取可用连接部分代码分析"></a>从连接池中获取可用连接部分代码分析</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个连接去承载新的流，优先使用现有连接，接着是连接池中的连接，最后是创建一个新的连接</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 检查取消事件  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.尝试去重用call的连接  </span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="comment">// 检查这个连接是否可用和可复用  </span></span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        <span class="comment">// 连接不可用，在call中移除该连接，并返回该连接对应的Socket，随后要关闭它  </span></span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="comment">// 如果连接可以使用，那么就返回该连接  </span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    <span class="comment">// 关闭Socket  </span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need a new connection. Give it fresh stats.</span></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.尝试从连接池中获取连接(第一次)</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="comment">// 连接池里没有东西，计算下一条要尝试的路由  </span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 从现有的routeSelection中获取一个路由  </span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算一个新的routeSelector，这是一个阻塞操作  </span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="comment">// 如果routeSelector为null，那么就先创建一个RouteSelector  </span></span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从routeSelector中获取一个新的routeSelection  </span></span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    <span class="comment">// 获取routeSelection中的路由列表  </span></span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">    <span class="comment">// the pool. We have a better chance of matching thanks to connection coalescing.</span></span><br><span class="line">    <span class="comment">// 3.现在我们有了一组IP地址，再次尝试从连接池中获取连接，由于连接合并，这次我们有更大的希望</span></span><br><span class="line">    <span class="comment">// 从连接池里获取一个连接(第二次)  </span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="comment">// 返回连接</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从routeSelection中获取一个路由，用于新连接的创建  </span></span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="comment">// 4.创建新连接  </span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行TCP+TLS握手(Https请求才会做TLS握手)，这是一个阻塞的操作    </span></span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we raced another call connecting to this host, coalesce the connections. This makes for 3</span></span><br><span class="line">  <span class="comment">// different lookups in the connection pool!</span></span><br><span class="line">  <span class="comment">// 5.如果有另一个调用也是连接到相同的主机，并且该调用已经创建了新连接，将连接放到了连接池里，</span></span><br><span class="line">  <span class="comment">// 那么就使用连接池里的连接(第三次)  </span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    <span class="comment">// 保存路由  </span></span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    <span class="comment">// 将前面新创建的连接的Socket关闭  </span></span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接池中的连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三次在连接池中获取连接，依然没找到，意味着要使用新创建的连接 */</span>  </span><br><span class="line">      </span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    <span class="comment">// 6.将先创建的连接放进连接池里面</span></span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="comment">// 返回新创建的连接  </span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CallServerInterceptor：读写拦截器"><a href="#CallServerInterceptor：读写拦截器" class="headerlink" title="CallServerInterceptor：读写拦截器"></a>CallServerInterceptor：<strong>读写拦截器</strong></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="comment">// 以Request作为Key，获取候选缓存  </span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据「当前时间、请求、候选缓存」，创建缓存策略  </span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="comment">// 如果该请求不需要使用网络，那么networkRequest就为null  </span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="comment">// 如果不存在该请求对应的缓存，那么cacheResponse为null  </span></span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且没有对应的缓存，那么直接报错，返回状态码504  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.satisfactionFailure(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且有对应的缓存，那么就进入If语句，返回缓存</span></span><br><span class="line">    <span class="comment">// (代码执行到这里，说明networkRequest和cacheResponse不能同时为null)  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 经过上面的两个If语句，代码执行到这里，说明networkRequest不为null，也就是该请求要使用网络 */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示网络请求的响应  </span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 进行网络请求，获取下一个拦截器返回的Response  </span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="comment">// 释放资源  </span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 之前已经获取到请求对应的缓存  </span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若网络请求返回的响应中，包含状态码304，说明之前的缓存数据有效，返回cacheResponse对应</span></span><br><span class="line">      <span class="comment">// 的缓存结果（HTTP_NOT_MODIFIED对应状态码304）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">  			<span class="comment">// 混合 缓存Response的Header 和 网络获取的Response的Header        </span></span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存过期，收回资源  </span></span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 在上面的一大段If语句中，若响应码为304，则缓存资源有效，返回缓存资源，若响应码不为304， */</span>  </span><br><span class="line">	<span class="comment">/* 则表示缓存资源过期，关闭缓存资源 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取网络请求的结果  </span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对网络请求获取的Response进行缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果请求方法不需要缓存，则移除缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回网络的请求结果  </span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>自定义拦截器有两种应用拦截器和网络拦截器分别在两个位置，一个是在拦截器链头部，一个是在<strong>CallServerInterceptor和</strong>ConnectInterceptor中间。</p>
<p>他俩的区别：</p>
<ul>
<li>添加方式</li>
</ul>
<p>头：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>尾：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Android 内存泄漏相关</title>
    <url>/2023/12/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p>每个 Android 应用在启动时都会创建一个新的进程，和一个对应的运行时环境实例，当中包括堆（Heap）的分配和垃圾回收等功能。在操作系统中，每个进程都有自己的独立地址空间，这包括了堆、栈、代码和数据段。</p>
<p>一个运行中的程序（进程）的内存空间被划分为几个区域，每个区域有特定的用途和属性：</p>
<ol>
<li><strong>栈（Stack）</strong>：<ul>
<li>栈是由编译器自动管理的内存区域，用于存储程序执行时的函数调用信息。</li>
<li>它包括函数的参数值、返回地址以及局部变量等。</li>
<li>栈的特点是后进先出（LIFO）的数据结构，每当一个函数被调用时，它的信息就被推入（push）栈中，当函数调用完成后，这些信息就会被弹出（pop）栈。</li>
<li>分配时机：栈空间通常在程序开始执行时由操作系统自动分配，随着函数的调用和返回，会动态地增长和缩减。</li>
<li>分配者：操作系统负责分配一个初始栈空间给进程，并在运行时对栈进行管理。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>堆是用于动态内存分配的区域，程序在运行时可以从堆上分配或释放内存。</li>
<li>在C语言中，动态内存分配是通过<code>malloc</code>、<code>calloc</code>、<code>realloc</code>和<code>free</code>等函数实现的。</li>
<li>在Android开发中，Java虚拟机（JVM）或其他运行环境（如Dalvik虚拟机或Android Runtime, ART）管理堆内存，程序员通常不需要手动管理这部分内存，因为垃圾回收器会自动回收不再使用的对象。</li>
<li>分配时机：堆空间的分配是在程序运行时根据需要进行的，通常是程序员通过代码请求分配。</li>
<li>分配者：在C和C++等语言中，是由程序员通过调用<code>malloc</code>、<code>new</code>等函数显式申请的。在Java、C#等使用垃圾回收机制的语言中，由虚拟机或运行时环境负责管理。</li>
</ul>
</li>
<li><strong>BSS段（Block Started by Symbol）</strong>：<ul>
<li>BSS段用于存储程序中的未初始化的全局变量和静态变量。</li>
<li>在程序启动时，BSS段会被操作系统初始化为零或空指针。</li>
<li>分配时机：BSS段的空间分配发生在程序启动时，在程序被加载到内存时自动分配。</li>
<li>分配者：操作系统在加载程序时，会根据可执行文件的信息为BSS段分配内存，并将其初始化为零。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>数据段用来存储程序中已初始化的全局变量和静态变量。</li>
<li>这些变量的初始值存储在程序的可执行文件中，并在程序加载到内存时被初始化。</li>
<li>分配时机：数据段也是在程序启动时分配的，当程序被加载到内存时进行。</li>
<li>分配者：操作系统根据程序的可执行文件内容，在加载程序时为数据段分配内存，并赋予初始值。</li>
</ul>
</li>
<li><strong>程序代码区（Text Segment 或 Code Segment）</strong>：<ul>
<li>程序代码区，也称为文本段，包含了程序的机器指令代码。</li>
<li>这部分内存通常是只读的，以防止程序在运行时被意外修改。</li>
<li>它对应的是程序源代码文件中的实际指令和函数定义。</li>
<li>分配时机：程序代码区的分配同样发生在程序启动时，即当程序被加载到内存中时。</li>
<li>分配者：操作系统根据可执行文件中的代码段来分配内存，并将程序代码加载到这一段内存中。</li>
</ul>
</li>
</ol>
<h3 id="JVM、ART、DVM-的区别"><a href="#JVM、ART、DVM-的区别" class="headerlink" title="JVM、ART、DVM 的区别"></a>JVM、ART、DVM 的区别</h3><p>Java虚拟机（JVM）和Android虚拟机（如Dalvik虚拟机和Android Runtime，ART）都是为了运行基于Java语言编写的程序而设计的，但它们在设计理念、架构和运行环境上存在一些关键区别：</p>
<h4 id="功能原理："><a href="#功能原理：" class="headerlink" title="功能原理："></a>功能原理：</h4><p><strong>JVM</strong>：</p>
<p>我们写的java文件,经过编译生成.class文件,然后经过java虚拟机类加载 就成了.class类,也就是我们运行时访问的XXX.class类。JVM底层会将字节码转换为机器码,然后运行在CPU内.也可以这么理解:<strong>JVM就是个转换器,他将我们写的代码转换为CPU可以识别的代码,然后运行在CPU内</strong>。</p>
<p>或者说: JVM将CPU可以识别的代码,翻译成我们认识的java代码,让我们来写,我们写完后,它再负责翻译回去,让CPU执行。不同平台有不同的JVM,所以我们写一套代码,就能转换成不同平台的机器码,也就可以运行在不同平台上,这就是java跨平台的原理.</p>
<p><strong>DVM</strong>：</p>
<p>在app启动后,我们执行到对应功能的时候,就将这部分功能对应的代码 转换为 机器码,保存起来然后执行,可以理解为:<strong>用到才转换,所以也被称为JIT(just in time)</strong>.</p>
<p>优点：节省内存</p>
<p>缺点：执行速度慢</p>
<p><strong>ART</strong>：</p>
<p>主要有两个改善的地方.</p>
<ul>
<li><p>1 将转换为机器码的过程提前到了安装apk的时候.</p>
</li>
<li><p>2 内存分配方式和垃圾回收机制做了极大的优化.</p>
<p>DVM是基于JIT实现的,也就是边编译边执行,在运行到对应功能的时候,才将代码转换为机器码,然后交给CPU去执行.</p>
<p>而ART则不然,ART是在app安装的时候,就提前将所有代码转换为机器码保存下来,等到执行的时候,直接取出来在CPU中执行,也就是说,<strong>ART将转换为机器码这件事提前了. 所以叫做AOT(ahead of time)</strong>.</p>
</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>JVM</strong>：</p>
<ul>
<li>基于堆栈，每个线程都有自己的方法调用栈，栈帧中存储局部变量和操作数。</li>
<li>运行标准Java字节码，通常以<code>.class</code>文件的形式存在。</li>
<li>可在多种操作系统上运行，是跨平台的。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li><p>Dalvik有自己的字节码，不使用Java字节码</p>
</li>
<li><p>基于寄存器，更适合于资源受限的系统，如移动设备。</p>
</li>
<li><p>执行专为Dalvik设计的.dex格式文件，这是一种紧凑、针对Dalvik优化的字节码格式。</p>
</li>
<li><p>ART通过预编译（AOT编译）将应用程序转换为本机代码，从而提高性能。Dalvik采用的是JIT即时编译技术。</p>
</li>
<li><p>专门为Android系统设计，不是通用的跨平台解决方案。</p>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>JVM</strong>：</p>
<ul>
<li>采用即时编译（JIT）技术，在程序运行时将字节码编译成本地代码，实现性能优化。</li>
<li>服务器和桌面环境中的JVM会进行大量的性能优化以提高吞吐量和减少延迟。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li>Dalvik使用JIT编译，但受限于移动设备的性能和电池寿命的限制。</li>
<li>ART使用AOT编译，应用程序在安装时就被编译成本地代码，并在运行时进行JIT编译优Java虚拟机（JVM）和Android虚拟机（主要是指Dalvik虚拟机和Android运行时ART）都是为了在不同的硬件和操作系统平台上运行编译后的代码而设计的，但它们在设计哲学、实现方式和优化目标上有所不同。</li>
</ul>
<p>以下是JVM和Android虚拟机（Dalvik和ART）的一些主要区别：</p>
<h4 id="目标平台："><a href="#目标平台：" class="headerlink" title="目标平台："></a>目标平台：</h4><ul>
<li><strong>JVM</strong>：设计用于运行跨平台的Java应用程序，通常安装在个人电脑、服务器和大型系统上。</li>
<li><strong>Android虚拟机</strong>：专门为低功耗、有限内存的移动设备设计。</li>
</ul>
<h4 id="执行代码格式："><a href="#执行代码格式：" class="headerlink" title="执行代码格式："></a>执行代码格式：</h4><ul>
<li><strong>JVM</strong>：执行Java字节码，通常是<code>.class</code>文件或<code>.jar</code>文件中的代码。</li>
<li><strong>Dalvik</strong>：执行为Android优化的Dex（Dalvik Executable）格式代码。</li>
<li><strong>ART</strong>：虽然也支持Dex格式，但在应用安装时会将Dex编译成系统特定的本地机器码。</li>
</ul>
<h4 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h4><ul>
<li><strong>JVM</strong>：主要使用即时编译（JIT），应用程序在运行时编译成本地代码。</li>
<li><strong>Dalvik</strong>：使用解释执行，但也有JIT编译提高性能。</li>
<li><strong>ART</strong>：使用预先编译（AOT），在安装时将应用编译成本地代码，以及在运行时通过JIT进行优化。</li>
</ul>
<h4 id="垃圾回收（GC）："><a href="#垃圾回收（GC）：" class="headerlink" title="垃圾回收（GC）："></a>垃圾回收（GC）：</h4><ul>
<li><strong>JVM</strong>：提供多种垃圾回收器，可根据应用需求选择（如G1、CMS、Parallel等）。</li>
<li><strong>Dalvik</strong>：使用一个简单的GC机制，适合内存有限的设备。</li>
<li><strong>ART</strong>：提供改进的GC机制，包括分代垃圾回收和并发垃圾回收，以减少应用暂停时间。</li>
</ul>
<h4 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h4><ul>
<li><strong>JVM</strong>：在服务器和桌面环境中，性能优化侧重于最大化吞吐量和减少GC暂停时间。</li>
<li><strong>Android虚拟机</strong>：在移动设备上，优化侧重于启动速度，运行效率和响应速度，以及减少内存使用。</li>
</ul>
<h4 id="开发和分发模型："><a href="#开发和分发模型：" class="headerlink" title="开发和分发模型："></a>开发和分发模型：</h4><ul>
<li><strong>JVM</strong>：通常用于开发通用Java应用程序，可以在任何安装了兼容JVM的系统上运行。</li>
<li><strong>Android虚拟机</strong>：用于开发Android应用程序，这些应用程序通过Google Play商店或其他方式分发给Android用户。</li>
</ul>
<p>综上所述，JVM和Android虚拟机虽然都是虚拟机，但是它们在设计上是为了满足不同平台和需求而优化的。JVM更加通用和多功能，而Android虚拟机则是专门为移动设备和Android操作系统优化。</p>
<h3 id="ART-Java-堆组成"><a href="#ART-Java-堆组成" class="headerlink" title="ART Java 堆组成"></a>ART Java 堆组成</h3><p>当 Android 虚拟机启动时，便会创建 Java 堆，后续所有 Java 对象所需要的内存都会从这个堆中分配，所以我们先来说说 Java 堆的组成。Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace</strong>：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。Java 堆的空间是有限的，加起来只有 512M；</p>
<h3 id="Java对象内存申请"><a href="#Java对象内存申请" class="headerlink" title="Java对象内存申请"></a>Java对象内存申请</h3><p>Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<h3 id="Java对象内存释放"><a href="#Java对象内存释放" class="headerlink" title="Java对象内存释放"></a>Java对象内存释放</h3><p>在 Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC。</p>
<p>对于 ART 虚拟机的垃圾回收器来说，<strong>是通过可达性分析来判断一个对象是否可以被回收</strong>。<strong>GarbageCollector</strong> 会对 <strong>space</strong> 中的每一个对象的引用链进行分析，如果这个对象的引用链最终被 <strong>GC Root</strong> 持有，就说明这个对象不可回收。否则，就可以回收。如下图所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们没有被 GC Roots 持有， 因此会被判定为可回收的对象。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9297dd5668e34c8e97422a9dc4ad4f58%7Etplv-k3u1fbpfcp-jj-mark%3A1512%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>GC Root 有下面几项：</p>
<ol>
<li>栈中引⽤的对象：比如应用中主线程的 Handler，它是不会退出的，如果在 Handler 中持有了一个对象，那么这个对象就是被主线程栈所引用的对象，属于 GC Root 可达。这样一来，在 GarbageCollector 执行 GC 时就不会释放这个对象。</li>
<li>静态变量、常量引⽤的对象：被静态变量应用的对象也是属于 GC Root 可达，只有我们手动置为 null 才能释放这个对象。</li>
<li>本地⽅法栈 Native ⽅法引⽤的对象：通过 JNI 调用，传递到 Native 层并被 Native 的函数引用的对象。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>通过上面对 Java 堆的原理的讲解，我们了解了这 2 个知识点：</p>
<ol>
<li>Java 堆的空间是有限的，加起来只有 512M；</li>
<li>只有在切断 Java 对象和 GC Root 的关联后，虚拟机的 GC 机制才会回收该对象。</li>
</ol>
<p>基于这 2 个底层的知识点，我们就可以总结出 Java 堆内存优化的 3 条方法论：</p>
<ol>
<li><strong>减少加载进程</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>及时清理加载进</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>增加</strong> <strong>Java</strong> <strong>堆空间可用大小</strong></li>
</ol>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><ul>
<li>通过new分配新对象时，堆中剩余空间不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>到达阈值</li>
<li>手动调用系统API System.gc()时，会产生一次GC动作。</li>
<li>系统空闲。这个空闲判断条件也很多，比如进到后台，或者消息队列没数据等等。 后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。</li>
<li>启动时候出现gc，主要还是在于内存压力，到达一定的压力水位，就会触发GC</li>
</ul>
<p>C有不同的程度的，内存不足的时候的GC是最深度的，对性能影响也最大。达到不同的预测，GC的程度不一样，刚到达阈值的时候，可能就只是轻度的GC，轻度的就是标记清除，中度的就是复制拷贝回收。</p>
<h3 id="Java堆内存的获取"><a href="#Java堆内存的获取" class="headerlink" title="Java堆内存的获取"></a>Java堆内存的获取</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">loge(<span class="string">&quot;JVM试图使用的最大内存量，即应用程序可以使用的最大堆内存 ：<span class="subst">$&#123;Runtime.getRuntime().maxMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM当前已经从系统获取的内存量，包括已使用的内存和未使用的内存  ：<span class="subst">$&#123;Runtime.getRuntime().totalMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM中未使用的内存量  ：<span class="subst">$&#123;Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM的最大内存减去当前已经被使用的内存，得出的结果是应用程序还可以继续使用的内存量: <span class="subst">$&#123;Runtime.getRuntime().maxMemory() - Runtime.getRuntime().totalMemory() + Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="OOM产生"><a href="#OOM产生" class="headerlink" title="OOM产生"></a>OOM产生</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::IsOutOfMemoryOnAllocation</span><span class="params">([[maybe_unused]] AllocatorType allocator_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">size_t</span> alloc_size, <span class="comment">// 请求分配的内存大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> grow)</span> </span>&#123;  <span class="comment">// 是否允许内存增长 </span></span><br><span class="line">  <span class="type">size_t</span> old_target = target_footprint_.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 获取当前目标内存占用</span></span><br><span class="line">  <span class="comment">// 无限循环，计算新内存占用</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_allocated = num_bytes_allocated_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 在当前已分配的内存基础上增加了新请求分配的内存。</span></span><br><span class="line">    <span class="type">size_t</span> new_footprint = old_allocated + alloc_size;</span><br><span class="line">    <span class="comment">// 判断新占用是否超过限制。UNLIKELY提示编译器该条件发生概率低</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &lt;= old_target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// growth_limit_ ：堆内存的最大值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &gt; growth_limit_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>old_target</code> 相当于是一个可以变动的内存占用警戒线，而 <code>growth_limit_</code> 是不可超越的最大内存使用边界。如果内存使用超出了 <code>old_target</code> 但未到 <code>growth_limit_</code>，程序可能还有一定的弹性空间来调整内存使用；但是一旦超出 <code>growth_limit_</code>，则通常没有余地。</p>
<h3 id="OOM产生路径"><a href="#OOM产生路径" class="headerlink" title="OOM产生路径"></a>OOM产生路径</h3><p><a href="https://juejin.cn/post/7240636469462597690#heading-2">https://juejin.cn/post/7240636469462597690#heading-2</a></p>
<h3 id="ART-GC历史"><a href="#ART-GC历史" class="headerlink" title="ART GC历史"></a>ART GC历史</h3><h4 id="Dalvik-GC-（直到Android-4-4-KitKat）"><a href="#Dalvik-GC-（直到Android-4-4-KitKat）" class="headerlink" title="Dalvik GC （直到Android 4.4 KitKat）"></a>Dalvik GC （直到Android 4.4 KitKat）</h4><ul>
<li>初始的Dalvik虚拟机采用的是“标记-清除”（Mark-Sweep）算法。</li>
<li>在必要时执行“Stop-the-World”（STW）垃圾回收，这意味着所有工作线程都必须暂停，直到垃圾回收过程完成。</li>
</ul>
<h4 id="ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）"><a href="#ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）" class="headerlink" title="ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:"></a>ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:</h4><ul>
<li>引入了“分代GC”（Generational GC），它对对象按照存活时间进行分类，短暂对象和长期对象分别管理，以提高效率。</li>
<li>引入了预编译技术，改善了垃圾回收的性能。</li>
</ul>
<h4 id="ART-GC-（Android-6-0-Nougat）"><a href="#ART-GC-（Android-6-0-Nougat）" class="headerlink" title="ART GC （Android 6.0 Nougat）:"></a>ART GC （Android 6.0 Nougat）:</h4><ul>
<li>ART&#x2F;Dalvik Android团队使用汇编语言重写了整个对象分配过程，进一步提高了效率和性能。</li>
</ul>
<h4 id="ART-GC-（Android-8-0-9-0）"><a href="#ART-GC-（Android-8-0-9-0）" class="headerlink" title="ART GC （Android 8.0 ~ 9.0）:"></a>ART GC （Android 8.0 ~ 9.0）:</h4><ul>
<li>引入了“并发复制GC”（Concurrent Copying GC），称为CMS（Concurrent Mark-Sweep）的改进版本，减少了应用的暂停时间。</li>
</ul>
<h4 id="ART-GC-（Android-10开始）"><a href="#ART-GC-（Android-10开始）" class="headerlink" title="ART GC （Android 10开始）:"></a>ART GC （Android 10开始）:</h4><ul>
<li>重新引入了“分代GC”，并作为“并发复制GC”的一个扩展，进一步优化内存管理和减少暂停时间</li>
</ul>
<p>在 Generational CC 中，堆内存并没有显式地划分为不同的代，而是在运行时 把不同的 region 标记为新生代或者老年代；</p>
<p>下面是JVM对用户空间的划分</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/3a21f3fd821143708a0ea69ca309bad1%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="在这里插入图片描述"></p>
<p>Android虚拟机将堆内存同样分为三个区域：<strong>年轻代，年老代，永久代</strong>，针对年轻代和老年代，ART和Dalvik又做了细分。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/5b4db7c314164ebab2619e5e7efc27e7%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0-20231228163627586.awebp" alt="在这里插入图片描述"></p>
<p><strong>ZygoteSpace：Zygote进程启动过程中创建的所有对象。这些对象是所有进程共享</strong></p>
<p><strong>ImageSpcace：存放预加载的类，Android Framework中通用的类都都是存储在这里</strong></p>
<p><strong>Large Obj Space：存放大于12k的类对象的空间</strong></p>
<p><strong>Main Allooc Space：存放小对象的空间</strong></p>
<p><strong>Non Moving Space&#x2F;Linear Alloc：只读的线性内存空间，主要用来存储虚拟机中在进程生命周期都不会结束清理的永久数据的类对象。</strong></p>
<p>ZygoteSpace和ImageSpace存放共享的预加载的类，这样可以提高启动速度，还有根据对象的大小和特性划分LargeObjSpace，AllocSpace和Non Moving Space可以采用不同的垃圾回收策略，提高gc的效率和性能。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1*bsfQgcHVbxeFsXOGv5onPA-20231228165437394.png" alt="img"></p>
<h3 id="Android中的GC"><a href="#Android中的GC" class="headerlink" title="Android中的GC"></a>Android中的GC</h3><p>Android中的GC是通过<strong>HeapTaskDaemon</strong>线程来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapTaskDaemon</span> <span class="keyword">extends</span> <span class="title class_">Daemon</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式，内部类中创建该类的唯一实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HeapTaskDaemon</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapTaskDaemon</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，设置守护线程的线程名为 &quot;HeapTaskDaemon&quot;。</span></span><br><span class="line">    HeapTaskDaemon() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;HeapTaskDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，用于中断指定的线程。</span></span><br><span class="line">    <span class="comment">// 这个方法会通知 VMRuntime 停止堆任务处理器。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        VMRuntime.getRuntime().stopHeapTaskProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程的核心执行方法。</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，确保线程安全。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果守护线程正在运行，则通知 VMRuntime 启动堆任务处理器。</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line">              VMRuntime.getRuntime().startHeapTaskProcessor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行堆任务。</span></span><br><span class="line">        <span class="comment">// 这个方法可能会执行垃圾收集（GC）或其他与堆管理相关的任务。</span></span><br><span class="line">        VMRuntime.getRuntime().runHeapTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapTaskDaemon 是一个守护线程（程序运行时在后台提供一种通用服务的线程），随着 Zygote 进程启动便会启动，该线程的 run 方法也比较简单，就是执行 runInternal 这个抽象函数，该抽象函数的实现方法中会执行 VMRuntime.getRuntime().runHeapTasks() 方法，runHeapTasks() 函数会执行 RunAllTasks 这个 Native 函数，它位于 <a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/task_processor.cc">task_processor.cc</a> 这个类中。</p>
<p>通过源码一路跟踪下来，可以看到 HeapTaskDaemon 线程的 run 方法中真正做的事情，实际只是在无限循环的调用 GetTask 函数获取 HeapTask 并执行。GetTask 中会不断从 tasks 集合中取出 HeapTask 来执行，并且对于需要延时的 HeapTask ，会阻塞到目标时间。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155739553.png" alt="image-20231229155739553"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155809976.png" alt="image-20231229155809976"></p>
<h3 id="GC导致应用程序卡顿"><a href="#GC导致应用程序卡顿" class="headerlink" title="GC导致应用程序卡顿"></a>GC导致应用程序卡顿</h3><p>GC导致了用户线程的停止，这个机制叫做STW，为了防止出现 GC开始时对象没引用被标记为垃圾，GC过程中对象又被引用这种情况。</p>
<p>回收策略：分代回收 分区回收</p>
<p>垃圾检测算法：引用计数 可达性分析</p>
<p>回收算法：标记复制 标记清除  标记整理</p>
<h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p><strong>标记清除</strong>：</p>
<ul>
<li><p>Mark阶段（标记阶段）：搜索内存中的Java对象（对ART虚拟机而言，就是遍历mirror Object对象），对那些能搜到的对象进行标记。</p>
</li>
<li><p>Sweep阶段（清除阶段）：释放那些没有被标记的对象所占据的内存。</p>
<p>整个过程需要将整个程序暂停，清除完成之后才恢复程序运行，而且这个算法会带来碎片化的问题。</p>
</li>
</ul>
<p><strong>复制算法</strong>：复制算法会将存活的对象复制到一块内存，然后将遗留下来的对象进行清理，这种算法不会产生碎片问题，但是会占用更多的内存，因为要一块空间来复制存活的对象。 年轻代</p>
<p><strong>标记整理</strong>：先从根节点标记哪些是被对象引用的。第二阶段将所有存活的对象压缩移动到内存的另一端，按顺序排放，最后清除所有边界以外的空间。 老年代</p>
<p><strong>分代算法</strong>：分代垃圾回收算法（Generational Garbage Collection）是基于对象生命周期不同的假设来进行垃圾回收的策略。它把对象分为几个“代”，通常至少分为两代：年轻代（Young Generation）和老年代（Old Generation）。</p>
<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><ul>
<li>局部变量表：正在执丸行的函数的参数、临时变量，临时值</li>
<li>方法区中的静态变量：如类的静态变量</li>
<li>方法区中的常量池：如常量池中的常量引用实例</li>
<li>本地方法栈中的变量：NI调用Native方法所引用的实例</li>
<li>同步锁持有的对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kotlin协程</title>
    <url>/2023/12/15/kotlin%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0ODk4OTI%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231225183233003.png" alt="在这里插入图片描述"></p>
<h3 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h3><h4 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式  CoroutineName: <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = CoroutineName(<span class="string">&quot;continuation 01&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 代码执行结果：  表明coroutineContext传递下来的</span></span><br><span class="line">    Suspend Lambda表达式  CoroutineName: CoroutineName(continuation <span class="number">01</span>)</span><br><span class="line">    <span class="comment">// 表明协程体执行结束后 结果的返回是由传入的Continuation实现的</span></span><br><span class="line">    resuming with result Success(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>深入createCoroutine这个方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br></pre></td></tr></table></figure>

<ul>
<li>简单总结:</li>
</ul>
<p>         suspend{      &#x2F;&#x2F;…     } 这部分代码被包装成了<code>createCoroutine</code>的<code>Receiver</code>,<strong>方法的参数<code>completion</code>会在协程执行完成后掉用，就是协程的完成回调。</strong></p>
<p>        而方法返回的Continuation只用于开启协程和承担协程体。<strong>如果它的内部还有协程的话，它就会作为completion参数传入内部协程。</strong></p>
<ul>
<li>原理：</li>
</ul>
<p>        <code>createCoroutine</code>方法返回的<code>Continuation</code>是<code>SafeContinuation</code>的实例(SafeContinuation继承自Continuation)，但是这只是一个“马甲”。</p>
<p>        SafeContinuation构造方法中有个名为delegate的属性，delegate 的属性是一个被委托的属性，它的类型是 Continuation<T>，实际上它所委托的对象就是这个由编译器生成的 Continuation 实现类的实例一个内部匿名类。</p>
<p>        先来看一下createCoroutineUnintercepted这个方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// gpt说这个函数是用来 暴露给协程调试器的占位函数</span></span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">// 这里的this 指的是上面的Suspend Lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">// 此处的create 和 下面的createCoroutineFromSuspendFunction</span></span><br><span class="line">        <span class="comment">// 可以参考 下面的对代码的一个反编译</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        这个实现类的类名是由编译器根据文件名、函数名和一些其他信息生成的，通常是类似于 <FileName>Kt<FunctionName>continuation$1 这样的形式。<strong>这个匿名内部类继承自SuspendLambda类，而SuspendLambda类又是Continuation接口的实现类。</strong></p>
<p>简单提一下匿名内部类的实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure>

<p>      Suspend Lambda表达式一个函数对应了一个类 ，这里的实现挺悬乎的 它是由编译器实现的这部分内容，SuspendLambda有一个抽象函数invokeSuspend，编译生成的匿名内部类中这个函数的实现就是我们的协程体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Function1</span> <span class="variable">var0</span> <span class="operator">=</span> (Function1)(<span class="keyword">new</span> <span class="title class_">Function1</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Nullable</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  ResultKt.throwOnFailure(var1);</span><br><span class="line">                  <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;Suspend Lambda表达式  CoroutineName: &quot;</span> + (CoroutineName)<span class="built_in">this</span>.getContext().get((CoroutineContext.Key)CoroutineName.Key);</span><br><span class="line">                  System.out.println(var2);</span><br><span class="line">                  <span class="keyword">return</span> Boxing.boxInt(<span class="number">5</span>);</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">            Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">            <span class="comment">// 把completion传入，并创建一个新的Function1，作为Continuation返回，</span></span><br><span class="line">            <span class="comment">// 这就是创建出来的协程体对象，协程的工作核心就是它内部的状态机，</span></span><br><span class="line">            <span class="comment">// invokeSuspend函数</span></span><br><span class="line">            <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Continuation</span> <span class="variable">var4</span> <span class="operator">=</span> ContinuationKt.createCoroutine(var0, (Continuation)(<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineName <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CoroutineName</span>(<span class="string">&quot;continuation 01&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext)<span class="built_in">this</span>.getContext();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;resuming with result &quot;</span> + Result.toString-impl(result);</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">      <span class="type">Unit</span> <span class="variable">var1</span> <span class="operator">=</span> Unit.INSTANCE;</span><br><span class="line">      Result.<span class="type">Companion</span> <span class="variable">var2</span> <span class="operator">=</span> Result.Companion;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      var4.resumeWith(Result.constructor-impl(var1));</span><br></pre></td></tr></table></figure>

<p>      总结一下就是createCoroutine方法所生成的对象是一个<code>SafeContinuation</code>的实例，同时这个实例中有一个委托属性，它所委托的对象是一个匿名内部类。匿名内部类继承自SuspendLambda类，而这个类又是Continuation接口的实现类。而Suspend Lambda表达式的函数体实现在了SuspendLambda类的抽象类invokeSuspend方法中。</p>
<p>     协程的启动就是创建出来的对象调用了resume方法，这个方法的调用最终会来到<strong>BaseContinuationImpl::resumeWith</strong>方法中，这个方法中调用了当前协程的invokeSuspend方法状态机相关的东西就在里面，从而开启了协程。</p>
<p>     上面的内容解释了所返回的Continuation对象的具体内容。也就是为什么调用了他的<code>resume</code>后协程会启动的原因。</p>
<ul>
<li>外部传入的那个Continuation的对象completion的的流向</li>
</ul>
<p>      首先completion是createCoroutine方法传入的参数，然后传给了createCoroutineUnintercepted方法，在这个方法里它的流向有两个分支，目前只说第一条，之后它被传入了create方法，前面说了suspend lambda 表达式对应一个匿名内部类，这个类里的create方法就是对应的实现，目前看代码能分析到这里。<strong>以类的构造方法参数传参的方式</strong>就到了BaseContinuationImpl::resumeWith方法中。先来看代码实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 在每个恢复的延续上调用“resume”调试探针，以便调试库基础设施</span></span><br><span class="line">        <span class="comment">// 可以精确跟踪挂起的调用堆栈的哪一部分已经恢复</span></span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="comment">// completion到了这里</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! <span class="comment">// completion为null直接抛出异常防止出现更严重的错误</span></span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里调用invokeSuspend开启了状态机</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// 此状态机实例正在终止</span></span><br><span class="line">            <span class="comment">// completion又开启了一层判断</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                <span class="comment">// 通过循环展开递归</span></span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 达到顶层完成——通过completion调用resumeWith返回结果</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来一个整体流程的函数原理</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#Continuation.kt</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    <span class="comment">//返回SafeContinuation 对象</span></span><br><span class="line">    <span class="comment">//SafeContinuation 构造函数需要2个参数，一个是delegate，另一个是协程状态</span></span><br><span class="line">    <span class="comment">//此处默认是挂起</span></span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">//此处的this 即为匿名内部类对象 MyAnonymous，它间接继承了BaseContinuationImpl</span></span><br><span class="line">        <span class="comment">//调用MyAnonymous 重写的create 函数</span></span><br><span class="line">        <span class="comment">//create 函数里new 新的MyAnonymous 对象</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    <span class="comment">//判断是否是ContinuationImpl 类型的Continuation</span></span><br><span class="line">    <span class="comment">//我们的demo里是true，因此会继续尝试调用拦截器</span></span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kt</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    <span class="comment">//查看是否已经有拦截器，如果没有，则从上下文里找，上下文没有，则用自身，最后赋值。</span></span><br><span class="line">    <span class="comment">//在我们的demo里上下文里没有，用的是自身</span></span><br><span class="line">    intercepted</span><br><span class="line">        ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">            .also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">#CoroutineDispatcher.kt</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        <span class="comment">// 这里构造出了一个DispatchedContinuation对象 </span></span><br><span class="line">        <span class="comment">// 其中的this指的是context[ContinuationInterceptor] 取出的调度器</span></span><br><span class="line">        <span class="comment">// continuation 是createCoroutineUnintercepted方法中create创建的对象</span></span><br><span class="line">        <span class="comment">// 也就是下面伪代码中的MyAnonymous类的对象</span></span><br><span class="line">        <span class="comment">// DispatchedContinuation(this, continuation)</span></span><br><span class="line">        <span class="comment">// 这里返回了一个DispatchedContinuation对象，它继承自Runnable和Continuation。</span></span><br><span class="line">        <span class="comment">// 然后可以回到上面的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后得出的Continuation 赋值给SafeContinuation 的成员变量：delegate。</span><br><span class="line">至此，SafeContinuation 对象已经构造完毕，接着继续看如何用它开启协程。</span><br><span class="line"></span><br><span class="line">#SafeContinuationJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// lock-free loop</span></span><br><span class="line">        <span class="keyword">val</span> cur = <span class="keyword">this</span>.result <span class="comment">// atomic read</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            <span class="comment">//初始化状态为UNDECIDED，因此直接return</span></span><br><span class="line">            cur === CoroutineSingletons.UNDECIDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>,</span><br><span class="line">                    CoroutineSingletons.UNDECIDED, result.value)) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">//如果是挂起，将它变为恢复状态，并调用恢复函数</span></span><br><span class="line">           <span class="comment">//demo 里初始化状态为COROUTINE_SUSPENDED，因此会走到这</span></span><br><span class="line">            cur === COROUTINE_SUSPENDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>, COROUTINE_SUSPENDED,</span><br><span class="line">                    CoroutineSingletons.RESUMED)) &#123;</span><br><span class="line">                <span class="comment">//delegate 为之前创建的Continuation，demo 里因为没有拦截，因此为MyAnonymous</span></span><br><span class="line">                delegate.resumeWith(result)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already resumed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kotlin</span><br><span class="line">#BaseContinuationImpl类的成员函数</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="keyword">val</span> completion = completion!!</span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//invokeSuspend 即为MyAnonymous 里的方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="comment">//如果返回值是挂起状态，则函数直接退出</span></span><br><span class="line">                    <span class="keyword">if</span> (outcome === kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    kotlin.Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    kotlin.Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//执行到这，最终执行外层的completion，在demo里会输出&quot;result:$result&quot;</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h3><p>        先来思考问题，挂起函数挂起需要哪些条件？ 什么情况下会真正的挂起？</p>
<p>在这之前先看两个函数变换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，形参为函数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后</span></span><br><span class="line"><span class="comment">// 在JVM 平台函数类型参数最终是用匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty(<span class="meta">@NotNull</span> Function0  block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function0的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// suspend类型的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty1</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里成了Function1</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty1(<span class="meta">@NotNull</span> Function1 block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function1的定义  相较于Function0多了个参数. 对于挂起函数来说这个参数就是Continuation类型的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function1</span>&lt;<span class="type">in P1, out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function with the specified argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看挂起函数的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里函数的类型就是 suspend () -&gt; T</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test suspend&quot;</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">&quot;test suspend in thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        上面这段代码会被提示<code>Redundant &#39;suspend&#39; modifier </code>，意思是suspend是多余的。内部没有执行其他的挂机函数挂起没意义。</p>
<p>简单创建一个原始协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">launchFish</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建协程，返回值为SafeContinuation(实现了Continuation 接口)</span></span><br><span class="line">    <span class="comment">//入参为Continuation 类型，参数名为completion，顾名思义就是</span></span><br><span class="line">    <span class="comment">//协程结束后(正常返回&amp;抛出异常）将会调用它。</span></span><br><span class="line">    <span class="keyword">var</span> coroutine = block.createCoroutine(<span class="keyword">object</span> : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程结束后调用该函数</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;result:<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//开启协程</span></span><br><span class="line">    coroutine.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里调用launchFish函数</span></span><br><span class="line">    <span class="comment">// 这里传入一个 lambda 好像会自动被包装成suspend lambda</span></span><br><span class="line">    <span class="comment">// suspend 修饰的函数类型，当调用者实现其函数体时，传入的实参将会继承自SuspendLambda</span></span><br><span class="line">    launchFish &#123;</span><br><span class="line">        println(<span class="string">&quot;I am coroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下反编译后的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnonymous</span> <span class="keyword">extends</span> <span class="title class_">SuspendLambda</span> <span class="keyword">implements</span> <span class="title class_">Function1</span> &#123;</span><br><span class="line">    <span class="type">int</span> label;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var4</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>.label) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;I am coroutine&quot;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                System.out.println(var2);</span><br><span class="line">                <span class="comment">// 这里永远会返回Unit.INSTANCE; 协程永远不会挂起</span></span><br><span class="line">                <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">        <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">launchFish</span><span class="params">(<span class="meta">@NotNull</span> MyAnonymous block)</span> &#123;</span><br><span class="line">    <span class="type">Continuation</span> <span class="variable">coroutine</span> <span class="operator">=</span> ContinuationKt.createCoroutine(block, (<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext) EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;result:&quot;</span> + Result.toString-impl(result);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//这里开启协程</span></span><br><span class="line">    coroutine.resumeWith(Result.constructor-impl(var3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="meta">@NotNull</span> String[] array)</span> &#123;</span><br><span class="line">    <span class="type">MyAnonymous</span> <span class="variable">myAnonymous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAnonymous</span>();</span><br><span class="line">    launchFish(myAnonymous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用suspendCoroutine</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunc02</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span></span><br><span class="line">         = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; &#123; continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">5</span>)) <span class="comment">// ... 1 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码反编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">suspendFunc02</span><span class="params">(<span class="meta">@NotNull</span> String a, <span class="meta">@NotNull</span> String b, <span class="meta">@NotNull</span> Continuation $completion)</span> &#123;</span><br><span class="line">     <span class="type">SafeContinuation</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeContinuation</span>(IntrinsicsKt.intercepted($completion));</span><br><span class="line">     <span class="type">Continuation</span> <span class="variable">continuation</span> <span class="operator">=</span> (Continuation)var4;</span><br><span class="line">     <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     ThreadsKt.thread$<span class="keyword">default</span>(<span class="literal">false</span>, <span class="literal">false</span>, (ClassLoader)<span class="literal">null</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (Function0)(<span class="keyword">new</span> <span class="title class_">KotlinTestKt$suspendFunc02$2$1</span>(continuation)), <span class="number">31</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">     <span class="comment">// getOrThrow用于判断结果是否已经确定，</span></span><br><span class="line">     <span class="comment">// 如果没有确定，则将协程挂起并返回一个特殊的值。</span></span><br><span class="line">     <span class="comment">// 如果结果已经确定，它将检查结果类型，如果是失败的结果，则抛出异常，否则返回结果本身。</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> var4.getOrThrow();</span><br><span class="line">     <span class="keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">        DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> var10000;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>        suspendCoroutine会接收suspendFunc02函数的suspend所转化出的completion，也就是获取当前函数的Continuation实例，用来作为协程执行完毕后的回调函数。而其内部会生成一个用于执行协程体的SafeContinuation对象。</p>
<p>        如果不使用suspendCoroutine获取当前协程的续体，则无法实现真正的挂起与resume。</p>
<p>        所谓协程的挂起其实就是程序执行流程<strong>发生异步调用</strong>时，异步调用是否发生，取决于resume函数与对应的挂起函数的调用是否在相同的调用栈上，切换函数调用栈的方法可以是切换到其他线程上执行，也可以是不切换线程但在当前函数返回之后的某一个时刻再执行。 </p>
<p>        上面扯的有些复杂了，是否挂起要看内部协程返回的值，如果只会<code>return Unit.INSTANCE;</code> 那么永远不会挂起。在<strong>发生异步调用</strong>时会返回对应的标志挂起的值，SafeContinuation类的作用也非常简单，它可以确保只有发生异步调用时才会挂起。</p>
<h4 id="协程的恢复"><a href="#协程的恢复" class="headerlink" title="协程的恢复"></a>协程的恢复</h4><p>        首先要知道一个知识点：一个协程体的invokeSuspend被调用有两种情况，第一种是在它刚被创建时从<code>CoroutineStart::invoke</code>到<code>(suspend () -&gt; T).startCoroutineCancellable</code>再到<code>(suspend () -&gt; T).createCoroutineUnintercepted</code>然后会走到<code>create(completion)</code>也就是在反编译后的那个create方法，紧接着就会调用它的invokeSuspend方法来执行协程体。</p>
<p>        第二种是它被作为completion传入了子协程中，在<code>BaseContinuationImpl::resumeWith</code>方法中被子协程回调结果时调用走<code>completion.resumeWith(outcome)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;parent coroutine running&quot;</span>)</span><br><span class="line"></span><br><span class="line">        getStuInfoV1()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;after suspend&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStuInfoV1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;son coroutine running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的整体流程图：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/99353b7e71c69.jpg" alt="img"></p>
<h4 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h4><p>        协程通过传递Continuation来控制异步调用流程。</p>
<p>        协程的创建和运行过程，我们的协程体本身就是一个Continuation实例，正因如此挂起函数才能在协程体内运行。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<p>        协程是一种控制流的抽象，当协程被挂起时，它会将当前的执行状态（包括程序计数器、寄存器等）保存到一个回调函数中，这个回调函数就是挂起函数的 Continuation。这样，在协程恢复执行时，它会从保存的执行状态继续执行，而不是从头开始执行。这种机制使得协程能够在不同的时间点之间暂停和恢复执行，从而实现更加灵活的控制流程。</p>
<p>        当前调用流程的执行状态进入等待状态。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<h4 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h4><p>        先看一段Continuation实现的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        CoroutineContext作为一个接口内部的成员对象存在。且是val的，所有Continuation的实现类通过<code>public override val context: CoroutineContext       get() = EmptyCoroutineContext</code>的方式进行重写。</p>
<p>        CoroutineContext的结构类似List，具体可看其实现源码。其内部元素的结构是Element，且元素本身就实现了CoroutineContext对象。这看上去就好像Int实现了List<Int>接口一样，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? =</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">        operation(initial, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        list中的元素都有一个index，表示元素的索引，而这里协程上下文元素的key就是<br>协程上下文这个集合中元素的索引，不同之处是这个索引“长”在了数据里面，这意味着协程上下文的数据在“出生”时就找到了自己的位置。</p>
<p>        <strong>协程上下文的内部实现实际上是一个单链表</strong>，Kotlin协程上下文的内部实现是通过一个单链表来实现的，这个单链表中包含了多个协程上下文元素。每个协程上下文元素都包含了一些协程上下文属性，例如调度器、异常处理器等等。通过将这些协程上下文元素链接起来，就可以形成一个完整的协程上下文。当协程执行时，它会按照链表中的顺序依次应用每个协程上下文元素中的属性，以实现对协程的控制和管理。因此，单链表是协程上下文内部实现的核心部分。具体论证观察CoroutineContext类的plus方法的实现。</p>
<h4 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = LogInterceptor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line"><span class="comment">//  延长线程存活时间</span></span><br><span class="line">    sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义拦截器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">get</span>() = ContinuationInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;) :</span><br><span class="line">    Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此处对协程的表达进行了拦截</span></span><br><span class="line">        println(<span class="string">&quot;before resumeWith: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">&quot;after resumeWith.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 日志打印</span></span><br><span class="line"><span class="comment">// 此处拦截的是createCoroutine方法创建出的continuation执行resumeWith开启协程</span></span><br><span class="line"><span class="comment">// 协程启动挂起</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">after resumeWith.</span><br><span class="line"><span class="comment">// 此处拦截的是所传入的continuation来进行结果回调时调用resumeWith</span></span><br><span class="line"><span class="comment">// 协程执行结束恢复</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">Suspend Lambda表达式</span><br><span class="line">resuming with result Success(<span class="number">5</span>)</span><br><span class="line">after resumeWith.</span><br></pre></td></tr></table></figure>

<h4 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h4><p><strong>CoroutineContext 里存放着协程的分发器。</strong></p>
<ul>
<li><p><strong>Dispatchers.Main</strong>  UI 线程，在Android里为主线程</p>
</li>
<li><p><strong>Dispatchers.IO</strong>  IO 线程，主要执行IO 操作</p>
</li>
<li><p><strong>Dispatchers.Default</strong> 主要执行CPU密集型操作，比如一些计算型任务</p>
</li>
<li><p><strong>Dispatchers.Unconfined</strong>  不限定具体的线程类型，当前调度器在哪个线程，就在该线程上进行执行。也就是和它的父协程保持一致。</p>
</li>
</ul>
<h3 id="协程框架"><a href="#协程框架" class="headerlink" title="协程框架"></a>协程框架</h3><h4 id="自定义一个delay函数"><a href="#自定义一个delay函数" class="headerlink" title="自定义一个delay函数"></a>自定义一个delay函数</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">        executor.schedule(&#123;</span><br><span class="line">            continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;, time, unit)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>) &#123; runnable -&gt;</span><br><span class="line">    Thread(runnable, <span class="string">&quot;Scheduler&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程作用域种类"><a href="#协程作用域种类" class="headerlink" title="协程作用域种类"></a>协程作用域种类</h3><p>GlobalScope。即全局协程作用域，在这个范围内启动的协程可以一直运行直到应用停止运行。GlobalScope 本身不会阻塞当前线程，且启动的协程相当于守护线程，不会阻止 JVM 结束运行</p>
<p>runBlocking。一个顶层函数，和 GlobalScope 不一样，它会阻塞当前线程直到其内部所有相同作用域的协程执行结束</p>
<p>自定义 CoroutineScope。可用于实现主动控制协程的生命周期范围，对于 Android 开发来说最大意义之一就是可以在 Activity、Fragment、ViewModel 等具有生命周期的对象中按需取消所有协程任务，从而确保生命周期安全，避免内存泄露</p>
<h3 id="async和launch的区别"><a href="#async和launch的区别" class="headerlink" title="async和launch的区别"></a>async和launch的区别</h3><p><code>async</code> 可以返回协程的执行结果，而 <code>launch</code> 不行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncA = async &#123;</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> asyncB = async &#123;</span><br><span class="line">                delay(<span class="number">4000</span>)</span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            log(asyncA.await() + asyncB.await())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async的最后一行为返回值</p>
<h3 id="Kotlin-协程库四个-Dispatcher"><a href="#Kotlin-协程库四个-Dispatcher" class="headerlink" title="Kotlin 协程库四个 Dispatcher"></a>Kotlin 协程库四个 Dispatcher</h3><p>**<code>Dispatchers.Main</code>**：这是主调度器，通常用于 Android 或其它 UI 框架中。它会在主线程上运行协程，用于更新 UI 或做其它需要在主线程完成的操作。例如更新 TextView 或 RecyclerView 等 UI 组件</p>
<p>**<code>Dispatchers.Default</code>**：默认调度器，用于执行长时间运行并且需要大量 CPU 资源的任务，比如排序列表或者解析大型 JSON 数据等 CPU 密集型任务。</p>
<p>**<code>Dispatchers.IO</code>**：I&#x2F;O 调度器，适用于大量 I&#x2F;O 操作，如网络请求，文件读写等。</p>
<p>**<code>Dispatchers.Unconfined</code>**：无限制的调度器，协程会在启动的立即执行，直到第一个挂起点。当挂起函数结束后，协程会在挂起函数结束的线程上恢复执行。它适用于一些不需要特定线程，同时又需要立即执行的情况。但使用时要小心，因为它很容易造成一些意想不到的问题。</p>
<h3 id="协程中的线程局部变量的原子性和可见性"><a href="#协程中的线程局部变量的原子性和可见性" class="headerlink" title="协程中的线程局部变量的原子性和可见性"></a>协程中的线程局部变量的原子性和可见性</h3><p>在使用了线程池的调度器（例如 <code>Dispatchers.IO</code> 或 <code>Dispatchers.Default</code>）来运行一个 <code>withContext()</code> 块时，整个withContext内的代码块可能没有运行在同一个线程上。</p>
<p>例如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Prints &quot;IO dispatcher worker 1&quot; </span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// This is a suspend function</span></span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Might print &quot;IO dispatcher worker 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>suspendSomeIoOperation()</code> 是一个挂起函数，当它挂起时，当前线程可能会去运行其他的任务。当操作 A 完成后，可能会有一个不同的线程（从线程池中选择）来恢复这个协程的执行。因此，<code>threadName1</code> 和 <code>threadName2</code> 可能会是不同的，即使他们都在同一个 <code>withContext()</code> 块中。</p>
<p>这个特性有两个影响：</p>
<ol>
<li><strong>不保证线程局部变量的一致性</strong>：线程局部变量<strong>不是</strong>跨线程的，如果你的协程在两个不同的线程上运行，那么你将看到线程局部变量的不同版本。</li>
<li><strong>不保证并发操作的原子性和可见性</strong>：如果你的协程代码块包含对共享资源的写操作，那么你需要确保这些操作是线程安全的，否则可能会出现并发问题，如数据竞争。</li>
</ol>
<p>如果希望让整个 <code>withContext&#123;&#125;</code> 块始终在同一个线程上运行，应该使用一个单线程的调度器，比如 <code>newSingleThreadContext(&quot;myThread&quot;)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;newSingleThreadContext&quot;</span>)</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="string">&quot;Unconfined 4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 Mutex 或 @Volatile 来实现线程安全的示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.withLock &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// 启动100个协程进行累加</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>@Volatile</code> 注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        </span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// @Volatile 不保证原子性，意味着 counter++ 不是一个原子操作，还可能会存在竞态条件，所以结果可能会小于100。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicInteger</code> 类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> counter = AtomicInteger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter.incrementAndGet()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// Start multiple coroutines</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter.<span class="keyword">get</span>()) <span class="comment">// Will always print 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="job-join"><a href="#job-join" class="headerlink" title="job.join()"></a>job.join()</h3><p><code>join()</code>的作用是挂起当前协程，直到这个 <code>Job</code> 完成。这个方法使得您可以等待一个协程任务执行完毕。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;job completed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Waiting for job...&quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;Job is done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，主协程被阻塞并等待由 <code>job.join()</code> 返回。只有在 <code>job</code> 协程完成之后， “Job is done!” 才会被打印出来。</p>
<h3 id="传播取消操作"><a href="#传播取消操作" class="headerlink" title="传播取消操作"></a>传播取消操作</h3><p>一般情况下，协程的取消操作会通过协程的层次结构来进行传播：如果取消父协程或者父协程抛出异常，那么子协程都会被取消；而如果子协程被取消，则不会影响同级协程和父协程，但如果子协程抛出异常则也会导致同级协程和父协程被取消 </p>
<p>使用SupervisorJob</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> supervisorJob = SupervisorJob()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main + supervisorJob)</span><br><span class="line"></span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用supervisorScope</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程和线程对比"><a href="#协程和线程对比" class="headerlink" title="协程和线程对比"></a>协程和线程对比</h3><p>系统的最小执行单元是线程，一个线程同一时间点也只能执行一个任务，使用协程也不可能改变这种情况。</p>
<p>只能说使用了协程后，线程的并发灵活度会提高：当线程需要等待某个 suspend 函数返回时，在等待的过程中此线程还可以用于执行其它协程任务，从而提高线程的灵活度，避免线程空转。</p>
<p>协程是程序本身实现的切换机制，不需要陷入系统内核，轻松高并发。</p>
<p>代码对比下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">thread &#123;</span><br><span class="line">        <span class="comment">// I/O 阻塞操作</span></span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">打印：   </span><br><span class="line">[Thread-<span class="number">0</span>] thread</span><br></pre></td></tr></table></figure>

<p>这种只会在阻塞操作操作结束后才会打印日志。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">al job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job + Dispatchers.IO)</span><br><span class="line">thread &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">        <span class="comment">// 防止JVM退出</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>)</span><br><span class="line">  </span><br><span class="line">打印：  </span><br><span class="line">  [Thread-<span class="number">0</span>] thread</span><br><span class="line">	[DefaultDispatcher-worker-<span class="number">1</span>] launch</span><br></pre></td></tr></table></figure>

<p>线程在利用空闲时间执行了后续操作。</p>
<h3 id="协程的四个基础概念"><a href="#协程的四个基础概念" class="headerlink" title="协程的四个基础概念"></a>协程的四个基础概念</h3><ol>
<li><p><strong>协程构建器（Coroutine Builders）</strong>：在 Kotlin 中，使用协程构建器如 <code>launch</code>、<code>async</code>等来启动一个新的协程。</p>
<ul>
<li><p><code>launch</code>: 它创建一个新的协程并同时启动。<code>launch</code> 返回一个 <code>Job</code>，你可以用它来取消协程。此协程不会返回结果。</p>
</li>
<li><p><code>async/start</code>: 创建一个新的协程并返回一个 <code>Deferred&lt;T&gt;</code> —— 一种轻量级的非阻塞性 future，它表示一个带有结果的 promise。可以使用它的 <code>.await()</code> 方法获取结果。</p>
</li>
<li><p><code>runBlocking</code>: 这是一个特殊的构建器，它创建了一个新的协程并阻塞当前线程直到其完成。</p>
</li>
</ul>
</li>
<li><p><strong>挂起函数（Suspend Functions）</strong>：<code>suspend</code>关键字标记的函数称为挂起函数。这种函数可以”挂起”，即在不阻塞当前线程的情况下，暂停其执行，并稍后在适当的时间点继续执行。挂起函数只能在协程或其他挂起函数中调用。</p>
<ul>
<li>这些函数可以在协程内部进行长期运行的操作（如网络请求或数据库查询），而不会阻塞线程。这就是它们的”挂起”能力。挂起函数通过 <code>suspend</code> 关键字来定义，并且只能在协程或其他挂起函数中调用。</li>
</ul>
</li>
<li><p><strong>调度器（Dispatchers）</strong>：<code>Dispatchers</code>确定协程运行在哪个线程或线程池上。例如，<code>Dispatchers.IO</code> 用于磁盘和网络 I&#x2F;O，<code>Dispatchers.Default</code> 用于计算密集型任务，<code>Dispatchers.Main</code> 用于更新 UI。</p>
<ul>
<li><p><code>Dispatchers.Main</code>：这个调度器被限定在主线程中执行，这对大部分UI框架来说非常必要。然而，不同平台有自己的主线程计划。例如，Android会有 <code>Dispatchers.Main</code>，用于更新UI，执行时会检查是否在主线程里，不是的话它会调度到主线程执行。</p>
</li>
<li><p><code>Dispatchers.IO</code>：设计用于磁盘和网络 I&#x2F;O，因此不应用于计算密集型工作。IO调度器基于ForkJoinPool，它使用一个利用主机CPU数量的线程数量，但网络和磁盘允许线程无限制地增长和缩小。此调度模式的设计是为了允许大量的线程可以等待I&#x2F;O操作（如读写磁盘，网络数据读写）完成而无需消耗大量内存。</p>
</li>
<li><p><code>Dispatchers.Default</code>：用于计算密集型任务，这个调度器用于可能阻塞但CPU密集型工作，如算法和复杂计算。默认调度器内部使用了固定大小的线程池，大小为Kotlin runtime可以计算的CPU数量，默认大小为CPU核心数量减1，但至少为1。</p>
</li>
<li><p><code>Dispatchers.Unconfined</code>：一个特殊的调度器，它在调用者线程中立即执行调度的协程。但只有当挂起函数被调用，或者显式使用不同的调度器，那么协程的执行将会挂起并重新调度它的执行线程。</p>
<p>不添加调度器的话默认使用父协程的调度器。</p>
</li>
</ul>
</li>
<li><p><strong>作用域（Scopes）</strong>：协程的执行属于某种特定的作用域。作用域控制了相关协程的生命周期。例如，在 Android 中你可能会使用 <code>viewModelScope</code>，这样当 ViewModel 销毁时，所有的协程也将被取消。</p>
<ul>
<li><p><code>GlobalScope</code>：它绑定到整个应用程序的生命周期。你一旦启动了全局作用域的协程，它只有在应用程序完全停止运行后才会被销毁。</p>
<p>它默认的调度器是Dispatchers.Default</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">      log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CoroutineScope</code>：本身并非作用域，但却经常拿来创建作用域。它需要一个 <code>Job</code>（或者可以供其他方式提供一个 <code>CoroutineContext</code>）作为参数。<code>CoroutineScope</code> 不提供默认的 <code>Job</code>，所以如果你使用 <code>CoroutineScope(EmptyCoroutineContext)</code> 创建作用域，那么它所启动的协程就一定会使用 <code>GlobalScope</code>。所以，最佳实践是，总是用 <code>CoroutineScope(Job())</code> 来创建作用域。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CoroutineScope(Job()).launch &#123;</span><br><span class="line">        log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MainScope</code></p>
<p>默认运行在主线程的作用域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">throw</span>  NullPointerException(<span class="string">&quot;空指针&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">//网络请求...</span></span><br><span class="line">            <span class="string">&quot;请求结果&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">//网络请求3...</span></span><br><span class="line">        &#125;</span><br><span class="line">        btn.text = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>viewModelScope</code>：Android KTX库提供了一个创建在 <code>ViewModel</code> 生命周期内工作的协程的作用域。当 <code>ViewModel</code> 清理时，所有作用域内的协程都会自动取消。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>lifecycleScope</code>：这个也是由Android KTX库提供的，它提供了一个绑定到 <code>Android Lifecycle</code> 生命周期的作用域（如 <code>Activity</code> 或 <code>Fragment</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.IO</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Default</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Unconfined</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印：</span><br><span class="line">[main] <span class="number">4</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">2</span>] <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] <span class="number">3</span></span><br><span class="line">[main] <span class="number">1</span></span><br><span class="line">[main] <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CoroutineStart协程启动模式"><a href="#CoroutineStart协程启动模式" class="headerlink" title="CoroutineStart协程启动模式"></a><code>CoroutineStart</code>协程启动模式</h3><ol>
<li><code>DEFAULT</code>    默认启动模式，我们可以称之为饿汉启动模式，因为协程创建后立即开始调度，虽然是立即调度，单不是立即执行，有可能在执行前被取消。</li>
<li><code>LAZY</code>    懒汉启动模式，启动后并不会有任何调度行为，直到我们需要它执行的时候才会产生调度。也就是说只有我们主动的调用<code>Job</code>的<code>start</code>、<code>join</code>或者<code>await</code>等函数时才会开始调度。</li>
<li><code>ATOMIC</code>  一样也是在协程创建后立即开始调度，但是它和<code>DEFAULT</code>模式有一点不一样，通过<code>ATOMIC</code>模式启动的协程执行到第一个挂起点之前是不响应<code>cancel </code>取消操作的，<code>ATOMIC</code>一定要涉及到协程挂起后<code>cancel </code>取消操作的时候才有意义。</li>
<li><code>UNDISPATCHED</code> 协程在这种模式下会直接开始在当前线程下执行，直到运行到第一个挂起点。这听起来有点像 <code>ATOMIC</code>，不同之处在于<code>UNDISPATCHED</code>是不经过任何调度器就开始执行的。当然遇到挂起点之后的执行，将取决于挂起点本身的逻辑和协程上下文中的调度器。</li>
</ol>
<h3 id="协程生命周期"><a href="#协程生命周期" class="headerlink" title="协程生命周期"></a>协程生命周期</h3><ol>
<li>新建：此时协程已经创建，但尚未开始运行。例如，当使用 <code>CoroutineStart.LAZY</code> 选项调用 <code>launch</code> 或 <code>async</code> 时，创建的协程仅在显式调用其 <code>Job</code> 的 <code>start</code> 或 <code>join</code> 方法时才开始执行。</li>
<li>活动：此阶段的协程正在执行其任务。通常，协程会在 <code>launch</code> 或 <code>async</code> 调用后立即进入此状态 (除非你指定了 <code>CoroutineStart.LAZY</code> 选项)。</li>
<li>完成：协程成功完成其任务并正常结束，或者因异常被终止。对于异常的情况，如果协程是由 <code>launch</code> 创建的，则需要在协程体内部进行异常处理。而对于 <code>async</code> 创建的协程，异常会被延期处理，直至 <code>await()</code> 的调用。</li>
<li>取消：通过调用协程的 <code>Job</code> 的 <code>cancel</code> 方法，可以取消协程。这将导致协程中断执行。当协程被取消时，所有挂起函数将会抛出 <code>CancellationException</code>。协程可以通过定期检查其状态 (使用 <code>isActive</code> 属性或 <code>yield</code> 函数)，或通过在挂起函数处对 <code>CancellationException</code> 进行响应来响应取消操作。</li>
</ol>
<h3 id="协程的阻塞和非阻塞"><a href="#协程的阻塞和非阻塞" class="headerlink" title="协程的阻塞和非阻塞"></a>协程的阻塞和非阻塞</h3><p>看下下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;launch start&quot;</span>)</span><br><span class="line">            launch(Dispatchers.IO) &#123;</span><br><span class="line">                log(<span class="string">&quot;Job start&quot;</span>)</span><br><span class="line">                testSuspends()</span><br><span class="line">                log(<span class="string">&quot;Job end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="string">&quot;launch end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">[main] start</span><br><span class="line">[main] launch start</span><br><span class="line">[main] launch end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] Job start</span><br><span class="line">[main] end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] testSuspends</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] Job end</span><br></pre></td></tr></table></figure>

<p>协程的非阻塞是相对于线程的，当遇到协程挂起后会越过他执行后面的任务，等挂起恢复后再执行回复原来的执行。</p>
<h3 id="解析源码"><a href="#解析源码" class="headerlink" title="解析源码"></a>解析源码</h3><p>下面的代码模拟在主线程中实现异步加载操作，然后在回到主线程处理数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[main] runBlocking</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] testSuspends</span><br><span class="line">[main] result: <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>分析代码：</p>
<p>代码可以分为两大部分，第一部分是上面的<code>runBlocking </code>协程块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这部分代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> currentThread = Thread.currentThread() <span class="comment">// Thread[main,5,main]</span></span><br><span class="line">  	<span class="comment">// 在给定的协程上下文中获取 ContinuationInterceptor，它是用于控制协程的调度的拦截器</span></span><br><span class="line">    <span class="keyword">val</span> contextInterceptor = context[ContinuationInterceptor] <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">val</span> eventLoop: EventLoop?</span><br><span class="line">    <span class="keyword">val</span> newContext: CoroutineContext</span><br><span class="line">    <span class="keyword">if</span> (contextInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果没有指定调度器，那么创建或者使用私有的事件循环。</span></span><br><span class="line">        eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">      	<span class="comment">// 这里的context是EmptyCoroutineContext eventLoop是BlockingEventLoop</span></span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span></span><br><span class="line">        <span class="comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span></span><br><span class="line">        eventLoop = (contextInterceptor <span class="keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;</span><br><span class="line">            ?: ThreadLocalEventLoop.currentOrNull()</span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context)</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 创建一个 BlockingCoroutine 实例，它是一个运行在指定线程和事件循环中的协程。</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">    <span class="comment">// 开始执行协程，CoroutineStart.DEFAULT 是启动方式，表示立即执行协程体 block</span></span><br><span class="line">    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br><span class="line">  	<span class="comment">// 等待协程结束并返回结果。线程会在这里阻塞，直到协程执行完毕。</span></span><br><span class="line">    <span class="keyword">return</span> coroutine.joinBlocking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>走到<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>开始执行开启这个协程，这里传入了三个参数，首先是<code>CoroutineStart.DEFAULT</code>表示直接开启协程，<code>coroutine</code>是上面创建的BlockingCoroutine对象它是一个运行在指定线程和事件循环中的协程。<code>EventLoop</code> 的功能主要是管理和调度协程在当前线程中的执行。它维护了一个队列，用来存储在当前线程中需要执行的协程。<code>block</code>就是协程体也就是打括号内的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AbstractCoroutine:</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// receiver和this都是传入的coroutine也就是BlockingCoroutine对象。</span></span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里将receiver, this也就是传入的coroutine和block 又传入了CoroutineStart中，其中这个this代表coroutine。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>, receiver: <span class="type">R</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 走到了这里 </span></span><br><span class="line">            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">            ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">            LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>显示传入的是CoroutineStart.DEFAULT，显而易见 根据规则走到了<code>block.startCoroutineCancellable(receiver, completion)</code>这个分支。</p>
<p><strong>这里再回顾一下block就是协程体runBlocking大括号内的东西，它的类型是<code>suspend CoroutineScope.() -&gt; T</code>，receiver是BlockingCoroutine，completion也是，都是传入的那个BlockingCoroutine实例。</strong></p>
<p><strong>receiver和completion都是传入的coroutine也就是BlockingCoroutine对象。</strong></p>
<p>继续往下走</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion)   <span class="comment">// 重新创建续体对象（SuspendLambda子类对象）</span></span><br><span class="line">      .intercepted() <span class="comment">// 从协程上下文中获取调度器拦截原续体，将其包装为DispatchedContinuation类型</span></span><br><span class="line">      .resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下里面的内容</p>
<p><code>runSafely</code>单纯的只是给包裹了一层try catch 出现异常的话就<code>completion.resumeWith(Result.failure(e))</code>，</p>
<p><code>createCoroutineUnintercepted</code>的话可以看一下代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  			<span class="comment">// 如果不是，说明是一个普通的挂起函数，不包含协程的实现细节。</span></span><br><span class="line">        <span class="comment">// 那么要手动创建一个协程来包装这个函数。</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">          	<span class="comment">// 将这个挂起函数视为一个接受Continuation参数并返回Any?的函数，</span></span><br><span class="line">            <span class="comment">// Any?表示可能返回null或任何类型结果。</span></span><br><span class="line">            <span class="comment">// 然后使用已经得到的`probeCompletion`作为参数调用它。</span></span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进行了一个判断<code>this is BaseContinuationImpl</code>，这里有个知识点就是这里this是上面的block 它的类型是<code>suspend CoroutineScope.() -&gt; T</code>但是经过Kotlin编译器编译之后它就会成为SuspendLambda类的对象，这是编译器自己完成的。</p>
<p>而SuspendLambda是继承自ContinuationImpl的，所以这里会走到<code>create(probeCompletion)</code>。</p>
<p><code>create</code>的实现可以看源代码的反编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      。。。</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">      <span class="type">Function2</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object var2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;), <span class="number">1</span>, (Object)<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的create函数的内容总结就是传入了一个completion然后生成一个completion，这个传入的completion是就是在runBlocking方法中创建的BlockingCoroutine对象。</p>
<p><code>&lt;anonymous constructor&gt;</code> 是一个匿名构造函数，接受 <code>completion</code> 作为参数，它返回的 <code>Continuation</code> 对象封装了一个协程。这个协程对象就是自身实例。</p>
<p> 目前来看<code>createCoroutineUnintercepted(receiver, completion)</code>这段代码会生成一个SuspendLambda对象，然后调用<code>intercepted()</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"> <span class="comment">// 从上下文中获取拦截器，实现续体对象包装</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br></pre></td></tr></table></figure>

<p><strong>从当前续体对象(SuspendLambda的子类对象)的上下文中获取拦截器(调度器对象)拦截当前续体对象，将其包装为<code>DispatchedContinuation</code>类型的续体</strong>。这里的<code>this</code>是<code>runBlocking</code>的构造方法中<code>eventLoop = ThreadLocalEventLoop.eventLoop</code>这行代码创建了一个<code>BlockingEventLoop</code>对象作为调度器，<code>context[ContinuationInterceptor]</code>取出了这个对象然后构造返回了<code>DispatchedContinuation</code>对象。<code>DispatchedContinuation</code>构造中的this传入的是前面创建的<code>BlockingEventLoop</code>对象，<code>continuation</code>是创建<code>SuspendLambda</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br></pre></td></tr></table></figure>

<p>到现在为止前半部分的代码执行的结果</p>
<p><code>DispatchedContinuation[BlockingEventLoop@4f49f6af, Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)@461ad730]</code></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231225114546894.png" alt="image-20231225114546894"></p>
<p>创建出<code>DispatchedContinuation</code>对象后执行它的<code>resumeCancellableWith</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DispatchedContinuation：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果续体类型是DispatchedContinuation，调用resumeCancellableWith()启动协程</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">  			<span class="comment">// 判断是否需要调度 这里默认是true</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 切换线程后开始执行协程代码</span></span><br><span class="line">          	<span class="comment">// this 就是SuspendLambda包装的DispatchedContinuation</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的dispatcher是前面创建的<code>BlockingEventLoop</code>对象,<code>dispatcher.isDispatchNeeded(context)</code>这里默认会返回true，后面就会走到<code>BlockingEventLoop</code>的</p>
<p><code>dispatch</code>方法，其父类EventLoopImplBase中有具体的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop:</span><br><span class="line"></span><br><span class="line"><span class="comment">// `dispatch` 函数用于将给定的任务（block）调度到适当的执行上下文中。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> = enqueue(block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enqueue` 函数将任务加入队列。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(task: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enqueueImpl(task)) &#123; <span class="comment">// 如果任务成功入队</span></span><br><span class="line">        unpark() <span class="comment">// 解除阻塞，准备执行任务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DefaultExecutor.enqueue(task) <span class="comment">// 如果任务未成功入队，使用默认执行器加入任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueueImpl</span><span class="params">(task: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    _queue.loop &#123; queue -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isCompleted) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果当前已完成，不再接受新任务</span></span><br><span class="line">        <span class="keyword">when</span> (queue) &#123;</span><br><span class="line">            <span class="literal">null</span> -&gt; <span class="keyword">if</span> (_queue.compareAndSet(<span class="literal">null</span>, task)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果队列为空，尝试将任务作为第一个元素入队</span></span><br><span class="line">            <span class="keyword">is</span> Queue&lt;*&gt; -&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果队列非空，尝试在队列尾部添加任务</span></span><br><span class="line">                <span class="keyword">when</span> ((queue <span class="keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;</span><br><span class="line">                    Queue.ADD_SUCCESS -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 添加成功</span></span><br><span class="line">                    Queue.ADD_CLOSED -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭，无法添加</span></span><br><span class="line">                    Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next()) <span class="comment">// 队列被冻结，尝试更新队列状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">when</span> &#123;</span><br><span class="line">                queue === CLOSED_EMPTY -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭且为空，无法添加</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 如果队列是单个任务，转换为完整队列并添加任务</span></span><br><span class="line">                    <span class="keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="literal">true</span>)</span><br><span class="line">                    newQueue.addLast(queue <span class="keyword">as</span> Runnable)</span><br><span class="line">                    newQueue.addLast(task)</span><br><span class="line">                    <span class="keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 更新队列并添加任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先将任务入队列，上面的runBlocking函数最后返回的是<code>coroutine.joinBlocking()</code>，分析下这个函数干了啥。</p>
<p>joinBlocking是coroutine中的函数，看一下它的创建。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">    newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">		coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br></pre></td></tr></table></figure>

<p>看joinBlocking的具体实现</p>
<p>eventLoop就是<code>ThreadLocalEventLoop.eventLoop</code>创建的BlockingEventLoop对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">BlockingCoroutine：</span><br><span class="line"><span class="comment">// `joinBlocking` 函数用于在阻塞模式下等待协程完成，并返回协程的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinBlocking</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    registerTimeLoopThread() <span class="comment">// 注册当前线程到时间循环。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop?.incrementUseCount() <span class="comment">// 增加事件循环的使用计数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125; <span class="comment">// 如果线程被中断，抛出中断异常。</span></span><br><span class="line">                <span class="keyword">val</span> parkNanos = eventLoop?.processNextEvent() ?: <span class="built_in">Long</span>.MAX_VALUE <span class="comment">// 处理下一个事件，或等待最大时间。</span></span><br><span class="line">                <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span> <span class="comment">// 如果协程已完成，则退出循环。</span></span><br><span class="line">                parkNanos(<span class="keyword">this</span>, parkNanos) <span class="comment">// 阻塞当前线程指定的纳秒数。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 无论如何都会执行的清理代码。</span></span><br><span class="line">            eventLoop?.decrementUseCount() <span class="comment">// 减少事件循环的使用计数。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 另一个清理代码块。</span></span><br><span class="line">        unregisterTimeLoopThread() <span class="comment">// 取消注册当前线程到时间循环。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取协程的结果。</span></span><br><span class="line">    <span class="keyword">val</span> state = <span class="keyword">this</span>.state.unboxState() <span class="comment">// 获取协程的状态。</span></span><br><span class="line">    (state <span class="keyword">as</span>? CompletedExceptionally)?.let &#123; <span class="keyword">throw</span> it.cause &#125; <span class="comment">// 如果是异常完成，则抛出异常。</span></span><br><span class="line">    <span class="keyword">return</span> state <span class="keyword">as</span> T <span class="comment">// 返回协程的结果。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>val parkNanos = eventLoop?.processNextEvent() ?: Long.MAX_VALUE // 处理下一个事件，或等待最大时间。</code> 这里是不是有点熟悉，想不想handler的消息轮训。看下<code>processNextEvent</code>的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop：</span><br><span class="line"><span class="comment">// `processNextEvent` 函数预定于处理下一个协程事件，并返回下一个事件发生之前的时间（以纳秒为单位）。</span></span><br><span class="line"><span class="comment">// 如果没有事件需要处理，它返回 Long.MAX_VALUE，这是一个常用的约定，表示无限的延迟时间。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">processNextEvent</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试处理一个非受限的事件，如果成功处理，返回 0。</span></span><br><span class="line">    <span class="comment">// 如果没有事件处理，会返回 Long.MAX_VALUE，这意味着没有事件需要立即处理。</span></span><br><span class="line">    <span class="keyword">if</span> (!processUnconfinedEvent()) <span class="keyword">return</span> <span class="built_in">Long</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `processUnconfinedEvent` 处理一个非受限的协程的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processUnconfinedEvent</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 获取非受限的任务队列。</span></span><br><span class="line">    <span class="keyword">val</span> queue = unconfinedQueue ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 从队列中移除一个任务，如果队列为空则返回 false。</span></span><br><span class="line">    <span class="keyword">val</span> task = queue.removeFirstOrNull() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 执行取出的任务。</span></span><br><span class="line">    task.run()</span><br><span class="line">    <span class="comment">// 如果成功执行了任务，返回 true。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显<code>task.run()</code>开启了任务，这里先看看任务是怎么入队列的<code>resumeCancellableWith</code> → <code>dispatcher.dispatch(context, this)</code>→<code>enqueue(task: Runnable)</code>→<code>enqueueImpl</code>。这个流程走完将任务入队列，具体的任务task是个<code>DispatchedContinuation</code>对象就是<code>createCoroutineUnintercepted(receiver, completion).intercepted()</code>这步生成的。它同时实现了Continuation和Runnable接口。</p>
<p>run方法实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 这是`Runnable`的一个重写方法，当任务运行时会被执行。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="comment">// 确保在任务被调度之前已经初始化了`resumeMode`。</span></span><br><span class="line">      assert &#123; resumeMode != MODE_UNINITIALIZED &#125;</span><br><span class="line">      <span class="comment">// 获取任务的上下文。</span></span><br><span class="line">      <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">      <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 将代理转换为`DispatchedContinuation`，它包含需要继续的协程。</span></span><br><span class="line">          <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">          <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">          <span class="comment">// 临时设置当前持续上下文为协程的上下文。</span></span><br><span class="line">          withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">              <span class="keyword">val</span> context = continuation.context</span><br><span class="line">              <span class="comment">// 尝试从代理获取状态，它可能是一个结果或异常。</span></span><br><span class="line">              <span class="keyword">val</span> state = takeState() </span><br><span class="line">              <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line">              <span class="comment">// 检查是否应该可以取消任务，以及它是否仍然活跃。</span></span><br><span class="line">              <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                  <span class="comment">// 如果任务被取消，则使用取消异常来继续协程。</span></span><br><span class="line">                  <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                  cancelCompletedResult(state, cause)</span><br><span class="line">                  continuation.resumeWithStackTrace(cause)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 否则，正常地继续协程，用异常或成功的结果。</span></span><br><span class="line">                  <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                      continuation.resumeWithException(exception)</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 这里走进了resumewith</span></span><br><span class="line">                      continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">          <span class="comment">// 捕获任务执行期间发生的任何致命异常。</span></span><br><span class="line">          fatalException = e</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 完成任务后，进行必要的清理，处理任何致命异常。</span></span><br><span class="line">          <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">          handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">		<span class="comment">// 调用resumeWith</span></span><br><span class="line">    resumeWith(Result.success(value)) <span class="comment">// Success(kotlin.Unit)</span></span><br></pre></td></tr></table></figure>

<p><code>continuation.resume(getSuccessfulResult(state))</code>这里的continuation是<code>createCoroutineUnintercepted(receiver, completion)</code>这里生成的SuspendLambda对象，具体为<code>Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</code>。</p>
<p>SuspendLambda是继承自BaseContinuationImpl的，所以这里resumeWith的实现在BaseContinuationImpl。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// current: Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">  	<span class="comment">// param: null</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">   	<span class="comment">// 进入死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">          	<span class="comment">// completion：BlockingCoroutine  这个是在runBlocking方法中创建的。</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! </span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">// 走到这里执行invokeSuspend方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() </span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123; </span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码执行到了<code>val outcome = invokeSuspend(param)</code>,这里的实现得看反编译的代码，仅看invokeSuspend方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      Object var10000;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            TestActivityKt.log(<span class="string">&quot;runBlocking&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 在这里又执行了testSuspends方法</span></span><br><span class="line">            var10000 = MainKt.testSuspends(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var3) &#123;</span><br><span class="line">               <span class="keyword">return</span> var3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            var10000 = $result;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> ((Number)var10000).intValue();</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面又走到了<code>MainKt.testSuspends(this);</code> ，这就像递归一样，走到了下一个方法中。再看下<code>testSuspends</code>的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">10000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会走到withContext中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>,  <span class="comment">// Dispatchers.IO</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>  <span class="comment">// kotlinx.coroutines.CoroutineScope.() -&gt; kotlin.Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span> &#123; uCont -&gt;  <span class="comment">// Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)</span></span><br><span class="line">        <span class="keyword">val</span> oldContext = uCont.context <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, BlockingEventLoop@7d322cad]</span></span><br><span class="line">        <span class="keyword">val</span> newContext = oldContext.newCoroutineContext(context)  <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO] 将BlockingEventLoop顶掉了</span></span><br><span class="line">        newContext.ensureActive()</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文相同，则直接执行代码块而不进行任何调度。                                   </span></span><br><span class="line">        <span class="keyword">if</span> (newContext === oldContext) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文使用的是相同的`ContinuationInterceptor`，则使用`UndispatchedCoroutine`执行代码块。                                                      </span></span><br><span class="line">        <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont)</span><br><span class="line">            withCoroutineContext(coroutine.context, <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 对于所有其他情况，创建一个`DispatchedCoroutine`，并且以可以取消的方式启动协程。</span></span><br><span class="line">				<span class="comment">// newContext： [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO]    </span></span><br><span class="line">				<span class="comment">// uCont： Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)                                                      </span></span><br><span class="line">        <span class="keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        <span class="comment">// 启动协程并设置代码块。</span></span><br><span class="line">				<span class="comment">// coroutine                                                       </span></span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        <span class="comment">// 获取协程的结果。</span></span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要是通过<code>suspendCoroutineUninterceptedOrReturn</code>获取了续体和它的context来构建DispatchedCoroutine。</p>
<p><code>createCoroutineUnintercepted(receiver, completion).intercepted()</code> 这段代码生成的对象为<code>DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</code>。 传入的Dispatchers为Dispatchers.IO。Dispatchers.IO返回的对象为<code>public val IO: CoroutineDispatcher = DefaultIoScheduler</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 这里的dispatcher为DefaultIoScheduler </span></span><br><span class="line">          	<span class="comment">// context：[DispatchedCoroutine&#123;Active&#125;@19976a65, Dispatchers.IO]</span></span><br><span class="line">          	<span class="comment">// this：DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看下DefaultIoScheduler::dispatch</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#DefaultIoScheduler</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  	<span class="comment">// default：LimitedDispatcher</span></span><br><span class="line">    default.dispatch(context, block)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> default = UnlimitedIoScheduler.limitedParallelism(</span><br><span class="line">        systemProp(</span><br><span class="line">            IO_PARALLELISM_PROPERTY_NAME,</span><br><span class="line">            <span class="number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">最终挖到</span><br><span class="line">#LimitedDispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// 这里的dispatcher是UnlimitedIoScheduler</span></span><br><span class="line">        dispatchInternal(block) &#123; worker -&gt;</span><br><span class="line">            dispatcher.dispatch(<span class="keyword">this</span>, worker)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">所以最终调用的是UnlimitedIoScheduler下的dispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        DefaultScheduler.dispatchWithContext(block, BlockingContext, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">DefaultScheduler继承自SchedulerCoroutineDispatcher</span><br><span class="line">#SchedulerCoroutineDispatcher</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchWithContext</span><span class="params">(block: <span class="type">Runnable</span>, context: <span class="type">TaskContext</span>, tailDispatch: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        coroutineScheduler.dispatch(block, context, tailDispatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里到了协程线程池的知识点了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//block 为DispatchedContinuation</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//构建Task对象,block 本身就是Task类型</span></span><br><span class="line">    <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">    <span class="comment">//当前线程是否是Worker类型，也就是说当前线程是否是线程池内的线程</span></span><br><span class="line">    <span class="keyword">val</span> currentWorker = currentWorker()<span class="comment">//①</span></span><br><span class="line">    <span class="comment">//如果是，则尝试提交任务到本地队列，否则返回任务本身</span></span><br><span class="line">    <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)<span class="comment">//②</span></span><br><span class="line">    <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有提交到本地队列，则提交到全局队列 </span></span><br><span class="line">        <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;<span class="comment">//③</span></span><br><span class="line">            <span class="comment">//添加队列失败则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要跳过唤醒线程，主要用在IO分发器</span></span><br><span class="line">    <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;<span class="comment">//④</span></span><br><span class="line">        <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//非阻塞任务，唤醒cpu 线程</span></span><br><span class="line">        signalCpuWork()<span class="comment">//⑤</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//阻塞任务，唤醒blocking 线程</span></span><br><span class="line">        signalBlockingWork(skipUnpark = skipUnpark)<span class="comment">//⑥</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下构建的线程池的参数</p>
<p>最先线程数非常大，核心线程数与cpu核数相关。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> CORE_POOL_SIZE = systemProp(</span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>,</span><br><span class="line">    AVAILABLE_PROCESSORS.coerceAtLeast(<span class="number">2</span>), <span class="comment">// 获取运行时java虚拟机的核心数 比2大的话CORE_POOL_SIZE就是这个值</span></span><br><span class="line">    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 可以自定义</span></span><br><span class="line">System.setProperty(<span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><a href="https://juejin.cn/post/7137905800504148004">https://juejin.cn/post/7137905800504148004</a></p>
<h3 id="大概流程图"><a href="#大概流程图" class="headerlink" title="大概流程图"></a>大概流程图</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9047de897d71447aa30e5b50b9e0a917%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="Kotlin协程工作流程"></p>
<p>在14，15 这两步一直循环到有可用的值就开始返回。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2024/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。</p>
<p>通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。</p>
<p>以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load(shop.goodsCount , r1) //指令1，将变量 shop.goodsCount 的值从内存读到寄存器 r1</span><br><span class="line">increment(r1) //指令2，将寄存器 r1 的值加1</span><br><span class="line">store(shop.goodsCount , r1) //指令3，将寄存器 r1 的内容写入变量 shop.goodsCount 所对应的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程 A 在执行完指令1，开始执行或者正在执行指令2时，线程 B 可能已经执行完了指令3，这使得线程 A 当前持有的共享变量 shop.goodsCount 是旧值，当线程 A 执行完指令3时，这就使得线程 B 对共享变量的更新被覆盖了，即造成了更新丢失。</p>
<blockquote>
<p>竞态可以看做是由于访问（读取、更新）同一组共享变量的多个线程所执行的操作被相互交错而导致的。而上述代码中遇到的<strong>更新丢失</strong>和<strong>读到脏数据</strong>问题就是由于竞态的存在而导致的</p>
<p>需要注意的是，竞态的产生前提是涉及到了多个线程和共享变量。如果系统仅包含单个线程，或者不涉及共享变量，那么就不会产生竞态。对于局部变量（包括形式参数和方法体内定义的变量），由于不同的线程访问的是各自的那一份局部变量，<strong>因此局部变量的使用不会导致竞态</strong><br>链接：<a href="https://juejin.cn/post/6899452217528025095">https://juejin.cn/post/6899452217528025095</a></p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程安全问题概括来说表现为三个方面：<strong>原子性、可见性、有序性</strong></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>对于涉及共享变量访问的操作，若该操作从其执行线程以外的其它任意线程来看是不可分割的，那么该操作就是<strong>原子操作</strong>，相应的就称该操作具有<strong>原子性</strong>。</p>
<p>简单来说就是如果当前线程的一块逻辑，相对于其他线程来说要么是已经执行完了要么是还未执行，不会出现执行到一半的情况。</p>
<p>Java 中有两种方式来提供原子性：</p>
<ul>
<li>第一种是使用锁（Lock）。锁具有排他性，它能够保障共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，从而消除了竞态</li>
<li>第二种是利用处理器提供的 CAS 指令。CAS 指令实现原子性的方式与锁在本质上是相同的，差别在于锁通常是在软件这一层面实现的，而 CAS 是直接在硬件（处理器和内存）这一层次实现的，可以被看做“硬件锁”</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的其它线程可能无法立即读取到这个更新的结果，甚至永远也无法读取到，这体现了多线程安全性问题中的一个：可见性。<strong>可见性是指一个线程对共享变量的更新结果对于其它读取相应共享变量的线程而言是否可见的问题。</strong>多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据，而这往往会导致我们的程序出现意想不到的问题。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640.jpg" alt="640"></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排一般分为以下三种：</p>
<ul>
<li><p><strong>编译器优化重排</strong></p>
<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下会出现执行<code>instance.doSomething();</code>时instance还未完成初始化的情况。</p>
<p>使用关键字new创建一个对象，大致分为一下过程：</p>
<ul>
<li>在栈空间创建引用地址</li>
<li>以类文件为模版在堆空间对象分配内存</li>
<li>成员变量初始化</li>
<li>使用构造函数初始化</li>
<li>将引用值赋值给左侧存储变量</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>并发的实现和是否拥有多个处理器无关，即使只有单个处理器也能够通过处理器<strong>时间片分配</strong>技术来实现并发。操作系统通过给每个线程分配一小段占有处理器使用权的时间来供其运行，然后在每个线程的运行时间结束后又快速切换到下一个线程来运行，多个线程以这种断断续续的方式来实现并发并完成各自的任务。</p>
<p>操作系统会分出一个个时间片，每个线程每次运行会分配到若干个时间片，时间片决定了一个线程可以连续占用处理器运行的时间长度，一般是只有几十毫秒，单处理器上的多线程就是通过这种<strong>时间片分配</strong>的方式来实现并发。当一个进程中的一个线程由于其时间片用完或者由于其自身的原因被迫或者主动暂停其运行时，另外一个线程（当前进程中的线程或者其它进程中的线程）就可以被线程调度器选中来占用处理器并开始运行。这种一个线程被剥夺处理器的使用权并暂停运行，另外一个线程被赋予处理器的使用权并开始运行的过程就称为线程上下文切换。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度是指操作系统为线程分配处理器使用权的过程。主要的调度方式有两种：</p>
<ul>
<li>协同式线程调度。在这种策略下，线程的执行时机由线程本身来决定，线程通过主动通知系统切换到另一个线程的方式来让出处理器的使用权。该策略的优点是实现简单，可以通过精准控制线程的执行顺序来避免线程安全性问题。缺点是可能会由于单个线程的代码缺陷问题导致无法切换到下一个线程，最终导致进程被阻塞</li>
<li>抢占式线程调度。这也是 Java 平台使用的线程调度策略。在这种策略下，由操作系统来决定当前处理器时间片交由哪个线程来使用，线程无法决定具体的运行时机和运行顺序。虽然我们可以通过 <code>Thread.yieid()</code> 方法来让出时间片，但是无法主动抢夺时间片，且虽然 Thread 类也提供了设置线程优先级的方法，但线程的具体执行顺序还是取决于其运行系统。该策略的优点是不会由于一个线程的问题导致整个进程被阻塞，且提高了并发性。缺点是实现较为复杂，且会带来多线程安全性问题。</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<p>在没有锁的情况下，当一个Thread创建后，start()调用后就会变成Runnable状态，然后当该线程抢到时间片后，就会Running状态（即开始运行），当执行完毕后便会结束Terminated，当然在运行中如果调用wait()后便会转为等待状态Waiting，然后一直到其他线程调用notify()或者notifyAll()才会被唤醒会，进入Runnable状态，然后抢时间片，重新Running。</p>
<p>如果涉及到锁的时候，当该线程抢到锁后，其他线程便会处于Blocked状态，等到该线程释放锁之后，那些阻塞的线程拿到锁后进入Runnable状态，然后Running：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>线程创建时的内存分配默认大小是1M，也就是1024k</p>
<h2 id="synchronize使用"><a href="#synchronize使用" class="headerlink" title="synchronize使用"></a>synchronize使用</h2><p>先举个线程不安全的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRunnable</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = LockRunnable()</span><br><span class="line">    <span class="keyword">val</span> thread1 = Thread(runnable)</span><br><span class="line">    <span class="keyword">val</span> thread2 = Thread(runnable)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread2.join()</span><br><span class="line">        thread1.join()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    println(LockRunnable.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待两个线程执行完成之后a的值理论上应该是2000，但是实际上值是不确定的。</p>
<p>使用synchronized来保证线程安全</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">           synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">               a++</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<h2 id="synchronize原理"><a href="#synchronize原理" class="headerlink" title="synchronize原理"></a>synchronize原理</h2><p>先看一个知识点，Java对象是在堆区里，它是由对象头、实例数据和对齐填充数据组成的，而一个对象的锁状态信息就是记录在对象头里的。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/2931590af3214062b83e36980a36a0b2.jpeg" alt="在这里插入图片描述"></p>
<p><code>mark word</code>用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32bit，64位系统上长度为64bit。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<p>根据对象锁状态的不同，系统位数所记载的信息也不同。比如无锁状态下前25位就代表hashcode。</p>
<p>来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="comment">//需要同步的代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同步块部分的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: 3: monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit						  // monitorexit指令退出同步块 getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit	</span><br></pre></td></tr></table></figure>

<p>进入到synchronized同步块中，需要通过monitorenter指令获取到对象的monitor（也通常称之为对象锁）后才能往下进行执行，在处理完对应的方法内部逻辑之后通过monitorexit指令来释放所持有的monitor，以供其他并发实体进行获取。</p>
<p>再具体的原理可以看重量级锁的释放锁部分</p>
<h2 id="synchronize锁状态"><a href="#synchronize锁状态" class="headerlink" title="synchronize锁状态"></a>synchronize锁状态</h2><table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody></table>
<p>一个对象其实有四种锁状态,级别由低到高:</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<h4 id="1、无锁"><a href="#1、无锁" class="headerlink" title="1、无锁"></a>1、无锁</h4><p>释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。</p>
<h4 id="2、偏向锁（JDK15被废弃）"><a href="#2、偏向锁（JDK15被废弃）" class="headerlink" title="2、偏向锁（JDK15被废弃）"></a>2、偏向锁（JDK15被废弃）</h4><p>偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在<strong>资源无竞争</strong>情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</p>
<p>当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。</p>
<p>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
<h4 id="3、轻量级锁"><a href="#3、轻量级锁" class="headerlink" title="3、轻量级锁"></a>3、轻量级锁</h4><p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>发现是无锁状态，线程会<strong>把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）</strong> ，然后通过CAS尝试将锁的Mark Word修改为一根指针，指向自己的Displaced Mark Word（Displaced Mark Word与原mark word的内容一模一样，保存了HashCode，GC年龄等信息）</p>
</li>
<li><p>发现处于轻量级锁状态</p>
</li>
</ol>
<ul>
<li>如果轻量级锁的mark word指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功（如果是重入，会将markword改为null，空指针，即0）</li>
<li>如果轻量级锁的markword不是指向自己，锁膨胀，升级为「重量级锁」</li>
</ul>
<p><strong>CAS失败直接膨胀</strong></p>
<h4 id="4、-重量级锁"><a href="#4、-重量级锁" class="headerlink" title="4、 重量级锁"></a>4、 重量级锁</h4><p>由原来线程主动去抢锁对象变成由系统内核来决定最后锁对象分配给谁</p>
<p>从轻量级锁开始膨胀：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>monitor对象的结构：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<ul>
<li>Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构</li>
<li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</li>
<li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li>
<li>Owner：获得锁的线程称为Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
<p>ContentionList，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a><strong>获取锁</strong></h5><blockquote>
<p>对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己</p>
</blockquote>
<p>当一个线程尝试获得重量级锁时</p>
<ul>
<li>首先尝试「自旋」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』</li>
<li>进入cxq后，陷入「死循环」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「死循环」</li>
</ul>
<h5 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h5><p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
<p><strong>自旋逻辑</strong>：trySpin</p>
<p>首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：</p>
<p>开始自旋5000次（假设是第一次开始自旋，上限就为5000）</p>
<ul>
<li>成功，下次+100，下次可以最多自旋5100次</li>
<li>失败，下次- 200，下次可以最多自旋4800次，不会少于1000次</li>
</ul>
<p><strong>死循环</strong></p>
<p>死循环主要是在「阻塞」和「自旋」之间切换</p>
<ul>
<li>park阻塞，注意不会移动到WaitSet中</li>
<li>unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞</li>
</ul>
<p>只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>monitor有个计数器recursions，起初为0，Monitorenter + 1，Monitorexit - 1，减为0会释放锁</p>
<ol>
<li>通过CAS的方式将Monitor结构的Owner修改为nullptr</li>
<li>根据QMode参数的不同，执行不同的逻辑</li>
</ol>
<p>因为QMode默认值为0，我们来看一下<strong>默认的逻辑</strong>：</p>
<ul>
<li>如果EntryList和cxq均为空：什么也不做</li>
<li>如果EntryList非空：就取EntryList首元素唤醒</li>
<li>如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；</li>
</ul>
<p>锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。</p>
<h2 id="wait-notify底层原理"><a href="#wait-notify底层原理" class="headerlink" title="wait&#x2F;notify底层原理"></a>wait&#x2F;notify底层原理</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><ol>
<li>将当前线程包装成ObjectWaiter对象，放入WaitSet中，并调用park挂起</li>
<li>执行「释放锁」的逻辑。</li>
</ol>
<blockquote>
<p>只有notify方法有可能将线程从WaitSet拯救出来，处于WaitSet的线程永远是阻塞状态，不可能参与锁竞争</p>
</blockquote>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>从WaitSet中取出第一个线程，根据Policy的不同，将这个线程放入EntryList或者cxq队列中的起始或末尾位置</p>
<p>默认Policy为2，即：</p>
<ul>
<li>EntryList队列为空，将线程放入EntryList</li>
<li>EntryList队列非空，将线程放入cxq队列的头部位置（栈顶）；</li>
</ul>
<p>强调一下：notify方法只是将线程从WaitSet移动到EntryList或者cxq，不是直接让它开始自旋CAS。</p>
<h2 id="synchronized内存特性"><a href="#synchronized内存特性" class="headerlink" title="synchronized内存特性"></a>synchronized内存特性</h2><p><strong>内存可见性</strong></p>
<ul>
<li><strong>获取锁（进入 <code>synchronized</code> 块）</strong>：当一个线程获取锁并进入 <code>synchronized</code> 块时，它会清空本地内存（如果有的话），然后从主内存中读取共享变量的最新值。</li>
<li><strong>释放锁（退出 <code>synchronized</code> 块）</strong>：当一个线程释放锁并退出 <code>synchronized</code> 块时，它会将在 <code>synchronized</code> 块中对共享变量的所有修改刷新（写回）到主内存中。</li>
</ul>
<p><strong>原子性</strong></p>
<ul>
<li><code>synchronized</code>通过<code>monitorenter</code>和<code>monitorexit</code> 指令来保证原子性</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量</li>
<li>E：旧值</li>
<li>N：新值</li>
</ul>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>可见性</strong>：</p>
<p>第一项是保证此变量对所有线程的可见性，这里的“性”是指<strong>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>禁止指令重排序优化</strong></p>
<p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的<br>执行顺序一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2可能会比步骤1先执行</p>
<p>JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。如下所示：</p>
<blockquote>
<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>
<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>
</blockquote>
<p>当编译器遇到<code>volatile</code>变量的写操作时，会在写操作之前插入一个StoreStore屏障，防止写操作和之前的写操作发生重排；并在写操作之后插入一个StoreLoad屏障，防止写操作和之后的读写操作发生重排。</p>
<p>同样，当编译器遇到<code>volatile</code>变量的读操作时，会在读操作之后插入一个LoadLoad屏障，防止读操作和之后的读操作发生重排。</p>
<p>内存屏障（Memory Barrier），也称为内存栅栏，是一种用于处理器指令的同步机制，可以防止指令重排序。内存屏障主要分为以下四种类型： ，   </p>
<ol>
<li><strong>LoadLoad屏障</strong>：这种屏障确保在其前面的读操作（Load）不会被重排序到其后面的读操作之后。</li>
<li><strong>StoreStore屏障</strong>：这种屏障确保在其前面的写操作（Store）不会被重排序到其后面的写操作之后。</li>
<li><strong>LoadStore屏障</strong>：这种屏障确保在其前面的读操作不会被重排序到其后面的写操作之后。</li>
<li><strong>StoreLoad屏障</strong>：这种屏障确保在其前面的写操作不会被重排序到其后面的读操作之后。</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>) <span class="comment">// true设置为公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientThread</span>(name: String) : Thread(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(currentThread().name + <span class="string">&quot;开始尝试获取锁&quot;</span>)</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;成功获取锁&quot;</span>)</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;完成释放锁&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t1 = ClientThread(<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t2 = ClientThread(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t3 = ClientThread(<span class="string">&quot;线程3&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：					</span><br><span class="line">线程<span class="number">2</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">1</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">3</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">2</span>成功获取锁</span><br><span class="line">线程<span class="number">3</span>成功获取锁</span><br><span class="line">线程<span class="number">2</span>完成释放锁</span><br><span class="line">线程<span class="number">3</span>完成释放锁</span><br><span class="line">线程<span class="number">1</span>成功获取锁</span><br><span class="line">线程<span class="number">1</span>完成释放锁</span><br></pre></td></tr></table></figure>

<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ol>
<li><strong>公平锁</strong>：公平锁是指多个线程按照申请锁的顺序来获取锁。也就是说，锁会被授予等待时间最长的线程。这种方式可以防止资源饥饿，但是在锁的释放和获取之间会产生较大的开销，因此公平锁的整体吞吐量会比非公平锁小。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>类的构造函数可以接受一个布尔值，用来表示这个锁是否是公平的。</li>
<li><strong>非公平锁</strong>：非公平锁是指多个线程获取锁的顺序并不固定，也就是说，有可能新请求的线程比已经在等待的线程更早获取到锁。这种方式可能会导致某些线程等待时间过长甚至无限期等待，也就是所谓的饥饿现象。但是非公平锁的优点是吞吐量大，因为线程获取锁的速度通常比公平锁快，上下文切换次数也少。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>默认就是非公平锁。</li>
</ol>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p>
<p><strong>核心原理：</strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，<strong>AQS中的队列是CLH变体的虚拟双向队列（FIFO）</strong>，AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1ebefeb23a184f2a9b515bf01eb430da%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p>
<p>AQS 中的 CLH 变体等待队列拥有以下特性</p>
<ol>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋（进入一个循环中，不断检查锁是否已经被释放，而不是进入睡眠状态）获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ol>
<h3 id="ReentrantLock与AQS的关联"><a href="#ReentrantLock与AQS的关联" class="headerlink" title="ReentrantLock与AQS的关联"></a>ReentrantLock与AQS的关联</h3><p>追一下ReentrantLock加锁时的源码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>)</span><br><span class="line">lock.lock()</span><br></pre></td></tr></table></figure>

<p>lock()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个sync是FairSync对象或NonfairSync对象，是sync抽象类的实现类。然后看一下Sync的定义，AbstractQueuedSynchronizer就是AQS。下面都以NonfairSync非公平锁为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> <span class="comment">// 公平锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Syn</span> <span class="comment">// 非公平锁</span></span><br></pre></td></tr></table></figure>

<p>sync.lock()的实现看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Sync</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个initialTryLock方法就是用来尝试获取锁的，这个方法尝试获取一个可重入的独占锁，如果成功则返回true，如果失败则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">initialTryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用CAS操作尝试将锁的状态从0（未锁定）改变为1（已锁定）</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁已经被某个线程持有，检查锁的所有者是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">        <span class="comment">// 如果锁的所有者是当前线程，说明这是一个重入操作</span></span><br><span class="line">        <span class="comment">// 获取锁的当前状态并加1，表示锁被重入了一次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查锁的状态是否超过了int的最大值，如果超过，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 将锁的状态设置为新的值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁的所有者不是当前线程，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setState(c)就是设置之前说的那个表示同步状态的state值，如果获取锁成功将锁的所有者设置为当前线程，获取失败的话返回false开始执行 acquire(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AbstractQueuedSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            acquire(<span class="literal">null</span>, arg, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"># NonfairSync</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查锁的状态是否为0（未被锁定）</span></span><br><span class="line">    <span class="comment">// 如果锁的状态为0，使用CAS操作尝试将锁的状态从0改变为传入的acquires值</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁的状态不为0或者CAS操作失败，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会再次重试获取锁，如果获取失败的话就执行acquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">acquire</span><span class="params">(Node node, <span class="type">int</span> arg, <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> interruptible, <span class="type">boolean</span> timed, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些变量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">spins</span> <span class="operator">=</span> <span class="number">0</span>, postSpins = <span class="number">0</span>; <span class="comment">// 用于控制&quot;自旋&quot;的变量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, first = <span class="literal">false</span>; <span class="comment">// interrupted记录线程是否被中断，first记录node是否是队列的第一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// pred记录node的前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个无限循环，直到成功获取锁或者线程被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">                Thread.onSpinWait();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">                <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">                cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点是null，则根据是否共享锁创建相应类型的节点</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果CAS失败，回滚操作</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">            Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">            node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束，调用cancelAcquire方法取消获取锁，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个队列就是上面说的CLH变体的虚拟双向队列，acquire方法开启了一个死循环直到当前线程成功获取锁或者线程被中断才终止循环。</p>
<p>分析for内的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line"><span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(first = (head == pred))) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">    <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cleanQueue();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">        Thread.onSpinWait();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码首先检查当前节点是否是第一个节点，如果不是，并且当前节点有前驱节点，那么就检查前驱节点的状态。如果前驱节点的状态小于0，那么说明前驱节点已经被取消，此时需要调用cleanQueue()方法清理队列，然后继续下一轮循环。</p>
<p>如果前驱节点没有前驱，那么就调用<code>Thread.onSpinWait()</code>方法让出CPU，并继续下一轮循环。<code>Thread.onSpinWait()</code>是Java 9引入的一个新方法，它可以用来提示JVM当前线程正在进行自旋操作，这样JVM可以采取一些优化措施，如减少线程的调度优先级，以避免占用过多的CPU资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line"><span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> acquired;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (shared)</span><br><span class="line">            acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquired = tryAcquire(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">        cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是尝试获取锁。如果<code>node</code>是第一个节点或者没有前驱节点，那么就会尝试获取锁。</p>
<p>在这段代码中，如果锁是共享锁，那么就调用<code>tryAcquireShared(arg)</code>方法尝试获取锁，如果成功获取锁（返回值大于等于0），那么<code>acquired</code>就会被设置为<code>true</code>。如果锁是独占锁，那么就调用<code>tryAcquire(arg)</code>方法尝试获取锁，如果成功获取锁，那么<code>acquired</code>就会被设置为<code>true</code>。</p>
<p>如果在尝试获取锁的过程中发生异常，那么就调用<code>cancelAcquire(node, interrupted, false)</code>方法取消获取，并抛出异常。</p>
<p>这段代码是一个典型的锁获取过程，它使用了Java的并发编程技术来实现线程安全的锁获取。</p>
<p>获取锁之后会进行一个清理的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是在成功获取锁之后进行一系列的操作。如果成功获取了锁（<code>acquired</code>为<code>true</code>），并且当前节点是第一个节点（<code>first</code>为<code>true</code>），那么就会进行一些清理和设置操作。</p>
<p>在代码中，如果成功获取了锁，并且当前节点是第一个节点，那么就会将当前节点的<code>prev</code>属性设置为<code>null</code>，将<code>head</code>设置为当前节点，将前驱节点的<code>next</code>属性设置为<code>null</code>，并将当前节点的<code>waiter</code>属性设置为<code>null</code>。这些操作都是为了清理和设置节点的状态。</p>
<p>接下来，如果获取的是共享锁，那么就会调用<code>signalNextIfShared(node)</code>方法通知下一个等待的节点。如果在获取锁的过程中线程被中断，那么就会调用<code>current.interrupt()</code>方法来中断当前线程。</p>
<p>最后，如果成功获取了锁，那么就返回1，表示成功获取了锁。</p>
<p>这段代码是一个典型的并发编程的代码片段，它使用了Java的并发编程技术来实现线程安全的锁获取和释放。</p>
<p>根据原来的代码流程来看，第一次进来node会是null会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br></pre></td></tr></table></figure>

<p>这个shared默认是false，会给node赋值一个ExclusiveNode实例，然后开始下一个循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExclusiveNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123; &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">volatile</span> Node prev;       <span class="comment">// initially attached via casTail</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;       <span class="comment">// visibly nonnull when signallable</span></span><br><span class="line">      Thread waiter;            <span class="comment">// visibly nonnull when enqueued</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">      。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">    node.waiter = current;  <span class="comment">// 将当前线程设置为节点的等待线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取队列的尾节点</span></span><br><span class="line">    node.setPrevRelaxed(t);  <span class="comment">// 将尾节点设置为当前节点的前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        tryInitializeHead();  <span class="comment">// 如果尾节点为null，尝试初始化头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node)) </span><br><span class="line">        node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果使用CAS设置尾节点失败，回滚操作，将当前节点的前驱设置为null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首相将节点的waiter属性设置为当前线程，然后判断tail，这个tail是队列的尾节点，如果是第一次初始化队列的话会为null，然后就走了tryInitializeHead方法，这个方法内部会通过CAS的方式给tail初始化。</p>
<p><code>casTail(t, node)</code>是一个CAS操作，它尝试将队列的尾节点从<code>t</code>更新为<code>node</code>。如果在这个过程中，其他线程已经修改了尾节点，那么CAS操作会失败，这时就需要进行回滚操作，将当前节点的前驱设置为<code>null</code>。如果CAS操作成功，那么就将当前节点设置为新的尾节点。</p>
<p>看下下面部分的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">    --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">    Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">    node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">long</span> nanos;</span><br><span class="line">    spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">    <span class="keyword">if</span> (!timed)</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">        LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">    node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">    <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，如果当前节点是第一个节点并且<code>spins</code>不为0，那么就减少<code>spins</code>的值，并调用<code>Thread.onSpinWait()</code>方法进行自旋等待，这是一种轻量级的等待方式，相比于阻塞等待，它可以在等待时间较短的情况下减少线程切换的开销。如果当前节点的状态是0，那么就将其状态设置为等待状态。如果当前节点的状态不是0，那么就会更新<code>spins</code>和<code>postSpins</code>的值，并根据是否是定时等待来决定是调用<code>LockSupport.park(this)</code>方法使线程进入阻塞等待状态，还是调用<code>LockSupport.parkNanos(this, nanos)</code>方法使线程进入定时阻塞等待状态。如果等待时间已经过去，那么就跳出循环。然后，清除节点状态。最后，如果线程被中断并且是可中断的，那么就跳出循环。</p>
<p>上面就是一个加锁的逻辑</p>
<p>解锁的话从<strong>unlock</strong>方法入手探索，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#AbstractOwnableSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            signalNext(head);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> #Sync</span><br><span class="line"> <span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// 获取当前锁的状态并减少指定的数量</span></span><br><span class="line">    <span class="comment">// 检查当前线程是否是锁的所有者，如果不是，抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> (c == <span class="number">0</span>);  <span class="comment">// 检查是否可以释放锁（锁的状态是否为0）</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">// 如果可以释放锁，将锁的所有者设置为null</span></span><br><span class="line">    setState(c);  <span class="comment">// 更新锁的状态</span></span><br><span class="line">    <span class="keyword">return</span> free;  <span class="comment">// 返回是否成功释放了锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果tryRelease失败的话就执行signalNext方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 检查头节点是否存在，以及头节点的下一个节点是否存在并且其状态不为0</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);  <span class="comment">// 清除下一个节点的等待状态</span></span><br><span class="line">        LockSupport.unpark(s.waiter);  <span class="comment">// 唤醒下一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是唤醒下一个在等待锁的线程。它首先检查头节点（通常是当前占用锁的线程）是否存在，以及头节点的下一个节点（通常是等待锁的下一个线程）是否存在并且其状态不为0。如果满足这些条件，那么它将清除下一个节点的等待状态，并使用<code>LockSupport.unpark(s.waiter)</code>方法唤醒下一个等待的线程。</p>
<h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><p>原理弄清楚了，顺便总结了几点Synchronized和ReentrantLock的区别：</p>
<ol>
<li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>ReentrantLock#isLocked</code>判断；</li>
<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>Synchronized是不可以被中断的，而<code>ReentrantLock#lockInterruptibly</code>方法是可以被中断的；</li>
<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说），而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>锁实现机制</td>
<td>对象头监视器模式</td>
<td>依赖 AQS</td>
</tr>
<tr>
<td>灵活性</td>
<td>不灵活</td>
<td>支持响应中断、超时、尝试获取锁</td>
</tr>
<tr>
<td>释放锁形式</td>
<td>自动释放锁</td>
<td>显示调用 unlock()</td>
</tr>
<tr>
<td>支持锁类型</td>
<td>非公平锁</td>
<td>公平锁 &amp; 非公平锁</td>
</tr>
<tr>
<td>条件队列</td>
<td>单条件队列</td>
<td>多个条件队列</td>
</tr>
<tr>
<td>是否支持可重入</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>参考连接：</p>
<p><a href="https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23">https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23</a></p>
<p><a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
<p><a href="https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA">https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA</a></p>
<p><a href="https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA">https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA</a></p>
<p><a href="https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2023/12/15/view%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Android-view-绘制流程"><a href="#Android-view-绘制流程" class="headerlink" title="Android view 绘制流程"></a>Android view 绘制流程</h1><h2 id="布局加载过程"><a href="#布局加载过程" class="headerlink" title="布局加载过程"></a>布局加载过程</h2><ul>
<li><p>我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">  		<span class="comment">// 这里调用了PhoneWindow的setContentView方法</span></span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;  </span><br><span class="line">                mDecor = generateDecor();  </span><br><span class="line">                mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">                mDecor.setIsRootNamespace(<span class="literal">true</span>);  </span><br><span class="line">                <span class="comment">//...  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;  </span><br><span class="line">              	<span class="comment">// 这里引入R.layout.screen_simple add到了DecorView上 并将R.id.content传递给mContentParent 可以看下面的源码部分</span></span><br><span class="line">                mContentParent = generateLayout(mDecor);  </span><br><span class="line">                mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">                <span class="keyword">if</span> (mTitleView != <span class="literal">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//根据FEATURE_NO_TITLE隐藏，或者设置mTitleView的值  </span></span><br><span class="line">                    <span class="comment">//...  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);  </span><br><span class="line">                    <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">//设置ActionBar标题、图标神马的；根据FEATURE初始化Actionbar的一些显示  </span></span><br><span class="line">                        <span class="comment">//...  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 先是一系列的属性设置贴了一些平时常用的</span></span><br><span class="line">    <span class="comment">// 取消标题栏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="literal">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置全屏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="literal">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    <span class="comment">// 一系列的窗口属性设置</span></span><br><span class="line">    <span class="comment">// 如：SDK 31 新增的高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowBlurBehindEnabled, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getForcedWindowFlags() &amp; WindowManager.LayoutParams.FLAG_BLUR_BEHIND) == <span class="number">0</span>) &#123;</span><br><span class="line">            params.flags |= WindowManager.LayoutParams.FLAG_BLUR_BEHIND;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        params.setBlurBehindRadius(a.getDimensionPixelSize(</span><br><span class="line">                android.R.styleable.Window_windowBlurBehindRadius, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 整体布局文件</span></span><br><span class="line">    <span class="type">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据一系列判断选择 SDK 中的布局一般默认是 R.layout.screen_simple</span></span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载到DecorView上</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到 screen_simple.xml 布局的内容部分 （R.id.content）</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">DecorView:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="type">int</span> layoutResource)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 通过 LayoutInflater 将 screen_simple.xml 解析成 View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 addView 将 root 添加到 DecorView 上</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前最终的布局层次</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
</li>
</ul>
<p>此时只是完成了基础的activity的DecirView的初始化 我们实现的布局还没有解析到布局上</p>
<p>回头看setContentView()方法，目前上面的部分实现了installDecor()，也就是初始化完成了DecorView 并解析了R.layout.screen_simple到上面，并将里面的FrameLayout（R.id.content）的引用传递出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">    	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">      installDecor();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      mContentParent.removeAllViews();  </span><br><span class="line">  &#125;  </span><br><span class="line">		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">  mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">  <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">      cb.onContentChanged();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面就是解析自己的布局过程，就是下面这行代码开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br></pre></td></tr></table></figure>

<p>往下挖源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater:	</span><br><span class="line">	<span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">    <span class="comment">// 如果开启了调试模式，打印日志，显示正在从哪个资源文件加载视图</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">              + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line">    <span class="comment">// 尝试从预编译的资源中加载视图，如果成功则返回视图 </span></span><br><span class="line">    <span class="comment">// 目前这个方法被禁用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取XML资源解析器</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用解析器，根据root和attachToRoot参数来加载视图</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后关闭解析器</span></span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用同步块，确保多线程环境下的安全性</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// 开始性能追踪，用于调试和性能优化</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上下文和属性集</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root; <span class="comment">// root 赋值给 result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果根视图不为空并且根视图的 ViewRootImpl 不为空，通知渲染器进行昂贵帧的处理</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将解析器推进到第一个START_TAG 也就是根View</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 拿到根 View 名字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点是 &lt;merge&gt;，则需要合并布局</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果根视图为空或者不需要附加到根视图，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行合并布局</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 根据标签创建视图</span></span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图为空且 temp 不为空 且 temp 的 ViewRootImpl 不为空，通知渲染器处理昂贵帧</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span> &amp;&amp; temp.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 布局参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图不为空，则生成根视图的布局参数</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Creating params from root: &quot;</span> + root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初始化布局参数</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要附加到根视图，则设置布局参数给 temp</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; start inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; done inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将创建的根 View 添加到 root 也就是 mContentParent 中</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回传入的根视图还是在 XML 中找到的顶层视图</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="comment">// XML 解析异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                    getParserStateDescription(inflaterContext, attrs)</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要保留对上下文的静态引用</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束性能追踪</span></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">     View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果标签名为 &quot;view&quot;，则尝试获取 &quot;class&quot; 属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不忽略主题属性，则尝试应用主题包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="comment">// 从属性中获取主题信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果主题资源 ID 不为 0，则使用 ContextThemeWrapper 包装上下文</span></span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试直接创建视图  </span></span><br><span class="line">      	<span class="comment">// 这里是使用Factory2创建view </span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">				</span><br><span class="line">       <span class="comment">// 如果创建失败进入 if</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果直接创建失败，则尝试通过其他方式创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 表示 sdk 中的 View (Text、Button...)</span></span><br><span class="line">                    view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 表示自定义 View 或者 support 包中的 View (androidx.appcompat.widget.AppCompatButton...)</span></span><br><span class="line">                    view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 InflateException，则直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ClassNotFoundException，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果是其他异常，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结上述源码：</p>
<p>LayoutInflater::inflate 开启了布局解析，<code>XmlResourceParser parser = res.getLayout(resource);</code>获取了布局解析器，然后<code>inflate(parser, root, attachToRoot);</code> 进入了具体的解析流程。从<code>final View temp = createViewFromTag(root, name, inflaterContext, attrs);</code>进入createViewFromTag方法，然后走下如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">           mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                   view = onCreateView(context, parent, name, attrs);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>tryCreateView是尝试创建view，看看具体代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很简单就是通过mFactory2&#x2F;mFactory来创建view。</p>
<p>其中Activity的父类AppCompatActivity中的构造方法中会执行一个initDelegate()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 添加上下文可用监听器</span></span><br><span class="line">    addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AppCompatDelegate 实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">            <span class="comment">// 安装视图工厂 这里开启了Factory</span></span><br><span class="line">            delegate.installViewFactory();</span><br><span class="line">            <span class="comment">// 调用 AppCompatDelegate 的 onCreate 方法，并传入从 SavedStateRegistry 恢复的状态</span></span><br><span class="line">            delegate.onCreate(getSavedStateRegistry()</span><br><span class="line">                    .consumeRestoredStateForKey(DELEGATE_TAG));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDelegateImpl:</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 这里setFactory2 将this也就是AppCompatDelegateImpl</span></span><br><span class="line">            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                        + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码走完又可以回到这部分了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view;</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用的onCreateView方法的实现应该是在AppCompatDelegateImpl中，看下具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 AppCompatViewInflater 为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mAppCompatViewInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewInflaterClassName</span> <span class="operator">=</span></span><br><span class="line">                a.getString(R.styleable.AppCompatTheme_viewInflaterClass);</span><br><span class="line">        <span class="keyword">if</span> (viewInflaterClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未指定自定义的 ViewInflater 类名，使用默认的 AppCompatViewInflater</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用反射加载自定义的 ViewInflater 类</span></span><br><span class="line">                Class&lt;?&gt; viewInflaterClass =</span><br><span class="line">                        mContext.getClassLoader().loadClass(viewInflaterClassName);</span><br><span class="line">                mAppCompatViewInflater =</span><br><span class="line">                        (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor()</span><br><span class="line">                                .newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 加载失败时，使用默认的 AppCompatViewInflater，并打印错误日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Failed to instantiate custom view inflater &quot;</span></span><br><span class="line">                        + viewInflaterClassName + <span class="string">&quot;. Falling back to default.&quot;</span>, t);</span><br><span class="line">                mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承上下文，用于处理 &lt;include&gt; 标签的情况</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inheritContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (IS_PRE_LOLLIPOP) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 5.0 之前的版本，处理 &lt;include&gt; 标签的继承上下文情况</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector == <span class="literal">null</span>) &#123;</span><br><span class="line">            mLayoutIncludeDetector = <span class="keyword">new</span> <span class="title class_">LayoutIncludeDetector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector.detect(attrs)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前视图是 &lt;include&gt; 的根视图，则继承上下文</span></span><br><span class="line">            inheritContext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 &lt;include&gt; 标签，根据深度或者使用旧的启发式方法来判断是否继承上下文</span></span><br><span class="line">            inheritContext = (attrs <span class="keyword">instanceof</span> XmlPullParser)</span><br><span class="line">                    ? ((XmlPullParser) attrs).getDepth() &gt; <span class="number">1</span></span><br><span class="line">                    : shouldInheritContext((ViewParent) parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AppCompatViewInflater 的 createView 方法创建视图</span></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* 只在 Android 5.0 之前读取 android:theme 属性 */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* 无论何时都读取 app:theme 属性作为后备，基于传统原因 */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* 只有在启用时对上下文进行着色处理 */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又走到了createView方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">originalContext</span> <span class="operator">=</span> context;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can emulate Lollipop&#x27;s android:theme attribute propagating down the view hierarchy</span></span><br><span class="line">      <span class="comment">// by using the parent&#x27;s context</span></span><br><span class="line">      <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">          context = parent.getContext();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">          <span class="comment">// We then apply the theme on the context, if specified</span></span><br><span class="line">          context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">          context = TintContextWrapper.wrap(context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We need to &#x27;inject&#x27; our tint aware Views in place of the standard framework versions</span></span><br><span class="line">      <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">              view = createTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">              view = createImageView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">              view = createButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">              view = createEditText(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">              view = createSpinner(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">              view = createImageButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">              view = createCheckBox(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">              view = createRadioButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">              view = createCheckedTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">              view = createRatingBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">              view = createSeekBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ToggleButton&quot;</span>:</span><br><span class="line">              view = createToggleButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">              <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">              <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">              <span class="comment">// later in this method.</span></span><br><span class="line">              view = createView(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">          <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">          <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">          view = createViewFromTag(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">          checkOnClickListener(view, attrs);</span><br><span class="line">          backportAccessibilityAttributes(context, view, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总结上面：AppCompatActivity 默认设置了 Factory2，并且其实现创建 View 是直接通过 new 的方式，并没有使用反射。</p>
<p>上面一节有个方法需要注意下，就是布局的子view是如果添加到根view的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/LayoutInflater.java</span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    				...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">								</span><br><span class="line">						...</span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数的深度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 逐个 View 解析</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:focusable=&quot;true&quot;, 获取View的焦点</span></span><br><span class="line">            pendingRequestFocus = <span class="literal">true</span>;</span><br><span class="line">            consumeChildElements(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:tag标签</span></span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析include标签，include标签不能作为根布局</span></span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;include /&gt; cannot be the root element&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, context, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// merge标签必须作为根布局</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; must be the root element&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据元素名解析，生成View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 添加解析的View</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果finishInflate为true，则调用onFinishInflate方法</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为AppCompatActivity 默认设置了 Factory2，且Factory2只能设置一次，如果activity集成了AppCompatActivity那么只能通过反射设置Factory2了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory2</span><span class="params">(Factory2 factory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Given factory can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> <span class="title class_">FactoryMerger</span>(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射将mFactorySet重新设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//上面提到过：Android布局加载器使用mFactorySet标记是否设置过Factory，如设置过抛出一次</span></span><br><span class="line">  <span class="comment">//所以需要通过反射设置mFactorySet为false</span></span><br><span class="line">  <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LayoutInflater.class.getDeclaredField(<span class="string">&quot;mFactorySet&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用factory2设置布局加载工厂</span></span><br><span class="line"><span class="type">SkinLayoutInflaterFactory</span> <span class="variable">skinLayoutInflaterFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkinLayoutInflaterFactory</span></span><br><span class="line">  (activity);</span><br><span class="line">LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>

<p><strong>setContentView总结：</strong></p>
<p>在<code>Activity</code>实例创建好并且执行<code>attach()</code>方法的时候，会为<code>Activity</code>创建一个<code>PhoneWindow</code>，接下来就到了<code>onCreate()</code>的生命周期，在调用<code>setContentView()</code>的时候，如果还没有初始化<code>ContentParent</code>，说明是第一次进行<code>setContentView()</code>，那么就会初始化<code>DecorView</code>，还会给<code>DecorView</code>添加一个系统页面样式的<code>子View(R.layout.screen_simple)</code>，那么在系统样式的<code>ViewGroup</code>中，就可以通过<code>id</code>找到用来加载自定义布局的<code>ContentParent</code>，再通过<code>inflate</code>就可以将我们自己写的<code>xml</code>文件<code>(R.layout.main)</code>转化为一颗<code>ViewTree</code>了，这颗<code>ViewTree</code>就在<code>ContentParent</code>里面。</p>
<p>所以<code>setContentView()</code>的作用最终可以总结为：</p>
<ul>
<li><strong>创建<code>DecorView</code></strong></li>
<li><strong>创建<code>ContentParent</code></strong></li>
<li><strong>自定义布局转化为<code>ViewTree</code>，放在<code>ContentParent</code>中</strong></li>
</ul>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA">https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA</a><br><a href="https://www.jianshu.com/p/5a71014e7b1b">https://www.jianshu.com/p/5a71014e7b1b</a></p>
<p><a href="https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11">https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11</a></p>
<p><a href="https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff">https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff</a><br><a href="https://www.jianshu.com/p/8e554406bd15">https://www.jianshu.com/p/8e554406bd15</a></p>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>上面布局解析完之后还不可见，在activity处于<code>onResume()</code>生命周期时才会展示布局。</p>
<p><code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中执行的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isForward, <span class="type">boolean</span> shouldSendCompatFakeFocus, String reason)</span> &#123;</span><br><span class="line">      	...</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">// 这里的decor就是上面setContentView加载的DecorView</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">          	<span class="comment">// 每一个Activity都会对应一个WindowManager对象（Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象）</span></span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">            WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 将DecorView add进WindowManager中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">						。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>wm.addView</code>最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法。这个方法中会调用<code>requestLayout()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 将布局请求安排到消息队列中，以便在下一个消息循环中执行。</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 获取 Looper 并创建同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">          	<span class="comment">// 在 Choreographer 中调度遍历的回调</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这里的mTraversalRunnable是个Runnable对象</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 到这里终于看到了绘制的起点了</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>onResume 总结：</strong></p>
<p>在<code>onResume()</code>中会调用<code>WindowManager</code>中的<code>addView()</code>添加<code>DecorView</code>，当<code>WindowManager</code>管理<code>ViewTree</code>的时候会给<code>ViewTree</code>分配一个<code>ViewRootImpl</code>，<code>ViewRootImpl</code>的第一个作用就是管理<code>ViewTree</code>的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个<code>Activity</code>的情况下，每个<code>Activity</code>都有自己的<code>PhoneWindow</code>、<code>DecorView</code>以及<code>WindowManagerImpl</code>，<code>WindowManagerGlobal</code>持有每个<code>Activity</code>的<code>RootView</code>，<code>mWindowSession</code>和<code>mWindow</code>是用来和<code>WMS</code>进行双向通信的。</p>
<p>看一下performTraversals的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123; </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRootMeasureSpec</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">int</span> rootDimension)</span> &#123; </span><br><span class="line">   <span class="type">int</span> measureSpec; </span><br><span class="line">   <span class="keyword">switch</span> (rootDimension) &#123; </span><br><span class="line">   <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT: </span><br><span class="line">   <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.   </span></span><br><span class="line">   measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY);</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   ...... </span><br><span class="line">  &#125; </span><br><span class="line"> <span class="keyword">return</span> measureSpec; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView是一个FrameLayout下面会直接进入FrameLayout的measure方法，参数就是上面生成的childWidthMeasureSpec和childHeightMeasureSpec。</p>
<h3 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h3><ul>
<li><p><strong>MeasureSpec 的理解</strong></p>
<p>MeasureSpec是一个32位的int值，用于描述View的大小和模式。它的高2位表示模式（mode），低30位表示大小（size）MeasureSpec有三种模式：</p>
<ol>
<li><p>精确模式（<strong>MeasureSpec.EXACTLY</strong>）：在这种模式下，View的大小已经确定，为SpecSize所指定的值。例如，当我们将控件的layout_width或layout_height指定为具体数值或者为<strong>MATCH_PARENT</strong>时，都是控件大小已经确定的情况，都是精确尺寸</p>
</li>
<li><p>最大模式（<strong>MeasureSpec.AT_MOST</strong>）：在这种模式下，父控件给出的是最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。例如，当控件的layout_width或layout_height指定为<strong>WRAP_CONTENT</strong>时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。</p>
</li>
<li><p>未指定模式（<strong>MeasureSpec.UNSPECIFIED</strong>）：在这种模式下，父控件不会干涉子View想要多大的尺寸，子View可以随意使用空间，不受限制。例如，在ScrollView或NestedScrollView中，子View的测量模式可能会被设置为MeasureSpec.UNSPECIFIED，这样子View就可以根据自己的内容来决定自己的大小。</p>
</li>
</ol>
</li>
</ul>
<p><strong>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求</strong></p>
<ul>
<li><p><strong>mode的值</strong></p>
<p>-<strong>2147483648</strong>   对应的二进制表示是 <code>0b10000000000000000000000000011000</code>。在这个二进制中，最低的两位 <code>00</code> 表示测量模式为 <code>AT_MOST</code>。 </p>
<p><strong>1073742099</strong> 对应的二进制表示是 <code>0b10000000000000000000000100100011</code>。在这个二进制中，最低的两位 <code>11</code> 表示测量模式为 <code>EXACTLY</code>。</p>
</li>
<li><p><strong>ViewGroup的Measure</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed, <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，你在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>以LinearLayout为例 解析Measure过程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先分析下Android View 的结构：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>我们写的布局最终会add到上面图片的FrameLayout中。</p>
<p>然后开始FrameLayout的measure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;  </span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>measureChildWithMargins的源码就是上面的ViewGroup的Measure的代码。</p>
<p>上面的performTraversals方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br></pre></td></tr></table></figure>

<p>再结合view视图层次DecorView的下一级是ViewRoot这是个LinearLayout。ViewRoot 是系统的View，它的LayoutParams默认都是match_parent。</p>
<p>根据上面的计算规则：</p>
<p>ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size。</p>
<p><strong>目前ViewRoot的measure方法的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。</strong></p>
<p>measure方法会调用onMeasure方法开启计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinearLayout：</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewRoot的子view有两个ViewStub和id.content.</p>
<p>调用ViewRoot.measure后会调用，LinearLayout 的onMeasure 方法开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用。</p>
<p>根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿<strong>ViewRoot 的MeasureSpec</strong> 和 <strong>android.R.id.content的LayoutParams</strong> 做计算了，计算过程就是调用getChildMeasureSpec的方法。</p>
<p>来看下计算过程，首先ViewRoot.measure的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。content的width和height都是matchparent。那么看下getChildMeasureSpec方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 只看这个分支</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// 根据条件走到这个分支</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 后传递给content的Measure方法</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>id&#x2F;content是个FrameLayout然后又开启了新的计算流程。</p>
<p>这个计算流程就开始计算我们自己写的布局了，再看下原布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先应该是先计算最外面的LinearLayout，根据规则LinearLayout的measure(int widthMeasureSpec, int heightMeasureSpec)的两个MeasureSpec的mode都应该是<strong>EXACTLY</strong></p>
<p>然后开启LinearLayout的onMeasure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后根据LinearLayout的measure结合TextView的LayoutParams计算得到传递给TextView的MeasureSpaec。</p>
<p>这里看看LinearLayout的measure的源码，因为orientation&#x3D;”vertical”所以会走measureVertical(widthMeasureSpec, heightMeasureSpec);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>; <span class="comment">// 总高度，子控件累加总高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大子控件的宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子view测量状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">alternativeMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 没有设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weightedMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allFillParent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 子控件全设置match_parent</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子控件累加总权重（子控件设置了layout_weight）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();<span class="comment">// 子控件总数量</span></span><br><span class="line"><span class="comment">// 这里获取了LinearLayout的Mode</span></span><br><span class="line">  	<span class="comment">// 根据上面分析widthMode都是EXACTLY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matchWidth</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 有子View宽度设置为match_parent</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skippedMeasure</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否跳过重新测量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">baselineChildIndex</span> <span class="operator">=</span> mBaselineAlignedChildIndex; <span class="comment">// 基线子view</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 跟setMeasureWithLargestChildEnabled()有关</span></span><br><span class="line">		<span class="comment">// 当设定为true，所有有设定了weight的子View的最小高度是：最大的View的高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useLargestChild</span> <span class="operator">=</span> mUseLargestChild;</span><br><span class="line"><span class="comment">// 最大子控件的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestChildHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">consumedExcessSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 需要测量的子View总数，不需要测量指的是设定了weight</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nonSkippedChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子view数量开启循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 测量view为null占据的高度，默认返回0</span></span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonSkippedChildCount++;</span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取当前子view的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 处理 weight</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 判断当前子view的height == 0 且 weight &gt; 0  </span></span><br><span class="line">      	<span class="comment">// 根据布局来看 useExcessSpace应该为false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useExcessSpace</span> <span class="operator">=</span> lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 子View的高度是具体的，可以这直接算出来，不需算子View的高度</span></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="literal">true</span>; <span class="comment">// 该子View直接忽略二次计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// useExcessSpace 为false  无法精确计算子View</span></span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">              <span class="comment">// 假设为true的话 让子view的height为WRAP_CONTENT</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">				<span class="comment">// 判断Weight的值，为0则usedHeight为mTotalLength  mTotalLength表示目前为止已经测量过的子视图的总高度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">usedHeight</span> <span class="operator">=</span> totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">          	<span class="comment">// 开始走getChildMeasureSpec流程。 这里是获取TextView的MeasureSpec 然后走它的onMeasure方法</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line">				<span class="comment">// 获取child的高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">          	<span class="comment">// 获取总共的长度 </span></span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                    + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                    + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="literal">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span> lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 底部是否有分割线，计算最高高度</span></span><br><span class="line">    <span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置了 measureWithLargestChild 且 总高度无法确定，需要重新计算 mToatalLength</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 添加padding</span></span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查最小高度</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据heightMeasureSpec计算最后结果，heightSizeAndState存储最终的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSizeAndState</span> <span class="operator">=</span> resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingExcess</span> <span class="operator">=</span> heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 简单来说就是 skippedMeasure为true说明之前的测量被跳过了需要重新测量</span></span><br><span class="line">  	<span class="comment">// 或者使用了Weight属性 要启动二次测量</span></span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">            || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">      	<span class="comment">// 计算总的weight，mWidgetSum是外部设定，totalWeight是首次计算出来的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">remainingWeightSum</span> <span class="operator">=</span> mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">childWeight</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 计算分配的值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> (<span class="type">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">              	<span class="comment">// 剩余分配高度</span></span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">              	<span class="comment">// 剩余比重总和</span></span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                  	<span class="comment">// 子View直接是largestChildHeight</span></span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// 子view是没有height，直接为分配高度</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子View有height，另外还要加上分配的高度</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">              	<span class="comment">// 重新测量子View</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span>  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">          	<span class="comment">// 计算子View的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span></span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">childExtra</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LinearLayout的onMeasure中的child.measure启动了TextView的onMeasure():</p>
<p>源码就不展示了，大概就是根据传入的获取MeasureSpec计算自己的宽度和高度，然后通过setMeasuredDimension方法将获取的值赋值给mMeasuredWidth和mMeasuredHeight。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个值就是layout进行定位的值。</p>
<h3 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h3><p>回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>

<p>measure执行完之后就该执行layout了，mView.getMeasuredWidth()和mView.getMeasuredHeight()就是上个阶段计算得到的值。</p>
<p>还是先看FrameLayout的layout干了啥</p>
<p>FrameLayout没有自己实现layout函数，得看ViewGroup里的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没啥东西，还是得看super.layout(l, t, r, b);的实现，也就是View中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      .....</span><br><span class="line">     <span class="comment">//设置View位于父视图的坐标轴  主要是初始化了四个值  mLeft  mTop  mRight mBottom</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> setFrame(l, t, r, b); </span><br><span class="line">      <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">              ViewDebug.trace(<span class="built_in">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line">          mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">      mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在View中onLayout是空实现，所以回到FrameLayout中看具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> childLeft;</span><br><span class="line">                <span class="type">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                        <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// layout(int l, int t, int r, int b)</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是根据规则获取了child的childLeft和childTop,然后启动child的layout函数。</p>
<p>这里看一下view的坐标系</p>
<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/cc5c57e82f5346e0ad194f914edd0e5d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png" style="zoom: 50%;" />

<p>left和top坐标确定了view左上角的位置，right和bottom坐标确定了右下角的位置。</p>
<p>right - left 为view的宽(width)  bottom - top 为view的高(height)。</p>
<p>Layout流程就这些没啥好说的。</p>
<h3 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h3><p>再回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br></pre></td></tr></table></figure>

<p>FrameLayout和ViewGroup都没有重写draw方法，所以我们看下View中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         *      7. If necessary, draw the default focus highlight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="type">int</span> saveCount;</span><br><span class="line">				<span class="comment">// 绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShowingLayoutBounds()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;re done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程用这张图片概括一下，循环的入口是draw方法。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/webp-20231215160503207" alt="img"></p>
<h1 id="Android-View事件分发"><a href="#Android-View事件分发" class="headerlink" title="Android View事件分发"></a>Android View事件分发</h1><h2 id="分发的事件是什么"><a href="#分发的事件是什么" class="headerlink" title="分发的事件是什么"></a>分发的事件是什么</h2><p>我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的。根据不同动作，主要有以下三种事件类型：<br>1.ACTION_DOWN：<strong>手指刚接触屏幕，按下去的那一瞬间产生该事件</strong><br>2.ACTION_MOVE：<strong>手指在屏幕上移动时候产生该事件</strong><br>3.ACTION_UP：<strong>手指从屏幕上松开的瞬间产生该事件</strong></p>
<p><strong>从ACTION_DOWN开始到ACTION_UP结束我们称为一个事件序列</strong></p>
<p>正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在MotionEvent上来讲无外乎下面两种。<br><strong>1.点击后抬起，也就是单击操作：ACTION_DOWN -&gt; ACTION_UP<br>2.点击后再风骚的滑动一段距离，再抬起：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP</strong></p>
<h2 id="MotionEvent事件分发的三个方法"><a href="#MotionEvent事件分发的三个方法" class="headerlink" title="MotionEvent事件分发的三个方法"></a>MotionEvent事件分发的三个方法</h2><ul>
<li><p><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong><br>通过方法名我们不难猜测，它就是事件分发的重要方法。那么很明显，如果一个MotionEvent传递给了View，那么dispatchTouchEvent方法一定会被调用！<br>返回值：表示是否消费了当前事件。可能是View本身的onTouchEvent方法消费，也可能是子View的dispatchTouchEvent方法中消费。返回true表示事件被消费，本次的事件终止。返回false表示View以及子View均没有消费事件，将调用父View的onTouchEvent方法</p>
</li>
<li><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong><br>事件拦截，当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。特别注意，这是ViewGroup特有的方法，View并没有拦截方法<br>返回值：是否拦截事件传递，返回true表示拦截了事件，那么事件将不再向下分发而是调用View本身的onTouchEvent方法。返回false表示不做拦截，事件将向下分发到子View的dispatchTouchEvent方法。</p>
</li>
<li><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong><br>真正对MotionEvent进行处理或者说消费的方法。在dispatchTouchEvent进行调用。<br>返回值：返回true表示事件被消费，本次的事件终止。返回false表示事件没有被消费，将调用父View的onTouchEvent方法</p>
</li>
</ul>
<p>上面的三个方法可以用以下的伪代码来表示其之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//事件是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev))&#123;<span class="comment">//调用onInterceptTouchEvent判断是否拦截事件</span></span><br><span class="line">        consume = onTouchEvent(ev);<span class="comment">//如果拦截则调用自身的onTouchEvent方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);<span class="comment">//不拦截调用子View的dispatchTouchEvent方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;<span class="comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件分发的具体流程"><a href="#事件分发的具体流程" class="headerlink" title="事件分发的具体流程"></a>事件分发的具体流程</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。那么很明显我们先看Activity的dispatchTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Activity：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getWindow().superDispatchTouchEvent(ev)方法发现是Window类当中的一个抽象方法，Window的唯一实现类是PhoneWindow。那么去看PhoneWindow对应的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneWindow</span></span><br><span class="line">    <span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line">    <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个DecorView就是Window的顶级View，我们通过setContentView设置的View是它的子View，</strong>到这里事件已经被传递到我们的顶级View中，一般是ViewGroup。</p>
<p>看看ViewGroup的dispatchTouchEvent方法实现，代码比较多先看下判断是否拦截事件的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// 在开始新的触摸手势时，丢弃所有以前的状态。由于应用切换、ANR 或其他一些状态更改，框架可能已删除上一个手势的 up 或 cancel 事件。</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里会执行 mFirstTouchTarget = null;  mFirstTouchTarget是用来承载处理事件的子View对象，这个对象非常重要，它决定了ViewGroup是否拦截事件</span></span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否拦截事件的标志位</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">    	   <span class="comment">// 判断是否是ACTION_DOWN事件和mFirstTouchTarget是否为null，如果是ACTION_DOWN事件说明是一个新的事件或者mFirstTouchTarget不为null说明有处理事件的子View，会然后会判断子view是否调用了requestDisallowInterceptTouchEvent方法来禁止ViewGroup拦截，判断通过后会调用onInterceptTouchEvent方法来判断最终是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查触摸事件是否来自鼠标设备</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            <span class="comment">// 检查触摸事件的动作是否为按下（ACTION_DOWN）</span></span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            <span class="comment">// 检查是否按下了主要的鼠标按钮</span></span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            <span class="comment">// 调用isOnScrollbarThumb方法检查是否在滚动条拇指上</span></span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getXDispatchLocation(<span class="number">0</span>), ev.getYDispatchLocation(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">// 如果上述条件都为真，表示需要拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件有一个为假，表示不需要拦截该事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码，通过判断actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN和 mFirstTouchTarget !&#x3D; null判断是否拦截，这里有一点要注意的是，根据逻辑 <strong>如果ViewGroup没有拦截ACTION_DOWN事件的话说明这组事件会有子view处理，所以mFirstTouchTarget 不会为null。否则的话mFirstTouchTarget 为null且不是ACTION_DOWN事件说明之前拦截了ACTION_DOWN事件，则后面的事件直接拦截。</strong></p>
<p><strong>mFirstTouchTarget 是否有值决定了ViewGroup是否拦截ACTION_DOWN以外的事件</strong></p>
<p>假设这里不拦截的话，看后续的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="comment">//对子View进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断1，View可见并且没有播放动画。2，点击事件的坐标落在View的范围内</span></span><br><span class="line">            <span class="comment">//如果上述两个条件有一项不满足则continue继续循环下一个View</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 走到这里说明找到了满足的子View了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里会判断mFirstTouchTarget，因为目前还未将事件传递给子view所以还是null 返回的也会是null</span></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="comment">//如果有子View处理即newTouchTarget 不为null则跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">//dispatchTransformedTouchEvent第三个参数child这里不为null，实际调用的是child的dispatchTouchEvent方法，具体实现可以看下面。 重点方法</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX = ev.getX();</span><br><span class="line">                mLastTouchDownY = ev.getY();</span><br><span class="line">                <span class="comment">//当child处理了点击事件，那么会设置mFirstTouchTarget 在addTouchTarget被赋值，具体实现看下面</span></span><br><span class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//子View处理了事件，然后就跳出了for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     ......</span><br><span class="line">         <span class="comment">// 如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false） </span></span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true，子View为GroupView的话会重复上面的逻辑，不是的话会直接走View的dispatchTouchEvent方法。</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">     	<span class="comment">// 这里给mFirstTouchTarget赋值了，也就是上面说的是否处理了事件看mFirstTouchTarget是否为null</span></span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示ViewGroup进行事件传递的逻辑，在dispatchTransformedTouchEvent中会判断子View是否消费了事件，如果消费了会给mFirstTouchTarget赋值否则mFirstTouchTarget仍为null。</p>
<p>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）。会再次调用dispatchTransformedTouchEvent方法，且传入得child为null。</p>
<p>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">           handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">           handled = child.dispatchTouchEvent(event);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>目前为止ViewGroup的事件处理逻辑分析完了。</p>
<p><strong>结论</strong>：</p>
<blockquote>
<p><strong>ViewGroup会遍历所有子View去寻找能够处理点击事件的子View（可见，没有播放动画，点击事件坐标落在子View内部）最终调用子View的dispatchTouchEvent方法处理事件</strong></p>
</blockquote>
<blockquote>
<p><strong>当子View处理了事件则mFirstTouchTarget 被赋值，并终止子View的遍历。</strong></p>
</blockquote>
<blockquote>
<p><strong>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）那么ViewGroup会去处理这个事件（本质调用View的dispatchTouchEvent去处理）</strong></p>
</blockquote>
<p>如果ViewGrop处理这个事件的话会调用View的dispatchTouchEvent。如果不是ViewGroup处理事件，而是普通的View处理事件的话会直接调用View的dispatchTouchEvent方法。</p>
<p>所以最终都会走到View的dispatchTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">//如果窗口没有被遮盖</span></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            <span class="comment">//当前监听事件</span></span><br><span class="line">            <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">            <span class="comment">//需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件,如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//result为false调用自己的onTouchEvent方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View会先判断是否设置了OnTouchListener，<strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong> <strong>且当前View的dispatchTouchEvent方法就会返回false。</strong><br>当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    ... </span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span></span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p><strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>加一个知识点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">            setLongClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>View的setOnClickListener会默认将View的clickable设置成true。<br>View的setOnLongClickListener同样会将View的longClickable设置成true。</strong></p>
<p><strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong>这里的View的dispatchTouchEvent就会返回false，也就是dispatchTransformedTouchEvent方法会返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的<strong>dispatchTouchEvent是View嵌套调用的</strong>，所以最终的结果会由View层回调到Window层中，看一下原来的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值又会返回到Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个事件循环结束了循环</p>
<p>面试回答的时候为了逻辑清晰，可以定义一个只有一个ViewGroup和View的传递链</p>
<p>Activity - Window - GroupView - View</p>
<p>事件由Activity 开始传递，依次到Window 然后到了GroupView 再到View，事件传递主要的逻辑就是GroupView层和 View层，</p>
<p>首先事件会走到Activity 的dispatchTouchEvent方法，里面会调用Window的superDispatchTouchEvent方法去处理事件。</p>
<p>如果Window没有处理了事件会调用Activity的onTouchEvent方法去消费事件。再Window传递到ViewGroup和ViewGroup传递到View的过程中同样如此，会尝试调用自己的onTouchEvent方法去消费事件。</p>
<p>回单原来的逻辑，目前事件传递到了Window层，Window的superDispatchTouchEvent方法中会调用DecorView的事件分发方法。DecorView就是个FrameLayout，所以事件到了Viewgroup层。</p>
<p>Viewgroup的dispatchTouchEvent方法的逻辑，首先逻辑开始会判断要不要拦截当前事件，判断是否拦截会有两个判断条件。一个是当前的action事件是否为down事件，还有一个就是子View是否处理了事件的标志位。</p>
<p>这里如果是down事件或者标志位不等于null就会调用onInterceptTouchEvent方法判断是否拦截。这里调用onInterceptTouchEvent之前还会有一个标志位的判断，这个标志位是子View通过requestDisallowInterceptTouchEvent来通知父View的。</p>
<p>如果不是down事件且子View是否处理了事件的标志位为null说明之前的down事件被ViewGroup拦截了，所以后面move和up事件都会被拦截。</p>
<p>如果判断不拦截的话就会调用子View的dispatchTouchEvent方法，也就是View类中定义的逻辑。</p>
<p>这个方法首先会判断当前View是否设置了OnTouchListener监听，如果设置了监听且onTouch方法返回了true，那么onTouchEvent不会被调用。如果返回false的话会接着调用onTouchEvent方法。</p>
<p>这个方法会判断clickable和longClickable，只要有一个是true就会消费事件，然后会通过switch case判断事件的类型，再up case中会调用当前view设置的点击事件。</p>
<p>目前一整个事件传递从activity到view消费的这么一个逻辑，其实主要还是再Viewgroup和View传递的逻辑。之前说了View 消费的情况，我下面说一下View不消费的情况。</p>
<p>View不消费的话ViewGroup同样会走View类的dispatchTouchEvent方法的逻辑，然后调用onTouchEvent方法。如果onTouchEvent方法返回false的话事件会返回到Window层然后再返回到Activity层，也就是一开始说的逻辑，会调用activity的onTouchEvent方法。</p>
<h1 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h1><h2 id="自定义-View实现方式"><a href="#自定义-View实现方式" class="headerlink" title="自定义 View实现方式"></a>自定义 View实现方式</h2><p>总结下来有三种：</p>
<ul>
<li>继承某个控件，然后对它的一些功能进行修改，或者删除添加</li>
<li>将多个控件组合在一起形成一个新的View</li>
<li>继承 View &#x2F; ViewGroup 类，重写 <strong><code>onMeasure()</code><strong>、</strong><code>onLayout()</code><strong>、</strong><code>onDraw()</code></strong> 三大方法，从 0 到 1 创造一个新的控件。</li>
</ul>
<p>代码示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaterialEdit</span>(context: Context,attrs:AttributeSet) :</span><br><span class="line">    AppCompatEditText(context,attrs) &#123; <span class="comment">// 定义一个名为 MaterialEdit 的类，继承自 AppCompatEditText</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量和变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_SIZE = <span class="number">12.</span>dp  <span class="comment">// 文本大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_MARGIN = <span class="number">8.</span>dp <span class="comment">// 文本边距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> HORIZONTAL_OFFSET = <span class="number">5.</span>dp <span class="comment">// 水平偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> VERTICAL_OFFSET = <span class="number">23.</span>dp <span class="comment">// 垂直偏移量  浮动标签距离view顶部的向下偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> EXTRA_VERTICAL_OFFSET = <span class="number">16.</span>dp <span class="comment">// 便签动画时的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG) <span class="comment">// 创建一个 Paint 对象，用于绘制文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> floatingLabelShown = <span class="literal">false</span> <span class="comment">// 一个标志，表示浮动标签是否正在显示</span></span><br><span class="line">    <span class="keyword">var</span> useFloatingLabel = <span class="literal">false</span> <span class="comment">// 一个标志，表示是否使用浮动标签</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field != value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                <span class="keyword">if</span> (field) &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop + TEXT_SIZE + TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop - TEXT_SIZE - TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">            <span class="keyword">by</span> lazy &#123;</span><br><span class="line">                ObjectAnimator.ofFloat(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.textSize = TEXT_SIZE <span class="comment">// 设置 Paint 的文本大小</span></span><br><span class="line">        <span class="comment">// 获取自定义属性 useFloatingLabel 的值  会触发 set 方法</span></span><br><span class="line">        <span class="keyword">val</span> typeArray = context.obtainStyledAttributes(attrs,R.styleable.MaterialEdit)</span><br><span class="line">        useFloatingLabel = typeArray.getBoolean(R.styleable.MaterialEdit_useFloatingLabel,<span class="literal">true</span>)</span><br><span class="line">        typeArray.recycle() <span class="comment">// 回收 typeArray</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 EditText 中的文本改变时，执行这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        text: <span class="type">CharSequence</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        start: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthBefore: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthAfter: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮动标签正在显示，且文本变为空，那么隐藏浮动标签</span></span><br><span class="line">        <span class="keyword">if</span> (floatingLabelShown &amp;&amp; text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">false</span></span><br><span class="line">            animator.reverse() <span class="comment">// 执行动画的逆向操作，即隐藏浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果浮动标签没有显示，且文本不为空，那么显示浮动标签</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!floatingLabelShown &amp;&amp; !text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">true</span></span><br><span class="line">            animator.start() <span class="comment">// 开始执行动画，即显示浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个方法中绘制 EditText 的界面</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas) <span class="comment">// 调用父类的 onDraw 方法，绘制 EditText 的主体</span></span><br><span class="line">        paint.alpha = (floatingLabelFraction * <span class="number">0xff</span>).toInt() <span class="comment">// 根据动画的进度，设置 Paint 的透明度</span></span><br><span class="line">        <span class="comment">// 计算当前的垂直位置</span></span><br><span class="line">        <span class="keyword">val</span> currentVerticalValue =</span><br><span class="line">            VERTICAL_OFFSET + EXTRA_VERTICAL_OFFSET * (<span class="number">1</span> - floatingLabelFraction)</span><br><span class="line">        <span class="comment">// 在计算出的位置绘制提示文本</span></span><br><span class="line">        hint?.toString()?.let &#123;</span><br><span class="line">            canvas.drawText(</span><br><span class="line">                it,</span><br><span class="line">                HORIZONTAL_OFFSET,</span><br><span class="line">                currentVerticalValue,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Android-动画"><a href="#Android-动画" class="headerlink" title="Android 动画"></a>Android 动画</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p><strong>帧动画（Frame Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">val frameAnimation = imageView.background as AnimationDrawable</span><br><span class="line">frameAnimation.start()</span><br></pre></td></tr></table></figure>

<p><strong>补间动画（Tween Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">val rotateAnimation = AnimationUtils.loadAnimation(context, R.anim.rotate)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p><strong>属性动画（Property Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">2000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure>

<p><strong>过渡动画（Transition Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup = findViewById(R.id.scene_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> scene1: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene1, context)</span><br><span class="line"><span class="keyword">val</span> scene2: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene2, context)</span><br><span class="line"></span><br><span class="line">TransitionManager.go(scene2, TransitionInflater.from(context).inflateTransition(R.transition.example_transition))</span><br></pre></td></tr></table></figure>

<p><strong>触摸反馈动画（Touch Feedback Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义触摸反馈动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;?android:attr/colorControlHighlight&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/button_normal&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br><span class="line">button.background = ContextCompat.getDrawable(context, R.drawable.ripple)</span><br></pre></td></tr></table></figure>

<p><strong>物理动画（Physics-based Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> springAnimation = SpringAnimation(imageView, DynamicAnimation.ROTATION, <span class="number">0f</span>)</span><br><span class="line">springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW</span><br><span class="line">springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY</span><br><span class="line">springAnimation.start()</span><br></pre></td></tr></table></figure>

<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">   imageView.setBackgroundResource(R.drawable.animation)</span><br><span class="line">   <span class="keyword">val</span> animationDrawable = imageView.background <span class="keyword">as</span> AnimationDrawable</span><br><span class="line">   animationDrawable.start()</span><br></pre></td></tr></table></figure>

<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.ani)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p>补间动画的属性</p>
<p>补间动画（Tween Animation）在 Android 中主要包括四种类型：AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation，它们分别对应透明度、缩放、位移和旋转四种动画效果。</p>
<p>以下是这四种补间动画的主要属性：</p>
<ol>
<li><strong>AlphaAnimation（透明度动画）</strong>：<ul>
<li>fromAlpha：动画开始时视图的透明度（0.0 - 1.0）</li>
<li>toAlpha：动画结束时视图的透明度（0.0 - 1.0）</li>
</ul>
</li>
<li><strong>ScaleAnimation（缩放动画）</strong>：<ul>
<li>fromXScale：动画开始时视图的X轴缩放比例</li>
<li>toXScale：动画结束时视图的X轴缩放比例</li>
<li>fromYScale：动画开始时视图的Y轴缩放比例</li>
<li>toYScale：动画结束时视图的Y轴缩放比例</li>
<li>pivotX：X轴的缩放中心点</li>
<li>pivotY：Y轴的缩放中心点</li>
</ul>
</li>
<li><strong>TranslateAnimation（位移动画）</strong>：<ul>
<li>fromXDelta：动画开始时视图在X轴的位置</li>
<li>toXDelta：动画结束时视图在X轴的位置</li>
<li>fromYDelta：动画开始时视图在Y轴的位置</li>
<li>toYDelta：动画结束时视图在Y轴的位置</li>
</ul>
</li>
<li><strong>RotateAnimation（旋转动画）</strong>：<ul>
<li>fromDegrees：动画开始时视图的旋转角度</li>
<li>toDegrees：动画结束时视图的旋转角度</li>
<li>pivotX：旋转的中心点X坐标</li>
<li>pivotY：旋转的中心点Y坐标</li>
</ul>
</li>
</ol>
<p>以上每种动画类型的属性都可以在 XML 中定义，也可以在代码中动态设置。除了这些特定的属性外，所有的补间动画还有一些共同的属性，例如：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>fillAfter：动画结束后，视图是否保持动画结束时的状态</li>
<li>fillBefore：动画开始前，视图是否保持动画开始时的状态</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatMode：动画的重复模式（重新开始或反向执行）</li>
<li>interpolator：动画的插值器（用于控制动画的速度变化）</li>
</ul>
<p>区域问题</p>
<p>补间动画虽然能对控件做动画 ，但是并没有改变控件内 部 的属性值 。也就是说只是做了动画，它的位置属性啥的都没有变。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>补问动画和逐帧动画统称为视图动画 ，从字面意思 中可以看 出，这两个动画只能对派生自 View 类的控件实例起作用； 而属性动画则不同，从名字 中可以看出它应该是作用于控件属性的 。<strong>正因为属性动画 能够只针对控件的某一个属性来做动画，所以造就了它能单独改变控件某一个属性的值 ，比如颜色 。</strong></p>
<p>属性动画分为ValueAnimator 和 ObjectAnimator 。</p>
<h3 id="ValueAnimator-："><a href="#ValueAnimator-：" class="headerlink" title="ValueAnimator ："></a><strong>ValueAnimator</strong> ：</h3><p>简单使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">   animator.setDuration(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 在这里监听</span></span><br><span class="line">   animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">       <span class="comment">// 可以在这里根据value值对View进行操作</span></span><br><span class="line">       <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">       loge(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   animator.start()</span><br></pre></td></tr></table></figure>

<p>比如用来移动View</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">		<span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(value, value, value + imageView.width, value + imageView.height)</span><br><span class="line">        &#125;</span><br><span class="line">	    animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationStart&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationEnd&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationRepeat&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        animator.start()</span><br><span class="line">	    <span class="comment">//无限次重复的动画必须得在合适的时机cancel</span></span><br><span class="line">        animator.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View就会沿着从左上角到右下角的对角线进行移动。1秒钟完成动画，然后无限次的重复动画。</p>
<h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">animator.interpolator = AccelerateDecelerateInterpolator()</span><br></pre></td></tr></table></figure>

<p>Android SDK 提供了多种内置的插值器：</p>
<ol>
<li><code>LinearInterpolator</code>: 时间和动画进度之间是线性关系，也就是匀速运动。</li>
<li><code>AccelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐加快。</li>
<li><code>DecelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐减慢。</li>
<li><code>AccelerateDecelerateInterpolator</code>: 动画开始时速度逐渐加快，然后在结束时速度逐渐减慢。</li>
<li><code>AnticipateInterpolator</code>: 开始时，先向相反方向改变一段距离，然后再沿正常方向开始动画。</li>
<li><code>OvershootInterpolator</code>: 动画结束时，会超出目标值一些，然后再弹回来。</li>
<li><code>AnticipateOvershootInterpolator</code>: 开始时向相反方向改变，结束时超出目标值，然后再弹回。</li>
<li><code>BounceInterpolator</code>: 动画结束时，会像弹球一样多次弹跳。</li>
<li><code>CycleInterpolator</code>: 动画会循环指定的次数，每次循环都包括一个正向和一个反向的动画。</li>
<li><code>FastOutSlowInInterpolator</code>: 开始时快速，然后慢慢减速。</li>
</ol>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">100</span>, <span class="number">400</span>)</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">        loge(currentValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里currentValue的计算公式为，比如都到了全程的百分二十</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentValue = 100 + (400 -100)x 0.2</span><br></pre></td></tr></table></figure>

<p>这个0.2也就是进度值时插值器里的getinterpolatio方法返回的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getInterpolation</span><span class="params">(<span class="type">float</span> input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>input 参数与任何我们设定的值没有关系，只与时间有关 ，随着时间的推移，动画的进度也自然地增加，input 参数就代表了当前动画的进度，而返回值则表示动画的当前数值进度。</p>
<p>Linearlnterpolator插值器中就直接返回了input</p>
<p>所以自定义插值器只需要实现TimeInterpolator 接口然后自定义getInterpolation方法的返回值就可以了。</p>
<h3 id="Evaluator估值器"><a href="#Evaluator估值器" class="headerlink" title="Evaluator估值器"></a>Evaluator估值器</h3><p>作用：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1705668341835.jpg" alt="1705668341835"></p>
<p>我们通过监昕器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值 。 那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator 。Evaluator 用 于将从插值器返回的数值进度转换成对应的数值。</p>
<p>oflnt（）和ofFloat（）都是系统直接提供的函数 ，所以会有默认的插值器和 Evaluator 可供使用 。</p>
<p>以IntEvaluator为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startInt</span> <span class="operator">=</span> startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>(int)(startInt + fraction * (endValue - startInt))</code>就等价于上面的<code>currentValue = 100 + (400 -100)×进度值</code></p>
<p>自定义Evaluator</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEvaluator</span> : <span class="type">android.animation.TypeEvaluator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Int</span>, endValue: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.setEvaluator(ReverseEvaluator())</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(imageView.left, currentValue, imageView.right, currentValue + imageView.height)</span><br><span class="line">            loge(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br></pre></td></tr></table></figure>

<p>最终实现了View从下到上也就是从终点到起点的运动。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p><strong>ValueAnimator 有一个缺点 ，就是只能对动画中的数值进行计算 。</strong> 如果想对那个个控件执行操作，就需要监听 ValueAnimator 的动画过程，相比于补间动画要烦琐得多 。所以在 ValueAnimator 的基础上派生了 一个类 ObjectAnimator 。ObjectAnimator 是直接针对属性进行改变。 </p>
<p><strong>简单使用</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">    <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView,<span class="string">&quot;alpha&quot;</span>,<span class="number">0f</span>,<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// 一次的动画时常为2000毫秒</span></span><br><span class="line">    animator.setDuration(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">    animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">    animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">    animator.start()</span><br></pre></td></tr></table></figure>

<p>代码设置了imageView的透明度的从0到1的变化动画，ObjectAnimator 做动画，并不是根据控件XML 中的属性来改变的，而是通过指定属性所对应的 set 函数来改变的。View类中定义了alpha的set函数。</p>
<h3 id="ObjectAnimator动画原理"><a href="#ObjectAnimator动画原理" class="headerlink" title="ObjectAnimator动画原理"></a>ObjectAnimator动画原理</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122162025356.png" alt="image-20240122162025356"></p>
<p>​		在 ObjectAnimator 的动画流程中，先通过插值器产生当前进度的百分比，然后再经过 Evaluator 生成对应百分比所对应的数字值 。 这两步与 ValueAnimator 的动画流程是完全一样的，唯一不同的是最后一步，在 ValueAnimator 中，需要通过添加监昕器来监昕当前的数值；而在 ObjectAnimator 中，则先根据属性值拼装成对应的 set 函数的名 字（ 比如这里的scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，得到 setScaleY ），然后通过反射找到对应控件的setScaleY (float scale Y）函数，井将当前的数值作为setScaleY (floatscaleY）函数的参数传入 。</p>
<p>​		第一，拼接 set 函数的方法。<strong>首先强制将属性的第一个字母大写 ，然后与 set 拼接</strong>，就得到对应的 set 函数的名字。注意，只是强制将属性的第一个字母大写 ，后面的部分是保持不变的 。反过来， 如果我们的函数名为 setScalePointX（），那么在写属性时可以写成 scalePointX 或者 ScalePointX，<strong>即第一个字母大小写随意，但是后面的部分必须与set 函数后面部分的大小写保持一致 。找函数这一步是通过反射来实现的。</strong></p>
<p>​		第二，如何确定函数的参数类型？我们知道了如何找到对应的函数名，那么对应方法中的参数类型如何确定呢？我们在介绍 ValueAnimator 的时候说过，动画过程中产生的数值与构造时传入的值类型是一样的。由于 ObjectAnimator 与 ValueAnimator 在插值器和 Evaluator 这两步是完全一样的，而当前的动画数值是在 Evaluator 这一步产生的，所以 ObjectAnimator 的动画中产生的数值类型与构造时传入的值类型也是一样的。</p>
<p>​		第三，调用set 函数以后怎么办 ？从ObjectAnimator 的动画流程中可以看到，ObjectAnimator 只负责把动画过程中的数值传到对应属性的 s et 函数中就结束了。注意，传给set 函数以后就结束了！set 函数就相当于我们在ValueAnimator 中添加的监听器，set 函数中对控件的操作还是需要由我们自己来写的。</p>
<h3 id="自定义-ObjectAnimator-属性"><a href="#自定义-ObjectAnimator-属性" class="headerlink" title="自定义 ObjectAnimator 属性"></a>自定义 ObjectAnimator 属性</h3><p>在自定义View的时候，可以来自定义一个属性来实现动画的载体。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">       <span class="keyword">set</span>(value) &#123;</span><br><span class="line">           field = value</span><br><span class="line">           invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">           <span class="keyword">by</span> lazy &#123;</span><br><span class="line">               ObjectAnimator.ofFloat(</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                   <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中floatingLabelFraction就是自定义的属性，然后再ofFloat方法中的target设置为this。</p>
<p>当且仅当动画只有一个过渡值时，系统才会调用对应属性的 get 函数来得到动画的初始值。如下面</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">&quot;floatingLabelFraction&quot;</span>, <span class="number">1f</span> )</span><br></pre></td></tr></table></figure>

<p>当不存在 get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h3 id="组合动画AnimatorSet"><a href="#组合动画AnimatorSet" class="headerlink" title="组合动画AnimatorSet"></a>组合动画AnimatorSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translation</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  <span class="comment">// 平移动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);  <span class="comment">// 旋转动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 透明度动画 // 创建组合动画的对象 </span></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();  <span class="comment">// 根据需求组合动画 </span></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  <span class="comment">//启动动画 </span></span><br><span class="line">animSet.start()</span><br></pre></td></tr></table></figure>

<p>常用的组合方法</p>
<ul>
<li>AnimatorSet.play(Animator anim)   ：播放当前动画</li>
<li>AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行</li>
<li>AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行</li>
<li>AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行</li>
<li>AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行</li>
</ul>
<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>PropertyValuesHolder 类的含义就是 ，它其 中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内 部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态 的 。在封装成Prope向NaluesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframeO</span> <span class="operator">=</span> Keyframe . ofFloat(Of , <span class="number">1</span>);</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframel</span> <span class="operator">=</span> Keyframe.ofFloat(O.lf , <span class="number">1.</span>lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframe9</span> <span class="operator">=</span> Keyframe .ofFloat(<span class="number">0</span> . <span class="number">9f</span> , l . lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframelO</span> <span class="operator">=</span> Keyframe . ofFloat(l , <span class="number">1</span>) ;</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">frameHolder2</span> <span class="operator">=</span> PropertyValuesHolder . ofKeyframe (” ScaleX”,</span><br><span class="line">scaleXframeO , scaleXframel, scaleXframe9 , scaleXframelO) ;</span><br><span class="line"> <span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(mimage,frameHolderl,frameHolder2,frameHolder3);</span><br><span class="line">        animator.setDuration(lOOO);</span><br><span class="line">        animator.start();</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator 中唯一一个能实现多动画同时播放的方法。</p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>为 View 的动画操作提供一种更加便捷的用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tvText.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> animator = tvText.animate()</span><br><span class="line">    animator.duration=<span class="number">1000</span></span><br><span class="line">    animator.translationX(<span class="number">100f</span>)<span class="comment">//点击一次会向右偏移，再点击没效果</span></span><br><span class="line">    animator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
