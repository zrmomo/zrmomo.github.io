<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java JVM</title>
    <url>/2024/01/25/JavaJVM/</url>
    <content><![CDATA[<h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h1><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122212026094.png" alt="image-20240122212026094"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​		程序计数器可以看作是当前<strong>线程所执行的字节码的行号指示器。</strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>​		在java多线程中一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​		Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口等信息。</strong>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>​		局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>​		<strong>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示</strong>，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​		本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>​		Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java<br>世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>​		<strong>逃逸分析</strong>：</p>
<p>​		这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>​		逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>二、<strong>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</strong></p>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>​	问：是不是所有的对象和数组都会在堆内存分配空间？</p>
<p>​	答：不一定，随着JIT编译器的发展，在编译期间，如果JIT(即时编译）经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。在开启逃逸分析之后，也并不是所有对象都没有在堆上分配。<a href="https://juejin.cn/post/6844903639308304397#heading-2">#</a></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​		方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p>
<p>​		方法区只是一个规范，Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。永久代（PermGen区）用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代（PermGen区）中。</p>
<p>​		但在Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了本地内存（Native memory）；字符串常量池(interned strings)转移到了Java 堆（heap）中；<strong>类的静态变量(class statics)转移到了Java Heap。</strong></p>
<p>​		在Java8中取消了永久代，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。</p>
<p>本地内存：</p>
<p>堆内存是Java程序运行的主要内存区，由JVM自动管理，主要用于存储Java对象。本地内存则是由操作系统管理，需要程序员手动管理，主要用于执行本地方法和存储直接缓冲区。</p>
<p>java8下的内存模型</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/16f04cdf3a0ba3ea%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="img"></p>
<p>方法区版本变迁：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101535441.png" alt="在这里插入图片描述"></p>
<p>常量池和静态变量的存储位置：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101554905.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101603471.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101611971.png" alt="在这里插入图片描述"></p>
<p>总结一下：</p>
<p>在1.6及以前方法区由永久代实现在堆物理内存中，静态变量和运行时常量池在永久代，字符串常量池也在运行时常量池中。</p>
<p>在1.7运行时常量池在永久代，将静态变量和字符串常量池移到了堆中</p>
<p>在1.8 方法区由元空间实现在本地内存中，静态变量和字符串常量池仍然在堆空间中</p>
<p><a href="https://blog.csdn.net/wanderlustLee/article/details/80762851">引用博客</a></p>
<p><a href="https://blog.csdn.net/alex6586/article/details/107757796">引用博客2</a></p>
<p>Java中基本数据类型存储在JVM中的存储位置？</p>
<p>简单来说：这取决于变量的声明位置，而不是它的类型。</p>
<p>局部变量存储在栈中，<a href="https://so.csdn.net/so/search?q=%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">实例变量</a>和静态变量存储在堆中。</p>
<p>也就是说，基本数据类型如果声明在方法内，那么它就存储在栈中，如果声明在类的成员或声明为 <code>static</code> 那么就存储在堆中</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​		运行时常量池（Runtime Constant Pool）是方法区的一部分。<strong>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>​		除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​		<strong>运行时常量池一个重要特征是具备动态性运行期间也可以将新的常量放入池中</strong>，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>​		既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<p>​		这里会存储类静态属性的引用，但是所引用的对象存放在堆中。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>​		在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，<strong>引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>new Person()</code>创建了一个新的<code>Person</code>对象存放在堆中，<code>person</code>是一个引用声明为局部变量存放在栈中，声明为成员变量就存储在堆中，它指向这个新创建的<code>Person</code>对象。</strong></p>
<p>​		当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>​		对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p>
<p>​		内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<p>​		对象头通常包含了关于对象的元数据，如哈希码、GC状态信息、类元数据的引用等。这部分内容在创建对象时由JVM处理，不会被初始化为零。</p>
<p>​		实例字段（也就是我们通常说的对象的属性或成员变量）在对象创建时，如果我们没有明确给它们赋值，那么它们就会被初始化为对应类型的零值。具体的零值取决于字段的数据类型：</p>
<ul>
<li>对于数值类型（如int, long, double等），零值就是0。</li>
<li>对于布尔类型（boolean），零值是false。</li>
<li>对于字符类型（char），零值是null字符（’\u0000’）。</li>
<li>对于引用类型（如类、接口、数组等），零值是null。</li>
</ul>
<p>这样做的好处是，可以确保在任何情况下，只要对象被创建，它的实例字段就可以被安全地访问，不会出现未定义的状态。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 JVM 中，Java对象保存在堆中时，由以下三部分组成：</p>
<ul>
<li><strong>对象头（object header）</strong>：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。</li>
<li><strong>实例数据（Instance Data）</strong>：主要是存放类的数据信息，父类的信息，对象字段属性信息。</li>
<li><strong>对齐填充（Padding）</strong>：为了字节对齐，填充的数据，不是必须的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200917170455322-1670500196.png" alt="img"></p>
<p><strong>对象头：</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200917170544775-1625770619.png" alt="img"></p>
<p>Mark Word在32位JVM中是这么存的</p>
<p><a href="https://img2020.cnblogs.com/blog/1162587/202009/1162587-20200918154115022-312986152.png"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200918154115022-312986152.png" alt="img"></a></p>
<p>在64位JVM中是这么存的</p>
<p><a href="https://img2020.cnblogs.com/blog/1162587/202009/1162587-20200918154125385-1537793659.png"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200918154125385-1537793659.png" alt="img"></a></p>
<p>虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。</p>
<ul>
<li><strong>锁标志位（lock）</strong>：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</li>
<li><strong>biased_lock</strong>：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</li>
<li><strong>分代年龄（age）</strong>：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li><strong>对象的hashcode（hash）</strong>：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。</li>
<li><strong>偏向锁的线程ID（JavaThread）</strong>：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li>
<li><strong>epoch</strong>：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
<li><strong>ptr_to_lock_record</strong>：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li>
<li><strong>ptr_to_heavyweight_monitor</strong>：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li>
</ul>
<p>​		<strong>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</strong></p>
<p><strong>实例数据：</strong></p>
<p>如果对象有属性字段，则这里会有数据信息。如果对象无属性字段，则这里就不会有数据。根据字段类型的不同占不同的字节，例如boolean类型占1个字节，int类型占4个字节等等；</p>
<p><strong>对齐数据</strong><a href="https://www.cnblogs.com/jajian/p/13681781.html#%E5%AF%B9%E9%BD%90%E6%95%B0%E6%8D%AE">#</a></p>
<p>对象可以有对齐数据也可以没有。默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节则需要对其填充，以此来补齐对象头和实例数据占用内存之后剩余的空间大小。如果对象头和实例数据已经占满了JVM所分配的内存空间，那么就不用再进行对齐填充了。</p>
<p>所有的对象分配的字节总SIZE需要是8的倍数，如果前面的对象头和实例数据占用的总SIZE不满足要求，则通过对齐数据来填满。</p>
<p><strong>其实对其填充的最终目的是为了计算机高效寻址。</strong></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>也就是栈中的指针访问到堆中对象的方式，主流的访问方式主要有使用句柄和直接指针两种：</p>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240123202431236.png" alt="image-20240123202431236"></p>
<ul>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240123202532036.png" alt="image-20240123202532036"></p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​		这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<ul>
<li><p>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p>
</li>
<li><p>在方法区中类<strong>静态属性引用（这里的只是引用在方法区对象还是在堆）</strong>的对象，譬如Java类的引用类型静态变量。</p>
</li>
<li><p>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</p>
</li>
<li><p>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
</li>
<li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如<br>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li><p>所有被同步锁（synchronized关键字）持有的对象。</p>
</li>
<li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
<li></li>
</ul>
<p>区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量/属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STATIC_CONST</span> <span class="operator">=</span> <span class="string">&quot;Static Constant&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量（普通变量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONST</span> <span class="operator">=</span> <span class="string">&quot;Constant&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法中的局部变量和常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
</li>
</ul>
<h2 id="对象的生存与死亡"><a href="#对象的生存与死亡" class="headerlink" title="对象的生存与死亡"></a>对象的生存与死亡</h2><p>​		要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>​		如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<p>​		finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，<strong>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；</strong>如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<p><strong>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行</strong></p>
<h2 id="垃圾回收算法以及分代收集理论"><a href="#垃圾回收算法以及分代收集理论" class="headerlink" title="垃圾回收算法以及分代收集理论"></a>垃圾回收算法以及分代收集理论</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
<p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
<p>基于这两个假说出现了垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p>
<p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。</p>
<p>基于新生代和老年代相互引用的情况，出现了第三条假说：</p>
<p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<p>存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<p>基于这个假说就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在<strong>新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</strong>此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。</p>
<p><strong>回收类型概念</strong>：</p>
<ol>
<li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li>
</ol>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​		算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。</p>
<p><strong>缺点：</strong></p>
<p>​		第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p>
<p>​		第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>​		它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>​		如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>
<p>​		缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​		针对老年代对象的存亡特征，提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器#"></a>垃圾收集器<a href="https://huminxi.netlify.app/2022/07/06/java%208%20vs%20java%2017%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">#</a></h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/gc-preview.png" alt="img"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>​		Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机<strong>新生代收集器</strong>的唯一选择。当它使用<strong>标记-复制算法</strong>进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p>​		这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p>​		优点：简单、高效、它是所有收集器里额外内存消耗最小的；在资源匮乏的环境下的不二之选。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的<strong>老年代</strong>版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。</p>
<p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<blockquote>
<p>它是客户端模式下的老年代收集器。在服务端模式下有两种用途：一种是在 JDK 5 及之前的版本中与 Parallel Scavenge 收集器配合使用；另一种就是在 CMS 收集器发生 <a href="https://www.zhihu.com/question/50398881">Concurrent Mode Failure</a> 时使用（处理浮动垃圾和内存碎片）。</p>
</blockquote>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew <strong>实质上是 Serial 收集器的多线程并行版本</strong>。除了同时使用多条线程进行垃圾收集之外，其余行为都与 Serial 收集器完全一致。</p>
<blockquote>
<p>ParNew 与 Serial 相比并没有太多创新之处，但它却是许多运行在服务端模式下的 HotSpot 虚拟机（尤其是 JDK 7 之前）首选的新生代收集器。其中一个很重要的原因是：除了 Serial 收集器之外，只有它能与 CMS 收集器配合工作。</p>
</blockquote>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>它是基于<strong>标记-复制</strong>算法实现的<strong>新生代</strong>收集器，也是能够并行收集的多线程收集器。与另一个并行收集器 ParNew 相比，Parallel Scavenge 关注的是吞吐量（Throughput）。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240125214740599.png" alt="image-20240125214740599"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持多线程并发收集（不会停止工作线程），基于<strong>标记-整理</strong>算法实现。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是基于<strong>标记-清除</strong>算法实现的老年代垃圾收集器，CMS的工作方式包括：</p>
<ol>
<li><strong>初始标记（Initial Mark）：</strong> 在初始标记阶段，<strong>CMS会暂停应用程序线程</strong>，标记所有的GC Roots，以及直接与GC Roots有关联的对象。</li>
<li><strong>并发标记（Concurrent Mark）：</strong> CMS通过并发标记阶段来标记所有可达的对象，尽量减少暂停时间。</li>
<li><strong>重新标记（Remark）：</strong> 在并发标记之后，<strong>CMS需要进行一次短暂的暂停</strong>来处理在并发标记期间产生的新的引用关系。</li>
<li><strong>并发清除（Concurrent Sweep）：</strong> 在重新标记后，CMS会并发地清理未标记的对象，释放空间</li>
</ol>
<p>由于CMS在标记和清理过程中尽量减少了停顿时间，因此它适合用于那些对停顿时间敏感的应用。然而，CMS也有一些缺点，例如可能产生碎片，以及在某些情况下可能需要进行Full GC。在Java 9及以后版本，G1（Garbage-First）收集器逐渐取代了CMS作为更先进的垃圾收集器。</p>
<ol>
<li>初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；</li>
<li>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</li>
<li>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ol>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器#"></a>Garbage First收集器<a href="https://juejin.cn/post/6844903894196158471">#</a></h3><p>它开创了收集器<strong>面向局部收集</strong>的设计思路和<strong>基于Region（独立区域）</strong>的内存布局形式。G1收集器的名称源于其“Garbage-First”（G1）算法，<strong>该算法的目标是优先回收包含垃圾最多的Region。</strong>这有助于最大程度地减少堆中的垃圾。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</p>
<blockquote>
<p>G1 不再坚持固定大小以及固定数量的分代区域划分，而是<strong>把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。</strong>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。</p>
</blockquote>
<p>在 G1 收集器出现之前的所有收集器（包括 CMS 在内），垃圾收集的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set），衡量标准不再是它属于哪个分代，<strong>而是哪块内存中存放的垃圾数量最多，回收收益最大，优先处理回收收益最大的那些 Region，这也就是 Garbage First 名字的由来</strong>。</p>
<ul>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<p>相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。<strong>与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，</strong>无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<h2 id="Java8下的垃圾回收"><a href="#Java8下的垃圾回收" class="headerlink" title="Java8下的垃圾回收"></a>Java8下的垃圾回收</h2><p>java8使用的收集器是Parallel Scavenge加Parallel Old组合，Parallel Scavenge是基于<strong>标记-复制</strong>算法实现的<strong>新生代</strong>收集器，Parallel Old是基于<strong>标记-整理</strong>算法实现老年代收集器。</p>
<p>分代下的内存回收策略：</p>
<ul>
<li><strong>对象优先在Eden区分配</strong></li>
<li><strong>大对象直接进入老年代</strong></li>
<li><strong>长期存活的对象进入老年代</strong></li>
<li><strong>对象年龄的动态判断</strong></li>
<li><strong>空间分配担保</strong></li>
</ul>
<p>Java堆内存被划分为物理上隔开的2个大区域：</p>
<ul>
<li><strong>青年代Young Generation</strong></li>
<li><strong>老年代Old Generation</strong></li>
</ul>
<p>其中青年代(新生代)又分为了3个独立的区域：</p>
<ul>
<li><strong>Eden</strong></li>
<li><strong>Survivor</strong></li>
<li><strong>Survivor</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-450e07949f232db9fc7909c3e553ab2f_720w.webp" alt="img"></p>
<p><strong>Eden</strong>：大多数新建的Java对象被分配到这里(少数很大的对象会直接划分在老年代)，MinorGC（新生代的垃圾收集）后，此区域内的对象大多数被GC清理干净，释放内存，只有少数躲过了GC，从而提升至Survivor区域。</p>
<p><strong>Survivor</strong>：青年代中含有两个Survivor区域，为什么？因为青年代采用的是复制算法，复制算法会将左边已经使用过的对象复制到右边Survivor未使用区域，然后对左边Survivor区域做一次GC垃圾回收。存放在Survivor区域的对象，都是经历过至少1此MinorGC的，如果在此区域的对象能够顺利躲过多次MinorGC，则会提升至老年代。</p>
<p><strong>对象优先在Eden区分配</strong></p>
<p><strong>大多数情况下，新生的对象会直接在Eden区域分配内存，当内存不够时，虚拟机将会发动一次MinorGC。</strong></p>
<blockquote>
<p>MinorGC：在年轻代内存区域上的垃圾收集过程，因为大多数在年轻代上的对象“朝生夕灭”，所以MinorGC非常频繁，一般收集的速度也很快。<br>MajorGC&#x2F;Full GC：指发生在老年代的GC，此区域一般对象存活率高，GC一次的速度同城比MinorGC慢10倍以上。</p>
</blockquote>
<p><strong>大对象直接进入老年代</strong></p>
<p>所谓的大对象是指需要大量连续内存空间的Java对象，长字符串及大容量的数组。安放这些大对象，虚拟机会直接将其放在老年代，因为大对象一般涉及到的引用多，不容易「死」掉。而且大对象占内存，所以直接在老年代为其开辟一块连续的内存就比较合适。如果内存不够分配，虚拟机会触发垃圾收集过程。</p>
<p><strong>长期存活的对象进入老年代</strong></p>
<p>既然虚拟机采用分代收集的策略来管理内存，那么内存回收时就应该相应的判别哪些对象该放在青年代，哪些放在老年代。为此，JVM给每个对象定义了一个<strong>「年龄」</strong>计数器。如果对象在Eden出生，并且经过一次MinorGC后仍然存在，则「年龄」增加1岁。当年龄增加到一定数目(如：默认为15岁)，就会被<strong>「提升」</strong>至老年代。部分虚拟机提供了参数可以设置此<strong>年龄「阈值」</strong>。</p>
<p>青年代和老年代在Java堆内存上被划分为两块不同的物理区域，其中青年代中又单独划分成了三块——Eden+Survivor+Survivor。在这些不同区域上任何一个内存“满”了以后，都会触发一次垃圾收集过程。Java中绝大部分的新创建的对象都被分配到了青年代中的Eden区，当青年代满了，就会触发一次在青年代上的垃圾收集过程。</p>
<blockquote>
<p><strong>注意</strong>：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代 GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的 <code>card table</code>，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 <code>card table</code> 即可，大大提高了性能。</p>
</blockquote>
<p><strong>动态对象年龄判定</strong></p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远要求对象年龄必须达到「阈值」才能提升至老年代。在有的垃圾收集器实现中，如果Survivor空间中相同年龄的对象占用空间&gt;Survivor总空间的一半，则此年龄的所有对象就可以提前进入老年代，而不是必须达到阈值。</p>
<p><strong>空间分配担保</strong></p>
<p>在MinorGC之前，JVM会首先检查老年代最大可用的连续内存空间是否 &gt; 青年代所有对象总空间，并以其作为MajorGC执行的「担保」。如果大于则MinorGC可以正常执行。否则JVM会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，则继续执行MinorGC，否则则执行MajorGC用来回收足够的内存空间</p>
]]></content>
  </entry>
  <entry>
    <title>Android 虚拟机</title>
    <url>/2024/02/02/Android%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="Android-虚拟机"><a href="#Android-虚拟机" class="headerlink" title="Android 虚拟机"></a>Android 虚拟机</h1><p>在Android系统中，Java虚拟机是借由大名鼎鼎的Zygote进程来创建的。Zygote是Java世界的创造者——即Android中所有Java进程都由Zygote进程fork而来，而Zygote进程自己又是Linux系统上的init进程通过解析配置脚本来启动的。</p>
<h2 id="Dalvik-DVM"><a href="#Dalvik-DVM" class="headerlink" title="Dalvik DVM"></a>Dalvik DVM</h2><h3 id="与JVM对比"><a href="#与JVM对比" class="headerlink" title="与JVM对比"></a>与JVM对比</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-93cda252f04eaa29f9e0a3cd27ba2470_1440w.webp" alt="img"></p>
<p><strong>基于栈的虚拟机（如 Java 虚拟机 - JVM）：</strong></p>
<p>基于栈的虚拟机每一个运行的线程，都有一个独立的栈，栈中记录了方法调用的历史，每一个方法的调用，都对应一个栈帧，并且将栈帧压入栈中，最顶部的栈帧为当前栈帧，既 当前执行的方法，基于栈帧与操作数栈进行所有操作。</p>
<p>执行流程：</p>
<ul>
<li><strong>将栈顶某类型值存入局部变量某处</strong>：这是说，我们从栈（一种数据结构，可以想象成一摞盘子）的顶部取出一个值（就像取走最上面的盘子），然后把这个值放到我们的”局部变量”中。你可以把”局部变量”想象成一种存储区域，我们可以在那里放东西，以便稍后使用。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要暂时保存一些数据以便稍后使用时发生。例如，你可能正在计算一个复杂的表达式，需要将中间结果暂时保存下来，以便在稍后的计算中使用。这时，你就可以将这个中间结果（即栈顶的值）保存到局部变量中。</p>
</blockquote>
<ul>
<li><strong>将局部变量中某处某类型常量压入操作数栈</strong>：这是说，我们从”局部变量”中取出一个值（就像从抽屉里取出一件衣服），然后把这个值放到栈的顶部（就像把一个新盘子放到盘子堆的顶部）。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要使用之前保存的数据时发生。例如，你可能需要使用之前保存的中间结果来完成表达式的计算。这时，你就可以将这个中间结果（即局部变量中的值）压入栈中，以便进行接下来的计算。</p>
</blockquote>
<ul>
<li><strong>执行相关指令</strong>：这是说，我们要执行一些操作，这些操作可能会使用栈顶的值，也可能会改变栈顶的值，或者做其他的事情。这些操作是由虚拟机的指令集定义的，每一种指令都有特定的功能，例如加法、减法、乘法等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-404079569b9204d0783c7a324e201fcb_1440w.webp" alt="img"></p>
<p><strong>基于寄存器的虚拟机（如 Dalvik 虚拟机 - DVM）</strong>：</p>
<p>基于寄存器的虚拟机中没有操作数栈，不过有很多虚拟寄存器，类似操作数栈，这些寄存器也存放在运行时栈中，本质上就是一个数组，与JVM相似，在Dalvik 虚拟机中每个线程都有自己的程序计数器 和 调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p>
<blockquote>
<p>寄存器 CPU的组成部分，寄存器是有限存储容量的高速存储容器（计算机中各级存储速度 寄存器-&gt; 一级缓存-&gt;二级缓存 -&gt; 内存 -&gt; 硬盘），可以用来管理指令、数据的地址。</p>
</blockquote>
<p>执行流程：</p>
<p>直接依据指令，将某类型值存入虚拟寄存器中，相关的操作也依据指令在虚拟寄存器中通过CPU处理，将处理结果返回虚拟寄存器（省掉了基于栈的流程中局部变量与操作数栈中数据的流动）</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-f7c8576e5446b47136b6836b83c8caac_1440w.webp" alt="img"></p>
<p><a href="https://www.zhihu.com/question/20207106">借鉴文章</a></p>
<h3 id="DVM本身的优化"><a href="#DVM本身的优化" class="headerlink" title="DVM本身的优化"></a>DVM本身的优化</h3><ol>
<li>将多个类文件收集到同一个dex文件中，以便节省空间；</li>
<li>使用只读的内存映射方式加载dex文件，以便可以多进程共享dex文件，节省程序加载时间；</li>
<li>提前调整好字节序（byte order）和字对齐（word alignment）方式，使得它们更适合于本地机器，以便提高指令执行速度；</li>
<li>尽量提前进行字节码验证（bytecode verification），提高程序的加载速度；</li>
<li>需要重写字节码的优化要提前进行。</li>
</ol>
<h3 id="DVM内存管理"><a href="#DVM内存管理" class="headerlink" title="DVM内存管理"></a>DVM内存管理</h3><p>Dalvik虚拟机的内存大体上可以分为Java Object Heap、Bitmap Memory和Native Heap三种。</p>
<p><strong>Java Object Heap：</strong>用来分配Java对象的，也就是我们在代码new出来的对象都是位于Java Object Heap上的。</p>
<p><strong>Bitmap Memory：</strong>在Android 3.0之前，Bitmap Memory是在Native Heap中分配的，但是这部分内存同样计入Java Object Heap中，也就是说，Bitmap占用的内存和Java Object占用的内存加起来不能超过Java Object Heap的最大值。在Android 3.0以及更高的版本中，<strong>Bitmap Memory就直接是在Java Object Heap中分配了，这样就可以直接接受GC的管理。</strong>Native Heap就是在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<p><strong>Native Heap：</strong>在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<h3 id="简述GC"><a href="#简述GC" class="headerlink" title="简述GC"></a>简述GC</h3><p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h3 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译(JIT)"></a>即时编译(JIT)</h3><p>JIT是相对AOT而言的，即JIT是在程序运行的过程中进行编译的，而AOT是在程序运行前进行编译的</p>
<h3 id="DVM进程和线程管理特点"><a href="#DVM进程和线程管理特点" class="headerlink" title="DVM进程和线程管理特点"></a>DVM进程和线程管理特点</h3><ol>
<li>每一个Android应用程序进程都有一个Dalvik虚拟机实例。这样做的好处是Android应用程序进程之间不会相互影响，也就是说，一个Android应用程序进程的意外中止，不会影响到其它的Android应用程序进程的正常运行。</li>
<li>每一个Android应用程序进程都是由一种称为Zygote的进程fork出来的。Zygote进程是由init进程启动起来的，也就是在系统启动的时候启动的。Zygote进程在启动的时候，会创建一个虚拟机实例，并且在这个虚拟机实例将所有的Java核心库都加载起来。每当Zygote进程需要创建一个Android应用程序进程的时候，它就通过复制自身来实现，也就是通过fork系统调用来实现。这些被fork出来的Android应用程序进程，一方面是复制了Zygote进程中的虚拟机实例，另一方面是与Zygote进程共享了同一套Java核心库。这样不仅Android应用程序进程的创建过程很快，而且由于所有的Android应用程序进程都共享同一套Java核心库而节省了内存空间。</li>
</ol>
<h3 id="DVM启动分析"><a href="#DVM启动分析" class="headerlink" title="DVM启动分析"></a>DVM启动分析</h3><p>启动过程主要就是完成了以下四个事情：</p>
<ol>
<li>创建了一个Dalvik虚拟机实例；</li>
<li>加载了Java核心类及其JNI方法；</li>
<li>为主线程的设置了一个JNI环境；</li>
<li>注册了Android核心类的JNI方法。</li>
</ol>
<p>​		Zygote进程为Android系统准备好了一个Dalvik虚拟机实例，以后Zygote进程在创建Android应用程序进程的时候，就可以将它自身的Dalvik虚拟机实例复制到新创建Android应用程序进程中去，从而加快了Android应用程序进程的启动过程。此外，Java核心类和Android核心类（位于dex文件中），以及它们的JNI方法（位于so文件中），都是以内存映射的方式来读取的，因此，<strong>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。</strong></p>
<h3 id="DVM下的GC"><a href="#DVM下的GC" class="headerlink" title="DVM下的GC"></a>DVM下的GC</h3><p><a href="https://jasonzhong.github.io/2017/09/28/Android-%E6%B5%85%E6%9E%90-GC-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">Android-浅析-GC-基础原理</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/41822747">Dalvik虚拟机垃圾收集（GC）过程分析</a></p>
<p>Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做Active Heap，另一部分叫做Zygote Heap。<strong>Zygote堆用来管理Zygote进程在启动过程中预加载和创建的各种对象</strong>，而Active堆是在Zygote进程fork第一个子进程之前创建的。之后无论是Zygote进程还是其子进程，都在Active堆上进行对象分配和释放。这样做的目的是使得Zygote进程和其子进程最大限度地共享Zygote堆所占用的内存。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240127151630567.png" alt="image-20240127151630567"></p>
<p>Dalvik虚拟机需要一些辅助数据结构，包括一个Card Table、两个Heap Bitmap和一个Mark Stack。</p>
<p>Card Table：记录在垃圾收集过程中对象的引用情况的，以便可以实现Concurrent G。</p>
<p>Live Heap Bitmap：用来记录上次GC之后，还存活的对象</p>
<p>Mark Heap Bitmap：用来记录当前GC中还存活的对象。</p>
<p>上次GC后存活的但是当前GC不存活的对象，就是需要释放的对象。<strong>Davlk虚拟机使用标记-清除（Mark-Sweep）算法进行GC。</strong>在标记阶段，通过一个<strong>Mark Stack来实现递归检查被引用的对象</strong>，即在当前GC中存活的对象。有了这个Mark Stack，就可以通过循环来模拟函数递归调用。Mark阶段从根集（Root Set）开始，递归地<strong>标记出当前所有被引用的对象</strong>，而Sweep阶段负责回收那些没有被引用的对象。</p>
<p>在分析Dalvik虚拟机使用的Mark-Sweep算法之前，我们先来了解一下什么情况下会触发GC。Dalvik虚拟机在三种情况下会触发四种类型的GC。</p>
<p>jvm将GC抽象成了一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GcSpec</span> &#123;    </span><br><span class="line">  <span class="type">bool</span> isPartial;  <span class="comment">// 为true时，表示仅仅回收Active堆的垃圾；为false时，表示同时回收Active堆和Zygote堆的垃圾。</span></span><br><span class="line">  <span class="type">bool</span> isConcurrent; <span class="comment">// 为true时，表示执行并行GC；为false时，表示执行非并行GC。</span></span><br><span class="line">  <span class="type">bool</span> doPreserve;  <span class="comment">// 为true时，表示在执行GC的过程中，不回收软引用引用的对象；为false时，表示在执行GC的过程中，回收软引用引用的对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *reason;  <span class="comment">// 描述</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>然后产生了四种GC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_FOR_MALLOC;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_CONCURRENT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_EXPLICIT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_BEFORE_OOM;  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GC_FOR_MALLOC</strong>: 表示是在堆上分配对象时内存不足触发的GC。</li>
<li><strong>GC_CONCURRENT</strong>: 表示是在已分配内存达到一定量之后触发的GC。</li>
<li><strong>GC_EXPLICIT</strong>: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。</li>
<li><strong>GC_BEFORE_OOM</strong>: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</li>
</ul>
<p>GC_FOR_MALLOC、GC_CONCURRENT和GC_BEFORE_OOM三种类型的GC都是在分配对象的过程触发的</p>
<p>Dalvik虚拟机支持非并行和并行两种GC,它们的总体流程是相似的，主要差别在于前者在执行的过程中一直是挂起非GC线程的，而后者是有条件地挂起非GC线程。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20Dalvik%20GC.png" alt="Android Dalvik GC"></p>
<p>以上就是并行和非并行GC的执行总体流程，它们的主要区别在于，<strong>前者在GC过程中，有条件地挂起和唤醒非GC线程，而后者在执行GC的过程中，一直都是挂起非GC线程的。</strong>并行GC通过有条件地挂起和唤醒非GC线程，就可以使得应用程序获得更好的响应性。但是我们也应该看到，并行GC需要多执行一次标记根集对象以及递归标记那些在GC过程被访问了的对象的操作。也就是说，并行GC在使用得应用程序获得更好的响应性的同时，也需要花费更多的CPU资源。</p>
<p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>下面都是基于Android4.4</p>
<h3 id="ART替换DVM"><a href="#ART替换DVM" class="headerlink" title="ART替换DVM"></a>ART替换DVM</h3><p>ART虚拟机，它和Dalvik虚拟机、Java虚拟机的关系如图1所示：<br><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/d3c3b501eff5f127d1227631137b4c81_653x445.png" alt="d3c3b501eff5f127d1227631137b4c81_653x445">Dalvik虚拟机和ART虚拟机都实现了三个用来抽象Java虚拟机的接口：</p>
<ol>
<li>JNI_GetDefaultJavaVMInitArgs – 获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM – 在进程中创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs – 获取进程中创建的虚拟机实例</li>
</ol>
<p>在Android系统中，Davik虚拟机实现在libdvm.so中，ART虚拟机实现在libart.so中。也就是说，libdvm.so和libart.so导出了JNI_GetDefaultJavaVMInitArgs、JNI_CreateJavaVM和JNI_GetCreatedJavaVMs这三个接口，供外界调用。</p>
<p>此外，Android系统还提供了一个系统属性persist.sys.dalvik.vm.lib，它的值要么等于libdvm.so，要么等于libart.so。当等于libdvm.so时，就表示当前用的是Dalvik虚拟机，而当等于libart.so时，就表示当前用的是ART虚拟机。</p>
<p>以上描述的Dalvik虚拟机和ART虚拟机的共同之处，当然它们之间最显著还是不同之处。不同的地方就在于，<strong>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。</strong>这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8852432">Dalvik虚拟机简要介绍和学习计划</a>这个系列的文章。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，<strong>将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。</strong>因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>
<p>DVM在应用在安装的过程，其实也会执行一次“翻译”的过程。只不过这个“翻译”的过程是将dex字节码进行优化，也就是由dex文件生成odex文件。而ART将这个过程换成了直接翻译成机器码，从流程的角度来说没什么改变。</p>
<p>应用程序的安装发生在两个时机，<strong>第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。</strong>在第一个时机中，系统除了会对&#x2F;system&#x2F;app和&#x2F;data&#x2F;app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对&#x2F;system&#x2F;framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。</p>
<h3 id="ART简要介绍"><a href="#ART简要介绍" class="headerlink" title="ART简要介绍"></a>ART简要介绍</h3><p>在APK运行之前，就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了。这种技术不但使得我们可以不对原有的APK作任何修改，还可以使得这些APK只需要在安装时翻译一次，就可以无数次以本地机器指令的形式运行。在ART中，打包在APK里面的Dex字节码是通过LLVM翻译成本地机器指令的。LLVM是一个用来快速开发自己的编译器的框架系统</p>
<p>在ART运行时中，APK在安装的时候，安装服务PackageManagerService会通过守护进程installd调用另外一个工具dex2oat对打包在APK里面包含有Dex字节码进翻译。这个翻译器实际上就是基于LLVM架构实现的一个编译器，它的前端是一个Dex语法分析器。</p>
<p>ART的运行原理：</p>
<ul>
<li>在Android系统启动过程中创建的Zygote进程利用ART运行时导出的Java虚拟机接口创建ART虚拟机。</li>
<li>APK在安装的时候，打包在里面的classes.dex文件会被工具dex2oat翻译成本地机器指令，最终得到一个ELF格式的oat文件。</li>
<li>APK运行时，上述生成的oat文件会被加载到内存中，并且ART虚拟机可以通过里面的oatdata和oatexec段找到任意一个类的方法对应的本地机器指令来执行。</li>
</ul>
<h3 id="ART加载OAT文件"><a href="#ART加载OAT文件" class="headerlink" title="ART加载OAT文件"></a>ART加载OAT文件</h3><p>Android运行时ART，它的核心是OAT文件。OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p>APK在安装的过程中，会通过dex2oat工具生成一个OAT文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_dex2oat</span><span class="params">(<span class="type">int</span> zip_fd, <span class="type">int</span> oat_fd, <span class="type">const</span> <span class="type">char</span>* input_file_name,    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* output_file_name, <span class="type">const</span> <span class="type">char</span>* dexopt_flags)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* DEX2OAT_BIN = <span class="string">&quot;/system/bin/dex2oat&quot;</span>;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_INT_LEN = <span class="number">12</span>;      <span class="comment">// &#x27;-&#x27;+10dig+&#x27;\0&#x27; -OR- 0x+8dig    </span></span><br><span class="line">    <span class="type">char</span> zip_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> zip_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-location=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    <span class="type">char</span> oat_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> oat_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-name=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_fd_arg, <span class="string">&quot;--zip-fd=%d&quot;</span>, zip_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_location_arg, <span class="string">&quot;--zip-location=%s&quot;</span>, input_file_name);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_fd_arg, <span class="string">&quot;--oat-fd=%d&quot;</span>, oat_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_location_arg, <span class="string">&quot;--oat-location=%s&quot;</span>, output_file_name);    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Running %s in=%s out=%s\n&quot;</span>, DEX2OAT_BIN, input_file_name, output_file_name);    </span><br><span class="line">    <span class="built_in">execl</span>(DEX2OAT_BIN, DEX2OAT_BIN,    </span><br><span class="line">          zip_fd_arg, zip_location_arg,    </span><br><span class="line">          oat_fd_arg, oat_location_arg,    </span><br><span class="line">          (<span class="type">char</span>*) <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;execl(%s) failed: %s\n&quot;</span>, DEX2OAT_BIN, <span class="built_in">strerror</span>(errno));    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="ART堆组成"><a href="#ART堆组成" class="headerlink" title="ART堆组成"></a>ART堆组成</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141224005343406" alt="img"></p>
<p>​		ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space。其中，Image Space、Zygote Space、Allocation Space是在地址上连续的空间，称为Continuous Space，而Large Object Space是一些离散地址的集合，用来分配一些大对象，称为Discontinuous Space。</p>
<p>​		在Image Space和Zygote Space之间，隔着一段用来映射system@<a href="mailto:&#102;&#114;&#97;&#x6d;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#111;&#x74;&#46;&#x61;&#x72;&#116;">&#102;&#114;&#97;&#x6d;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#111;&#x74;&#46;&#x61;&#x72;&#116;</a>@classes.oat文件的内存。system@<a href="mailto:&#102;&#x72;&#x61;&#x6d;&#x65;&#119;&#111;&#114;&#x6b;&#64;&#x62;&#111;&#111;&#116;&#x2e;&#x61;&#x72;&#x74;">&#102;&#x72;&#x61;&#x6d;&#x65;&#119;&#111;&#114;&#x6b;&#64;&#x62;&#111;&#111;&#116;&#x2e;&#x61;&#x72;&#x74;</a>@classes.oat是一个OAT文件，它是由在系统启动类路径中的所有DEX文件翻译得到的，而<strong>Image Space空间就包含了那些需要预加载的系统类对象。</strong>这意味着需要预加载的类对象是在生成system@<a href="mailto:&#102;&#x72;&#97;&#x6d;&#101;&#x77;&#x6f;&#x72;&#x6b;&#64;&#x62;&#x6f;&#111;&#116;&#46;&#x61;&#114;&#x74;">&#102;&#x72;&#97;&#x6d;&#101;&#x77;&#x6f;&#x72;&#x6b;&#64;&#x62;&#x6f;&#111;&#116;&#46;&#x61;&#114;&#x74;</a>@classes.oat这个OAT文件的时候创建并且保存在文件system@<a href="mailto:&#x66;&#114;&#97;&#x6d;&#101;&#119;&#x6f;&#x72;&#107;&#64;&#98;&#111;&#111;&#116;&#x2e;&#x61;&#114;&#x74;">&#x66;&#114;&#97;&#x6d;&#101;&#119;&#x6f;&#x72;&#107;&#64;&#98;&#111;&#111;&#116;&#x2e;&#x61;&#114;&#x74;</a>@classes.dex中，以后只要系统启动类路径中的DEX文件不发生变化（即不发生更新升级），那么以后每次系统启动只需要将文件system@<a href="mailto:&#x66;&#114;&#x61;&#x6d;&#x65;&#119;&#x6f;&#114;&#107;&#64;&#98;&#x6f;&#x6f;&#116;&#x2e;&#x61;&#114;&#116;">&#x66;&#114;&#x61;&#x6d;&#x65;&#119;&#x6f;&#114;&#107;&#64;&#98;&#x6f;&#x6f;&#116;&#x2e;&#x61;&#114;&#116;</a>@classes.dex直接映射到内存即可，省去了创建各个类对象的时间。之前使用Dalvik虚拟机作为应用程序运行时时，每次系统启动时，都需要为那些预加载的类创建类对象。因此，虽然ART运行时第一次启动时会比较慢，但是以后启动实际上会更快。</p>
<pre><code>     Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的。Zygote Space在Zygote进程和应用程序进程之间共享的，而Allocation Space则是每个进程独占的。同样的，Zygote进程一开始只有一个Image Space和一个Zygote Space。**在Zygote进程fork第一个子进程之前，就会把Zygote Space一分为二，原来的已经被使用的那部分堆还叫Zygote Space，而未使用的那部分堆就叫Allocation Space。以后的对象都在Allocation Space上分配。**
</code></pre>
<p>​		Image Space和Zygote Space在Zygote进程和应用程序进程之间进行共享，而Allocation Space就每个进程都独立地拥有一份。注意，虽然Image Space和Zygote Space都是在Zygote进程和应用程序进程之间进行共享，但是前者的对象只创建一次，而后者的对象需要在系统每次启动时根据运行情况都重新创建一遍。</p>
<p>与Dalivk虚拟机类似，ART运行时也使用一个Heap对象来描述堆：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141229201435625" alt="img"></p>
<p>Heap类包含了以下重要成员变量描述ART运行时的堆，它们的作用如下所述：</p>
<pre><code>   1. mark_sweep_collectors_: 一个std::vector&lt;collector::MarkSweep*&gt;向量，保存了六种Mark-Sweep垃圾收集器。

   2. continuous_spaces_: 一个std::vector&lt;space::ContinuousSpace*&gt;向量，保存了图1所示的三个在地址空间上连续的Image Space、Zygote Space和Allocation Space。

   3. concurrent_gc_: 一个bool变量，描述是否支持并行GC，可以通过ART运行时启动选项-Xgc来指定。

   4. parallel_gc_threads_: 一个size_t变量，指定在GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ParallelGCThreads指定。如果没有指定，它的值就等于CPU核心数减1。这里之所以要减1是因为parallel_gc_threads_描述的实际上是除了当前GC线程之外的其它也用于GC任务的线程的个数。

   5. conc_gc_threads_: 一个size_t变量，指定非GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ConcGCThreads来指定。

   6. discontinuous_spaces_: 一个std::vector&lt;space::DiscontinuousSpace*&gt;向量，保存了图1所示的在地址空间上不连续的Large Object Space。

   7. alloc_space_: 一个space::DlMallocSpace指针，指向一个space::DlMallocSpace对象，该对象描述的是图1所示的Allocation Space。

   8. large_object_space_: 一个space::LargeObjectSpace指针，指向一个space::LargeObjectSpace对象，该对象描述的是图1所示的Large Object Space。

   9. card_table_: 一个UniquePtr&lt;accounting::CardTable&gt;指针，指向一个accounting::CardTable对象，该对象描述的是图1所示的Card Table。

   10. image_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于上方的Mod Union Table对象，用来记录在GC并行阶段在Image Space上分配的对象对在Zygote Space和Allocation Space上分配的对象的引用。

   11. zygote_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于下方的Mod Union Table，用来记录在GC并行阶段在Zygote Space上分配的对象对在Allocation Space上分配的对象的引用。

   12. mark_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Mark Stack，用来在GC过程中实现递归对象标记。

   13. allocation_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Allocation Stack，用来记录上一次GC后分配的对象，用来实现类型为Sticky的Mark Sweep Collector。

   14. live_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Live Stack，配合allocation_stack_一起使用，用来实现类型为Sticky的Mark Sweep Collector。

   15. mark_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Mark Bitmap，与Dalvik虚拟机的Mark Bitmap作用是一样的，用来标记当前GC之后还存活的对象。

   16. live_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Live Bitmap，与Dalvik虚拟机的Live Bitmap作用是一样的，用来标记上一次GC之后还存活的对象。

    除了上述的16个成员变量，Heap类还定义了以下三个垃圾收集接口：

    1. CollectGarbage: 用来执行显式GC，例如用实现System.gc接口。

    2. ConcurrentGC: 用来执行并行GC，只能被ART运行时内部的GC守护线程调用。

    3. CollectGarbageInternal: ART运行时内部调用的GC接口，可以执行各种类型的GC。
</code></pre>
<p>​		上面我们提到，Heap类的成员变量mark_sweep_collectors_保存了ART运行时内部使用的六种垃圾收集器，这六种垃圾收集器分为两组。其中一组是支持并行GC的，另一组是不支持并行GC的。每一组都由MarkSweep、PartialMarkSweep和StickyMarkSweep三种类型的垃圾收集器组成</p>
<p>​		StickyMarkSweep继承于PartialMarkSweep，PartialMarkSweep又继承于MarkSweep、而MarkSweep又继承于GarbageCollector。因此，我们可以推断出，GarbageCollector定义了垃圾收集器接口，而MarkSweep、PartialMarkSweep和StickyMarkSweep通过重定某些接口来实现不同类型的垃圾收集器。</p>
<p>​		 在GarbageCollector中，有一个成员变量heap_，指向的是ART运行时堆，同时定义了两个public成员函数IsConcurrent和GetGcType。前者用来获得一个垃圾收集器是否支持并行GC，后者用来获得垃圾收集器类型 。</p>
<p> 垃圾收集器类型通过枚举类型GcType：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  kGcTypeNone, <span class="comment">// 一个占位符</span></span><br><span class="line">  kGcTypeSticky, <span class="comment">// 指的就是StickyMarkSweep类型的垃圾收集器，用来收集上次GC以来分配的对象。</span></span><br><span class="line">  kGcTypePartial,<span class="comment">// 指的就是PartialMarkSweep类型的垃圾收集器，用来收集在Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeFull, <span class="comment">//指的就是MarkSweep类型的垃圾收集器，用来收集在Zygote Space和Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeMax, <span class="comment">// 垃圾收集器类型个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GarbageCollector通过定义以下五个虚函数描述GC的各个阶段：</p>
<pre><code>   1. InitializePhase: 用来实现GC的初始化阶段，用来初始化垃圾收集器内部的状态。

   2. MarkingPhase: 用来实现GC的标记阶段，该阶段有可能是并行的，也有可能不是并行。

   3. HandleDirtyObjectsPhase: 用来实现并行GC的Dirty Object标记，也就是递归标记那些在并行标记对象阶段中被修改的对象。

   4. ReclaimPhase: 用来实现GC的回收阶段。

   5. FinishPhase: 用来实现GC的结束阶段。
</code></pre>
<p>MarkSweep类通过重写上述五个虚函数实现自己的垃圾收集过程，同时，它又通过定义以下三个虚函数来让子类PartialMarkSweep和StickyMarkSweep实现特定的垃圾收集器：</p>
<ol>
<li><p>MarkReachableObjects: 用来递归标记从根集对象引用的其它对象。</p>
</li>
<li><p>BindBitmap: 用来指定垃圾收集范围。</p>
</li>
<li><p>Sweep: 用来回收垃圾对象。</p>
</li>
</ol>
<p>   其中，MarkSweep类通过自己实现的成员函数BindBitmap将垃圾收集范围指定为Zygote和Allocation空间，而PartialMarkSweep和StickyMarkSweep类通过重写成员函数BindBitmap将垃圾收集范围指定为Allocation空间和上次GC后所分配的对象。此外，StickyMarkSweep类还通过重定成员函数MarkReachableObjects和Sweep将对象标记和回收限制为上次GC后所分配的对象</p>
<h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><p>ART模式英文全称为：Android runtime，谷歌Android 4.4系统新增的一种应用运行模式。<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<p>ART GC 与 Dalvik 的一个主要区别在于 <strong>ART GC 引入了移动垃圾回收器。</strong>使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。</p>
<ol>
<li>半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc&#x2F;DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。</li>
<li>同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。</li>
</ol>
<p><strong>OAT文件</strong></p>
<p>OAT文件是Android运行时ART的核心，它是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20ART%20GC.png" alt="Android ART GC"></p>
<p>非并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>恢复第2步挂起的ART运行时线程。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记即可。</li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。</li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。</li>
</ol>
<p>ART 的优点主要有三点：</p>
<ol>
<li>标记自身：ART在对象分配时会将新分配的对象压入到Heap类的成员变量allocation<em>stack</em>描述的Allocation Stack中去，从而可以一定程度上缩减对象遍历范围。</li>
<li>预读取：对于标记Allocation Stack的内存时，会预读取接下来要遍历的对象，同时在取出来该对象后又会将该对象引用的其他对象压入栈中，直至遍历完毕。</li>
<li>减少挂起时间：在Mark阶段是不会Block其他线程的，这个阶段会有Dirty数据，比如Mark发现不会使用的但是这个时候又被其他线程使用的数据，在Mark阶段也会处理一些Dirty数据而不是留在最后Block的时候再去处理，这样也会减少后面Block阶段对于脏数据的处理的时间。</li>
</ol>
<h3 id="Android-5-0-7-0-ART-GC"><a href="#Android-5-0-7-0-ART-GC" class="headerlink" title="Android 5.0 ~ 7.0 ART GC"></a>Android 5.0 ~ 7.0 ART GC</h3><p><strong>引入分代管理</strong></p>
<p>将堆分为新生代 (Young Generation) 和老年代 (Old Generation)，对应的GC也分为两种：</p>
<ul>
<li>Minor GC: 针对新生代的垃圾回收</li>
<li>Major GC (Full GC) : 针对整个堆的垃圾回收</li>
</ul>
<p><a href="http://lihaizhou.top/2021/10/27/%E5%AF%B9Android-S-ART-GC%E7%9A%84%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86/">对Android-S-ART-GC的源码梳理</a></p>
<p><a href="https://juejin.cn/post/6875678394332217357">ART虚拟机 | GC的触发时机和条件</a></p>
<p><a href="https://hello2mao.github.io/2015/12/11/ART_GC_VS_Dalvik_GC/">Android 5.0 ART GC 对比 Android 4.x Dalvik GC</a></p>
<p><a href="https://juejin.cn/post/6966205309782065159">android-gc-简史</a></p>
<p><a href="https://medium.com/@banerjee.s.sayans/android-garbage-collection-in-a-nutshell-e5c8acfa1538">Android Garbage Collection in a Nutshell</a></p>
<p><a href="https://paul.pub/android-art-vm/">Android上的ART虚拟机</a></p>
<p><a href="https://source.android.com/docs/core/runtime/gc-debug?hl=zh-cn">谷歌文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24835977">Android GC原理探究</a></p>
<p><a href="https://www.zhihu.com/question/297654028">Android Devlik和ART采用的是哪种垃圾收集器？</a></p>
<h3 id="ART-GC-回收策略的类型"><a href="#ART-GC-回收策略的类型" class="headerlink" title="ART GC 回收策略的类型"></a>ART GC 回收策略的类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># art/runtime/gc/collector/gc_type.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  <span class="comment">// Placeholder for when no GC has been performed.</span></span><br><span class="line">  kGcTypeNone,</span><br><span class="line">  <span class="comment">// Sticky mark bits GC that attempts to only free objects allocated since the last GC.</span></span><br><span class="line">  kGcTypeSticky,</span><br><span class="line">  <span class="comment">// Partial GC that marks the application heap but not the Zygote.</span></span><br><span class="line">  kGcTypePartial,</span><br><span class="line">  <span class="comment">// Full GC that marks and frees in both the application and Zygote heap.</span></span><br><span class="line">  kGcTypeFull,</span><br><span class="line">  <span class="comment">// Number of different GC types.</span></span><br><span class="line">  kGcTypeMax,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>kGcTypeNone:</strong><ul>
<li>描述：表示没有进行垃圾回收。</li>
<li>用途：作为占位符，表示在此时没有执行垃圾回收操作。</li>
</ul>
</li>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
<li><strong>kGcTypeFull:</strong><ul>
<li>描述：表示完全垃圾回收，同时标记并释放应用和Zygote堆中的对象。</li>
<li>用途：执行整个堆的垃圾回收，涉及应用堆和Zygote堆的所有对象。</li>
</ul>
</li>
<li><strong>kGcTypeMax:</strong><ul>
<li>描述：表示不同垃圾回收类型的总数。</li>
<li>用途：作为一个计数器，表示所有可能的垃圾回收类型的数量。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201211109922.png" alt="image-20240201211109922"></p>
<h3 id="ART-Heap的创建"><a href="#ART-Heap的创建" class="headerlink" title="ART Heap的创建"></a>ART Heap的创建</h3><p>看一下Heap创建时的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kMemMapSpaceName[<span class="number">2</span>] = &#123;<span class="string">&quot;main space&quot;</span>, <span class="string">&quot;main space 1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kRegionSpaceName = <span class="string">&quot;main space (region space)&quot;</span></span><br><span class="line"></span><br><span class="line">Heap::<span class="built_in">Heap</span>(……)&#123;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;space::ImageSpace&gt;&gt; boot_image_spaces;</span><br><span class="line">  <span class="comment">// 创建ImageSpace,用来加载boot.oat</span></span><br><span class="line">  <span class="keyword">if</span> (space::ImageSpace::<span class="built_in">LoadBootImage</span>(……,&amp;boot_image_spaces,……)) &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemMap main_mem_map_1;</span><br><span class="line">  MemMap main_mem_map_2;</span><br><span class="line"></span><br><span class="line">  std::string error_str;</span><br><span class="line">  MemMap non_moving_space_mem_map;</span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="comment">// 创建ZygoteSpace虚拟内存，大小为64M</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* space_name = is_zygote ? kZygoteSpaceName : kNonMovingSpaceName;</span><br><span class="line">    <span class="keyword">if</span> (heap_reservation.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      non_moving_space_mem_map = heap_reservation.<span class="built_in">RemapAtEnd</span>(</span><br><span class="line">          heap_reservation.<span class="built_in">Begin</span>(), space_name, PROT_READ | PROT_WRITE, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      non_moving_space_mem_map = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          space_name, request_begin, non_moving_space_capacity, &amp;error_str);</span><br><span class="line">    &#125;</span><br><span class="line">    request_begin = kPreferredAllocSpaceBegin + non_moving_space_capacity;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 前台gc不是并发复制回收时，会创建两个space，5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ != kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (separate_non_moving_space || !is_zygote) &#123;</span><br><span class="line">    <span class="comment">//3. 创建name为“main space”的space的虚拟内存</span></span><br><span class="line">      main_mem_map_1 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          kMemMapSpaceName[<span class="number">0</span>], request_begin, capacity_, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ……</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//同样是5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (support_homogeneous_space_compaction ||</span><br><span class="line">      background_collector_type_ == kCollectorTypeSS ||</span><br><span class="line">      foreground_collector_type_ == kCollectorTypeSS) &#123;</span><br><span class="line">    <span class="comment">//4. 创建name为“main space 1”的space的虚拟内存</span></span><br><span class="line">    main_mem_map_2 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">        kMemMapSpaceName[<span class="number">1</span>], main_mem_map_1.<span class="built_in">End</span>(), capacity_, &amp;error_str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = non_moving_space_mem_map.<span class="built_in">Size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* non_moving_space_mem_map_begin = non_moving_space_mem_map.<span class="built_in">Begin</span>();</span><br><span class="line">    <span class="comment">//通过DlMallocSpace来管理ZygoteSpze</span></span><br><span class="line">    non_moving_space_ = space::DlMallocSpace::<span class="built_in">CreateFromMemMap</span>(std::<span class="built_in">move</span>(non_moving_space_mem_map),</span><br><span class="line">                                                               <span class="string">&quot;zygote / non moving space&quot;</span>,</span><br><span class="line">                                                               kDefaultStartingSize,</span><br><span class="line">                                                               initial_size,</span><br><span class="line">                                                               size,</span><br><span class="line">     ……</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前台gc为并发复制回收，8.0及以上系统采用的gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ == kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="comment">//创建一个容量为capacity_ * 2，即1g的space，虽然这里创建了1g，但是可用的只有512，另外一半是GC时，用于对象移动的</span></span><br><span class="line">    MemMap region_space_mem_map =</span><br><span class="line">        space::RegionSpace::<span class="built_in">CreateMemMap</span>(kRegionSpaceName, capacity_ * <span class="number">2</span>, request_begin);</span><br><span class="line">   </span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsMovingGc</span>(foreground_collector_type_)) &#123;</span><br><span class="line">    <span class="comment">// 通过BumpPointerSpace管理前面创建的main space和main space</span></span><br><span class="line">    bump_pointer_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 1&quot;</span>,</span><br><span class="line">                                                                    std::<span class="built_in">move</span>(main_mem_map_1));</span><br><span class="line">   </span><br><span class="line">    temp_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 2&quot;</span>,</span><br><span class="line">                                                            std::<span class="built_in">move</span>(main_mem_map_2));</span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//通过MainMallocSpace来管理前面创建的main space和main space</span></span><br><span class="line">    <span class="built_in">CreateMainMallocSpace</span>(std::<span class="built_in">move</span>(main_mem_map_1), initial_size, growth_limit_, capacity_);</span><br><span class="line">    <span class="keyword">if</span> (main_mem_map_2.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* name = kUseRosAlloc ? kRosAllocSpaceName[<span class="number">1</span>] : kDlMallocSpaceName[<span class="number">1</span>];</span><br><span class="line">      main_space_backup_.<span class="built_in">reset</span>(<span class="built_in">CreateMallocSpaceFromMemMap</span>(std::<span class="built_in">move</span>(main_mem_map_2),</span><br><span class="line">                                                           initial_size,</span><br><span class="line">                                                           growth_limit_,</span><br><span class="line">                                                           capacity_,</span><br><span class="line">                                                           name,</span><br><span class="line">                                                           <span class="comment">/* can_move_objects= */</span> <span class="literal">true</span>));</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请并创建LargeObjectSpace</span></span><br><span class="line">  <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kFreeList) &#123;</span><br><span class="line">    large_object_space_ = space::FreeListSpace::<span class="built_in">Create</span>(<span class="string">&quot;free list large object space&quot;</span>, capacity_);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kMap) &#123;</span><br><span class="line">    large_object_space_ = space::LargeObjectMapSpace::<span class="built_in">Create</span>(<span class="string">&quot;mem map large object space&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>所有的 Space 创建，都是先通过 mmap 申请一块匿名内存，然后将这块内存放入对应的 Space 空间中进行管理</strong>。比如 ZygoteSpace 的创建，会先通过 CreateFromMemMap 函数创建一个名字为 zygote，大小为 64M 的匿名内存，然后将这一块内存放入 DlMallocSpace 管理。下面简单介绍一下用来管理申请内存的 Space：</p>
<ol>
<li><strong>DlMallocSpace</strong>：通过 dlmalloc 内存分配器来申请和释放内存，这是一个很出名的内存分配器，网上有大量的资料介绍，这里就不详细介绍了。</li>
<li><strong>MainMallocSpace</strong>：通过谷歌开发的 rosalloc 内存分配管理器来申请和释放内存。rosalloc 的用法比 dlmalloc 要复杂得多，而且还需要 ART 虚拟机中其他模块进行配合。但是分配的效果要比 dlmalloc 更好，并且多线程下表现更好。</li>
<li><strong>BumpPointerSpace</strong>：很简单的内存分配算法，按照顺序分配，类似于链表，容易出现内存碎片，所以只用在线程本地存储或者存活周期很长的对象空间上。</li>
<li><strong>RegionSpace</strong>：RegionSpace 的内存分配算法比 BumpPointerSpace 稍微高级一点。它先将内存资源划分成一个个固定大小（由 kRegionSize 指定，默认为 1MB）的内存块，每一个内存块由一个 Region 对象表示，进行内存分配时，先找到满足要求的 Region，然后从这个 Region 中分配资源。</li>
<li><strong>FreeListSpace&#x2F;LargeObjectMapSpace</strong>：通过 list 或者 map 来分配和释放内存，比 BumpPointerSpace 更简单。</li>
</ol>
<p>MainSpace 会根据 GC 回收器类型这个条件判断，有不同的创建方式，并且选择是放入 RegionSpace、BumpPointerSpace 还是 MainMallocSpace 中，这里判断规则如下：</p>
<ol>
<li>Android5.x~7.x：会创建名字为 “main space” 和 “main space 1”，大小都为 512M 的空间，并且 main space 和 main space 1 会通过 MainMallocSpace 来维护和管理，实际只会使用其中的一个空间，只有当执行 GC 的时候，另一个空间才派上用场。此时，GC 回收器会将前面所使用的空间中的存活对象全部移动到另一个空间来。</li>
<li>Android8.0 及以上：创建 main space (region space)，并且通过 <strong>RegionSpace</strong> 来维护和管理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9865353d11a44837aec2fd55a1e4aff3%7Etplv-k3u1fbpfcp-jj-mark%3A2079%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace(</strong><code>region space</code>**)**：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p><strong>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。</strong></p>
<h3 id="ART堆对象分配"><a href="#ART堆对象分配" class="headerlink" title="ART堆对象分配"></a>ART堆对象分配</h3><p>在 Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存，我们直接看这个接口申请内存的代码逻辑（完整的代码可以看：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">heap-inl.h</a>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只保留了主逻辑，通过注释可以看到，虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<p>什么是大对象呢？通过 ShouldAllocLargeObject 判断接口可以看到，申请的内存大小大于 3页，且是基本类型数组或者字符串便认为是大对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::ShouldAllocLargeObject</span><span class="params">(ObjPtr&lt;mirror::Class&gt; c, <span class="type">size_t</span> byte_count)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> byte_count &gt;= large_object_threshold_ &amp;&amp; (c-&gt;<span class="built_in">IsPrimitiveArray</span>() || c-&gt;<span class="built_in">IsStringClass</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ART堆对象的释放"><a href="#ART堆对象的释放" class="headerlink" title="ART堆对象的释放"></a>ART堆对象的释放</h3><p> Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC，在上面申请流程中我们可以看到申请内存失败后，会调用 AllocateInternalWithGc 接口去重新申请，这个接口会调用 CollectGarbageInternal 接口进行 GC。(源码连接：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++复制代码<span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//1. 选择对应的垃圾回收器</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) </span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// Try to read each page of the memory map in case mprotect didn&#x27;t work properly b/19894268.</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">      current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 执行GC</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的逻辑比较简单：</p>
<ol>
<li>选择合适的 GarbageCollector（垃圾回收器），并设置好这个 collector 的环境，如 kCollectorTypeSS（半空间回收）就会设置好 FromSpace 和 ToSpace。</li>
<li>接着调用执行 collector-&gt;Run 接口，collector 会执行对象的回收策略。</li>
</ol>
<p>不同的 GarbageCollector 对应了不同的 GC 算法，这一块的知识比较庞大，超出了该篇章的内容，不做详细的介绍了，只简单介绍一下 GarbageCollector 是如何判断一个对象是否可回收的。</p>
<h2 id="ART-GC-1"><a href="#ART-GC-1" class="headerlink" title="ART  GC"></a>ART  GC</h2><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>root set的定义在虚拟机的<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/">art</a>&#x2F;<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/">runtime</a>&#x2F;<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/gc_root.h">gc_root.h</a>文件下，</p>
<p>在 Android 内存管理中，”根对象” 是指那些能够直接或间接引用其他对象的对象。垃圾收集器通过识别和遍历这些根对象，能够确定哪些对象是可达的，哪些对象是不可达的，从而进行垃圾回收。</p>
<p><strong>虚拟机能直接找到的Object对象都属于root set。</strong>所谓的”root set”指的是包含了一些Java对象（在ART虚拟机中具体是mirror Object对象）的集合。这些对象不是通过其他对象的引用型成员变量来找到的，而是由虚拟机根据其实现特点来确定的。一般而言，”root set”包含多种类型的root信息。</p>
<p>这些根对象的类型用于表示对象的引用来源和作用域,这些内容以枚举类型的形式存放在gc_root.h下。</p>
<p>以下是其中一些根对象类型的简要解释：</p>
<ul>
<li><code>kRootJNIGlobal</code>: <strong>JNI 全局引用</strong>，即由 JNI（Java Native Interface）创建的全局引用。</li>
<li><code>kRootJNILocal</code>: <strong>JNI 局部引用</strong>，即由 JNI 创建的局部引用。</li>
<li><code>kRootJavaFrame</code>: <strong>表示 Java 方法调用的栈帧</strong>，即 Java 方法中的局部变量和操作数栈。</li>
<li><code>kRootNativeStack</code>: <strong>表示 Native 方法的调用栈</strong>，即 Native 方法中的局部变量和操作数栈。</li>
<li><code>kRootStickyClass</code>: Sticky 类，通常指的是被标记为 “sticky” 的类对象。在垃圾回收的实现中，可能会有一些对象在回收过程中被标记为 “sticky”，这表示它们在接下来的阶段中，例如移动对象的阶段，将不会被移动或发生其他变化。这样的标记有助于提高垃圾回收的效率，因为不需要频繁地处理这些对象。</li>
<li><code>kRootThreadBlock</code>: <strong>线程块</strong>，表示线程的信息块。</li>
<li><code>kRootMonitorUsed</code>: 正在使用的监视器，即被线程锁，锁住的对象。</li>
<li><code>kRootThreadObject</code>: <strong>线程对象，表示 Java 中的线程对象。</strong></li>
<li><code>kRootInternedString</code>: Interned 字符串，表示在字符串常量池中的字符串。</li>
<li><code>kRootFinalizing</code>: 正在进行 finalization（终结操作）的对象。</li>
<li><code>kRootDebugger</code>: 被调试器引用的对象。</li>
<li><code>kRootReferenceCleanup</code>: 引用清理，通常与引用队列相关。</li>
<li><code>kRootVMInternal</code>: <strong>虚拟机内部使用的对象。</strong></li>
<li><code>kRootJNIMonitor</code>: JNI 监视器对象，即由 JNI 创建的监视器。</li>
</ul>
<p>这些根对象类型的识别和分析对于 Android 内存分析和垃圾回收是至关重要的，它们帮助系统找出哪些对象是存活的，哪些对象可以被回收。</p>
<h3 id="ART-GC-方案"><a href="#ART-GC-方案" class="headerlink" title="ART  GC 方案"></a>ART  GC 方案</h3><p>ART 默认的GC方案Android 14 为CMC，Android 13-8为CMS。</p>
<p>​	下面这段代码时JNI层设置AndroidRuntime，大概是读取配置文件来解析对应的GC处理器选项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># /frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"><span class="comment">// 解析运行时选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.gctype&quot;</span>, gctypeOptsBuf, <span class="string">&quot;-Xgc:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取是否启用分代收集的配置</span></span><br><span class="line">std::string enable_generational_cc =</span><br><span class="line">    server_configurable_flags::<span class="built_in">GetServerConfigurableFlag</span>(RUNTIME_NATIVE_BOOT_NAMESPACE,</span><br><span class="line">                                                         ENABLE_GENERATIONAL_CC,</span><br><span class="line">                                                         <span class="comment">/*default_value=*/</span> <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 根据配置值决定是否启用分代收集，并添加相应选项</span></span><br><span class="line"><span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kGenerationalCCRuntimeOption);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;false&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kNoGenerationalCCRuntimeOption);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析后台GC处理器的配置选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.backgroundgctype&quot;</span>, backgroundgcOptsBuf, <span class="string">&quot;-XX:BackgroundGC=&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的<code>backgroundgcOptsBuf</code>和<code>gctypeOptsBuf</code>分别读取配置然后解析设置了前台GC和后台GC，下面看下GC具体的解析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># art/cmdline/cmdline_types.h</span></span><br><span class="line"><span class="comment">// 解析垃圾收集器类型的方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> gc::CollectorType <span class="title">ParseCollectorType</span><span class="params">(<span class="type">const</span> std::string&amp; option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (option == <span class="string">&quot;MS&quot;</span> || option == <span class="string">&quot;nonconcurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CMS&quot;</span> || option == <span class="string">&quot;concurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;SS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeSS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CC&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCC;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上面就是前后台通用的GC处理器项有：</p>
<ul>
<li><code>kCollectorTypeMS</code>: 代表标记-清除（Mark-Sweep）垃圾回收器。在这种回收器中，首先标记不再使用的内存，然后清除或回收这些标记的内存。</li>
<li><code>kCollectorTypeCMS</code>: 代表并发标记-清除（Concurrent Mark-Sweep）垃圾回收器。这是一种改进的标记-清除算法，它允许在标记过程中应用程序线程和垃圾回收线程并发运行。</li>
<li><code>kCollectorTypeSS</code>: 代表单步垃圾回收器（Sticky-Start）。这可能是一种实验性的或者特殊用途的垃圾回收策略，具体实现和特性可能因系统和环境而异。</li>
<li>kCollectorTypeGSS：GSS 垃圾回收器是在 SS 的基础上引入了分代的概念。</li>
<li><code>kCollectorTypeCC</code>: 代表并发复制回收器（Compact Collection）垃圾回收器。这种回收器的目标是在回收内存的同时压缩内存，以减少内存碎片化。</li>
</ul>
<p>后台会多一个</p>
<ul>
<li>kCollectorTypeHomogeneousSpaceCompact：代表同质空间压缩垃圾回收器，将存活对象压缩到内存区域的一端，从而在另一端创建一个连续的空闲空间。这有助于减少内存碎片，提高内存的可用性。</li>
</ul>
<h3 id="ART-GC-分配器实现"><a href="#ART-GC-分配器实现" class="headerlink" title="ART GC 分配器实现"></a>ART GC 分配器实现</h3><p>分配器的类型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AllocatorType</span> : <span class="type">char</span> &#123;</span><br><span class="line">  kAllocatorTypeBumpPointer,      <span class="comment">// 使用全局 CAS（Compare and Swap）实现的 BumpPointer 分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeTLAB,             <span class="comment">// 在 BumpPointer 空间内使用 TLAB（Thread-Local Allocation Buffer）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeRosAlloc,         <span class="comment">// 使用 RosAlloc（分离大小、自由列表）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeDlMalloc,         <span class="comment">// 使用 dlmalloc（著名的 C malloc）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeNonMoving,        <span class="comment">// 用于非移动对象的特殊分配器。</span></span><br><span class="line">  kAllocatorTypeLOS,              <span class="comment">// 大对象空间。</span></span><br><span class="line">  <span class="comment">// 以下与 BumpPointer 分配器的主要区别在于从多个区域而不是单个连续空间分配内存。</span></span><br><span class="line">  kAllocatorTypeRegion,           <span class="comment">// 在区域内使用 CAS 实现的连续 BumpPointer 分配。 (*)</span></span><br><span class="line">  kAllocatorTypeRegionTLAB,       <span class="comment">// 使用区域片段作为 TLAB。对大多数小对象的默认设置。 (*)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>不同的分配器，对应着不同的内存空间，而不同的内存空间，又都有着自身的内存分配方式 。</strong>ART GC中所涉及的内存空间是用 一 个枚举类型 SpaceType 来表示的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpaceType</span> &#123;</span><br><span class="line">  kSpaceTypeImageSpace,           <span class="comment">// 用于存储应用程序的可执行代码和资源的空间</span></span><br><span class="line">  kSpaceTypeMallocSpace,          <span class="comment">// 用于分配堆对象的普通堆空间</span></span><br><span class="line">  kSpaceTypeZygoteSpace,          <span class="comment">// 用于存储 Zygote 进程中的共享对象的空间</span></span><br><span class="line">  kSpaceTypeBumpPointerSpace,     <span class="comment">// 用于快速分配对象的堆空间</span></span><br><span class="line">  kSpaceTypeLargeObjectSpace,     <span class="comment">// 用于存储大对象的空间，通常采用不同的分配和回收策略</span></span><br><span class="line">  kSpaceTypeRegionSpace,          <span class="comment">// 用于分配堆对象的区域化空间，实现一种分代垃圾回收策略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过switch- case 结构，根据分配器类型 allocator_ type 的不同取值，去选择对应的<strong>空间类</strong>，并调用其分配空间函数，以此去实现内存分配 。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201230533603.png" alt="image-20240201230533603"></p>
<p>空间类的继承关系：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1163119-20170514004423957-2085494711.jpg" alt="img"></p>
<h3 id="ATR-GC-回收器的实现"><a href="#ATR-GC-回收器的实现" class="headerlink" title="ATR GC 回收器的实现"></a>ATR GC 回收器的实现</h3><p>​		在ART中，回收器的实现代码位于<code>art/Runtime/gc/collector</code>目录之下。回收器本身有一个实现类<code>GarbageCollector</code>，不同回收方案所对应的回收器是作为<code>GarbageCollector</code>的子类进行实现的。</p>
<p>​		<code>GarbageCollector</code>类的声明和实现分别位于<code>art/Runtime/gc/collector</code>目录下的<code>garbage_collector.h</code>和<code>garbage_collector.cc</code>中。<code>GarbageCollector</code>类继承自<code>RootVisitor</code>、<code>IsMarkedVisitor</code>和<code>MarkObjectVisitor</code>。</p>
<p>​		<code>GarbageCollector</code>类中包含一个<code>ScopedPause</code>类，<code>ScopedPause</code>类有一个重要的成员变量<code>collector_</code>，它是指向回收器的指针。在<code>GarbageCollector</code>类中，比较重要的成员函数包括<code>Run()</code>函数和<code>RunPhases()</code>函数。<code>Run()</code>函数用于运行回收器，而<code>RunPhases()</code>函数用于运行GC的所有阶段。</p>
<p>​		<code>GarbageCollector::Run()</code>函数在实现垃圾回收功能时，通过调用<code>RunPhases()</code>函数来运行所有的GC阶段，从而最终实现垃圾回收的目标。</p>
<p>​		<code>RunPhases()</code>函数在<code>GarbageCollector</code>类中并没有具体实现，而是要在其子类中根据需要去实现。因此，<code>GarbageCollector</code>类的子类的<code>RunPhases()</code>函数是对应回收器的核心实现。这种设计允许每个具体的垃圾回收方案有自己的实现方式，以满足特定的需求。</p>
<p>下面是GC中主要类的关系</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240202192845076.png" alt="image-20240202192845076"></p>
<h3 id="分配器与回收器"><a href="#分配器与回收器" class="headerlink" title="分配器与回收器"></a>分配器与回收器</h3><p>​	选择回收器</p>
<p>​	<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heap::ChangeCollector</span><span class="params">(CollectorType collector_type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 只有在挂起所有 Mutator 线程以避免竞态条件时才执行此操作。</span></span><br><span class="line">  <span class="keyword">if</span> (collector_type != collector_type_) &#123;</span><br><span class="line">    <span class="comment">// 更新收集器类型</span></span><br><span class="line">    collector_type_ = collector_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除当前 GC 计划</span></span><br><span class="line">    gc_plan_.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据新的收集器类型生成新的 GC 计划</span></span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC: &#123;</span><br><span class="line">        <span class="comment">// 如果使用分代 CC（Generational CC），添加 Sticky GC 类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB（Thread-Local Allocation Buffer） 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegionTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegion);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">UNIMPLEMENTED</span>(FATAL);</span><br><span class="line">        <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的并发启动字节数</span></span><br><span class="line">    <span class="built_in">SetDefaultConcurrentStartBytesLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配器和回收器对应表</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201231055275.png" alt="image-20240201231055275"></p>
<h3 id="堆内存GC流程"><a href="#堆内存GC流程" class="headerlink" title="堆内存GC流程"></a>堆内存GC流程</h3><h4 id="对象内存申请"><a href="#对象内存申请" class="headerlink" title="对象内存申请"></a>对象内存申请</h4><p>分配器要为新建立的对象分配空间，这个操作主要靠 Heap 类的 AllocObjectWithAllocator( ）函数实现， AllocObjectWithAll ocator( ）函数的实现位于 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">art &#x2F; Runtime&#x2F;gc&#x2F; heap- inl. h</a> 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h4><p>GC 回收器主要在进行垃圾回收的时候使用，而垃圾回收的执行需要触发事件进行触发 。垃圾回收的触发，在实现上专门由 一 个枚举类型 GcCause 表示，这个枚举类型的定义位于 art &#x2F; Runtime &#x2F; gc &#x2F; gc_cause. h 中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcCause</span> &#123;</span><br><span class="line">  <span class="comment">// 无效的 GC 原因，用作占位符。</span></span><br><span class="line">  kGcCauseNone,</span><br><span class="line">  <span class="comment">// 由于分配失败而触发的 GC。执行分配的线程在重试分配之前被阻塞，等待 GC 完成。</span></span><br><span class="line">  kGcCauseForAlloc,</span><br><span class="line">  <span class="comment">// 用于确保在分配之前有足够的空闲内存的后台 GC。</span></span><br><span class="line">  kGcCauseBackground,</span><br><span class="line">  <span class="comment">// 显式的 System.gc() 调用。</span></span><br><span class="line">  kGcCauseExplicit,</span><br><span class="line">  <span class="comment">// 在超过 NativeAllocationGcWatermark 时触发的为本地分配而进行的 GC。</span></span><br><span class="line">  <span class="comment">// （根据是否运行非并发收集器，这可能是一个阻塞的 GC）。</span></span><br><span class="line">  kGcCauseForNativeAlloc,</span><br><span class="line">  <span class="comment">// 为了进行收集器转换而触发的 GC。</span></span><br><span class="line">  kGcCauseCollectorTransition,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于禁用移动 GC（目前用于 GetPrimitiveArrayCritical）。</span></span><br><span class="line">  kGcCauseDisableMovingGc,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于修整堆。</span></span><br><span class="line">  kGcCauseTrim,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和插装之间的排除。</span></span><br><span class="line">  kGcCauseInstrumentation,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除应用程序图像空间。</span></span><br><span class="line">  kGcCauseAddRemoveAppImageSpace,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和调试器之间的排除。</span></span><br><span class="line">  kGcCauseDebugger,</span><br><span class="line">  <span class="comment">// 在前台和后台收集器都是 CMS 时触发的用于背景转换的 GC。</span></span><br><span class="line">  kGcCauseHomogeneousSpaceCompact,</span><br><span class="line">  <span class="comment">// 类链接器原因，用于保护填充 art 方法的特殊值。</span></span><br><span class="line">  kGcCauseClassLinker,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现代码缓存元数据和 GC 之间的排除。</span></span><br><span class="line">  kGcCauseJitCodeCache,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除系统弱引用持有者。</span></span><br><span class="line">  kGcCauseAddRemoveSystemWeakHolder,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 hprof 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseHprof,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 GetObjectsAllocated 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseGetObjectsAllocated,</span><br><span class="line">  <span class="comment">// 用于 Profile Saver 的 GC 原因。</span></span><br><span class="line">  kGcCauseProfileSaver,</span><br><span class="line">  <span class="comment">// 在启动时删除 dex 缓存数组的 GC 原因。</span></span><br><span class="line">  kGcCauseDeletingDexCacheArrays,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于开发者而言，常见的是其中三种：</p>
<ul>
<li>GcCauseForAlloc：通过new分配新对象时，堆中剩余空间(普通应用默认上限为256M，声明largeHeap的应用为512M)不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>GcCauseExplicit：当应用调用系统API System.gc()时，会产生一次GC动作。</li>
<li>GcCauseBackground：后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。相比于前两种GC，后台GC出现的更多也更加隐秘。这个触发动作是在分配内存成功之后进行的触发 。为了确保每次分配空 间都 有空 间可用。</li>
</ul>
<p>最终的GC 触发最终都会通过调用CollectGarbagelnternal ( ）函数进行 GC 。实现位于<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc;l=2709">art&#x2F;Runtime&#x2F;gc &#x2F; heap.cc</a> 中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前线程和运行时对象</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果堆无法运行GC，则静默失败并返回未运行任何GC。</span></span><br><span class="line">  <span class="keyword">switch</span> (gc_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> collector::kGcTypePartial: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">HasZygoteSpace</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果没有Zygote空间，不增加gcs_completed_计数，应该使用kGcTypeFull重试。</span></span><br><span class="line">        <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// 其他GC类型没有特殊情况，这使它们不可运行。主要的情况是全GC。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换线程状态，确保没有持有Mutator锁</span></span><br><span class="line">  <span class="function">ScopedThreadStateChange <span class="title">tsc</span><span class="params">(self, ThreadState::kWaitingPerformingGc)</span></span>;</span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程正在处理堆栈溢出，则不足够的剩余堆栈空间运行GC。</span></span><br><span class="line">  <span class="keyword">if</span> (self-&gt;<span class="built_in">IsHandlingStackOverflow</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果我们正在抛出堆栈溢出错误，我们可能没有足够的剩余堆栈空间来运行GC。</span></span><br><span class="line">    <span class="comment">// 计数此GC，以防有人在等待它完成。</span></span><br><span class="line">    gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">    <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> compacting_gc;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取GC完成锁并切换线程状态，等待GC完成</span></span><br><span class="line">    gc_complete_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">    <span class="function">ScopedThreadStateChange <span class="title">tsc2</span><span class="params">(self, ThreadState::kWaitingForGcToComplete)</span></span>;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *gc_complete_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保一次只有一个GC</span></span><br><span class="line">    <span class="built_in">WaitForGcToCompleteLocked</span>(gc_cause, self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经在其他地方触发了适当的GC，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (requested_gc_num != GC_NUM_ANY &amp;&amp; !<span class="built_in">GCNumberLt</span>(<span class="built_in">GetCurrentGcNum</span>(), requested_gc_num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compacting_gc = <span class="built_in">IsMovingGc</span>(collector_type_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是压缩式GC，检查是否禁用了移动GC。</span></span><br><span class="line">    <span class="keyword">if</span> (compacting_gc &amp;&amp; disable_moving_gc_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Skipping GC due to disable moving GC count &quot;</span> &lt;&lt; disable_moving_gc_count_;</span><br><span class="line">      <span class="comment">// 再次计数此GC。</span></span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在关机过程中禁用了GC，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (gc_disabled_for_shutdown_) &#123;</span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置正在运行的收集器类型和最后的GC原因。</span></span><br><span class="line">    collector_type_running_ = collector_type_;</span><br><span class="line">    last_gc_cause_ = gc_cause;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是由于分配而触发的GC，增加统计信息计数。</span></span><br><span class="line">  <span class="keyword">if</span> (gc_cause == kGcCauseForAlloc &amp;&amp; runtime-&gt;<span class="built_in">HasStatsEnabled</span>()) &#123;</span><br><span class="line">    ++runtime-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">    ++self-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取在堆上执行GC的垃圾收集器对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes_allocated_before_gc = <span class="built_in">GetBytesAllocated</span>();</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(gc_type, collector::kGcTypeMax);</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(gc_type, collector::kGcTypeNone);</span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据GC类型和分配器类型选择垃圾收集器。</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(current_allocator_ == kAllocatorTypeBumpPointer ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeTLAB ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegion ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegionTLAB);</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        <span class="comment">// 选择SemiSpace收集器并设置SemiSpace的源和目标空间。</span></span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC:</span><br><span class="line">        <span class="comment">// 选择MarkCompact收集器。</span></span><br><span class="line">        collector = mark_compact_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        <span class="comment">// 选择ConcurrentCopying收集器。</span></span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> 其他线程必须在开始检查active_concurrent_copying_collector_之前进行翻转检查。</span></span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          <span class="built_in">DCHECK</span>(active_cc_collector-&gt;<span class="built_in">RegionSpace</span>() == region_space_);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid collector type &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于kCollectorTypeCMC，temp_space_将为null。</span></span><br><span class="line">    <span class="keyword">if</span> (temp_space_ != <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// 尝试读取内存映射的每一页，以防mprotect没有正确工作 b/19894268。</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">CHECK</span>(temp_space_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">             current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    <span class="comment">// 根据分配器类型选择垃圾收集器。</span></span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查垃圾收集器是否可用。</span></span><br><span class="line">  <span class="built_in">CHECK</span>(collector != <span class="literal">nullptr</span>)</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Could not find garbage collector with collector_type=&quot;</span></span><br><span class="line">      &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_) &lt;&lt; <span class="string">&quot; and gc_type=&quot;</span> &lt;&lt; gc_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行垃圾收集器。</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加已释放内存的计数。</span></span><br><span class="line">  <span class="built_in">IncrementFreedEver</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求堆修剪。</span></span><br><span class="line">  <span class="built_in">RequestTrim</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展堆，以便知道何时执行下一次GC。</span></span><br><span class="line">  <span class="built_in">GrowForUtilization</span>(collector, bytes_allocated_before_gc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录旧的本地分配的字节数。</span></span><br><span class="line">  old_native_bytes_allocated_.<span class="built_in">store</span>(<span class="built_in">GetNativeBytes</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录GC日志。</span></span><br><span class="line">  <span class="built_in">LogGC</span>(gc_cause, collector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成GC过程。</span></span><br><span class="line">  <span class="built_in">FinishGC</span>(self, gc_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际上将所有清除的引用入队。在GC正式完成后执行此操作，否则可能会发生死锁。</span></span><br><span class="line">  SelfDeletingTask* clear = reference_processor_-&gt;<span class="built_in">CollectClearedReferences</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行清理引用任务。</span></span><br><span class="line">  clear-&gt;<span class="built_in">Run</span>(self);</span><br><span class="line">  clear-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知DDMS GC已完成。</span></span><br><span class="line">  Dbg::<span class="built_in">GcDidFinish</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类卸载时卸载本地库。我们在调用FinishGC之后执行此操作，以防JNI_OnUnload函数进行分配。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line">    soa.<span class="built_in">Vm</span>()-&gt;<span class="built_in">UnloadNativeLibraries</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回GC的类型。</span></span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="GC流程补充"><a href="#GC流程补充" class="headerlink" title="GC流程补充"></a>GC流程补充</h3><p>Android 版本 8 到 13 期间，系统一直使用的是 Concurrent Copy 垃圾回收算法（CC）。该算法通过使用 FromSpace 和 ToSpace 两个内存空间，实现了一种巧妙的复制机制。这种机制通过在垃圾回收过程中，同时利用这两个空间，来达到空间换时间的效果，或者说通过复杂度来提高垃圾回收的效率。在具体操作中，对象被从一个空间（FromSpace）复制到另一个空间（ToSpace），从而清理掉 FromSpace 中不再被引用的对象。</p>
<p>这种复制机制会在垃圾回收过程中使用两倍的内存，因为需要同时维护两个空间。在极端情况下，这可能导致内存占用量翻倍，因为系统需要为每个对象在 FromSpace 和 ToSpace 中都分配空间。尽管这可能带来一些额外的内存消耗，但由于复制算法的高效性，通常能够更迅速地回收垃圾，从而提高整体性能。这种垃圾回收方式在某些场景下可能更适用，特别是对于实时性能要求较高的系统。</p>
<p>ART虚拟机创建时先确定内存回收器的类型，进而绑定对应的内存分配器，因回收器已设置为CC(ConcurrentCopying)即并发复制回收器，则Heap内存的主要分配区域定为RegionSpace，RegionSpace由一个个256KB的Region组成。对应的RegionSpace内存分配器定为kAllocatorTypeRegion。</p>
<p>从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。</p>
<p>并发复制 GC 的一些主要特性包括：</p>
<ul>
<li>CC 支持使用名为“RegionTLAB”的触碰指针分配器。此分配器可以向每个应用线程分配一个线程本地分配缓冲区 (TLAB)，这样，应用线程只需触碰“栈顶”指针，而无需任何同步操作，即可从其 TLAB 中将对象分配出去。</li>
<li>CC 通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理。这是在读取屏障的帮助下实现的，<strong>读取屏障会拦截来自堆的引用读取</strong>，无需应用开发者进行任何干预。</li>
<li>GC 只有一次很短的暂停，对于堆大小而言，该次暂停在时间上是一个常量。</li>
<li>在 Android 10 及更高版本中，CC 会扩展为分代 GC。它支持轻松回收存留期较短的对象，这类对象通常很快便会无法访问。这有助于提高 GC 吞吐量，并显著延迟执行全堆 GC 的需要。</li>
</ul>
<p>ART代码中的heap则是一个类，其作用更像是堆内存的管理器。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Android 4.4</th>
<th>Android 5~6</th>
<th>Android 7</th>
<th>Android 8~9</th>
<th>Android 10</th>
</tr>
</thead>
<tbody><tr>
<td>回收算法</td>
<td>CMS</td>
<td>CMS</td>
<td>CMS</td>
<td>CC</td>
<td>CC</td>
</tr>
<tr>
<td>内存分配机制</td>
<td>Single-Thread</td>
<td>Per-Thread</td>
<td>Per-thread</td>
<td>Bump Pointer</td>
<td>Bump Pointer</td>
</tr>
<tr>
<td>内存分配性能</td>
<td>1x</td>
<td>4-5x</td>
<td>10x</td>
<td>18x</td>
<td>18x</td>
</tr>
<tr>
<td>临时变量开销</td>
<td>高</td>
<td>低(分代)</td>
<td>低(分代)</td>
<td>中</td>
<td>低(分代)</td>
</tr>
<tr>
<td>内存整理(防止碎片化)</td>
<td>后台</td>
<td>后台&#x2F;事件</td>
<td>后台&#x2F;事件</td>
<td>前台并发</td>
<td>前台并发</td>
</tr>
</tbody></table>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是 Concurrent Mark Sweep 的简称，中文翻译为并发标记清除方案，可以简单地理解为并发的标记清除方案 。为了提高垃圾回收的效率，学者们提出了并发垃圾回收 。 并发垃圾回收允许赋值器线程和回收器线程同时执行以提高回收效率 。 在这里需要注意区分并发垃圾回收和并行垃圾回收 。 与并发垃圾回收不同的是，并行垃圾回收通常使用多个回收器线程进行垃圾回收 。CMS 方案允许赋值器和回收器线程同时执行，并且其回收器分为标记和清除两个阶段 。</p>
<h3 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h3><p>它是 “Semi-Space”（半空间）和 “Mark-Sweep”（标记-清除）两种垃圾回收算法的混合方案。</p>
<ol>
<li><strong>Semi-Space (半空间)</strong>: Semi-Space 是一种年轻代垃圾回收算法，通常用于处理新生代对象的回收。它将堆空间分为两个大小相等的半空间，一个是源空间，一个是目标空间。在垃圾回收过程中，存活的对象从源空间复制到目标空间，然后清理源空间中的所有对象。这有助于提高内存分配的效率，减少内存碎片。</li>
<li><strong>Mark-Sweep (标记-清除)</strong>: Mark-Sweep 是一种用于整个堆的垃圾回收算法。它分为两个主要阶段。首先，标记阶段会遍历并标记所有可达的对象。然后，在清除阶段，未标记的对象会被释放，堆空间得到整理。</li>
</ol>
<p>“SS” 方案将这两种算法结合在一起。在堆的年轻代使用 Semi-Space 进行垃圾回收，而在整个堆使用 Mark-Sweep 进行垃圾回收。这样，可以结合两种算法的优点，达到更好的性能和空间利用率。</p>
<h3 id="GSS"><a href="#GSS" class="headerlink" title="GSS"></a>GSS</h3><p>GSS 是 SS 回收方案的分代回收版本 。分代回收在对象中引入了“年龄＂的概念， 将对象分为新生代对象和老年代对象 。其中， 新生代对象指的是刚生成的对象，老年代对象指的是到达 一 定“年龄＂的对象 。因为新生代对象大部分会变成垃圾，所以分代回收将新生代对象和老年代对象分别进行 GC ，对新生代对象进行的 GC 称为新生代 GC ，对老年代对象进行的 GC 称为老年代 GC ， 一 般情况下会提高新生代 GC 的频率，降低老年代 GC 的频率，这样可以提高效率 。分代回收并不能单独作为 一 种方案而直接使用，它通常会和标记 －清除、复制等基本 GC方案结合起来进行使用 。在这里，分代回收会和 SS 回收方案结合起来，形成 一 个新的方案，即 GSS 。</p>
<h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>CC 是 Concurrent Copying 的简称，中文翻译为并发复制回收，它可以看作复制回收的并发版本 。CC 可以在读取屏障的帮助下，通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理，比非并发版本更加高效 </p>
<h3 id="CMC"><a href="#CMC" class="headerlink" title="CMC"></a>CMC</h3><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GCRoots Set</p>
<p>ART Java Heap</p>
<p>​		从Android 8 (Oreo) 开始默认方案是并发复制 (CC)，cc涉及到的堆空间的区域为RegionSpace。</p>
<p>​		在GC触发章节讲到在GC Case 枚举中对于开发者而言，常见的是其中三种：申请内存时触发的GcCauseForAlloc、调用系统API System.gc()时GcCauseExplicit、并发GCGcCauseBackground。具体的执行过程可以看章节的详解，但最终的GC 触发最终都会通过调用CollectGarbagelnternal。</p>
<p>​		CollectGarbageInternal里会通过switch casel来通过回收器类型来选择合适的 GarbageCollector（垃圾回收器），这里的类型就是<code>kCollectorTypeCC</code>。看下具体代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据垃圾回收器的类型选择相应的回收器</span></span><br><span class="line"><span class="keyword">switch</span> (collector_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> kCollectorTypeCC: <span class="comment">// 如果是并发拷贝垃圾回收器类型</span></span><br><span class="line">    collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_) &#123; <span class="comment">// 如果使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 根据回收类型选择相应的活跃拷贝垃圾回收器</span></span><br><span class="line">      active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">              young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">      <span class="comment">// 将选择的拷贝垃圾回收器存储为活跃拷贝垃圾回收器</span></span><br><span class="line">      active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                 std::memory_order_relaxed);</span><br><span class="line">      <span class="comment">// 设置当前回收器为选择的拷贝垃圾回收器</span></span><br><span class="line">      collector = active_cc_collector;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 获取存储的活跃拷贝垃圾回收器</span></span><br><span class="line">      collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 处理其他类型的垃圾回收器</span></span><br><span class="line">    <span class="comment">// 添加适当的处理逻辑或错误处理代码</span></span><br><span class="line">    <span class="comment">// 可以根据实际情况进行补充</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取对应的GarbageCollector后这里获取的应该是<a href="http://aospxref.com/android-13.0.0_r3/xref/art/runtime/gc/collector/concurrent_copying.h">concurrent_copying.h</a>，接着调用执行 collector-&gt;Run 接口，然后会执行RunPhases()函数。</p>
<p>这里简单看一下具体的代码实现，应该看不懂但是知道有这个流程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentCopying::RunPhases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否使用Baker读屏障或TableLookup读屏障</span></span><br><span class="line">  <span class="built_in">CHECK</span>(kUseBakerReadBarrier || kUseTableLookupReadBarrier);</span><br><span class="line">  <span class="comment">// 检查垃圾回收是否处于非活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收标记为活动状态</span></span><br><span class="line">  is_active_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">// 记录当前运行垃圾回收的线程</span></span><br><span class="line">  thread_running_gc_ = self;</span><br><span class="line">  <span class="comment">// 断言Mutator锁未被当前线程持有</span></span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化阶段</span></span><br><span class="line">    <span class="built_in">InitializePhase</span>();</span><br><span class="line">    <span class="comment">// 如果是分代垃圾回收，不是年轻代，且不强制撤离所有对象，则执行标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_ &amp;&amp; !young_gen_ &amp;&amp; !force_evacuate_all_) &#123;</span><br><span class="line">      <span class="built_in">MarkingPhase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用Baker读屏障且存在灰色的Dirty Immune对象</span></span><br><span class="line">  <span class="keyword">if</span> (kUseBakerReadBarrier &amp;&amp; kGrayDirtyImmuneObjects) &#123;</span><br><span class="line">    <span class="comment">// 切换到读屏障标记入口点，确保在灰色对象标记之前切换</span></span><br><span class="line">    <span class="built_in">ActivateReadBarrierEntrypoints</span>();</span><br><span class="line">    <span class="comment">// 并发标记灰色的Dirty Immune对象，以减少垃圾回收暂停时间</span></span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="built_in">GrayAllDirtyImmuneObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 翻转线程根</span></span><br><span class="line">  <span class="built_in">FlipThreadRoots</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行拷贝阶段</span></span><br><span class="line">    <span class="built_in">CopyingPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用NoFromSpaceRefsVerification</span></span><br><span class="line">  <span class="keyword">if</span> (kEnableNoFromSpaceRefsVerification) &#123;</span><br><span class="line">    <span class="comment">// 计时器，用于记录暂停时长</span></span><br><span class="line">    <span class="function">TimingLogger::ScopedTiming <span class="title">split</span><span class="params">(<span class="string">&quot;(Paused)VerifyNoFromSpaceReferences&quot;</span>, GetTimings())</span></span>;</span><br><span class="line">    <span class="comment">// 暂停，执行验证</span></span><br><span class="line">    <span class="function">ScopedPause <span class="title">pause</span><span class="params">(<span class="keyword">this</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;正在验证不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行验证不存在From-Space引用</span></span><br><span class="line">    <span class="built_in">VerifyNoFromSpaceReferences</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;验证完成，确保不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行回收阶段</span></span><br><span class="line">    <span class="built_in">ReclaimPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完成垃圾回收阶段</span></span><br><span class="line">  <span class="built_in">FinishPhase</span>();</span><br><span class="line">  <span class="comment">// 断言垃圾回收仍处于活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收状态标记为非活动</span></span><br><span class="line">  is_active_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 清空运行垃圾回收的线程信息</span></span><br><span class="line">  thread_running_gc_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		我们知道cc是基于标记-复制算法的，在Android 10 CC垃圾回收器引入了分代。但是ConcurrentCopying并非将空间划分为两个半空间，而是以RegionSpace中的Region为单位进行处理，同时还能根据存活对象所占内存的比例来灵活设置Region被划归为From Space的条件。这个分代思想有点类似于JavaJVM中的G1收集器的算法。<strong>从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现。</strong></p>
<p>​		上面的ART GC回收策略章节知道，kCollectorTypeCC对应的回收策略有kGcTypeSticky, kGcTypePartial。再看一遍这两个的定义</p>
<ol>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
</ol>
<p>GC的大体流程为：</p>
<ul>
<li><p>InitializePhase，初始化统计量，设置标记等。</p>
</li>
<li><p>MarkingPhase，遍历所有Root根集，将根集对象直接引用对象压入mark_stack，并发标记存活对象记录在mark_bitmap中（此阶段只用于确定回收区域，StickyGC和ExplicitGC不需要）。</p>
</li>
<li><p>FlipThreadRoots，依据上一阶段的标记信息，确定回收区域（倾向于回收垃圾对象多的region），回收区域设置为from_space。</p>
</li>
<li><p>CopyingPhase，处理跨代、跨区引用的dirty_card,将from_space中的存活对象拷贝至to_space，更新引用等。</p>
</li>
<li><p>ReclaimPhase，释放from_space的空间，重置为to_space。</p>
</li>
</ul>
<p>Sticky GC，基于“标记-复制”算法实现</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/01fa2365dfacd63e02e5d201654d7124.png" alt="01fa2365dfacd63e02e5d201654d7124.png"></p>
<p>Partial GC 基于标记-整理算法</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/90d0ecea1c99af4058c88b8af80c864e.png" alt="90d0ecea1c99af4058c88b8af80c864e.png"></p>
<p>其中还涉及的一些东西：</p>
<ol>
<li><p>内存分配算法：整个堆划分为多个同样大小的Region（256KB），Region内分配内存使用最高效的BumpPointer指针碰撞算法，缺点是无法单独释放某个对象的内存(漂浮垃圾无法避免)，只能整个释放Region占用的空间。</p>
</li>
<li><p>回收算法：全局层面为标记-整理算法，两个Region间为标记-复制算法。有效地减少内存碎片。</p>
</li>
<li><p>跨区引用：写屏障支持，用CardTable实现RememberSet，记录跨代&#x2F;特殊Space与RegionSpace间的引用。</p>
<ul>
<li><strong>跨区引用</strong>：在垃圾回收的上下文中，”跨区引用” 指的是对象之间的引用关系，其中被引用的对象位于不同的内存区域。在这种情况下，需要考虑如何有效地跟踪和处理这些跨区引用。写屏障是一种支持跨区引用的机制，通过它可以在修改对象引用时执行额外的代码。在这个特定的实现中，使用 CardTable 来实现 RememberSet。RememberSet 是一种数据结构，用于记录指向其他内存区域的引用。CardTable 会被标记为 “Dirty”，以指示某个区域内的引用发生了变化，需要在后续的回收阶段中进行处理。</li>
</ul>
</li>
<li><p>并发：由CardTable，转发指针，起始快照，目标空间不变(只访问to_space对象)等特性支持。</p>
<ul>
<li><p><strong>CardTable（卡表）</strong>：CardTable 是一种数据结构，通常是一个字节数组，用于跟踪堆内存中每个小块（通常是一小块连续的内存，称为 Card）的状态。在并发垃圾回收中，卡表被用来记录对象引用的变化，特别是在写入引用时，标记与之相关的卡为”Dirty”（脏）。这有助于回收器识别哪些部分的内存发生了变化，需要在后续的回收阶段中处理。</p>
</li>
<li><p><strong>转发指针</strong>：在并发垃圾回收期间，当一个对象被复制到新的内存空间时，原始的引用需要被修正，指向新的内存地址。这个修正过程中可能会用到转发指针，即在原始地址上放置一个指针，指向新的内存地址。</p>
</li>
<li><p><strong>起始快照</strong>：在并发垃圾回收开始时，需要对内存状态进行一次快照，即记录当前所有对象的状态和位置。这个快照通常称为起始快照，它是垃圾回收器追踪对象移动和变化的基准。</p>
</li>
<li><p><strong>目标空间不变</strong>：指的是在并发垃圾回收期间，被回收的对象会被复制到新的内存空间（通常称为 to_space），而这个 to_space 在整个回收过程中是保持不变的。这确保了应用线程在访问 to_space 中的对象时，可以避免对正在进行的垃圾回收操作产生干扰。</p>
</li>
</ul>
</li>
<li><p><strong>写屏障（Write Barrier）</strong>：</p>
</li>
</ol>
<ul>
<li><p><strong>写前屏障</strong>：<strong>在修改对象的引用型成员变量之前执行一段特殊代码。这段代码负责标记与该对象相关的内存卡（Card）为Dirty。</strong>在并发复制垃圾收集中，Card通常是内存空间的一个固定大小的块。Dirty表示该块中的对象引用发生了变化。</p>
</li>
<li><p><strong>写后屏障</strong>：在修改对象的引用型成员变量之后执行一段特殊代码。这段代码也负责标记与该对象相关的内存卡为Dirty（脏）。</p>
</li>
<li><p>作用：通过这两种写屏障，垃圾收集器能够跟踪在上一次垃圾回收之后和并发期间发生的引用变化。<strong>Dirty（脏）的标记会被用于确定哪些对象需要在垃圾回收期间进行复制。</strong></p>
</li>
</ul>
<ol start="6">
<li><strong>读屏障（Read Barrier）</strong>：</li>
</ol>
<ul>
<li><p>读取对象的引用型成员变量时，会在访问目标对象之前执行一段特殊代码。<strong>这段代码负责检查目标对象是否已经被拷贝到新的内存位置。</strong></p>
</li>
<li><p>在并发复制垃圾收集中，如果目标对象尚未被拷贝，Mutator（应用程序线程）会执行拷贝操作，将对象复制到新的内存位置，并更新原对象的LockWord，使其指向新的目标对象。然后，引用会被修正为新的目标对象。</p>
</li>
<li><p>作用：读屏障确保在读取对象引用时，始终能够获得有效的引用<strong>。如果目标对象已经被拷贝到新的位置，读屏障负责确保引用被修正为新的目标对象，而不是指向旧的内存位置。</strong></p>
</li>
</ul>
<ol start="7">
<li><p>转发指针：被拷贝后的from_space原对象LockWord配置转发指针，之后所有访问原对象都会自动指向to_space新对象。</p>
<ul>
<li><p>“转发指针” 是一种在垃圾回收中用于处理对象拷贝的机制。在并发复制（Concurrent Copying）的垃圾回收算法中，当一个对象被移动到新的内存空间（例如从 from_space 到 to_space）时，为了确保之前对原对象的引用仍然有效，会在原对象的位置留下一个特殊的标记，即 “转发指针”。</p>
<p>具体来说，转发指针是一个指向新的拷贝对象的指针。当程序试图访问原对象时，会经过这个转发指针，从而自动指向新的对象。这样一来，即使对象在垃圾回收过程中被移动，引用该对象的代码仍然能够正确地访问到新的位置。</p>
<p>这种机制的好处是，无需修改引用原对象的代码，就能够实现对象的动态迁移。这对于需要在垃圾回收过程中保持应用程序线程的活动性（不需要停顿应用线程）的并发垃圾回收算法是非常有用的。</p>
</li>
</ul>
</li>
<li><p>优势：</p>
</li>
</ol>
<p>指针碰撞分配，贡献最高的内存分配速度。</p>
<p>前后台内存整理，更少的内存碎片，可控的漂浮垃圾数量。</p>
<p>更灵活的内存管理单位，提升内存利用率，相比CMS降低平均32%的堆占用（google官方数据）。</p>
<p>更精准的分代垃圾回收策略，提升吞吐量（回收效率），减少PauseTime。</p>
<ol start="9">
<li>不足：</li>
</ol>
<p>预留两倍堆空间的内存地址（32位应用影响明显，增加虚拟内存地址不足OOM概率）。</p>
<p>并发复制过程耗时随堆大小、对象数递增，耗时较长。</p>
<p>Mutator线程参与对象拷贝和Tracing，存在对象移动风暴。</p>
<p>读写互斥锁与锁堆特殊场景阻塞应用线程。</p>
<p>无法单独释放某个对象的内存，并发过程中新增对象默认为存活，存在一定的漂浮垃圾。</p>
<p>有关回收器的知识可以看上面的章节“ART GC 的分配器实现”的讲解。</p>
<p>有关Space的东西看上面的ART Heap创建。</p>
<p>有关GC Case的情况看上面的回收器使用章节。</p>
<p>有关对象创建的东西看上面的ART堆对象分配章节。</p>
<p>有关对象释放的东西看上面的ART堆对象释放章节。</p>
<p>有关回收器的东西看上面的ART GC 回收器的实现</p>
<p>CC垃圾处理器涉及到的分配器是<strong>kAllocatorTypeReg1onTLAB</strong>，涉及到的空间类是<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/space/region_space.h">region_space</a>。</p>
]]></content>
  </entry>
  <entry>
    <title>okhttp详解</title>
    <url>/2023/12/15/OkHttp/</url>
    <content><![CDATA[<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:</span><br><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().xxx.build()</span><br></pre></td></tr></table></figure>

<p>创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">异步：</span><br><span class="line">		<span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">        <span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">        LogCat.e( Thread.currentThread())</span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 这里还是在子线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">同步：</span><br><span class="line">				thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                loge(response)</span><br><span class="line">                <span class="comment">// 在这里处理同步响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>同步请求：</strong><ul>
<li><strong>同步请求是在当前线程上执行的。</strong>这意味着，如果在主线程上执行同步请求，它会阻塞主线程，直到请求完成。</li>
<li>同步请求通常用于后台线程或不涉及用户界面的操作，因为它们可能会导致应用界面冻结，用户体验差。</li>
<li>在同步请求中，您在代码中直接等待响应，只有在请求完成后才能继续执行后续代码。</li>
</ul>
</li>
<li><strong>异步请求：</strong><ul>
<li><strong>异步请求是在后台线程上执行的，不会阻塞当前线程。</strong>这允许在请求完成之前继续执行其他操作，包括更新用户界面。</li>
<li>异步请求通常用于与用户界面交互的操作，以确保用户界面保持响应性。</li>
<li>在异步请求中，通常提供一个回调函数，该回调函数将在请求完成时执行，允许处理响应数据。</li>
</ul>
</li>
</ol>
<h2 id="请求生成"><a href="#请求生成" class="headerlink" title="请求生成"></a>请求生成</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">client?.newCall(request)?.execute()</span><br><span class="line"></span><br><span class="line">#OkHttpClient::newCall:最终生成一个RealCall对象</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">#RealCall::execute()：开启同步请求</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">	<span class="comment">// 检查是否已经被执行</span></span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 将当前realcall加入到OkHttpClient的调度器中  因为是同步 不需要线程池开启子线程 所以直接return getResponseWithInterceptorChain()</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#Dispatcher::enqueue()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 call 是否为 WebSocket 请求</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">		<span class="comment">// 查找具有相同主机的已经存在的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 将符合条件的调用从readyAsyncCalls提升到runningAsyncCalls</span></span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 确保在多线程环境下，异步调用的执行数量不会超过预定的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#Dispatcher::promoteAndExecute():</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变列表用于存储将要执行的异步调用</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个标志变量用于表示是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 块，确保以下操作在互斥锁的保护下进行</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 readyAsyncCalls 队列的迭代器</span></span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 readyAsyncCalls 队列中的异步调用</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 runningAsyncCalls 中的异步调用数已经达到了最大请求数（maxRequests），则停止添加新的异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 asyncCall.callsPerHost（每个主机的并发请求数）已经达到了最大请求数（maxRequestsPerHost），则继续下一个异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 readyAsyncCalls 队列中移除该异步调用</span></span><br><span class="line">            i.remove()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加该异步调用所在主机的并发请求数</span></span><br><span class="line">            asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 executableCalls 列表中，准备执行</span></span><br><span class="line">            executableCalls.add(asyncCall)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 runningAsyncCalls 列表中，表示正在执行</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有异步调用正在执行，更新 isRunning 变量</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 executableCalls 列表，执行每个异步调用</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">			<span class="comment">// 这里开启了线程池调用</span></span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealCall::AsyncCall:: executeOn()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span> <span class="comment">// 用于跟踪执行是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用传入的 executorService 来执行当前异步调用（实际上是执行该异步任务）</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果执行成功，设置 success 为 true</span></span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="comment">// 如果执行被拒绝，创建一个 InterruptedIOException 异常，并将原始异常作为其原因</span></span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 noMoreExchanges 方法，通知没有更多的交换操作，同时调用 responseCallback 的 onFailure 方法传递异常</span></span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：无论执行是否成功，都会执行的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 如果执行不成功，调用 client.dispatcher.finished(this) 来表示该调用不再运行</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncCall::<span class="keyword">class</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AsyncCall继承了Runnable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 给当前线程命名，通常用于日志记录和调试</span></span><br><span class="line">    threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span> <span class="comment">// 用于标记回调是否已经触发</span></span><br><span class="line">        timeout.enter() <span class="comment">// 进入超时状态，启动计时器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 getResponseWithInterceptorChain() 获取响应对象</span></span><br><span class="line">            <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记回调已经触发</span></span><br><span class="line">            signalledCallback = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 responseCallback 的 onResponse() 方法，将响应传递给回调函数</span></span><br><span class="line">            responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 不要触发回调两次！如果回调已经触发，记录日志</span></span><br><span class="line">                Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 responseCallback 的 onFailure() 方法，将异常传递给回调函数</span></span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">            cancel() <span class="comment">// 取消当前调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 如果回调尚未触发，创建一个异常，将其作为取消原因传递给回调函数</span></span><br><span class="line">                <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">                canceledException.addSuppressed(t)</span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抛出异常以终止线程</span></span><br><span class="line">            <span class="keyword">throw</span> t</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何，都要通知客户端调度程序当前调用已完成</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器的通过责任链模式挨个执行每个拦截器的任务，最后将请求的response返回给最上层</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后的具体网络请求实现还是得看 getResponseWithInterceptorChain()</span></span><br><span class="line"></span><br><span class="line">RealCall:: getResponseWithInterceptorChain()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 构建拦截器链，创建一个拦截器列表</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加用户自定义的普通拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 重试、重定向拦截器</span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</span></span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 读取、写入缓存的拦截器</span></span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 与服务器建立连接的拦截器</span></span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 WebSocket 请求，添加用户自定义的网络拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最终真正执行网络请求的拦截器</span></span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有拦截器合并为链，并调用其proceed()开始处理本次请求</span></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用拦截器链的 proceed 方法，处理请求并获取响应</span></span><br><span class="line">				<span class="comment">// 主要还是得看这个方法</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求被取消，关闭响应并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 捕获 IOException 异常，标记已经调用 noMoreExchanges 方法，并重新抛出异常</span></span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：如果没有调用过 noMoreExchanges 方法，则调用它来释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealInterceptorChain:: proceed()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 检查当前拦截器索引是否小于拦截器列表的大小</span></span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加调用计数</span></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查新请求的 URL 是否与当前请求的 URL 主机和端口相同</span></span><br><span class="line">        check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器链中的下一个拦截器</span></span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">		<span class="comment">// 获取当前index的拦截器对象</span></span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器的 intercept 方法，获取响应对象，如果为 null，则抛出异常</span></span><br><span class="line">		<span class="comment">// 这里的intercept方法传入的是下一个拦截器，</span></span><br><span class="line">		<span class="comment">// 在当中回调用下一个拦截器的proceed方法response = realChain.proceed(request)</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查下一个拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应对象是否有响应体</span></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>对OKHttp有了解吗，拦截器这一块有了解吗？</li>
<li>有没有用到过，或则自定义拦截器，怎么用的</li>
<li>拦截器一定会被执行吗</li>
<li>责任链模式和策略模式有什么区别</li>
</ol>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/RetryAndFollowUpInterceptor%EF%BC%9A%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%20d608e513720d4f7e85d2a65cb9df191a.md"><strong>RetryAndFollowUpInterceptor：</strong>重试、重定向拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/BridgeInterceptor%EF%BC%9A%E5%B0%86%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%94%A8%E6%88%B7%E5%93%8D%E5%BA%94%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20536849dff4944c349e970fdc8ae1619b.md">BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%209e0ba47ba1524aafb889cf0008e1b86e.md">CacheInterceptor：读取、写入缓存的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/ConnectInterceptor%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20bd971853d1ed4038ba3426d485bf6af5.md">ConnectInterceptor 建立连接的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CallServerInterceptor%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20b4e0c43b2b424fa686714b168d39b7e1.md"><strong>CallServerInterceptor：</strong>最终真正执行网络请求的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%20a209e906006a4e67a7e39c2b1bebec7b.md">自定义拦截器</a></p>
<h2 id="RetryAndFollowUpInterceptor：重试、重定向拦截器"><a href="#RetryAndFollowUpInterceptor：重试、重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor：重试、重定向拦截器"></a>RetryAndFollowUpInterceptor：重试、重定向拦截器</h2><p>重定向:</p>
<p>重定向简单理解则是客户端请求服务端时，服务端让客户端请求别的网站，服务端会在响应中添加新的请求地址，客户端去请求这个新的地址。</p>
<p>问题一：重试的判断条件</p>
<p>问题二：怎么主动控制禁止网络请求重试</p>
<p>问题三：循环重试会不会走入死循环</p>
<p>问题四：重定向怎么实现的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 将传入的 Interceptor.Chain 强制转换为 RealInterceptorChain</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request <span class="comment">// 获取请求</span></span><br><span class="line">    <span class="keyword">val</span> call = realChain.call <span class="comment">// 获取调用</span></span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span> <span class="comment">// 跟随请求计数</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span> <span class="comment">// 之前的响应</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span> <span class="comment">// 是否是新的交换</span></span><br><span class="line">    <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;() <span class="comment">// 已恢复的失败列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 创建ExchangeFinder，此类用于创建和寻找Exchange，Exchange主要处理此次请求中的IO的连接管理和事件请，会在后续的拦截器中进行分析</span></span><br><span class="line">        call.enterNetworkInterceptorExchange(request, newExchangeFinder) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response: Response</span><br><span class="line">        <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">// 此处调用下一个拦截器获取respnse</span></span><br><span class="line">								<span class="comment">// 将Request交给给下个节点，此处的下个节点为BridgeInterceptor，若下层节点处理过程中扔出错误会被下面的catch捕获</span></span><br><span class="line">                response = realChain.proceed(request) </span><br><span class="line">                newExchangeFinder = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">                <span class="comment">// 尝试通过路由连接失败，请求尚未发送</span></span><br><span class="line">								<span class="comment">// 重点方法，决定能否重试的关键方法，此方法返回为true才可重试，看重试小节中的分析</span></span><br><span class="line">                <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">                <span class="comment">// 通过recover方法检测路由异常是否能重新连接</span></span><br><span class="line">                <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e.firstConnectException</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 走到这里，则一定拿到了服务器的响应</span></span><br><span class="line">						<span class="comment">// 若循环中的代码完整执行过，则priorResponse不为空，也就意味着需要重定向（不太严谨的说法），类似链表的结构保存下来整个响应路径</span></span><br><span class="line">            <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">					          response = response.newBuilder()</span><br><span class="line">								              .priorResponse(priorResponse.newBuilder()</span><br><span class="line">						                  .body(<span class="literal">null</span>)</span><br><span class="line">						                  .build())</span><br><span class="line">								              .build()</span><br><span class="line">				        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exchange为Exchange类，主要处理此次网络连接的IO操作</span></span><br><span class="line">            <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">            <span class="comment">// 处理重定向的重点方法，此方法会根据返回的response和连接管理器判断是否需要重定向，看下重定向小节</span></span><br><span class="line">            <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">                    call.timeoutEarlyExit()</span><br><span class="line">                &#125;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 没有跟随请求，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">            <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 跟随请求有请求体，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.body?.closeQuietly() <span class="comment">// 关闭响应体</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp <span class="comment">// 使用跟随请求作为新的请求</span></span><br><span class="line">            priorResponse = response</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题一：</p>
<p>首先确认代码体主要是一个while true 死循环，然后看下面这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果recover返回了false 则直接抛出异常 中断了重试</span></span><br><span class="line"><span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">          <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recoveredFailures += e.firstConnectException</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>出现异常的大部分情况都会返回false  从而抛出异常，如果命中了可以重试的异常则会走continue 停止当前循环开启下一次循环从而开启下一次的请求。</p>
<p>然后看看recover的具体实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">	**RetryAndFollowUpInterceptor::**recover()</span><br><span class="line"><span class="comment">// 定义一个名为recover的私有函数，用于处理异常情况并决定是否需要进行错误恢复。</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    e: <span class="type">IOException</span>,                 <span class="comment">// 传入的异常对象，通常是与网络请求相关的IOException。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">RealCall</span>,                 <span class="comment">// RealCall对象，用于执行HTTP请求的实际调用。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    userRequest: <span class="type">Request</span>,           <span class="comment">// 用户发起的请求对象。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    requestSendStarted: <span class="type">Boolean</span>     <span class="comment">// 标志位，表示请求是否已经开始发送。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 如果客户端配置禁止在连接失败时重试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经开始发送，并且该请求是一次性的（不能重新发送），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果异常是不可恢复的（例如，连接超时等），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有更多的路由可以尝试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于错误恢复，使用相同的路由选择器创建一个新的连接。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// 返回true表示需要进行错误恢复操作。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">**RetryAndFollowUpInterceptor::**requestIsOneShot</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestIsOneShot</span><span class="params">(e: <span class="type">IOException</span>, userRequest: <span class="type">Request</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBody = userRequest.body</span><br><span class="line">  <span class="keyword">return</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) ||  <span class="comment">//isOneShot()是需要程序员重写RequestBody的方法，不重写的情况下默认返回为false</span></span><br><span class="line">      e <span class="keyword">is</span> FileNotFoundException  <span class="comment">//若下层节点处理过程中抛出FileNotFoundException也不允许重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**RetryAndFollowUpInterceptor::**isRecoverable</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isRecoverable</span><span class="params">(e: <span class="type">IOException</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 协议异常则不许重试，举一个协议异常的例子，没有使用代理却返回响应码407需要代理验证，此类与协议规范冲突的错误大多数为ProtocolException</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 若产生中断异常，Socket超时或者在非IO异常（路由异常）时可能可以重试（requestSendStarted是catch中捕获的最初的异常决定的）</span></span><br><span class="line">    <span class="comment">// 若捕获异常为RouteException，requestSendStarted为false</span></span><br><span class="line">    <span class="comment">// 若捕获异常为IOException，且异常的具体类型为ConnectionShutdownException时，requestSendStarted也为false</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">is</span> SocketTimeoutException &amp;&amp; !requestSendStarted</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ssl握手异常，且具体错误属于是证书异常，则不允许重试，因为重试也肯定失败</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.cause <span class="keyword">is</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//证书校验失败 不匹配 也不允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="comment">// 翻译：如果产生连接代理出现问题，且是抛出IO异常，此时要返回true，尝试新的路由路线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上述中不可重试的情况，分为两种情况一种是<strong>程序员不希望重试</strong>一种是<strong>下层抛出异常</strong>。</p>
<p>问题二：</p>
<ul>
<li>配置<code>OkhttpClient</code>时设置<code>retryOnConnectionFailure</code>为<code>false</code>，所有请求将不可重试。</li>
<li>使用请求体请求时，<code>Body</code>继承自<code>RequestBody</code>并重写<code>isOneShot()</code>返回为<code>true</code>，可以做到过滤某些请求。</li>
</ul>
<p>问题三：</p>
<p>不会，首先重试的条件是苛刻的，绝大多数重试情况都只是网络波动，且在判断是否可重试时，有非常关键的一个条件，有没有可以重试的路线，一直重试必然会导致路线全部使用完，此时也一定会跳出循环。</p>
<p>问题四：</p>
<p>需要重定向说明之前的请求完成了然后需要再请求别的网址，看下面这段代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里将followup 赋值给了request 然后在下一个循环开启对应请求。		</span></span><br><span class="line">request = followUp</span><br><span class="line">priorResponse = response</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将之前的请求响应内容保存下来。 priorResponse是上次循环上面代码保存下来的</span></span><br><span class="line"><span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">		response = response.newBuilder()</span><br><span class="line">							.priorResponse(priorResponse.newBuilder()</span><br><span class="line">						  .body(<span class="literal">null</span>)</span><br><span class="line">						  .build())</span><br><span class="line">							.build()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"><a href="#BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器" class="headerlink" title="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"></a>BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取用户发起的请求</span></span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="comment">// 创建一个请求构建器，用于修改请求头信息</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求体</span></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取请求体的内容类型</span></span><br><span class="line">        <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Type字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体的内容长度</span></span><br><span class="line">        <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Length字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">            <span class="comment">// 移除Transfer-Encoding字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果内容长度为-1，设置Transfer-Encoding为chunked</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">            <span class="comment">// 移除Content-Length字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Host字段，添加Host字段，使用请求URL的主机名</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Connection字段，添加Connection字段为Keep-Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Accept-Encoding字段，并且没有Range字段，添加Accept-Encoding字段为gzip</span></span><br><span class="line">		<span class="comment">// Accept-Encoding用于提供客户端支持的压缩方式，与响应头的Content-Encoding对应</span></span><br><span class="line">    <span class="comment">// Range表示客户端想要此次请求资源的某一部分如：Range: bytes=0-50, 100-150，表示只要0-50和100-150字节两个部分</span></span><br><span class="line">    <span class="comment">// 若没有指定上述两个请求头属性，则压缩方式指定为gzip</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="literal">true</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CookieJar中加载Cookies，并添加到请求头中的Cookie字段</span></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有User-Agent字段，添加User-Agent字段为指定的userAgent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行网络请求，获取网络响应</span></span><br><span class="line">		<span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将网络响应的头部信息传递给CookieJar，以便处理和存储Cookies</span></span><br><span class="line">		cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个响应构建器，用于修改网络响应</span></span><br><span class="line">		<span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">	    .request(userRequest)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果需要进行透明的gzip解压缩，并且响应头中包含Content-Encoding字段为gzip，且响应允许有响应体</span></span><br><span class="line">		<span class="comment">// 若上述使用gzip，则需要进行解压</span></span><br><span class="line">    <span class="comment">// Content-Encoding代表此次响应体的编码</span></span><br><span class="line">		<span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">		    <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">		    networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="comment">// 获取网络响应体</span></span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个GzipSource，用于解压gzip压缩的响应体</span></span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="comment">// 移除响应头中的Content-Encoding和Content-Length字段</span></span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        <span class="comment">// 设置响应构建器的头部信息</span></span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="comment">// 获取响应体的Content-Type</span></span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置响应体为解压后的内容</span></span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回修改后的响应</span></span><br><span class="line">		<span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说这个拦截器并不复杂主要也就是封装请求头。重要的还是涉及计网的部分，这部分有关http的知识在<a href="https://www.notion.so/bbcad4bff70d4beb8269b08602dd95e8?pvs=21">计网</a>查询。</p>
<h2 id="CacheInterceptor：读取、写入缓存的拦截器"><a href="#CacheInterceptor：读取、写入缓存的拦截器" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h2><h3 id="CacheInterceptor：读取、写入缓存的拦截器-1"><a href="#CacheInterceptor：读取、写入缓存的拦截器-1" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h3><p>先来个图总结cache的路径：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled.png" alt="Untitled"></p>
<p>主要看下面这个博客的内容。</p>
<p>总结下一些主要的东西：</p>
<ol>
<li>cache默认是null如果需要缓存需要在构建的时候添加。</li>
<li>走缓存还是走网络请求是通过<code>CacheStrategy</code> 类来判断的，判断公式为：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%2055.png" alt="Untitled 1"></p>
<p>具体代码体现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">      <span class="comment">// 若该请求没有对应的缓存响应，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若该请求为HTTPS请求，但是缓存响应中没有保存TLS握手相关信息，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过cacheResponse的响应码来判断响应是否允许被缓存，若不允许则忽略缓存响应，需要网络请求 </span></span><br><span class="line">      <span class="comment">// (其实参与判断的还有noStore指令的值) </span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CacheControl类：包含来自服务端或客户端的缓存指令，这些指令表明了什么响应可以被存储，</span></span><br><span class="line">      <span class="comment">// 这些存储的响应可以满足哪些需求。</span></span><br><span class="line">      <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">      <span class="comment">// noCache指令说明：noCache指令可以出现在请求、响应当中。若出现在响应的位置，它表明在发布</span></span><br><span class="line">      <span class="comment">// 缓存副本之前，必须向源服务器验证缓存的有效性；若出现在请求中，它表明不要使用一个缓存来回应</span></span><br><span class="line">      <span class="comment">// 该需求。  </span></span><br><span class="line">      <span class="comment">// hasConditions方法：若Request包含If-Modified-Since或If-None-Match其中一个Header，</span></span><br><span class="line">      <span class="comment">// 则该方法返回true。</span></span><br><span class="line">      <span class="comment">// 这里If语句的意思：若请求不允许使用缓存响应，或者请求头有If-Modified-Since/If-None-Match，  	  // 则忽略缓存响应，需要网络请求。(客户端发送的请求自己就带有If-Modified-Since或If-None-Match</span></span><br><span class="line">      <span class="comment">// ，缓存响应也是不会被使用的，OkHttp在下面的代码中是有为请求添加If-Modified-Since或</span></span><br><span class="line">      <span class="comment">// If-None-Match的Header的逻辑的) </span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">      <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果cacheResponse没有noCache指令(发布缓存前不用向源服务器验证)，并且cacheResponse</span></span><br><span class="line">      <span class="comment">// 仍然在存活时间内，则不需要进行网络请求，直接使用缓存响应  </span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加 If-None-Match/If-Modified-Since 的Header到请求头中，服务器通过验证这些Header，</span></span><br><span class="line">      <span class="comment">// 来判断客户端的缓存是否还有效，若缓存仍然有效，则返回304，响应中不会包含Response Body  </span></span><br><span class="line">      <span class="keyword">val</span> conditionName: String</span><br><span class="line">      <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">          conditionValue = etag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = lastModifiedString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = servedDateString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 If-None-Match/If-Modified-Since 的Header可以添加，则忽略缓存响应，需要网络请求   </span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在原来的Request上面添加包含If-None-Match/If-Modified-Since的Header  </span></span><br><span class="line">      <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="comment">// 返回一个包含网络请求和缓存响应的策略  </span></span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码总结看下面的博客。这段代码是真正控制缓存的关键。</p>
<ol>
<li>cache类的主要作用是在本地对<code>Response</code>进行<code>CRUD</code>（增删改查四种数据库操作）的操作。</li>
<li>CacheStrategy类具体判断networkRequest、cacheResponse是在computeCandidate方法实现的。具体看下面的博客。</li>
</ol>
<p><a href="https://www.cnblogs.com/giagor/p/15706508.html">探索OkHttp系列 (四) 缓存机制 - Giagor - 博客园</a></p>
<p>首先这个缓存器只会缓存GET请求，其次如果需要缓存的话需要在构建Request的时候添加cache</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient.Builder().cache(Cache(File(<span class="keyword">this</span>.externalCacheDir, <span class="string">&quot;okhttpcache&quot;</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)).build()</span><br><span class="line"><span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">object</span> : Callback)</span><br></pre></td></tr></table></figure>

<p>其次在Request的构造中有一个cacheControl方法这个方法会传入<code>CacheControl</code> 类，这个类可以在request中定制缓存策略。在Cache的官方头注释中有对这个类各种策略的使用示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheControl = CacheControl.Builder()</span><br><span class="line">    .maxAge(<span class="number">1</span>, TimeUnit.HOURS) <span class="comment">// 缓存有效期为1小时</span></span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://example.com/api/data&quot;</span>)</span><br><span class="line">    .cacheControl(cacheControl)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Cache类解析</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">  directory: File,</span><br><span class="line">  maxSize: <span class="built_in">Long</span>,</span><br><span class="line">  fileSystem: FileSystem</span><br><span class="line">) : Closeable, Flushable &#123;</span><br><span class="line">	 <span class="comment">// 这里使用的是磁盘缓存</span></span><br><span class="line">  <span class="comment">// 缓存最最重要的属性，看名字也知道缓存策略为硬盘LRU缓存，下述分析DiskLruCache</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cache = DiskLruCache(</span><br><span class="line">        fileSystem = fileSystem,	      <span class="comment">// 主机的本地文件系统，内部使用OKIO实现IO操作</span></span><br><span class="line">        directory = directory,            <span class="comment">// 缓存目录</span></span><br><span class="line">        appVersion = VERSION,			  <span class="comment">// 版本</span></span><br><span class="line">        valueCount = ENTRY_COUNT,         <span class="comment">// 缓存文件的类型，此处是2，因为一条缓存映射两个实体文件头和体</span></span><br><span class="line">        maxSize = maxSize,				  <span class="comment">// 缓存大小</span></span><br><span class="line">        taskRunner = TaskRunner.INSTANCE  <span class="comment">// 日志追踪线程池</span></span><br><span class="line">    )</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存使用的是磁盘缓存，缓存目录是添加cache时加的目录。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%202.png" alt="Untitled 2"></p>
<p>先来看看cache缓存数据的时候</p>
<p>Cache::put()缓存的只是响应头数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Cache::put()</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(response: <span class="type">Response</span>)</span></span>: CacheRequest? &#123;</span><br><span class="line">    <span class="keyword">val</span> requestMethod = response.request.method</span><br><span class="line">	<span class="comment">// 如果请求方法为POST,PATCH,PUT,DELETE,MOVE,则移除此缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remove(response.request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只允许get方法缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestMethod != <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some</span></span><br><span class="line">        <span class="comment">// POST requests, but the complexity of doing so is high and the benefit is low.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果 Vary 响应头中包含星号，也无法缓存此响应</span></span><br><span class="line">    <span class="comment">// vary 详情请看https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary</span></span><br><span class="line">    <span class="comment">// vary简单理解则是记录下来需要缓存的响应头的值</span></span><br><span class="line">    <span class="keyword">if</span> (response.hasVaryAll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry是Cache.Entry 非 DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">val</span> entry = Entry(response)</span><br><span class="line">    <span class="keyword">var</span> editor: DiskLruCache.Editor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用DiskLruCache的edit(), 此方法则会根据传入的参数获取DiskLruCache.Entry, 看下述2.DiskLruCache#edit中的解析</span></span><br><span class="line">        editor = cache.edit(key(response.request.url)) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 执行写入操作,看下Cache.Entry#writeTo</span></span><br><span class="line">        entry.writeTo(editor)</span><br><span class="line">        <span class="comment">// 返回RealCacheRequest,此时会创建响应体文件, 看下RealCacheRequest</span></span><br><span class="line">        <span class="keyword">return</span> RealCacheRequest(editor)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        abortQuietly(editor)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面都是对这个方法中所调用方法的解析</strong></p>
<p>DiskLruCache::edit() 中的解析</p>
<p>这个方法主要是在journal文件中写入DIRTY 然后返回val editor &#x3D; Editor(entry)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">edit</span><span class="params">(key: <span class="type">String</span>, expectedSequenceNumber: <span class="type">Long</span> = ANY_SEQUENCE_NUMBER)</span></span>: Editor? &#123;</span><br><span class="line">	<span class="comment">// 初始化DiskLruCache</span></span><br><span class="line">    initialize()</span><br><span class="line">	<span class="comment">// 检测缓存有没有关闭,若关闭则抛出异常</span></span><br><span class="line">    checkNotClosed()</span><br><span class="line">    <span class="comment">// 判断key是否有效</span></span><br><span class="line">    validateKey(key)</span><br><span class="line">    <span class="comment">// 获取lruEntries中key的value, 第一次则一定为null</span></span><br><span class="line">    <span class="keyword">var</span> entry: Entry? = lruEntries[key]</span><br><span class="line">    <span class="comment">// 若是添加操作则expectedSequenceNumber使用默认值ANY_SEQUENCE_NUMBER,if不会命中</span></span><br><span class="line">    <span class="comment">// 若是更新操作才有可能命中此if</span></span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">        (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Snapshot is stale.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 若entry绑定了Editor则也返回null</span></span><br><span class="line">    <span class="keyword">if</span> (entry?.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Another edit is in progress.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次添加不会命中,因为entry为null, lockingSourceCount是当前正在打开的输入流的总数</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.lockingSourceCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 无法写入此文件，因为读者仍在阅读它</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在清理过程中, 超过设置的缓存大小且移除Entry失败时会使mostRecentTrimFailed = true, 若需要重建journal, 日志文件创建失败会使mostRecentRebuildFailed = true, 这两种情况下会命中if</span></span><br><span class="line">    <span class="keyword">if</span> (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">        <span class="comment">// The OS has become our enemy! If the trim job failed, it means we are storing more data than</span></span><br><span class="line">        <span class="comment">// requested by the user. Do not allow edits so we do not go over that limit any further. If</span></span><br><span class="line">        <span class="comment">// the journal rebuild failed, the journal writer will not be active, meaning we will not be</span></span><br><span class="line">        <span class="comment">// able to record the edit, causing file leaks. In both cases, we want to retry the clean up</span></span><br><span class="line">        <span class="comment">// so we can get out of this state!</span></span><br><span class="line">        <span class="comment">// 翻译如下: 操作系统已成为我们的敌人！如果修剪作业失败，则意味着我们存储的数据多于用户请求的数据。不允许编辑，因此我们不会进一步超出该限制。如果日志重建失败，日志写入器将不会处于活动状态，这意味着我们将无法记录编辑，从而导致文件泄漏。在这两种情况下，我们都想重试清理，以便摆脱这种状态！</span></span><br><span class="line">        cleanupQueue.schedule(cleanupTask)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">    <span class="comment">// 翻译:在创建文件之前刷新日志以防止文件泄漏</span></span><br><span class="line">    <span class="comment">// 先在journal文件中写入DIRTY</span></span><br><span class="line">    <span class="keyword">val</span> journalWriter = <span class="keyword">this</span>.journalWriter!!</span><br><span class="line">    journalWriter.writeUtf8(DIRTY)</span><br><span class="line">    .writeByte(<span class="string">&#x27; &#x27;</span>.toInt())</span><br><span class="line">    .writeUtf8(key)</span><br><span class="line">    .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    journalWriter.flush()</span><br><span class="line">	<span class="comment">// 若写入journal文件失败则hasJournalErrors = true</span></span><br><span class="line">    <span class="keyword">if</span> (hasJournalErrors) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Don&#x27;t edit; the journal can&#x27;t be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry为DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123; </span><br><span class="line">        entry = Entry(key)</span><br><span class="line">        lruEntries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Editor、作用就是具体的输入流和输出流的操作者</span></span><br><span class="line">    <span class="keyword">val</span> editor = Editor(entry)</span><br><span class="line">    entry.currentEditor = editor</span><br><span class="line">    <span class="keyword">return</span> editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>DiskLruCache.Entry 的解析</strong></strong></p>
<p><code>DiskLruCache</code>中存储的缓存实体对象，一个<code>Entry</code>对象代表一条缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> key: String</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度数组，下标0代表头文件大小，下标1代表响应体内容文件大小</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> lengths: LongArray = LongArray(valueCount) </span><br><span class="line">    <span class="comment">// 像日志一样，分为tmp和正式文件，真正的缓存也是如此</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cleanFiles = mutableListOf&lt;File&gt;() <span class="comment">//正式缓存文件集合</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> dirtyFiles = mutableListOf&lt;File&gt;()	<span class="comment">//脏缓存文件集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前缓存是否可用</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readable: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前编辑或读取完成时必须删除此条目，则为真。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> zombie: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在进行的编辑，如果此条目未被编辑，则为 null。将此设置为 null 时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> currentEditor: Editor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此条缓存打开的输入流的总数。当将此值递减为零时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> lockingSourceCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sequenceNumber: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">   		<span class="comment">// 以key为文件名创建File对象</span></span><br><span class="line">        <span class="keyword">val</span> fileBuilder = StringBuilder(key).append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">val</span> truncateTo = fileBuilder.length</span><br><span class="line">        <span class="comment">// valueCount为2 循环两次</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until valueCount) &#123;</span><br><span class="line">            fileBuilder.append(i)</span><br><span class="line">            cleanFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            fileBuilder.append(<span class="string">&quot;.tmp&quot;</span>)</span><br><span class="line">            dirtyFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            <span class="comment">// 删除后缀</span></span><br><span class="line">            fileBuilder.setLength(truncateTo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache.Entry#writeTo</p>
<p>这个方法就是将请求头信息写入文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeTo</span><span class="params">(editor: <span class="type">DiskLruCache</span>.<span class="type">Editor</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 按照响应头的报文格式写入文件</span></span><br><span class="line">  editor.newSink(ENTRY_METADATA).buffer().use &#123; sink -&gt;</span><br><span class="line">    sink.writeUtf8(url).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(requestMethod).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="comment">// 写入Vary</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until varyHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(varyHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong((responseHeaders.size + <span class="number">2</span>).toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until responseHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(responseHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(responseHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    sink.writeUtf8(SENT_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(sentRequestMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(RECEIVED_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(receivedResponseMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isHttps) &#123;</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      sink.writeUtf8(handshake!!.cipherSuite.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      writeCertList(sink, handshake.peerCertificates)</span><br><span class="line">      writeCertList(sink, handshake.localCertificates)</span><br><span class="line">      sink.writeUtf8(handshake.tlsVersion.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheInterceptor</span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取当前的HTTP请求</span></span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取之前的缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前时间、请求和缓存响应计算缓存策略</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存策略中的网络请求和缓存响应</span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪缓存策略的结果</span></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HTTP请求的事件监听器</span></span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存候选项存在但不适用于当前请求，则关闭它。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果禁止使用网络且缓存不足，则返回一个响应表示无法满足请求</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.satisfactionFailure(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不需要网络请求，则直接返回缓存响应</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.cacheHit(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有缓存响应，通知监听器</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发起网络请求并获取网络响应</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果出现I/O错误或其他异常，确保不会泄漏缓存响应的主体（body）</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果同时有缓存响应和网络响应，表示进行条件获取（conditional get）操作</span></span><br><span class="line">		<span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 状态码给了304 说明服务器的Last-Modified字段对比一致 资源未修改可以使用缓存</span></span><br><span class="line">		    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应状态码为304（未修改），则合并两个响应</span></span><br><span class="line">		        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 关闭网络响应的主体</span></span><br><span class="line">		        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 更新缓存，将合并后的响应存储到缓存中</span></span><br><span class="line">		        cache!!.trackConditionalCacheHit()</span><br><span class="line">		        cache.update(cacheResponse, response)</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 返回合并后的响应，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">	        &#125;</span><br><span class="line">			    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应不是304，关闭缓存响应的主体</span></span><br><span class="line">			        cacheResponse.body?.closeQuietly()</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">// 走到这里说明缓存失效需要处理返回的数据</span></span><br><span class="line">			<span class="comment">// 创建网络响应对象，同时处理缓存响应和网络响应的主体</span></span><br><span class="line">			<span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">				    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">				    .networkResponse(stripBody(networkResponse))</span><br><span class="line">				    .build()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">		        <span class="comment">// 如果响应需要缓存并且满足缓存条件，将请求提供给缓存</span></span><br><span class="line">		        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        </span><br><span class="line">		        <span class="comment">// 返回一个响应，同时执行缓存写入操作，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">		            <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这会记录条件缓存未命中</span></span><br><span class="line">                listener.cacheMiss(call)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的HTTP方法会使缓存无效，尝试从缓存中删除相应的项</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// 缓存无法删除，忽略异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终的响应</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheWritingResponse</span><span class="params">(cacheRequest: <span class="type">CacheRequest</span>?, response: <span class="type">Response</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 如果缓存请求为空，或者响应的主体为空，则直接返回响应</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="literal">null</span> || response.body == <span class="literal">null</span>) <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存请求的未缓冲主体</span></span><br><span class="line">    <span class="keyword">val</span> cacheBodyUnbuffered = cacheRequest.body()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的主体源</span></span><br><span class="line">    <span class="keyword">val</span> source = response.body!!.source()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建缓存主体，使用缓冲</span></span><br><span class="line">    <span class="keyword">val</span> cacheBody = cacheBodyUnbuffered.buffer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于写入缓存的主体源</span></span><br><span class="line">    <span class="keyword">val</span> cacheWritingSource = <span class="keyword">object</span> : Source &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cacheRequestClosed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> bytesRead: <span class="built_in">Long</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bytesRead = source.read(sink, byteCount)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheRequest.abort() <span class="comment">// 写入缓存响应失败，中止缓存请求。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheBody.close() <span class="comment">// 缓存响应已完整写入！</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据写入缓存主体</span></span><br><span class="line">            sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)</span><br><span class="line">            cacheBody.emitCompleteSegments()</span><br><span class="line">            <span class="keyword">return</span> bytesRead</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span> = source.timeout()</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheRequestClosed &amp;&amp;</span><br><span class="line">                !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                cacheRequest.abort()</span><br><span class="line">            &#125;</span><br><span class="line">            source.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的Content-Type和Content-Length</span></span><br><span class="line">    <span class="keyword">val</span> contentType = response.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> contentLength = response.body.contentLength()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的响应，使用缓存写入的主体</span></span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OKHttp的缓存设计"><a href="#OKHttp的缓存设计" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h3><p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制。它允许客户端缓存请求的响应数据，减少不必要的网络请求，从而提高应用的性能和响应速度。下面是OkHttp缓存设计的关键点：</p>
<ol>
<li><p><strong>缓存存储</strong>：</p>
<ul>
<li>OkHttp使用<code>Cache</code>类管理缓存。该类负责存储、检索和清除缓存响应。</li>
</ul>
</li>
<li><p><strong>可缓存性</strong>：</p>
<ul>
<li>OkHttp中决定一个响应是否可以被缓存是基于HTTP头部信息，如<code>Cache-Control</code>、<code>Last-Modified</code>和<code>ETag</code>。</li>
</ul>
</li>
<li><p><strong>缓存策略</strong>：</p>
<ul>
<li>通过<code>CacheStrategy</code>类确定是返回缓存的响应还是发起网络请求。该策略考虑请求头中的缓存指令和响应头中的验证器（如ETag或者Last-Modified）。</li>
</ul>
</li>
<li><p><strong>缓存验证</strong>：</p>
<ul>
<li>当缓存的响应被认为是过时的，OkHttp会在新的请求中添加条件头部（例如<code>If-None-Match</code>或<code>If-Modified-Since</code>）去验证缓存。如果服务器返回304（Not Modified），表明缓存仍然有效，客户端可以继续使用缓存的数据。否则，使用新的响应数据。</li>
</ul>
</li>
<li><p><strong>缓存拦截器</strong>：</p>
<ul>
<li><code>CacheInterceptor</code>是OkHttp中管理缓存逻辑的拦截器。它会检查请求的缓存指令，根据现有的缓存响应和请求条件，选择是从缓存返回数据还是发起新的网络请求。</li>
</ul>
</li>
<li><p><strong>新鲜度和过期</strong>：</p>
<ul>
<li>缓存的响应要在一定时间内被认定为新鲜的，基于<code>Cache-Control</code>的<code>max-age</code>指令、<code>Expires</code>头部或者启发式的计算。如果响应不再新鲜，OkHttp将尝试重新验证缓存。</li>
</ul>
</li>
<li><p><strong>同步和异步请求</strong>：</p>
<ul>
<li>OkHttp的缓存策略对于同步和异步请求都适用。但它会确保在异步请求中，缓存操作和网络调用都是在后台线程中执行，不会阻塞主线程。</li>
</ul>
</li>
<li><p><strong>透明处理</strong>：</p>
<ul>
<li>对于OkHttp的使用者来说，缓存大部分时间是透明的，只需要配置好<code>Cache</code>对象，并附着到OkHttp客户端即可。实际的缓存逻辑由库内部管理。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>OkHttp的缓存策略和逻辑遵循HTTP协议，但它也提供了一定程度的自定义，应用开发者可以通过设置请求头部来影响缓存的行为。</li>
</ul>
</li>
<li><p><strong>缓存持久性</strong>：</p>
<ul>
<li>OkHttp的缓存把响应数据存储在文件系统中，即使应用被杀死，这些缓存数据仍然可以在下次应用启动时被访问。</li>
</ul>
</li>
</ol>
<p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p><code>Http</code>的缓存规则分为两大类：<strong>强制缓存，对比缓存</strong>，与缓存规则相关的信息，均包含在报文的<code>Header</code>中。</p>
<p><strong>强制缓存</strong></p>
<p>强制缓存的实现依靠于<code>Expires</code>和<code>Cache-Control</code>这两个字段。<code>Expires</code> 通过这个 Header ，服务端可以告诉客户端缓存的过期时间，表示在过期时间内该资源都不会被更改，可以不用再向自己请求了。但因为客户端时间和服务器时间的差异，在在 HTTP&#x2F;1.1 协议中引入了 <code>Cache-Control</code> 机制，通过这个 Header 可以在服务端与客户端之间沟通缓存信息。常见的缓存指令如下</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center"><strong>客户端</strong>可以缓存</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center"><strong>客户端</strong>和<strong>代理服务器</strong>都可以缓存</td>
</tr>
<tr>
<td align="center">max-age&#x3D;xxx</td>
<td align="center">缓存数据在xxx秒后过期</td>
</tr>
<tr>
<td align="center">no-cache</td>
<td align="center">需要使用对比缓存来验证缓存数据</td>
</tr>
</tbody></table>
<p><strong>对比缓存</strong></p>
<p>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。<br>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若缓存资源仍有效，服务器会返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>通过Last-Modified &#x2F; If-Modified-Since与Cache-Control配合判断，<code>Last-Modified</code> 位于响应头，<code>If-Modified-Since</code> 位于请求头。</p>
<ul>
<li><p><code>Last-Modified</code>：该响应资源最后的修改时间，服务器在响应请求的时候可以填入该字段。</p>
</li>
<li><p>If-Modified-Since：客户端缓存过期时（<code>max-age</code> 到达），发现该资源具有 <code>Last-Modified</code> 字段，可以在 Header 中填入 <code>If-Modified-Since</code> 字段，并填入<code>Last-Modified</code>记录的时间。服务端收到该时间后会与该资源的最后修改时间进行比较。</p>
<ul>
<li><p>若该资源已经被修改 ，则会返回状态码200，并对整个资源响应。</p>
</li>
<li><p>否则说明该资源在访问时未被修改，则会响应状态码 304，告知客户端可以使用缓存的资源</p>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>强制缓存和对比缓存可以同时存在，<strong>强制缓存优先级高于对比缓存</strong>，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p>当强制缓存和对比缓存同时存在时：</p>
<ol>
<li>对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。</li>
<li>对于比较缓存，客户端将缓存信息中的<code>Etag</code>和<code>Last-Modified</code>通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。</li>
</ol>
<h2 id="ConnectInterceptor-建立连接的拦截器"><a href="#ConnectInterceptor-建立连接的拦截器" class="headerlink" title="ConnectInterceptor 建立连接的拦截器"></a>ConnectInterceptor 建立连接的拦截器</h2><p>该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。</p>
<p><a href="https://www.cnblogs.com/giagor/p/15706524.html">探索OkHttp系列 (五) 连接建立与复用 - Giagor - 博客园</a></p>
<h3 id="HTTP中的连接复用机制"><a href="#HTTP中的连接复用机制" class="headerlink" title="HTTP中的连接复用机制"></a><strong><strong>HTTP中的连接复用机制</strong></strong></h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Http协议需要首先建立Socket连接（即TCP&#x2F;IP连接），同时我们了解到TCP&#x2F;IP连接需要进行三次握手，断开连接需要完成四次挥手。在完成了对某一域名的Socket连接之后，借助此Socket来进行Http数据的交互。那么第一次交互完成之后，如果需要进行与此域名的第二次交互，就可以利用前一次的Socket连接进行。因此OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。</p>
<h3 id="okHttp如何复用TCP连接？"><a href="#okHttp如何复用TCP连接？" class="headerlink" title="okHttp如何复用TCP连接？"></a><strong>okHttp如何复用TCP连接？</strong></h3><p>这个其实主要说的是 <code>ConnectInterceptor</code> 拦截器中初始化 <code>Exchange</code> 时内部做的事，具体如下：</p>
<p><code>OkHttp</code> 使用连接池 <code>RealConnectionPool</code> 管理所有连接，连接池将所有活动的连接存储在池中，并维护了一个空闲的链接列表(<code>TaskQueue</code>)，当需要新的连接时，<strong>优先尝试从这个池中找</strong>，如果没找到，则 <strong>重新创建</strong> 一个 <code>RealConnection</code> 连接对象，并将其添加到连接池中。在具体的寻找连接的过程中，一共进行了下面5次尝试：</p>
<ol>
<li>尝试重连 <code>RealCall</code> 中的 <code>connection</code>，此时不需要重新获取连接；</li>
<li>尝试从连接池中获取一个连接，不带路由与多路复用；</li>
<li>再次尝试从连接池中获取一个连接，带路由，不带多路复用；</li>
<li>手动创建一个新连接；</li>
<li>再次尝试从连接池中获取一个连接，带路由与多路复用；</li>
</ol>
<p>当然 <code>OkHttp</code> 也支持自定义连接池，具体如下：</p>
<p><img src="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png" alt="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png"></p>
<p>上述代码中，创建了一个新的连接池，并设置其保留最多 <code>maxIdleConnections</code> 个空闲连接，并且连接的存活期为 <code>keepAliveDuration</code> 分钟。</p>
<h3 id="okhttp连接池使用流程"><a href="#okhttp连接池使用流程" class="headerlink" title="okhttp连接池使用流程"></a>okhttp连接池使用流程</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20211209161223068.png" alt="image-20211209161223068"></p>
<h3 id="从连接池中获取可用连接部分代码分析"><a href="#从连接池中获取可用连接部分代码分析" class="headerlink" title="从连接池中获取可用连接部分代码分析"></a>从连接池中获取可用连接部分代码分析</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个连接去承载新的流，优先使用现有连接，接着是连接池中的连接，最后是创建一个新的连接</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 检查取消事件  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.尝试去重用call的连接  </span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="comment">// 检查这个连接是否可用和可复用  </span></span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        <span class="comment">// 连接不可用，在call中移除该连接，并返回该连接对应的Socket，随后要关闭它  </span></span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="comment">// 如果连接可以使用，那么就返回该连接  </span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    <span class="comment">// 关闭Socket  </span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need a new connection. Give it fresh stats.</span></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.尝试从连接池中获取连接(第一次)</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="comment">// 连接池里没有东西，计算下一条要尝试的路由  </span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 从现有的routeSelection中获取一个路由  </span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算一个新的routeSelector，这是一个阻塞操作  </span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="comment">// 如果routeSelector为null，那么就先创建一个RouteSelector  </span></span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从routeSelector中获取一个新的routeSelection  </span></span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    <span class="comment">// 获取routeSelection中的路由列表  </span></span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">    <span class="comment">// the pool. We have a better chance of matching thanks to connection coalescing.</span></span><br><span class="line">    <span class="comment">// 3.现在我们有了一组IP地址，再次尝试从连接池中获取连接，由于连接合并，这次我们有更大的希望</span></span><br><span class="line">    <span class="comment">// 从连接池里获取一个连接(第二次)  </span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="comment">// 返回连接</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从routeSelection中获取一个路由，用于新连接的创建  </span></span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="comment">// 4.创建新连接  </span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行TCP+TLS握手(Https请求才会做TLS握手)，这是一个阻塞的操作    </span></span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we raced another call connecting to this host, coalesce the connections. This makes for 3</span></span><br><span class="line">  <span class="comment">// different lookups in the connection pool!</span></span><br><span class="line">  <span class="comment">// 5.如果有另一个调用也是连接到相同的主机，并且该调用已经创建了新连接，将连接放到了连接池里，</span></span><br><span class="line">  <span class="comment">// 那么就使用连接池里的连接(第三次)  </span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    <span class="comment">// 保存路由  </span></span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    <span class="comment">// 将前面新创建的连接的Socket关闭  </span></span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接池中的连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三次在连接池中获取连接，依然没找到，意味着要使用新创建的连接 */</span>  </span><br><span class="line">      </span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    <span class="comment">// 6.将先创建的连接放进连接池里面</span></span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="comment">// 返回新创建的连接  </span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CallServerInterceptor：读写拦截器"><a href="#CallServerInterceptor：读写拦截器" class="headerlink" title="CallServerInterceptor：读写拦截器"></a>CallServerInterceptor：<strong>读写拦截器</strong></h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="comment">// 以Request作为Key，获取候选缓存  </span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据「当前时间、请求、候选缓存」，创建缓存策略  </span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="comment">// 如果该请求不需要使用网络，那么networkRequest就为null  </span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="comment">// 如果不存在该请求对应的缓存，那么cacheResponse为null  </span></span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且没有对应的缓存，那么直接报错，返回状态码504  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.satisfactionFailure(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且有对应的缓存，那么就进入If语句，返回缓存</span></span><br><span class="line">    <span class="comment">// (代码执行到这里，说明networkRequest和cacheResponse不能同时为null)  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 经过上面的两个If语句，代码执行到这里，说明networkRequest不为null，也就是该请求要使用网络 */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示网络请求的响应  </span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 进行网络请求，获取下一个拦截器返回的Response  </span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="comment">// 释放资源  </span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 之前已经获取到请求对应的缓存  </span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若网络请求返回的响应中，包含状态码304，说明之前的缓存数据有效，返回cacheResponse对应</span></span><br><span class="line">      <span class="comment">// 的缓存结果（HTTP_NOT_MODIFIED对应状态码304）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">  			<span class="comment">// 混合 缓存Response的Header 和 网络获取的Response的Header        </span></span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存过期，收回资源  </span></span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 在上面的一大段If语句中，若响应码为304，则缓存资源有效，返回缓存资源，若响应码不为304， */</span>  </span><br><span class="line">	<span class="comment">/* 则表示缓存资源过期，关闭缓存资源 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取网络请求的结果  </span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对网络请求获取的Response进行缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果请求方法不需要缓存，则移除缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回网络的请求结果  </span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>自定义拦截器有两种应用拦截器和网络拦截器分别在两个位置，一个是在拦截器链头部，一个是在<strong>CallServerInterceptor和</strong>ConnectInterceptor中间。</p>
<p>他俩的区别：</p>
<ul>
<li>添加方式</li>
</ul>
<p>头：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>尾：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Recyclerview缓存机制</title>
    <url>/2023/12/15/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Recyclerview缓存机制"><a href="#Recyclerview缓存机制" class="headerlink" title="Recyclerview缓存机制"></a>Recyclerview缓存机制</h1><h2 id="Recyclerview基本使用"><a href="#Recyclerview基本使用" class="headerlink" title="Recyclerview基本使用"></a>Recyclerview基本使用</h2><p>xml中添加空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>item.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;测试&quot;</span> /&gt;</span></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<p>Adapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerView.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  OnItemClickListener itemClickListener;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShareBean&gt; mData = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecyclerAdapter</span><span class="params">(Context context, List&lt;ShareBean&gt; mData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mData = mData;</span><br><span class="line">        <span class="built_in">this</span>.mInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将布局转化为 View 并传递给 RecyclerView 封装好的 ViewHolder</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span>&#123;    </span><br><span class="line">        <span class="comment">// 实例化展示的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mInflater.inflate(R.layout.item_recyclerview, parent, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 实例化viewholder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemViewHolder</span>(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据与视图进行绑定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        ((ItemViewHolder) holder).mImageView.setImageResource(mData.get(position).getImage_id());</span><br><span class="line">        ((ItemViewHolder) holder).mTextView.setText(mData.get(position).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 Item 的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mData == <span class="literal">null</span> ? <span class="number">0</span> : mData.size();;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        CardView mCardView;</span><br><span class="line">        CircleImageView mImageView;</span><br><span class="line">        TextView mTextView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ItemViewHolder</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            mTextView = (TextView) itemView.findViewById(R.id.textView);</span><br><span class="line">            mCardView = (CardView) itemView.findViewById(R.id.cardView);</span><br><span class="line">            mImageView = (CircleImageView) itemView.findViewById(R.id.image);</span><br><span class="line">            mCardView.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (itemClickListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        itemClickListener.onItemClick(view, getPosition());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RecyclerView缓存的是什么？"><a href="#RecyclerView缓存的是什么？" class="headerlink" title="RecyclerView缓存的是什么？"></a>RecyclerView缓存的是什么？</h2><p>首先明确一点，Recyclerview缓存的是ViewHolder。</p>
<h2 id="RecyclerView缓存的目的？"><a href="#RecyclerView缓存的目的？" class="headerlink" title="RecyclerView缓存的目的？"></a>RecyclerView缓存的目的？</h2><ul>
<li>onCreateViewHolder：负责创建并初始化ViewHolder及其关联的视图，但不会填充视图内容。</li>
<li>onBindViewHolder：负责提取适当的数据，填充ViewHolder的视图内容。</li>
</ul>
<p>最优情况是——取得的缓存对象正好是原先的ViewHolder对象，这种情况下既不需要重新创建该对象，也不需要重新绑定数据，即拿即用。</p>
<p>次优情况是——取得的缓存对象虽然不是原先的ViewHolder对象，但由于二者的列表项类型(itemType)相同，其关联的视图可以复用，因此只需要重新绑定数据即可。</p>
<p>最后实在没办法了，才需要执行这2个方法的回调，即创建新的ViewHolder对象并绑定数据</p>
<p>应该通过对ViewHolder对象积极地缓存复用，来尽量减少对这2个方法的回调频次。</p>
<h2 id="RecyclerView缓存的实现"><a href="#RecyclerView缓存的实现" class="headerlink" title="RecyclerView缓存的实现"></a>RecyclerView缓存的实现</h2><h3 id="RecyclerView的滚动实现"><a href="#RecyclerView的滚动实现" class="headerlink" title="RecyclerView的滚动实现"></a>RecyclerView的滚动实现</h3><p>看源码分析从onTouchEvent方法的ACTION_MOVE事件开始，然后到scrollByInternal方法又到scrollStep方法最终又会调用到LayoutManager的方法来实现最终的滑动处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedX = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedY = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而LayoutManager中的这两个方法又分别交给了他的实现类去实现，这里以LinearLayoutManager类为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置回收标记，表示在布局过程中可以回收和复用视图</span></span><br><span class="line">    mLayoutState.mRecycle = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 根据滚动的方向，设置布局的方向。delta &gt; 0表示向结束方向滚动，否则向开始方向滚动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> delta &gt; <span class="number">0</span> ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">    <span class="comment">// 获取滚动距离的绝对值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absDelta</span> <span class="operator">=</span> Math.abs(delta);</span><br><span class="line">    <span class="comment">// 更新LayoutManager的状态，包括布局方向、滚动距离等</span></span><br><span class="line">    updateLayoutState(layoutDirection, absDelta, <span class="literal">true</span>, state);</span><br><span class="line">    <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">            + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">    。。。。</span><br><span class="line">    <span class="comment">//距离大于实际能够滚动的距离，就滚动实际能够滚动的距离，否则滚动请求的距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">scrolled</span> <span class="operator">=</span> absDelta &gt; consumed ? layoutDirection * consumed : delta;</span><br><span class="line">    <span class="comment">// 根据实际的滚动距离，移动所有的子视图</span></span><br><span class="line">    mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">    <span class="comment">// 保存实际的滚动距离，以便后续使用</span></span><br><span class="line">    mLayoutState.mLastScrollDelta = scrolled;</span><br><span class="line">    <span class="comment">// 返回实际的滚动距离</span></span><br><span class="line">    <span class="keyword">return</span> scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取填充项和进行回收项"><a href="#获取填充项和进行回收项" class="headerlink" title="获取填充项和进行回收项"></a>获取填充项和进行回收项</h3><p>这里又调用了fill方法，这个方法是用来获取填充项的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			...</span><br><span class="line">            <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">                <span class="comment">//在当前滚动偏移量基础上追加因新表项插入增加的像素（这句话对于“回收哪些表项”来说很关键）</span></span><br><span class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//回收表项</span></span><br><span class="line">                recycleByLayoutState(recycler, layoutState);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!layoutState.mRecycle || layoutState.mInfinite) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            <span class="comment">// 从列表头回收</span></span><br><span class="line">            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从列表尾回收</span></span><br><span class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="回收条件判断"><a href="#回收条件判断" class="headerlink" title="回收条件判断"></a>回收条件判断</h3><p>这里只看列表头回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向列表尾部滚动时回收滚出屏幕的表项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dt（该参数被用于检测滚出屏幕的表项）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="type">int</span> scrollingOffset,<span class="type">int</span> noRecycleSpace)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> scrollingOffset - noRecycleSpace;</span><br><span class="line">        <span class="comment">//从头开始遍历 LinearLayoutManager，以找出应该会回收的表项</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="comment">// 如果表项的下边界 &gt; limit 这个阈值</span></span><br><span class="line">            <span class="keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                    || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">                <span class="comment">//回收索引为 0 到 i-1 的表项</span></span><br><span class="line">                recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看上面代码中有一个判断条件<code>mOrientationHelper.getDecoratedEnd(child) &gt; limit</code>，***在纵向列表中，“表项底部纵坐标 &gt; 某个值”意味着表项位于某条线的下方，即 limit 是列表中隐形的线，所有在这条线上方的表项都应该被回收。</p>
<p><strong>limit 隐形线</strong>的初始值 &#x3D; 列表当前可见表项的底部到列表底部的距离，即列表在不填充新表项时，可以滑动的最大距离。每一个新填充表项消耗的像素值都会被追加到 limit 值之上，即<strong>limit 隐形线</strong>会随着新表项的填充而不断地下移。</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><h4 id="第一级mCachedViews"><a href="#第一级mCachedViews" class="headerlink" title="第一级mCachedViews"></a>第一级mCachedViews</h4><p>会看代码执行到了<code>recycleChildren(recycler, 0, i);</code>，跟代码最终会调用<code>recycler.recycleView(view);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Recycler </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycleView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取表项 ViewHolder </span></span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">            <span class="keyword">if</span> (holder.isTmpDetached()) &#123;</span><br><span class="line">                removeDetachedView(view, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                holder.unScrap();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                holder.clearReturnedFromScrapFlag();</span><br><span class="line">            &#125;</span><br><span class="line">            recycleViewHolderInternal(holder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>getChildViewHolderInt(view)获取的是滑出屏幕的项的ViewHolder，然后交给了recycleViewHolderInternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">mViewCacheMax</span> <span class="operator">=</span> DEFAULT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CACHE_SIZE</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">// mCachedViews的长度限制为2</span></span><br><span class="line">    	<span class="comment">// mCachedViews是一个ArrayList</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">                <span class="comment">//先存在mCachedViews里面</span></span><br><span class="line">                <span class="comment">//这里的判断条件决定了复用mViewCacheMax中的ViewHolder时不需要重新绑定数据</span></span><br><span class="line">                <span class="keyword">if</span> (mViewCacheMax &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">                        | ViewHolder.FLAG_REMOVED</span><br><span class="line">                        | ViewHolder.FLAG_UPDATE</span><br><span class="line">                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">                    <span class="comment">//如果mCachedViews大小超限了，则删掉最老的被缓存的ViewHolder</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">cachedViewSize</span> <span class="operator">=</span> mCachedViews.size();</span><br><span class="line">                    <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这里将索引为0的元素放入到回收池RecycledViewPool中  </span></span><br><span class="line">                        recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                        cachedViewSize--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">targetCacheIndex</span> <span class="operator">=</span> cachedViewSize;</span><br><span class="line">                    <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK</span><br><span class="line">                            &amp;&amp; cachedViewSize &gt; <span class="number">0</span></span><br><span class="line">                            &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> cachedViewSize - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> (cacheIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cachedPos</span> <span class="operator">=</span> mCachedViews.get(cacheIndex).mPosition;</span><br><span class="line">                            <span class="keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            cacheIndex--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        targetCacheIndex = cacheIndex + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//ViewHolder加到缓存中</span></span><br><span class="line">                    mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">                    cached = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若ViewHolder没有入缓存则存入回收池</span></span><br><span class="line">                <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">                    addViewHolderToRecycledViewPool(holder, <span class="literal">true</span>);</span><br><span class="line">                    recycled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码做了这么一件事，首先判断mCachedViews的元素数量，如果数量超过或者等于2就将最先添加到list的元素放到RecycledViewPool中，然后在mCachedViews中移除它。然后将传入的holder添加到mCachedViews中。</p>
<p>mCachedViews中的数量会限制为两个。移出屏幕的holder最先会添加到mCachedViews中，但是如果mViewCacheMax &lt;&#x3D; 0（setViewCacheSize方法可以修改这个值）或者holder有其中任何一个标识：</p>
<ul>
<li><code>ViewHolder.FLAG_INVALID</code>：表示这个视图是无效的，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_REMOVED</code>：表示这个视图已经被移除。</li>
<li><code>ViewHolder.FLAG_UPDATE</code>：表示这个视图的数据已经更新，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN</code>：表示这个视图的适配器位置未知</li>
</ul>
<p>都会将这个移出屏幕的holder越过mCachedViews直接放入RecycledViewPool中。<strong>所以从<code>mCachedViews</code>中复用的<code>ViewHolder</code>不需要重新绑定数据，从RecycledViewPool复用的<code>ViewHolder</code>需要重新绑定数据。</strong></p>
<h4 id="第二级RecycledViewPool"><a href="#第二级RecycledViewPool" class="headerlink" title="第二级RecycledViewPool"></a>第二级RecycledViewPool</h4><p>前面讲到会将mCachedViews中最老的元素放入RecycledViewPool中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存池实例</span></span><br><span class="line">        RecycledViewPool mRecyclerPool;</span><br><span class="line">        <span class="comment">// 将viewHolder存入缓存池</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">addViewHolderToRecycledViewPool</span><span class="params">(ViewHolder holder, <span class="type">boolean</span> dispatchRecycled)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            getRecycledViewPool().putRecycledView(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 RecycledViewPool 实例</span></span><br><span class="line">        RecycledViewPool <span class="title function_">getRecycledViewPool</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRecyclerPool == <span class="literal">null</span>) &#123;</span><br><span class="line">                mRecyclerPool = <span class="keyword">new</span> <span class="title class_">RecycledViewPool</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mRecyclerPool;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RecycledViewPool</span> &#123;</span><br><span class="line">        <span class="comment">// 单类型 ViewHolder 列表</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">            <span class="comment">// 最终存储 ViewHolder 实例的列表</span></span><br><span class="line">            ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//每种类型的 ViewHolder 最多存 5 个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//键值对:以 viewType 为键，ScrapData 为值，用以存储不同类型的 ViewHolder 列表</span></span><br><span class="line">        SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//ViewHolder 入池 按 viewType 分类入池，相同的 ViewType 存放在同一个列表中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putRecycledView</span><span class="params">(ViewHolder scrap)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> scrap.getItemViewType();</span><br><span class="line">            <span class="comment">// 获取viewType类型的ArrayList</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;</span><br><span class="line">            <span class="comment">//如果超限了，则放弃入池</span></span><br><span class="line">            <span class="keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 入回收池之前重置 ViewHolder</span></span><br><span class="line">            scrap.resetInternal();</span><br><span class="line">            <span class="comment">// 最终 ViewHolder 入池</span></span><br><span class="line">            scrapHeap.add(scrap);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ScrapData <span class="title function_">getScrapDataForType</span><span class="params">(<span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">     		<span class="comment">// 根据type获取ScrapData 这是个静态类</span></span><br><span class="line">            <span class="type">ScrapData</span> <span class="variable">scrapData</span> <span class="operator">=</span> mScrap.get(viewType);</span><br><span class="line">            <span class="keyword">if</span> (scrapData == <span class="literal">null</span>) &#123;</span><br><span class="line">                scrapData = <span class="keyword">new</span> <span class="title class_">ScrapData</span>();</span><br><span class="line">                mScrap.put(viewType, scrapData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> scrapData;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">    		<span class="comment">// 存放ViewHolder的list</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是RecycledViewPool的详细逻辑，首先呢RecycledViewPool中以 viewType 为键，ScrapData 为值使用SparseArray进行存储。且每种类型最多存储5个，多的直接抛弃掉了。	</p>
<h4 id="屏幕内的缓存项"><a href="#屏幕内的缓存项" class="headerlink" title="屏幕内的缓存项"></a>屏幕内的缓存项</h4><p>在RecyclerView的dispatchLayoutStep2方法中会调用LayoutManager的<em>onLayoutChildren</em>方法，这个方法也是子类实现的。还是看LinearLayoutManager 中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> <span class="keyword">implements</span> <span class="title class_">ScrollingView</span>, NestedScrollingChild2 &#123;</span><br><span class="line">    <span class="comment">// RecyclerView布局的第二步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchLayoutStep2</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#LinearLayoutManager </span><br><span class="line">		<span class="comment">// 布局所有子表项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在填充表项之前回收所有表项</span></span><br><span class="line">            detachAndScrapAttachedViews(recycler);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 填充表项</span></span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 暂时将当可见表项进行分离并回收</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detachAndScrapAttachedViews</span><span class="params">(Recycler recycler)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">            <span class="comment">// 遍历所有可见表项并回收他们</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">                scrapOrRecycleView(recycler, i, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在将表项一个个填充到列表之前会先将其先回收到<code>mAttachedScrap</code>中,下面看一下scrapOrRecycleView的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#RecyclerView</span><br><span class="line">	<span class="comment">// recycler是负责回收和复用视图的对象，index是需要处理的视图在当前布局中的位置，view是需要处理的视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="type">int</span> index, View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder应该被忽略（可能是因为它正在进行删除动画或者还没有绑定数据等原因），则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;ignoring view &quot;</span> + viewHolder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么从布局中移除这个视图，并将其回收</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">            removeViewAt(index);</span><br><span class="line">            <span class="comment">// 这里就是走的上面的一二级回收逻辑</span></span><br><span class="line">            recycler.recycleViewHolderInternal(viewHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，从布局中分离这个视图，但不回收它，而是将其添加到带复用视图列表中</span></span><br><span class="line">            detachViewAt(index);</span><br><span class="line">            recycler.scrapView(view);</span><br><span class="line">            <span class="comment">// 通知ViewInfoStore这个视图已经被分离，ViewInfoStore是用于存储视图信息的对象，例如视图的位置和大小等</span></span><br><span class="line">            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里会根据viewHolder的状态判断是放入回收池中还是调用scrapView方法放入mAttachedScrap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scrapView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder有任何指定的标志，或者没有更新，或者可以复用更新的ViewHolder</span></span><br><span class="line">        <span class="comment">// 那么将这个ViewHolder添加到已附加的废弃视图列表中</span></span><br><span class="line">        <span class="keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">            <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么抛出异常</span></span><br><span class="line">            <span class="comment">// 因为无效的视图不能从视图列表中复用，它们应该从回收池中重新绑定</span></span><br><span class="line">            <span class="keyword">if</span> (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Called scrap view with an invalid view.&quot;</span></span><br><span class="line">                        + <span class="string">&quot; Invalid views cannot be reused from scrap, they should rebound from&quot;</span></span><br><span class="line">                        + <span class="string">&quot; recycler pool.&quot;</span> + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已附加的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">            mAttachedScrap.add(holder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，如果已改变的废弃视图列表为空，那么创建这个列表</span></span><br><span class="line">            <span class="keyword">if</span> (mChangedScrap == <span class="literal">null</span>) &#123;</span><br><span class="line">                mChangedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已改变的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">            mChangedScrap.add(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>放入mAttachedScrap中还是放入mChangedScrap取决于ViewHolder的状态。</p>
<p>mChangedScrap主要的使用场景是：</p>
<ol>
<li>开启了列表项动画(itemAnimator)，并且列表项动画的<code>canReuseUpdatedViewHolder(ViewHolder viewHolder)</code>方法返回false的前提下；</li>
<li>调用了notifyItemChanged、notifyItemRangeChanged这一类方法，通知列表项数据发生变化；</li>
</ol>
<p><strong>mChangedScrap主要是为列表项数据发生变化时的动画效果服务的</strong>。</p>
<p><strong>mAttachedScrap应对的则是剩下的绝大部分场景</strong>，比如：</p>
<ul>
<li>像notifyItemMoved、notifyItemRemoved这种列表项发生移动，但列表项数据本身没有发生变化的场景。</li>
<li>关闭了列表项动画，或者列表项动画的canReuseUpdatedViewHolder方法返回true，即允许重用原先的ViewHolder对象的场景。</li>
</ul>
<p>最后在dispatchLayoutStep3方法也就是布局的最后一个阶段会将mChangedScrap和mAttachedScrap里的内容清空。</p>
<p>这2个缓存结构实际上更多是为了避免出现像<em><strong>局部刷新</strong></em>这一类的操作，导致所有的列表项都需要重绘的情形。在预布局会有解释。</p>
<p>结论：**<code>mAttachedScrap</code>用于屏幕中可见表项的回收和复用，生命周期起始于<code>RecyclerView</code>布局开始，终止于<code>RecyclerView</code>布局结束。**</p>
<p>回收部分到此为止</p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><h4 id="复用时机"><a href="#复用时机" class="headerlink" title="复用时机"></a>复用时机</h4><p><em><strong>当移出屏幕的项重新回到界面</strong></em></p>
<p>回顾上面LayoutManager类的scrollBy方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">                + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">        。。。。</span><br><span class="line">        <span class="keyword">return</span> scrolled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用fill方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutChunk方法就是填充新的项，看下一这个方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> &#123;</span><br><span class="line">        <span class="comment">//获得下一个表项</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> layoutState.next(recycler);</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将表项插入到列表中</span></span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                addView(view);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutState.next(recycler);就是用来获取下一项的，获取后将它添加到ViewGroup中。next最终就会调用到tryGetViewHolderForPositionByDeadline方法中这个方法真正实现的复用逻辑。</p>
<h4 id="复用逻辑"><a href="#复用逻辑" class="headerlink" title="复用逻辑"></a>复用逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获得指定位置的ViewHolder，要么从scrap，cache，RecycledViewPool中获取，要么直接重新创建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">fromScrapOrHiddenOrCache</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//0 从changed scrap集合中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1. 通过position从attach scrap或一级回收缓存中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                <span class="comment">//2. 通过id在attach scrap集合和一级回收缓存中查找viewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3. 从自定义缓存中获取ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; mViewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">                    <span class="comment">// know it.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.从缓存池中拿ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">                    ...</span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//所有缓存都没有命中，只能创建ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">bound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">                holder.mPreLayoutPosition = position;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有invalid的viewHolder才能绑定视图数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                <span class="comment">//获得ViewHolder后，绑定视图数据</span></span><br><span class="line">                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结上面代码：</p>
<p>上面设计到的数据结构有四个mChangedScrap、mAttachedScrap、mCachedViews、RecycledViewPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>代码检索总共会检索5次，第一次从mChangedScrap检索，第二次通过position从attach scrap或一级回收缓存中获取ViewHolder，第三次通过id在attach scrap集合和一级回收缓存中查找viewHolder，第四次从自定义缓存中获取ViewHolder，第五次从缓存池中拿ViewHolder，如果五次检索完都没有的画就会新创建一个viewHolder。</p>
<table>
<thead>
<tr>
<th>缓存结构</th>
<th>容器类型</th>
<th>容量限制</th>
<th>缓存用途</th>
<th>优先级顺序(数值越小，优先级越高)</th>
</tr>
</thead>
<tbody><tr>
<td>mChangedScrap&#x2F;mAttachedScrap</td>
<td>ArrayList</td>
<td>无，一般为屏幕内总的可见列表项数</td>
<td>临时存放仍在当前屏幕可见、但被标记为「移除」或「重用」的列表项</td>
<td>0</td>
</tr>
<tr>
<td>mCachedViews</td>
<td>ArrayList</td>
<td>默认为2</td>
<td>存放已被移出屏幕、但有可能很快重新进入屏幕的列表项</td>
<td>1</td>
</tr>
<tr>
<td>mViewCacheExtension</td>
<td>开发者自己定义</td>
<td>无</td>
<td>提供额外的可由开发人员自由控制的缓存层级</td>
<td>2</td>
</tr>
<tr>
<td>mRecyclerPool</td>
<td>SparseArray<ArrayList></td>
<td>每种itemType默认为5</td>
<td>按不同的itemType分别存放超出mCachedViews限制的、被移出屏幕的列表项</td>
<td>3</td>
</tr>
</tbody></table>
<h4 id="“mAttachedScrap用于屏幕中可见表项的回收和复用”"><a href="#“mAttachedScrap用于屏幕中可见表项的回收和复用”" class="headerlink" title="“mAttachedScrap用于屏幕中可见表项的回收和复用”"></a>“mAttachedScrap用于屏幕中可见表项的回收和复用”</h4><p>这是RecyclerView特殊的pre-layout &amp; post-layout 机制的产物。举个简单的例子，列表有1-4个表项，现删除了第3个表项，这会触发layout过程，RecyclerView的layout有好多个阶段，第一阶段列表的4个表项对应的ViewHolder都会被存入scrap列表，layout的最后阶段会去取用于用于展示的表项（1，2，4，5），此时1，2，4表项就可以从scap中获取，而5从recycler pool中获取</p>
<h3 id="预布局"><a href="#预布局" class="headerlink" title="预布局"></a>预布局</h3><p><a href="https://juejin.cn/post/6892809944702124045">https://juejin.cn/post/6892809944702124045</a></p>
<p><a href="https://juejin.cn/post/7181979065488769083">https://juejin.cn/post/7181979065488769083</a></p>
<p><a href="https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/6844903778303361038">https://juejin.cn/post/6844903778303361038</a></p>
]]></content>
  </entry>
  <entry>
    <title>kotlin泛型</title>
    <url>/2023/12/15/kotlin%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h3 id="泛型的基本声明方法"><a href="#泛型的基本声明方法" class="headerlink" title="泛型的基本声明方法"></a>泛型的基本声明方法</h3><p>函数声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span><span class="title">maxOf</span><span class="params">(a:<span class="type">T</span>,b:)</span></span>T</span><br></pre></td></tr></table></figure>

<p>类声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​                                                  </p>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = maxOf&lt;String&gt;(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = List.Cons(<span class="number">1.0</span>,ListNil)</span><br></pre></td></tr></table></figure>

<h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能将实现了Comparable接口的数据传进来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt;= b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的型变"><a href="#泛型的型变" class="headerlink" title="泛型的型变"></a>泛型的型变</h3><ul>
<li>不变</li>
</ul>
<p><strong>Nothing理论上是所有类型的子类</strong>，但这里的Lis<T>和Lis<Nothing>没有任何继承关系。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 此处会报错</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: List&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>协变</li>
</ul>
<p>协变点</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span>List<span class="type">&lt;T&gt;</span>.<span class="title">get</span><span class="params">(index:<span class="type">Int</span>)</span></span>:T</span><br></pre></td></tr></table></figure>

<p>函数返回值类型为泛型参数，这个返回值就叫做协变点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里不会报错了</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里对泛型添加out修饰  实现泛型的协变 Lis&lt;Nothing&gt;成为了Lis&lt;T&gt;的子类。</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">		<span class="comment">// 这里head的getter返回T 也是一个协变点</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: Lis&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>协变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>生产者Producer<Derived>兼容Producer<Base>.    <strong>能生产子类就能生产父类</strong></li>
<li>存在协变点的类的泛型参数必须声明为协变或不变</li>
<li>当泛型类作为泛型参数类实例的生产者时用协变</li>
</ol>
<p>生产者是要向外提供一些东西的，这里子类继承父类后会实现父类的方法。泛型如果是协变的，但是需要的地方是父类，又因为里氏替换原则子类可以代替父类（子类继承自父类），所以可以让Class<Son>成为Class<Father>的子类。</p>
<ul>
<li>逆变</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数参数类型为泛型参数。参数的位置就是逆变点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如</p>
<p>Int是Number的子类，但是能比较Int的不一定能比较Number，所以CompareTo<Number>是CompareTo<Int>的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垃圾</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Waste</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 干垃圾</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DryWaste</span> : <span class="type">Waste</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾桶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dustbin</span>&lt;<span class="type">in T : Waste</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 扔垃圾</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;put <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">contravariant</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dustbin: Dustbin&lt;Waste&gt; = Dustbin&lt;Waste&gt;()</span><br><span class="line">    <span class="comment">// 干垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dryWasteDustbin: Dustbin&lt;DryWaste&gt; = dustbin</span><br><span class="line">    <span class="comment">// 垃圾对象</span></span><br><span class="line">    <span class="keyword">val</span> waste = Waste()</span><br><span class="line">    <span class="comment">// 干垃圾对象 </span></span><br><span class="line">    <span class="keyword">val</span> dryWaste = DryWaste()</span><br><span class="line">    <span class="comment">// 扔垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(dryWaste)</span><br><span class="line">    <span class="comment">// 扔垃圾到干垃圾桶 这里报错：类型不匹配。要求:DryWaste实际:Waste</span></span><br><span class="line">    dryWasteDustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到干垃圾桶</span></span><br><span class="line">    dryWasteDustbin.put(dryWaste)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>逆变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>消费者Consumer.<Base>兼容Consumer<Derived>   <strong>能消费父类就能消费子类</strong></li>
<li>存在逆变点的类的泛型参数必须声明为逆变或不变</li>
<li>当泛型类作为泛型参数类实例的消费者时用逆变</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>泛型协变的语法规则：<code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code>，它限定的类型是当前上边界类或者其子类，如果是接口的话就是当前上边界接口或者实现类，协变的泛型变量只读，不可以写，可以添加 null ，但是没意义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 协变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">// 这里可以将SimpleData&lt;Student&gt;()赋值给SimpleData&lt;Person&gt;</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">    <span class="keyword">val</span> list1: ArrayList&lt;<span class="keyword">out</span> Person&gt; = ArrayList&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>泛型逆变的语法规则：<code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code>，它限定的类型是当前<strong>下边界类</strong>或者其父类，如果是接口的话就是当前下边界接口或者其父接口，逆变的泛型变量只能写，不建议读。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 逆变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">in T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1: Person = Student()</span><br><span class="line">  	<span class="comment">// 这里将SimpleData&lt;Person&gt;()赋值给SimpleData&lt;Student&gt; 必须是Student或Student的父类，比如Student的子类就会报错。</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric1: SimpleData&lt;Student&gt; = SimpleData&lt;Person&gt;()</span><br><span class="line">    <span class="keyword">val</span> list2: ArrayList&lt;<span class="keyword">in</span> Person&gt; = ArrayList&lt;Any&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不变的话就是没有对应的子父类关系</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">//编译器不允许</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型的出现是为了解决什么问题"><a href="#泛型的出现是为了解决什么问题" class="headerlink" title="泛型的出现是为了解决什么问题"></a>泛型的出现是为了解决什么问题</h3><ol>
<li>减少重复代码</li>
<li>增加编译时类型的检查，避免一些运行时的类型错误问题</li>
</ol>
<p>比如往集合中添加元素，可以添加任何类型。但是取得时候不知道类型会报错。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b1b5b02cad3adceb3514735733af8d14_720w.webp" alt="img"></p>
<p>如果一只猫是一只动物，那一群猫是一群动物吗？一群狗是一群动物吗？Java数组认为是的。如果Cat是Animal的子类型，那么<code>Cat[]</code>也是<code>Animal[]</code>的子类型，我们称这种性质为<strong>协变</strong>（covariance）。<strong>Java中，数组是协变的</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>kotlin协程</title>
    <url>/2023/12/15/kotlin%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0ODk4OTI%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231225183233003.png" alt="在这里插入图片描述"></p>
<h3 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h3><h4 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式  CoroutineName: <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = CoroutineName(<span class="string">&quot;continuation 01&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 代码执行结果：  表明coroutineContext传递下来的</span></span><br><span class="line">    Suspend Lambda表达式  CoroutineName: CoroutineName(continuation <span class="number">01</span>)</span><br><span class="line">    <span class="comment">// 表明协程体执行结束后 结果的返回是由传入的Continuation实现的</span></span><br><span class="line">    resuming with result Success(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>深入createCoroutine这个方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br></pre></td></tr></table></figure>

<ul>
<li>简单总结:</li>
</ul>
<p>         suspend{      &#x2F;&#x2F;…     } 这部分代码被包装成了<code>createCoroutine</code>的<code>Receiver</code>,<strong>方法的参数<code>completion</code>会在协程执行完成后掉用，就是协程的完成回调。</strong></p>
<p>        而方法返回的Continuation只用于开启协程和承担协程体。<strong>如果它的内部还有协程的话，它就会作为completion参数传入内部协程。</strong></p>
<ul>
<li>原理：</li>
</ul>
<p>        <code>createCoroutine</code>方法返回的<code>Continuation</code>是<code>SafeContinuation</code>的实例(SafeContinuation继承自Continuation)，但是这只是一个“马甲”。</p>
<p>        SafeContinuation构造方法中有个名为delegate的属性，delegate 的属性是一个被委托的属性，它的类型是 Continuation<T>，实际上它所委托的对象就是这个由编译器生成的 Continuation 实现类的实例一个内部匿名类。</p>
<p>        先来看一下createCoroutineUnintercepted这个方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// gpt说这个函数是用来 暴露给协程调试器的占位函数</span></span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">// 这里的this 指的是上面的Suspend Lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">// 此处的create 和 下面的createCoroutineFromSuspendFunction</span></span><br><span class="line">        <span class="comment">// 可以参考 下面的对代码的一个反编译</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        这个实现类的类名是由编译器根据文件名、函数名和一些其他信息生成的，通常是类似于 <FileName>Kt<FunctionName>continuation$1 这样的形式。<strong>这个匿名内部类继承自SuspendLambda类，而SuspendLambda类又是Continuation接口的实现类。</strong></p>
<p>简单提一下匿名内部类的实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure>

<p>      Suspend Lambda表达式一个函数对应了一个类 ，这里的实现挺悬乎的 它是由编译器实现的这部分内容，SuspendLambda有一个抽象函数invokeSuspend，编译生成的匿名内部类中这个函数的实现就是我们的协程体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Function1</span> <span class="variable">var0</span> <span class="operator">=</span> (Function1)(<span class="keyword">new</span> <span class="title class_">Function1</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Nullable</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  ResultKt.throwOnFailure(var1);</span><br><span class="line">                  <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;Suspend Lambda表达式  CoroutineName: &quot;</span> + (CoroutineName)<span class="built_in">this</span>.getContext().get((CoroutineContext.Key)CoroutineName.Key);</span><br><span class="line">                  System.out.println(var2);</span><br><span class="line">                  <span class="keyword">return</span> Boxing.boxInt(<span class="number">5</span>);</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">            Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">            <span class="comment">// 把completion传入，并创建一个新的Function1，作为Continuation返回，</span></span><br><span class="line">            <span class="comment">// 这就是创建出来的协程体对象，协程的工作核心就是它内部的状态机，</span></span><br><span class="line">            <span class="comment">// invokeSuspend函数</span></span><br><span class="line">            <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Continuation</span> <span class="variable">var4</span> <span class="operator">=</span> ContinuationKt.createCoroutine(var0, (Continuation)(<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineName <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CoroutineName</span>(<span class="string">&quot;continuation 01&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext)<span class="built_in">this</span>.getContext();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;resuming with result &quot;</span> + Result.toString-impl(result);</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">      <span class="type">Unit</span> <span class="variable">var1</span> <span class="operator">=</span> Unit.INSTANCE;</span><br><span class="line">      Result.<span class="type">Companion</span> <span class="variable">var2</span> <span class="operator">=</span> Result.Companion;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      var4.resumeWith(Result.constructor-impl(var1));</span><br></pre></td></tr></table></figure>

<p>      总结一下就是createCoroutine方法所生成的对象是一个<code>SafeContinuation</code>的实例，同时这个实例中有一个委托属性，它所委托的对象是一个匿名内部类。匿名内部类继承自SuspendLambda类，而这个类又是Continuation接口的实现类。而Suspend Lambda表达式的函数体实现在了SuspendLambda类的抽象类invokeSuspend方法中。</p>
<p>     协程的启动就是创建出来的对象调用了resume方法，这个方法的调用最终会来到<strong>BaseContinuationImpl::resumeWith</strong>方法中，这个方法中调用了当前协程的invokeSuspend方法状态机相关的东西就在里面，从而开启了协程。</p>
<p>     上面的内容解释了所返回的Continuation对象的具体内容。也就是为什么调用了他的<code>resume</code>后协程会启动的原因。</p>
<ul>
<li>外部传入的那个Continuation的对象completion的的流向</li>
</ul>
<p>      首先completion是createCoroutine方法传入的参数，然后传给了createCoroutineUnintercepted方法，在这个方法里它的流向有两个分支，目前只说第一条，之后它被传入了create方法，前面说了suspend lambda 表达式对应一个匿名内部类，这个类里的create方法就是对应的实现，目前看代码能分析到这里。<strong>以类的构造方法参数传参的方式</strong>就到了BaseContinuationImpl::resumeWith方法中。先来看代码实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 在每个恢复的延续上调用“resume”调试探针，以便调试库基础设施</span></span><br><span class="line">        <span class="comment">// 可以精确跟踪挂起的调用堆栈的哪一部分已经恢复</span></span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="comment">// completion到了这里</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! <span class="comment">// completion为null直接抛出异常防止出现更严重的错误</span></span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里调用invokeSuspend开启了状态机</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// 此状态机实例正在终止</span></span><br><span class="line">            <span class="comment">// completion又开启了一层判断</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                <span class="comment">// 通过循环展开递归</span></span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 达到顶层完成——通过completion调用resumeWith返回结果</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来一个整体流程的函数原理</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#Continuation.kt</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    <span class="comment">//返回SafeContinuation 对象</span></span><br><span class="line">    <span class="comment">//SafeContinuation 构造函数需要2个参数，一个是delegate，另一个是协程状态</span></span><br><span class="line">    <span class="comment">//此处默认是挂起</span></span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">//此处的this 即为匿名内部类对象 MyAnonymous，它间接继承了BaseContinuationImpl</span></span><br><span class="line">        <span class="comment">//调用MyAnonymous 重写的create 函数</span></span><br><span class="line">        <span class="comment">//create 函数里new 新的MyAnonymous 对象</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    <span class="comment">//判断是否是ContinuationImpl 类型的Continuation</span></span><br><span class="line">    <span class="comment">//我们的demo里是true，因此会继续尝试调用拦截器</span></span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kt</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    <span class="comment">//查看是否已经有拦截器，如果没有，则从上下文里找，上下文没有，则用自身，最后赋值。</span></span><br><span class="line">    <span class="comment">//在我们的demo里上下文里没有，用的是自身</span></span><br><span class="line">    intercepted</span><br><span class="line">        ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">            .also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">#CoroutineDispatcher.kt</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        <span class="comment">// 这里构造出了一个DispatchedContinuation对象 </span></span><br><span class="line">        <span class="comment">// 其中的this指的是context[ContinuationInterceptor] 取出的调度器</span></span><br><span class="line">        <span class="comment">// continuation 是createCoroutineUnintercepted方法中create创建的对象</span></span><br><span class="line">        <span class="comment">// 也就是下面伪代码中的MyAnonymous类的对象</span></span><br><span class="line">        <span class="comment">// DispatchedContinuation(this, continuation)</span></span><br><span class="line">        <span class="comment">// 这里返回了一个DispatchedContinuation对象，它继承自Runnable和Continuation。</span></span><br><span class="line">        <span class="comment">// 然后可以回到上面的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后得出的Continuation 赋值给SafeContinuation 的成员变量：delegate。</span><br><span class="line">至此，SafeContinuation 对象已经构造完毕，接着继续看如何用它开启协程。</span><br><span class="line"></span><br><span class="line">#SafeContinuationJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// lock-free loop</span></span><br><span class="line">        <span class="keyword">val</span> cur = <span class="keyword">this</span>.result <span class="comment">// atomic read</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            <span class="comment">//初始化状态为UNDECIDED，因此直接return</span></span><br><span class="line">            cur === CoroutineSingletons.UNDECIDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>,</span><br><span class="line">                    CoroutineSingletons.UNDECIDED, result.value)) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">//如果是挂起，将它变为恢复状态，并调用恢复函数</span></span><br><span class="line">           <span class="comment">//demo 里初始化状态为COROUTINE_SUSPENDED，因此会走到这</span></span><br><span class="line">            cur === COROUTINE_SUSPENDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>, COROUTINE_SUSPENDED,</span><br><span class="line">                    CoroutineSingletons.RESUMED)) &#123;</span><br><span class="line">                <span class="comment">//delegate 为之前创建的Continuation，demo 里因为没有拦截，因此为MyAnonymous</span></span><br><span class="line">                delegate.resumeWith(result)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already resumed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kotlin</span><br><span class="line">#BaseContinuationImpl类的成员函数</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="keyword">val</span> completion = completion!!</span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//invokeSuspend 即为MyAnonymous 里的方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="comment">//如果返回值是挂起状态，则函数直接退出</span></span><br><span class="line">                    <span class="keyword">if</span> (outcome === kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    kotlin.Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    kotlin.Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//执行到这，最终执行外层的completion，在demo里会输出&quot;result:$result&quot;</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h3><p>        先来思考问题，挂起函数挂起需要哪些条件？ 什么情况下会真正的挂起？</p>
<p>在这之前先看两个函数变换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，形参为函数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后</span></span><br><span class="line"><span class="comment">// 在JVM 平台函数类型参数最终是用匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty(<span class="meta">@NotNull</span> Function0  block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function0的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// suspend类型的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty1</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里成了Function1</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty1(<span class="meta">@NotNull</span> Function1 block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function1的定义  相较于Function0多了个参数. 对于挂起函数来说这个参数就是Continuation类型的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function1</span>&lt;<span class="type">in P1, out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function with the specified argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看挂起函数的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里函数的类型就是 suspend () -&gt; T</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test suspend&quot;</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">&quot;test suspend in thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        上面这段代码会被提示<code>Redundant &#39;suspend&#39; modifier </code>，意思是suspend是多余的。内部没有执行其他的挂机函数挂起没意义。</p>
<p>简单创建一个原始协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">launchFish</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建协程，返回值为SafeContinuation(实现了Continuation 接口)</span></span><br><span class="line">    <span class="comment">//入参为Continuation 类型，参数名为completion，顾名思义就是</span></span><br><span class="line">    <span class="comment">//协程结束后(正常返回&amp;抛出异常）将会调用它。</span></span><br><span class="line">    <span class="keyword">var</span> coroutine = block.createCoroutine(<span class="keyword">object</span> : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程结束后调用该函数</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;result:<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//开启协程</span></span><br><span class="line">    coroutine.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里调用launchFish函数</span></span><br><span class="line">    <span class="comment">// 这里传入一个 lambda 好像会自动被包装成suspend lambda</span></span><br><span class="line">    <span class="comment">// suspend 修饰的函数类型，当调用者实现其函数体时，传入的实参将会继承自SuspendLambda</span></span><br><span class="line">    launchFish &#123;</span><br><span class="line">        println(<span class="string">&quot;I am coroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下反编译后的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnonymous</span> <span class="keyword">extends</span> <span class="title class_">SuspendLambda</span> <span class="keyword">implements</span> <span class="title class_">Function1</span> &#123;</span><br><span class="line">    <span class="type">int</span> label;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var4</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>.label) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;I am coroutine&quot;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                System.out.println(var2);</span><br><span class="line">                <span class="comment">// 这里永远会返回Unit.INSTANCE; 协程永远不会挂起</span></span><br><span class="line">                <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">        <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">launchFish</span><span class="params">(<span class="meta">@NotNull</span> MyAnonymous block)</span> &#123;</span><br><span class="line">    <span class="type">Continuation</span> <span class="variable">coroutine</span> <span class="operator">=</span> ContinuationKt.createCoroutine(block, (<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext) EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;result:&quot;</span> + Result.toString-impl(result);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//这里开启协程</span></span><br><span class="line">    coroutine.resumeWith(Result.constructor-impl(var3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="meta">@NotNull</span> String[] array)</span> &#123;</span><br><span class="line">    <span class="type">MyAnonymous</span> <span class="variable">myAnonymous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAnonymous</span>();</span><br><span class="line">    launchFish(myAnonymous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用suspendCoroutine</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunc02</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span></span><br><span class="line">         = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; &#123; continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">5</span>)) <span class="comment">// ... 1 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码反编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">suspendFunc02</span><span class="params">(<span class="meta">@NotNull</span> String a, <span class="meta">@NotNull</span> String b, <span class="meta">@NotNull</span> Continuation $completion)</span> &#123;</span><br><span class="line">     <span class="type">SafeContinuation</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeContinuation</span>(IntrinsicsKt.intercepted($completion));</span><br><span class="line">     <span class="type">Continuation</span> <span class="variable">continuation</span> <span class="operator">=</span> (Continuation)var4;</span><br><span class="line">     <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     ThreadsKt.thread$<span class="keyword">default</span>(<span class="literal">false</span>, <span class="literal">false</span>, (ClassLoader)<span class="literal">null</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (Function0)(<span class="keyword">new</span> <span class="title class_">KotlinTestKt$suspendFunc02$2$1</span>(continuation)), <span class="number">31</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">     <span class="comment">// getOrThrow用于判断结果是否已经确定，</span></span><br><span class="line">     <span class="comment">// 如果没有确定，则将协程挂起并返回一个特殊的值。</span></span><br><span class="line">     <span class="comment">// 如果结果已经确定，它将检查结果类型，如果是失败的结果，则抛出异常，否则返回结果本身。</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> var4.getOrThrow();</span><br><span class="line">     <span class="keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">        DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> var10000;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>        suspendCoroutine会接收suspendFunc02函数的suspend所转化出的completion，也就是获取当前函数的Continuation实例，用来作为协程执行完毕后的回调函数。而其内部会生成一个用于执行协程体的SafeContinuation对象。</p>
<p>        如果不使用suspendCoroutine获取当前协程的续体，则无法实现真正的挂起与resume。</p>
<p>        所谓协程的挂起其实就是程序执行流程<strong>发生异步调用</strong>时，异步调用是否发生，取决于resume函数与对应的挂起函数的调用是否在相同的调用栈上，切换函数调用栈的方法可以是切换到其他线程上执行，也可以是不切换线程但在当前函数返回之后的某一个时刻再执行。 </p>
<p>        上面扯的有些复杂了，是否挂起要看内部协程返回的值，如果只会<code>return Unit.INSTANCE;</code> 那么永远不会挂起。在<strong>发生异步调用</strong>时会返回对应的标志挂起的值，SafeContinuation类的作用也非常简单，它可以确保只有发生异步调用时才会挂起。</p>
<h4 id="协程的恢复"><a href="#协程的恢复" class="headerlink" title="协程的恢复"></a>协程的恢复</h4><p>        首先要知道一个知识点：一个协程体的invokeSuspend被调用有两种情况，第一种是在它刚被创建时从<code>CoroutineStart::invoke</code>到<code>(suspend () -&gt; T).startCoroutineCancellable</code>再到<code>(suspend () -&gt; T).createCoroutineUnintercepted</code>然后会走到<code>create(completion)</code>也就是在反编译后的那个create方法，紧接着就会调用它的invokeSuspend方法来执行协程体。</p>
<p>        第二种是它被作为completion传入了子协程中，在<code>BaseContinuationImpl::resumeWith</code>方法中被子协程回调结果时调用走<code>completion.resumeWith(outcome)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;parent coroutine running&quot;</span>)</span><br><span class="line"></span><br><span class="line">        getStuInfoV1()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;after suspend&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStuInfoV1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;son coroutine running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的整体流程图：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/99353b7e71c69.jpg" alt="img"></p>
<h4 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h4><p>        协程通过传递Continuation来控制异步调用流程。</p>
<p>        协程的创建和运行过程，我们的协程体本身就是一个Continuation实例，正因如此挂起函数才能在协程体内运行。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<p>        协程是一种控制流的抽象，当协程被挂起时，它会将当前的执行状态（包括程序计数器、寄存器等）保存到一个回调函数中，这个回调函数就是挂起函数的 Continuation。这样，在协程恢复执行时，它会从保存的执行状态继续执行，而不是从头开始执行。这种机制使得协程能够在不同的时间点之间暂停和恢复执行，从而实现更加灵活的控制流程。</p>
<p>        当前调用流程的执行状态进入等待状态。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<h4 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h4><p>        先看一段Continuation实现的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        CoroutineContext作为一个接口内部的成员对象存在。且是val的，所有Continuation的实现类通过<code>public override val context: CoroutineContext       get() = EmptyCoroutineContext</code>的方式进行重写。</p>
<p>        CoroutineContext的结构类似List，具体可看其实现源码。其内部元素的结构是Element，且元素本身就实现了CoroutineContext对象。这看上去就好像Int实现了List<Int>接口一样，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? =</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">        operation(initial, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        list中的元素都有一个index，表示元素的索引，而这里协程上下文元素的key就是<br>协程上下文这个集合中元素的索引，不同之处是这个索引“长”在了数据里面，这意味着协程上下文的数据在“出生”时就找到了自己的位置。</p>
<p>        <strong>协程上下文的内部实现实际上是一个单链表</strong>，Kotlin协程上下文的内部实现是通过一个单链表来实现的，这个单链表中包含了多个协程上下文元素。每个协程上下文元素都包含了一些协程上下文属性，例如调度器、异常处理器等等。通过将这些协程上下文元素链接起来，就可以形成一个完整的协程上下文。当协程执行时，它会按照链表中的顺序依次应用每个协程上下文元素中的属性，以实现对协程的控制和管理。因此，单链表是协程上下文内部实现的核心部分。具体论证观察CoroutineContext类的plus方法的实现。</p>
<h4 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = LogInterceptor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line"><span class="comment">//  延长线程存活时间</span></span><br><span class="line">    sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义拦截器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">get</span>() = ContinuationInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;) :</span><br><span class="line">    Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此处对协程的表达进行了拦截</span></span><br><span class="line">        println(<span class="string">&quot;before resumeWith: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">&quot;after resumeWith.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 日志打印</span></span><br><span class="line"><span class="comment">// 此处拦截的是createCoroutine方法创建出的continuation执行resumeWith开启协程</span></span><br><span class="line"><span class="comment">// 协程启动挂起</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">after resumeWith.</span><br><span class="line"><span class="comment">// 此处拦截的是所传入的continuation来进行结果回调时调用resumeWith</span></span><br><span class="line"><span class="comment">// 协程执行结束恢复</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">Suspend Lambda表达式</span><br><span class="line">resuming with result Success(<span class="number">5</span>)</span><br><span class="line">after resumeWith.</span><br></pre></td></tr></table></figure>

<h4 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h4><p><strong>CoroutineContext 里存放着协程的分发器。</strong></p>
<ul>
<li><p><strong>Dispatchers.Main</strong>  UI 线程，在Android里为主线程</p>
</li>
<li><p><strong>Dispatchers.IO</strong>  IO 线程，主要执行IO 操作</p>
</li>
<li><p><strong>Dispatchers.Default</strong> 主要执行CPU密集型操作，比如一些计算型任务</p>
</li>
<li><p><strong>Dispatchers.Unconfined</strong>  不限定具体的线程类型，当前调度器在哪个线程，就在该线程上进行执行。也就是和它的父协程保持一致。</p>
</li>
</ul>
<h3 id="协程框架"><a href="#协程框架" class="headerlink" title="协程框架"></a>协程框架</h3><h4 id="自定义一个delay函数"><a href="#自定义一个delay函数" class="headerlink" title="自定义一个delay函数"></a>自定义一个delay函数</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">        executor.schedule(&#123;</span><br><span class="line">            continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;, time, unit)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>) &#123; runnable -&gt;</span><br><span class="line">    Thread(runnable, <span class="string">&quot;Scheduler&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程作用域种类"><a href="#协程作用域种类" class="headerlink" title="协程作用域种类"></a>协程作用域种类</h3><p>GlobalScope。即全局协程作用域，在这个范围内启动的协程可以一直运行直到应用停止运行。GlobalScope 本身不会阻塞当前线程，且启动的协程相当于守护线程，不会阻止 JVM 结束运行</p>
<p>runBlocking。一个顶层函数，和 GlobalScope 不一样，它会阻塞当前线程直到其内部所有相同作用域的协程执行结束</p>
<p>自定义 CoroutineScope。可用于实现主动控制协程的生命周期范围，对于 Android 开发来说最大意义之一就是可以在 Activity、Fragment、ViewModel 等具有生命周期的对象中按需取消所有协程任务，从而确保生命周期安全，避免内存泄露</p>
<h3 id="async和launch的区别"><a href="#async和launch的区别" class="headerlink" title="async和launch的区别"></a>async和launch的区别</h3><p><code>async</code> 可以返回协程的执行结果，而 <code>launch</code> 不行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncA = async &#123;</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> asyncB = async &#123;</span><br><span class="line">                delay(<span class="number">4000</span>)</span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            log(asyncA.await() + asyncB.await())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async的最后一行为返回值</p>
<h3 id="Kotlin-协程库四个-Dispatcher"><a href="#Kotlin-协程库四个-Dispatcher" class="headerlink" title="Kotlin 协程库四个 Dispatcher"></a>Kotlin 协程库四个 Dispatcher</h3><p>**<code>Dispatchers.Main</code>**：这是主调度器，通常用于 Android 或其它 UI 框架中。它会在主线程上运行协程，用于更新 UI 或做其它需要在主线程完成的操作。例如更新 TextView 或 RecyclerView 等 UI 组件</p>
<p>**<code>Dispatchers.Default</code>**：默认调度器，用于执行长时间运行并且需要大量 CPU 资源的任务，比如排序列表或者解析大型 JSON 数据等 CPU 密集型任务。</p>
<p>**<code>Dispatchers.IO</code>**：I&#x2F;O 调度器，适用于大量 I&#x2F;O 操作，如网络请求，文件读写等。</p>
<p>**<code>Dispatchers.Unconfined</code>**：无限制的调度器，协程会在启动的立即执行，直到第一个挂起点。当挂起函数结束后，协程会在挂起函数结束的线程上恢复执行。它适用于一些不需要特定线程，同时又需要立即执行的情况。但使用时要小心，因为它很容易造成一些意想不到的问题。</p>
<h3 id="协程中的线程局部变量的原子性和可见性"><a href="#协程中的线程局部变量的原子性和可见性" class="headerlink" title="协程中的线程局部变量的原子性和可见性"></a>协程中的线程局部变量的原子性和可见性</h3><p>在使用了线程池的调度器（例如 <code>Dispatchers.IO</code> 或 <code>Dispatchers.Default</code>）来运行一个 <code>withContext()</code> 块时，整个withContext内的代码块可能没有运行在同一个线程上。</p>
<p>例如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Prints &quot;IO dispatcher worker 1&quot; </span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// This is a suspend function</span></span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Might print &quot;IO dispatcher worker 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>suspendSomeIoOperation()</code> 是一个挂起函数，当它挂起时，当前线程可能会去运行其他的任务。当操作 A 完成后，可能会有一个不同的线程（从线程池中选择）来恢复这个协程的执行。因此，<code>threadName1</code> 和 <code>threadName2</code> 可能会是不同的，即使他们都在同一个 <code>withContext()</code> 块中。</p>
<p>这个特性有两个影响：</p>
<ol>
<li><strong>不保证线程局部变量的一致性</strong>：线程局部变量<strong>不是</strong>跨线程的，如果你的协程在两个不同的线程上运行，那么你将看到线程局部变量的不同版本。</li>
<li><strong>不保证并发操作的原子性和可见性</strong>：如果你的协程代码块包含对共享资源的写操作，那么你需要确保这些操作是线程安全的，否则可能会出现并发问题，如数据竞争。</li>
</ol>
<p>如果希望让整个 <code>withContext&#123;&#125;</code> 块始终在同一个线程上运行，应该使用一个单线程的调度器，比如 <code>newSingleThreadContext(&quot;myThread&quot;)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;newSingleThreadContext&quot;</span>)</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="string">&quot;Unconfined 4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 Mutex 或 @Volatile 来实现线程安全的示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.withLock &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// 启动100个协程进行累加</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>@Volatile</code> 注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        </span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// @Volatile 不保证原子性，意味着 counter++ 不是一个原子操作，还可能会存在竞态条件，所以结果可能会小于100。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicInteger</code> 类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> counter = AtomicInteger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter.incrementAndGet()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// Start multiple coroutines</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter.<span class="keyword">get</span>()) <span class="comment">// Will always print 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="job-join"><a href="#job-join" class="headerlink" title="job.join()"></a>job.join()</h3><p><code>join()</code>的作用是挂起当前协程，直到这个 <code>Job</code> 完成。这个方法使得您可以等待一个协程任务执行完毕。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;job completed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Waiting for job...&quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;Job is done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，主协程被阻塞并等待由 <code>job.join()</code> 返回。只有在 <code>job</code> 协程完成之后， “Job is done!” 才会被打印出来。</p>
<h3 id="传播取消操作"><a href="#传播取消操作" class="headerlink" title="传播取消操作"></a>传播取消操作</h3><p>一般情况下，协程的取消操作会通过协程的层次结构来进行传播：如果取消父协程或者父协程抛出异常，那么子协程都会被取消；而如果子协程被取消，则不会影响同级协程和父协程，但如果子协程抛出异常则也会导致同级协程和父协程被取消 </p>
<p>使用SupervisorJob</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> supervisorJob = SupervisorJob()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main + supervisorJob)</span><br><span class="line"></span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用supervisorScope</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程和线程对比"><a href="#协程和线程对比" class="headerlink" title="协程和线程对比"></a>协程和线程对比</h3><p>系统的最小执行单元是线程，一个线程同一时间点也只能执行一个任务，使用协程也不可能改变这种情况。</p>
<p>只能说使用了协程后，线程的并发灵活度会提高：当线程需要等待某个 suspend 函数返回时，在等待的过程中此线程还可以用于执行其它协程任务，从而提高线程的灵活度，避免线程空转。</p>
<p>协程是程序本身实现的切换机制，不需要陷入系统内核，轻松高并发。</p>
<p>代码对比下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">thread &#123;</span><br><span class="line">        <span class="comment">// I/O 阻塞操作</span></span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">打印：   </span><br><span class="line">[Thread-<span class="number">0</span>] thread</span><br></pre></td></tr></table></figure>

<p>这种只会在阻塞操作操作结束后才会打印日志。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">al job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job + Dispatchers.IO)</span><br><span class="line">thread &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">        <span class="comment">// 防止JVM退出</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>)</span><br><span class="line">  </span><br><span class="line">打印：  </span><br><span class="line">  [Thread-<span class="number">0</span>] thread</span><br><span class="line">	[DefaultDispatcher-worker-<span class="number">1</span>] launch</span><br></pre></td></tr></table></figure>

<p>线程在利用空闲时间执行了后续操作。</p>
<h3 id="协程的四个基础概念"><a href="#协程的四个基础概念" class="headerlink" title="协程的四个基础概念"></a>协程的四个基础概念</h3><ol>
<li><p><strong>协程构建器（Coroutine Builders）</strong>：在 Kotlin 中，使用协程构建器如 <code>launch</code>、<code>async</code>等来启动一个新的协程。</p>
<ul>
<li><p><code>launch</code>: 它创建一个新的协程并同时启动。<code>launch</code> 返回一个 <code>Job</code>，你可以用它来取消协程。此协程不会返回结果。</p>
</li>
<li><p><code>async/start</code>: 创建一个新的协程并返回一个 <code>Deferred&lt;T&gt;</code> —— 一种轻量级的非阻塞性 future，它表示一个带有结果的 promise。可以使用它的 <code>.await()</code> 方法获取结果。</p>
</li>
<li><p><code>runBlocking</code>: 这是一个特殊的构建器，它创建了一个新的协程并阻塞当前线程直到其完成。</p>
</li>
</ul>
</li>
<li><p><strong>挂起函数（Suspend Functions）</strong>：<code>suspend</code>关键字标记的函数称为挂起函数。这种函数可以”挂起”，即在不阻塞当前线程的情况下，暂停其执行，并稍后在适当的时间点继续执行。挂起函数只能在协程或其他挂起函数中调用。</p>
<ul>
<li>这些函数可以在协程内部进行长期运行的操作（如网络请求或数据库查询），而不会阻塞线程。这就是它们的”挂起”能力。挂起函数通过 <code>suspend</code> 关键字来定义，并且只能在协程或其他挂起函数中调用。</li>
</ul>
</li>
<li><p><strong>调度器（Dispatchers）</strong>：<code>Dispatchers</code>确定协程运行在哪个线程或线程池上。例如，<code>Dispatchers.IO</code> 用于磁盘和网络 I&#x2F;O，<code>Dispatchers.Default</code> 用于计算密集型任务，<code>Dispatchers.Main</code> 用于更新 UI。</p>
<ul>
<li><p><code>Dispatchers.Main</code>：这个调度器被限定在主线程中执行，这对大部分UI框架来说非常必要。然而，不同平台有自己的主线程计划。例如，Android会有 <code>Dispatchers.Main</code>，用于更新UI，执行时会检查是否在主线程里，不是的话它会调度到主线程执行。</p>
</li>
<li><p><code>Dispatchers.IO</code>：设计用于磁盘和网络 I&#x2F;O，因此不应用于计算密集型工作。IO调度器基于ForkJoinPool，它使用一个利用主机CPU数量的线程数量，但网络和磁盘允许线程无限制地增长和缩小。此调度模式的设计是为了允许大量的线程可以等待I&#x2F;O操作（如读写磁盘，网络数据读写）完成而无需消耗大量内存。</p>
</li>
<li><p><code>Dispatchers.Default</code>：用于计算密集型任务，这个调度器用于可能阻塞但CPU密集型工作，如算法和复杂计算。默认调度器内部使用了固定大小的线程池，大小为Kotlin runtime可以计算的CPU数量，默认大小为CPU核心数量减1，但至少为1。</p>
</li>
<li><p><code>Dispatchers.Unconfined</code>：一个特殊的调度器，它在调用者线程中立即执行调度的协程。但只有当挂起函数被调用，或者显式使用不同的调度器，那么协程的执行将会挂起并重新调度它的执行线程。</p>
<p>不添加调度器的话默认使用父协程的调度器。</p>
</li>
</ul>
</li>
<li><p><strong>作用域（Scopes）</strong>：协程的执行属于某种特定的作用域。作用域控制了相关协程的生命周期。例如，在 Android 中你可能会使用 <code>viewModelScope</code>，这样当 ViewModel 销毁时，所有的协程也将被取消。</p>
<ul>
<li><p><code>GlobalScope</code>：它绑定到整个应用程序的生命周期。你一旦启动了全局作用域的协程，它只有在应用程序完全停止运行后才会被销毁。</p>
<p>它默认的调度器是Dispatchers.Default</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">      log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CoroutineScope</code>：本身并非作用域，但却经常拿来创建作用域。它需要一个 <code>Job</code>（或者可以供其他方式提供一个 <code>CoroutineContext</code>）作为参数。<code>CoroutineScope</code> 不提供默认的 <code>Job</code>，所以如果你使用 <code>CoroutineScope(EmptyCoroutineContext)</code> 创建作用域，那么它所启动的协程就一定会使用 <code>GlobalScope</code>。所以，最佳实践是，总是用 <code>CoroutineScope(Job())</code> 来创建作用域。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CoroutineScope(Job()).launch &#123;</span><br><span class="line">        log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MainScope</code></p>
<p>默认运行在主线程的作用域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">throw</span>  NullPointerException(<span class="string">&quot;空指针&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">//网络请求...</span></span><br><span class="line">            <span class="string">&quot;请求结果&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">//网络请求3...</span></span><br><span class="line">        &#125;</span><br><span class="line">        btn.text = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>viewModelScope</code>：Android KTX库提供了一个创建在 <code>ViewModel</code> 生命周期内工作的协程的作用域。当 <code>ViewModel</code> 清理时，所有作用域内的协程都会自动取消。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>lifecycleScope</code>：这个也是由Android KTX库提供的，它提供了一个绑定到 <code>Android Lifecycle</code> 生命周期的作用域（如 <code>Activity</code> 或 <code>Fragment</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.IO</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Default</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Unconfined</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印：</span><br><span class="line">[main] <span class="number">4</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">2</span>] <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] <span class="number">3</span></span><br><span class="line">[main] <span class="number">1</span></span><br><span class="line">[main] <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CoroutineStart协程启动模式"><a href="#CoroutineStart协程启动模式" class="headerlink" title="CoroutineStart协程启动模式"></a><code>CoroutineStart</code>协程启动模式</h3><ol>
<li><code>DEFAULT</code>    默认启动模式，我们可以称之为饿汉启动模式，因为协程创建后立即开始调度，虽然是立即调度，单不是立即执行，有可能在执行前被取消。</li>
<li><code>LAZY</code>    懒汉启动模式，启动后并不会有任何调度行为，直到我们需要它执行的时候才会产生调度。也就是说只有我们主动的调用<code>Job</code>的<code>start</code>、<code>join</code>或者<code>await</code>等函数时才会开始调度。</li>
<li><code>ATOMIC</code>  一样也是在协程创建后立即开始调度，但是它和<code>DEFAULT</code>模式有一点不一样，通过<code>ATOMIC</code>模式启动的协程执行到第一个挂起点之前是不响应<code>cancel </code>取消操作的，<code>ATOMIC</code>一定要涉及到协程挂起后<code>cancel </code>取消操作的时候才有意义。</li>
<li><code>UNDISPATCHED</code> 协程在这种模式下会直接开始在当前线程下执行，直到运行到第一个挂起点。这听起来有点像 <code>ATOMIC</code>，不同之处在于<code>UNDISPATCHED</code>是不经过任何调度器就开始执行的。当然遇到挂起点之后的执行，将取决于挂起点本身的逻辑和协程上下文中的调度器。</li>
</ol>
<h3 id="协程生命周期"><a href="#协程生命周期" class="headerlink" title="协程生命周期"></a>协程生命周期</h3><ol>
<li>新建：此时协程已经创建，但尚未开始运行。例如，当使用 <code>CoroutineStart.LAZY</code> 选项调用 <code>launch</code> 或 <code>async</code> 时，创建的协程仅在显式调用其 <code>Job</code> 的 <code>start</code> 或 <code>join</code> 方法时才开始执行。</li>
<li>活动：此阶段的协程正在执行其任务。通常，协程会在 <code>launch</code> 或 <code>async</code> 调用后立即进入此状态 (除非你指定了 <code>CoroutineStart.LAZY</code> 选项)。</li>
<li>完成：协程成功完成其任务并正常结束，或者因异常被终止。对于异常的情况，如果协程是由 <code>launch</code> 创建的，则需要在协程体内部进行异常处理。而对于 <code>async</code> 创建的协程，异常会被延期处理，直至 <code>await()</code> 的调用。</li>
<li>取消：通过调用协程的 <code>Job</code> 的 <code>cancel</code> 方法，可以取消协程。这将导致协程中断执行。当协程被取消时，所有挂起函数将会抛出 <code>CancellationException</code>。协程可以通过定期检查其状态 (使用 <code>isActive</code> 属性或 <code>yield</code> 函数)，或通过在挂起函数处对 <code>CancellationException</code> 进行响应来响应取消操作。</li>
</ol>
<h3 id="协程的阻塞和非阻塞"><a href="#协程的阻塞和非阻塞" class="headerlink" title="协程的阻塞和非阻塞"></a>协程的阻塞和非阻塞</h3><p>看下下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;launch start&quot;</span>)</span><br><span class="line">            launch(Dispatchers.IO) &#123;</span><br><span class="line">                log(<span class="string">&quot;Job start&quot;</span>)</span><br><span class="line">                testSuspends()</span><br><span class="line">                log(<span class="string">&quot;Job end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="string">&quot;launch end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">[main] start</span><br><span class="line">[main] launch start</span><br><span class="line">[main] launch end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] Job start</span><br><span class="line">[main] end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] testSuspends</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] Job end</span><br></pre></td></tr></table></figure>

<p>协程的非阻塞是相对于线程的，当遇到协程挂起后会越过他执行后面的任务，等挂起恢复后再执行回复原来的执行。</p>
<h3 id="解析源码"><a href="#解析源码" class="headerlink" title="解析源码"></a>解析源码</h3><p>下面的代码模拟在主线程中实现异步加载操作，然后在回到主线程处理数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[main] runBlocking</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] testSuspends</span><br><span class="line">[main] result: <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>分析代码：</p>
<p>代码可以分为两大部分，第一部分是上面的<code>runBlocking </code>协程块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这部分代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> currentThread = Thread.currentThread() <span class="comment">// Thread[main,5,main]</span></span><br><span class="line">  	<span class="comment">// 在给定的协程上下文中获取 ContinuationInterceptor，它是用于控制协程的调度的拦截器</span></span><br><span class="line">    <span class="keyword">val</span> contextInterceptor = context[ContinuationInterceptor] <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">val</span> eventLoop: EventLoop?</span><br><span class="line">    <span class="keyword">val</span> newContext: CoroutineContext</span><br><span class="line">    <span class="keyword">if</span> (contextInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果没有指定调度器，那么创建或者使用私有的事件循环。</span></span><br><span class="line">        eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">      	<span class="comment">// 这里的context是EmptyCoroutineContext eventLoop是BlockingEventLoop</span></span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span></span><br><span class="line">        <span class="comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span></span><br><span class="line">        eventLoop = (contextInterceptor <span class="keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;</span><br><span class="line">            ?: ThreadLocalEventLoop.currentOrNull()</span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context)</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 创建一个 BlockingCoroutine 实例，它是一个运行在指定线程和事件循环中的协程。</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">    <span class="comment">// 开始执行协程，CoroutineStart.DEFAULT 是启动方式，表示立即执行协程体 block</span></span><br><span class="line">    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br><span class="line">  	<span class="comment">// 等待协程结束并返回结果。线程会在这里阻塞，直到协程执行完毕。</span></span><br><span class="line">    <span class="keyword">return</span> coroutine.joinBlocking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>走到<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>开始执行开启这个协程，这里传入了三个参数，首先是<code>CoroutineStart.DEFAULT</code>表示直接开启协程，<code>coroutine</code>是上面创建的BlockingCoroutine对象它是一个运行在指定线程和事件循环中的协程。<code>EventLoop</code> 的功能主要是管理和调度协程在当前线程中的执行。它维护了一个队列，用来存储在当前线程中需要执行的协程。<code>block</code>就是协程体也就是打括号内的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AbstractCoroutine:</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// receiver和this都是传入的coroutine也就是BlockingCoroutine对象。</span></span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里将receiver, this也就是传入的coroutine和block 又传入了CoroutineStart中，其中这个this代表coroutine。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>, receiver: <span class="type">R</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 走到了这里 </span></span><br><span class="line">            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">            ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">            LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>显示传入的是CoroutineStart.DEFAULT，显而易见 根据规则走到了<code>block.startCoroutineCancellable(receiver, completion)</code>这个分支。</p>
<p><strong>这里再回顾一下block就是协程体runBlocking大括号内的东西，它的类型是<code>suspend CoroutineScope.() -&gt; T</code>，receiver是BlockingCoroutine，completion也是，都是传入的那个BlockingCoroutine实例。</strong></p>
<p><strong>receiver和completion都是传入的coroutine也就是BlockingCoroutine对象。</strong></p>
<p>继续往下走</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion)   <span class="comment">// 重新创建续体对象（SuspendLambda子类对象）</span></span><br><span class="line">      .intercepted() <span class="comment">// 从协程上下文中获取调度器拦截原续体，将其包装为DispatchedContinuation类型</span></span><br><span class="line">      .resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下里面的内容</p>
<p><code>runSafely</code>单纯的只是给包裹了一层try catch 出现异常的话就<code>completion.resumeWith(Result.failure(e))</code>，</p>
<p><code>createCoroutineUnintercepted</code>的话可以看一下代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  			<span class="comment">// 如果不是，说明是一个普通的挂起函数，不包含协程的实现细节。</span></span><br><span class="line">        <span class="comment">// 那么要手动创建一个协程来包装这个函数。</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">          	<span class="comment">// 将这个挂起函数视为一个接受Continuation参数并返回Any?的函数，</span></span><br><span class="line">            <span class="comment">// Any?表示可能返回null或任何类型结果。</span></span><br><span class="line">            <span class="comment">// 然后使用已经得到的`probeCompletion`作为参数调用它。</span></span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进行了一个判断<code>this is BaseContinuationImpl</code>，这里有个知识点就是这里this是上面的block 它的类型是<code>suspend CoroutineScope.() -&gt; T</code>但是经过Kotlin编译器编译之后它就会成为SuspendLambda类的对象，这是编译器自己完成的。</p>
<p>而SuspendLambda是继承自ContinuationImpl的，所以这里会走到<code>create(probeCompletion)</code>。</p>
<p><code>create</code>的实现可以看源代码的反编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      。。。</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">      <span class="type">Function2</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object var2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;), <span class="number">1</span>, (Object)<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的create函数的内容总结就是传入了一个completion然后生成一个completion，这个传入的completion是就是在runBlocking方法中创建的BlockingCoroutine对象。</p>
<p><code>&lt;anonymous constructor&gt;</code> 是一个匿名构造函数，接受 <code>completion</code> 作为参数，它返回的 <code>Continuation</code> 对象封装了一个协程。这个协程对象就是自身实例。</p>
<p> 目前来看<code>createCoroutineUnintercepted(receiver, completion)</code>这段代码会生成一个SuspendLambda对象，然后调用<code>intercepted()</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"> <span class="comment">// 从上下文中获取拦截器，实现续体对象包装</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br></pre></td></tr></table></figure>

<p><strong>从当前续体对象(SuspendLambda的子类对象)的上下文中获取拦截器(调度器对象)拦截当前续体对象，将其包装为<code>DispatchedContinuation</code>类型的续体</strong>。这里的<code>this</code>是<code>runBlocking</code>的构造方法中<code>eventLoop = ThreadLocalEventLoop.eventLoop</code>这行代码创建了一个<code>BlockingEventLoop</code>对象作为调度器，<code>context[ContinuationInterceptor]</code>取出了这个对象然后构造返回了<code>DispatchedContinuation</code>对象。<code>DispatchedContinuation</code>构造中的this传入的是前面创建的<code>BlockingEventLoop</code>对象，<code>continuation</code>是创建<code>SuspendLambda</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br></pre></td></tr></table></figure>

<p>到现在为止前半部分的代码执行的结果</p>
<p><code>DispatchedContinuation[BlockingEventLoop@4f49f6af, Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)@461ad730]</code></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231225114546894.png" alt="image-20231225114546894"></p>
<p>创建出<code>DispatchedContinuation</code>对象后执行它的<code>resumeCancellableWith</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DispatchedContinuation：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果续体类型是DispatchedContinuation，调用resumeCancellableWith()启动协程</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">  			<span class="comment">// 判断是否需要调度 这里默认是true</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 切换线程后开始执行协程代码</span></span><br><span class="line">          	<span class="comment">// this 就是SuspendLambda包装的DispatchedContinuation</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的dispatcher是前面创建的<code>BlockingEventLoop</code>对象,<code>dispatcher.isDispatchNeeded(context)</code>这里默认会返回true，后面就会走到<code>BlockingEventLoop</code>的</p>
<p><code>dispatch</code>方法，其父类EventLoopImplBase中有具体的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop:</span><br><span class="line"></span><br><span class="line"><span class="comment">// `dispatch` 函数用于将给定的任务（block）调度到适当的执行上下文中。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> = enqueue(block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enqueue` 函数将任务加入队列。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(task: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enqueueImpl(task)) &#123; <span class="comment">// 如果任务成功入队</span></span><br><span class="line">        unpark() <span class="comment">// 解除阻塞，准备执行任务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DefaultExecutor.enqueue(task) <span class="comment">// 如果任务未成功入队，使用默认执行器加入任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueueImpl</span><span class="params">(task: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    _queue.loop &#123; queue -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isCompleted) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果当前已完成，不再接受新任务</span></span><br><span class="line">        <span class="keyword">when</span> (queue) &#123;</span><br><span class="line">            <span class="literal">null</span> -&gt; <span class="keyword">if</span> (_queue.compareAndSet(<span class="literal">null</span>, task)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果队列为空，尝试将任务作为第一个元素入队</span></span><br><span class="line">            <span class="keyword">is</span> Queue&lt;*&gt; -&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果队列非空，尝试在队列尾部添加任务</span></span><br><span class="line">                <span class="keyword">when</span> ((queue <span class="keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;</span><br><span class="line">                    Queue.ADD_SUCCESS -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 添加成功</span></span><br><span class="line">                    Queue.ADD_CLOSED -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭，无法添加</span></span><br><span class="line">                    Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next()) <span class="comment">// 队列被冻结，尝试更新队列状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">when</span> &#123;</span><br><span class="line">                queue === CLOSED_EMPTY -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭且为空，无法添加</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 如果队列是单个任务，转换为完整队列并添加任务</span></span><br><span class="line">                    <span class="keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="literal">true</span>)</span><br><span class="line">                    newQueue.addLast(queue <span class="keyword">as</span> Runnable)</span><br><span class="line">                    newQueue.addLast(task)</span><br><span class="line">                    <span class="keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 更新队列并添加任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先将任务入队列，上面的runBlocking函数最后返回的是<code>coroutine.joinBlocking()</code>，分析下这个函数干了啥。</p>
<p>joinBlocking是coroutine中的函数，看一下它的创建。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">    newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">		coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br></pre></td></tr></table></figure>

<p>看joinBlocking的具体实现</p>
<p>eventLoop就是<code>ThreadLocalEventLoop.eventLoop</code>创建的BlockingEventLoop对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">BlockingCoroutine：</span><br><span class="line"><span class="comment">// `joinBlocking` 函数用于在阻塞模式下等待协程完成，并返回协程的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinBlocking</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    registerTimeLoopThread() <span class="comment">// 注册当前线程到时间循环。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop?.incrementUseCount() <span class="comment">// 增加事件循环的使用计数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125; <span class="comment">// 如果线程被中断，抛出中断异常。</span></span><br><span class="line">                <span class="keyword">val</span> parkNanos = eventLoop?.processNextEvent() ?: <span class="built_in">Long</span>.MAX_VALUE <span class="comment">// 处理下一个事件，或等待最大时间。</span></span><br><span class="line">                <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span> <span class="comment">// 如果协程已完成，则退出循环。</span></span><br><span class="line">                parkNanos(<span class="keyword">this</span>, parkNanos) <span class="comment">// 阻塞当前线程指定的纳秒数。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 无论如何都会执行的清理代码。</span></span><br><span class="line">            eventLoop?.decrementUseCount() <span class="comment">// 减少事件循环的使用计数。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 另一个清理代码块。</span></span><br><span class="line">        unregisterTimeLoopThread() <span class="comment">// 取消注册当前线程到时间循环。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取协程的结果。</span></span><br><span class="line">    <span class="keyword">val</span> state = <span class="keyword">this</span>.state.unboxState() <span class="comment">// 获取协程的状态。</span></span><br><span class="line">    (state <span class="keyword">as</span>? CompletedExceptionally)?.let &#123; <span class="keyword">throw</span> it.cause &#125; <span class="comment">// 如果是异常完成，则抛出异常。</span></span><br><span class="line">    <span class="keyword">return</span> state <span class="keyword">as</span> T <span class="comment">// 返回协程的结果。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>val parkNanos = eventLoop?.processNextEvent() ?: Long.MAX_VALUE // 处理下一个事件，或等待最大时间。</code> 这里是不是有点熟悉，想不想handler的消息轮训。看下<code>processNextEvent</code>的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop：</span><br><span class="line"><span class="comment">// `processNextEvent` 函数预定于处理下一个协程事件，并返回下一个事件发生之前的时间（以纳秒为单位）。</span></span><br><span class="line"><span class="comment">// 如果没有事件需要处理，它返回 Long.MAX_VALUE，这是一个常用的约定，表示无限的延迟时间。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">processNextEvent</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试处理一个非受限的事件，如果成功处理，返回 0。</span></span><br><span class="line">    <span class="comment">// 如果没有事件处理，会返回 Long.MAX_VALUE，这意味着没有事件需要立即处理。</span></span><br><span class="line">    <span class="keyword">if</span> (!processUnconfinedEvent()) <span class="keyword">return</span> <span class="built_in">Long</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `processUnconfinedEvent` 处理一个非受限的协程的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processUnconfinedEvent</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 获取非受限的任务队列。</span></span><br><span class="line">    <span class="keyword">val</span> queue = unconfinedQueue ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 从队列中移除一个任务，如果队列为空则返回 false。</span></span><br><span class="line">    <span class="keyword">val</span> task = queue.removeFirstOrNull() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 执行取出的任务。</span></span><br><span class="line">    task.run()</span><br><span class="line">    <span class="comment">// 如果成功执行了任务，返回 true。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显<code>task.run()</code>开启了任务，这里先看看任务是怎么入队列的<code>resumeCancellableWith</code> → <code>dispatcher.dispatch(context, this)</code>→<code>enqueue(task: Runnable)</code>→<code>enqueueImpl</code>。这个流程走完将任务入队列，具体的任务task是个<code>DispatchedContinuation</code>对象就是<code>createCoroutineUnintercepted(receiver, completion).intercepted()</code>这步生成的。它同时实现了Continuation和Runnable接口。</p>
<p>run方法实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 这是`Runnable`的一个重写方法，当任务运行时会被执行。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="comment">// 确保在任务被调度之前已经初始化了`resumeMode`。</span></span><br><span class="line">      assert &#123; resumeMode != MODE_UNINITIALIZED &#125;</span><br><span class="line">      <span class="comment">// 获取任务的上下文。</span></span><br><span class="line">      <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">      <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 将代理转换为`DispatchedContinuation`，它包含需要继续的协程。</span></span><br><span class="line">          <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">          <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">          <span class="comment">// 临时设置当前持续上下文为协程的上下文。</span></span><br><span class="line">          withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">              <span class="keyword">val</span> context = continuation.context</span><br><span class="line">              <span class="comment">// 尝试从代理获取状态，它可能是一个结果或异常。</span></span><br><span class="line">              <span class="keyword">val</span> state = takeState() </span><br><span class="line">              <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line">              <span class="comment">// 检查是否应该可以取消任务，以及它是否仍然活跃。</span></span><br><span class="line">              <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                  <span class="comment">// 如果任务被取消，则使用取消异常来继续协程。</span></span><br><span class="line">                  <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                  cancelCompletedResult(state, cause)</span><br><span class="line">                  continuation.resumeWithStackTrace(cause)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 否则，正常地继续协程，用异常或成功的结果。</span></span><br><span class="line">                  <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                      continuation.resumeWithException(exception)</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 这里走进了resumewith</span></span><br><span class="line">                      continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">          <span class="comment">// 捕获任务执行期间发生的任何致命异常。</span></span><br><span class="line">          fatalException = e</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 完成任务后，进行必要的清理，处理任何致命异常。</span></span><br><span class="line">          <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">          handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">		<span class="comment">// 调用resumeWith</span></span><br><span class="line">    resumeWith(Result.success(value)) <span class="comment">// Success(kotlin.Unit)</span></span><br></pre></td></tr></table></figure>

<p><code>continuation.resume(getSuccessfulResult(state))</code>这里的continuation是<code>createCoroutineUnintercepted(receiver, completion)</code>这里生成的SuspendLambda对象，具体为<code>Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</code>。</p>
<p>SuspendLambda是继承自BaseContinuationImpl的，所以这里resumeWith的实现在BaseContinuationImpl。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// current: Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">  	<span class="comment">// param: null</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">   	<span class="comment">// 进入死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">          	<span class="comment">// completion：BlockingCoroutine  这个是在runBlocking方法中创建的。</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! </span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">// 走到这里执行invokeSuspend方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() </span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123; </span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码执行到了<code>val outcome = invokeSuspend(param)</code>,这里的实现得看反编译的代码，仅看invokeSuspend方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      Object var10000;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            TestActivityKt.log(<span class="string">&quot;runBlocking&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 在这里又执行了testSuspends方法</span></span><br><span class="line">            var10000 = MainKt.testSuspends(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var3) &#123;</span><br><span class="line">               <span class="keyword">return</span> var3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            var10000 = $result;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> ((Number)var10000).intValue();</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面又走到了<code>MainKt.testSuspends(this);</code> ，这就像递归一样，走到了下一个方法中。再看下<code>testSuspends</code>的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">10000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会走到withContext中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>,  <span class="comment">// Dispatchers.IO</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>  <span class="comment">// kotlinx.coroutines.CoroutineScope.() -&gt; kotlin.Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span> &#123; uCont -&gt;  <span class="comment">// Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)</span></span><br><span class="line">        <span class="keyword">val</span> oldContext = uCont.context <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, BlockingEventLoop@7d322cad]</span></span><br><span class="line">        <span class="keyword">val</span> newContext = oldContext.newCoroutineContext(context)  <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO] 将BlockingEventLoop顶掉了</span></span><br><span class="line">        newContext.ensureActive()</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文相同，则直接执行代码块而不进行任何调度。                                   </span></span><br><span class="line">        <span class="keyword">if</span> (newContext === oldContext) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文使用的是相同的`ContinuationInterceptor`，则使用`UndispatchedCoroutine`执行代码块。                                                      </span></span><br><span class="line">        <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont)</span><br><span class="line">            withCoroutineContext(coroutine.context, <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 对于所有其他情况，创建一个`DispatchedCoroutine`，并且以可以取消的方式启动协程。</span></span><br><span class="line">				<span class="comment">// newContext： [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO]    </span></span><br><span class="line">				<span class="comment">// uCont： Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)                                                      </span></span><br><span class="line">        <span class="keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        <span class="comment">// 启动协程并设置代码块。</span></span><br><span class="line">				<span class="comment">// coroutine                                                       </span></span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        <span class="comment">// 获取协程的结果。</span></span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要是通过<code>suspendCoroutineUninterceptedOrReturn</code>获取了续体和它的context来构建DispatchedCoroutine。</p>
<p><code>createCoroutineUnintercepted(receiver, completion).intercepted()</code> 这段代码生成的对象为<code>DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</code>。 传入的Dispatchers为Dispatchers.IO。Dispatchers.IO返回的对象为<code>public val IO: CoroutineDispatcher = DefaultIoScheduler</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 这里的dispatcher为DefaultIoScheduler </span></span><br><span class="line">          	<span class="comment">// context：[DispatchedCoroutine&#123;Active&#125;@19976a65, Dispatchers.IO]</span></span><br><span class="line">          	<span class="comment">// this：DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看下DefaultIoScheduler::dispatch</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#DefaultIoScheduler</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  	<span class="comment">// default：LimitedDispatcher</span></span><br><span class="line">    default.dispatch(context, block)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> default = UnlimitedIoScheduler.limitedParallelism(</span><br><span class="line">        systemProp(</span><br><span class="line">            IO_PARALLELISM_PROPERTY_NAME,</span><br><span class="line">            <span class="number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">最终挖到</span><br><span class="line">#LimitedDispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// 这里的dispatcher是UnlimitedIoScheduler</span></span><br><span class="line">        dispatchInternal(block) &#123; worker -&gt;</span><br><span class="line">            dispatcher.dispatch(<span class="keyword">this</span>, worker)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">所以最终调用的是UnlimitedIoScheduler下的dispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        DefaultScheduler.dispatchWithContext(block, BlockingContext, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">DefaultScheduler继承自SchedulerCoroutineDispatcher</span><br><span class="line">#SchedulerCoroutineDispatcher</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchWithContext</span><span class="params">(block: <span class="type">Runnable</span>, context: <span class="type">TaskContext</span>, tailDispatch: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        coroutineScheduler.dispatch(block, context, tailDispatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里到了协程线程池的知识点了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//block 为DispatchedContinuation</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//构建Task对象,block 本身就是Task类型</span></span><br><span class="line">    <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">    <span class="comment">//当前线程是否是Worker类型，也就是说当前线程是否是线程池内的线程</span></span><br><span class="line">    <span class="keyword">val</span> currentWorker = currentWorker()<span class="comment">//①</span></span><br><span class="line">    <span class="comment">//如果是，则尝试提交任务到本地队列，否则返回任务本身</span></span><br><span class="line">    <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)<span class="comment">//②</span></span><br><span class="line">    <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有提交到本地队列，则提交到全局队列 </span></span><br><span class="line">        <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;<span class="comment">//③</span></span><br><span class="line">            <span class="comment">//添加队列失败则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要跳过唤醒线程，主要用在IO分发器</span></span><br><span class="line">    <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;<span class="comment">//④</span></span><br><span class="line">        <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//非阻塞任务，唤醒cpu 线程</span></span><br><span class="line">        signalCpuWork()<span class="comment">//⑤</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//阻塞任务，唤醒blocking 线程</span></span><br><span class="line">        signalBlockingWork(skipUnpark = skipUnpark)<span class="comment">//⑥</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下构建的线程池的参数</p>
<p>最先线程数非常大，核心线程数与cpu核数相关。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> CORE_POOL_SIZE = systemProp(</span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>,</span><br><span class="line">    AVAILABLE_PROCESSORS.coerceAtLeast(<span class="number">2</span>), <span class="comment">// 获取运行时java虚拟机的核心数 比2大的话CORE_POOL_SIZE就是这个值</span></span><br><span class="line">    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 可以自定义</span></span><br><span class="line">System.setProperty(<span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><a href="https://juejin.cn/post/7137905800504148004">https://juejin.cn/post/7137905800504148004</a></p>
<h3 id="大概流程图"><a href="#大概流程图" class="headerlink" title="大概流程图"></a>大概流程图</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9047de897d71447aa30e5b50b9e0a917%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="Kotlin协程工作流程"></p>
<p>在14，15 这两步一直循环到有可用的值就开始返回。</p>
]]></content>
  </entry>
  <entry>
    <title>Android 内存泄漏相关</title>
    <url>/2023/12/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p>每个 Android 应用在启动时都会创建一个新的进程，和一个对应的运行时环境实例，当中包括堆（Heap）的分配和垃圾回收等功能。在操作系统中，每个进程都有自己的独立地址空间，这包括了堆、栈、代码和数据段。</p>
<p>一个运行中的程序（进程）的内存空间被划分为几个区域，每个区域有特定的用途和属性：</p>
<ol>
<li><strong>栈（Stack）</strong>：<ul>
<li>栈是由编译器自动管理的内存区域，用于存储程序执行时的函数调用信息。</li>
<li>它包括函数的参数值、返回地址以及局部变量等。</li>
<li>栈的特点是后进先出（LIFO）的数据结构，每当一个函数被调用时，它的信息就被推入（push）栈中，当函数调用完成后，这些信息就会被弹出（pop）栈。</li>
<li>分配时机：栈空间通常在程序开始执行时由操作系统自动分配，随着函数的调用和返回，会动态地增长和缩减。</li>
<li>分配者：操作系统负责分配一个初始栈空间给进程，并在运行时对栈进行管理。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>堆是用于动态内存分配的区域，程序在运行时可以从堆上分配或释放内存。</li>
<li>在C语言中，动态内存分配是通过<code>malloc</code>、<code>calloc</code>、<code>realloc</code>和<code>free</code>等函数实现的。</li>
<li>在Android开发中，Java虚拟机（JVM）或其他运行环境（如Dalvik虚拟机或Android Runtime, ART）管理堆内存，程序员通常不需要手动管理这部分内存，因为垃圾回收器会自动回收不再使用的对象。</li>
<li>分配时机：堆空间的分配是在程序运行时根据需要进行的，通常是程序员通过代码请求分配。</li>
<li>分配者：在C和C++等语言中，是由程序员通过调用<code>malloc</code>、<code>new</code>等函数显式申请的。在Java、C#等使用垃圾回收机制的语言中，由虚拟机或运行时环境负责管理。</li>
</ul>
</li>
<li><strong>BSS段（Block Started by Symbol）</strong>：<ul>
<li>BSS段用于存储程序中的未初始化的全局变量和静态变量。</li>
<li>在程序启动时，BSS段会被操作系统初始化为零或空指针。</li>
<li>分配时机：BSS段的空间分配发生在程序启动时，在程序被加载到内存时自动分配。</li>
<li>分配者：操作系统在加载程序时，会根据可执行文件的信息为BSS段分配内存，并将其初始化为零。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>数据段用来存储程序中已初始化的全局变量和静态变量。</li>
<li>这些变量的初始值存储在程序的可执行文件中，并在程序加载到内存时被初始化。</li>
<li>分配时机：数据段也是在程序启动时分配的，当程序被加载到内存时进行。</li>
<li>分配者：操作系统根据程序的可执行文件内容，在加载程序时为数据段分配内存，并赋予初始值。</li>
</ul>
</li>
<li><strong>程序代码区（Text Segment 或 Code Segment）</strong>：<ul>
<li>程序代码区，也称为文本段，包含了程序的机器指令代码。</li>
<li>这部分内存通常是只读的，以防止程序在运行时被意外修改。</li>
<li>它对应的是程序源代码文件中的实际指令和函数定义。</li>
<li>分配时机：程序代码区的分配同样发生在程序启动时，即当程序被加载到内存中时。</li>
<li>分配者：操作系统根据可执行文件中的代码段来分配内存，并将程序代码加载到这一段内存中。</li>
</ul>
</li>
</ol>
<h3 id="JVM、ART、DVM-的区别"><a href="#JVM、ART、DVM-的区别" class="headerlink" title="JVM、ART、DVM 的区别"></a>JVM、ART、DVM 的区别</h3><p>Java虚拟机（JVM）和Android虚拟机（如Dalvik虚拟机和Android Runtime，ART）都是为了运行基于Java语言编写的程序而设计的，但它们在设计理念、架构和运行环境上存在一些关键区别：</p>
<h4 id="功能原理："><a href="#功能原理：" class="headerlink" title="功能原理："></a>功能原理：</h4><p><strong>JVM</strong>：</p>
<p>我们写的java文件,经过编译生成.class文件,然后经过java虚拟机类加载 就成了.class类,也就是我们运行时访问的XXX.class类。JVM底层会将字节码转换为机器码,然后运行在CPU内.也可以这么理解:<strong>JVM就是个转换器,他将我们写的代码转换为CPU可以识别的代码,然后运行在CPU内</strong>。</p>
<p>或者说: JVM将CPU可以识别的代码,翻译成我们认识的java代码,让我们来写,我们写完后,它再负责翻译回去,让CPU执行。不同平台有不同的JVM,所以我们写一套代码,就能转换成不同平台的机器码,也就可以运行在不同平台上,这就是java跨平台的原理.</p>
<p><strong>DVM</strong>：</p>
<p>在app启动后,我们执行到对应功能的时候,就将这部分功能对应的代码 转换为 机器码,保存起来然后执行,可以理解为:<strong>用到才转换,所以也被称为JIT(just in time)</strong>.</p>
<p>优点：节省内存</p>
<p>缺点：执行速度慢</p>
<p><strong>ART</strong>：</p>
<p>主要有两个改善的地方.</p>
<ul>
<li><p>1 将转换为机器码的过程提前到了安装apk的时候.</p>
</li>
<li><p>2 内存分配方式和垃圾回收机制做了极大的优化.</p>
<p>DVM是基于JIT实现的,也就是边编译边执行,在运行到对应功能的时候,才将代码转换为机器码,然后交给CPU去执行.</p>
<p>而ART则不然,ART是在app安装的时候,就提前将所有代码转换为机器码保存下来,等到执行的时候,直接取出来在CPU中执行,也就是说,<strong>ART将转换为机器码这件事提前了. 所以叫做AOT(ahead of time)</strong>.</p>
</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>JVM</strong>：</p>
<ul>
<li>基于堆栈，每个线程都有自己的方法调用栈，栈帧中存储局部变量和操作数。</li>
<li>运行标准Java字节码，通常以<code>.class</code>文件的形式存在。</li>
<li>可在多种操作系统上运行，是跨平台的。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li><p>Dalvik有自己的字节码，不使用Java字节码</p>
</li>
<li><p>基于寄存器，更适合于资源受限的系统，如移动设备。</p>
</li>
<li><p>执行专为Dalvik设计的.dex格式文件，这是一种紧凑、针对Dalvik优化的字节码格式。</p>
</li>
<li><p>ART通过预编译（AOT编译）将应用程序转换为本机代码，从而提高性能。Dalvik采用的是JIT即时编译技术。</p>
</li>
<li><p>专门为Android系统设计，不是通用的跨平台解决方案。</p>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>JVM</strong>：</p>
<ul>
<li>采用即时编译（JIT）技术，在程序运行时将字节码编译成本地代码，实现性能优化。</li>
<li>服务器和桌面环境中的JVM会进行大量的性能优化以提高吞吐量和减少延迟。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li>Dalvik使用JIT编译，但受限于移动设备的性能和电池寿命的限制。</li>
<li>ART使用AOT编译，应用程序在安装时就被编译成本地代码，并在运行时进行JIT编译优Java虚拟机（JVM）和Android虚拟机（主要是指Dalvik虚拟机和Android运行时ART）都是为了在不同的硬件和操作系统平台上运行编译后的代码而设计的，但它们在设计哲学、实现方式和优化目标上有所不同。</li>
</ul>
<p>以下是JVM和Android虚拟机（Dalvik和ART）的一些主要区别：</p>
<h4 id="目标平台："><a href="#目标平台：" class="headerlink" title="目标平台："></a>目标平台：</h4><ul>
<li><strong>JVM</strong>：设计用于运行跨平台的Java应用程序，通常安装在个人电脑、服务器和大型系统上。</li>
<li><strong>Android虚拟机</strong>：专门为低功耗、有限内存的移动设备设计。</li>
</ul>
<h4 id="执行代码格式："><a href="#执行代码格式：" class="headerlink" title="执行代码格式："></a>执行代码格式：</h4><ul>
<li><strong>JVM</strong>：执行Java字节码，通常是<code>.class</code>文件或<code>.jar</code>文件中的代码。</li>
<li><strong>Dalvik</strong>：执行为Android优化的Dex（Dalvik Executable）格式代码。</li>
<li><strong>ART</strong>：虽然也支持Dex格式，但在应用安装时会将Dex编译成系统特定的本地机器码。</li>
</ul>
<h4 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h4><ul>
<li><strong>JVM</strong>：主要使用即时编译（JIT），应用程序在运行时编译成本地代码。</li>
<li><strong>Dalvik</strong>：使用解释执行，但也有JIT编译提高性能。</li>
<li><strong>ART</strong>：使用预先编译（AOT），在安装时将应用编译成本地代码，以及在运行时通过JIT进行优化。</li>
</ul>
<h4 id="垃圾回收（GC）："><a href="#垃圾回收（GC）：" class="headerlink" title="垃圾回收（GC）："></a>垃圾回收（GC）：</h4><ul>
<li><strong>JVM</strong>：提供多种垃圾回收器，可根据应用需求选择（如G1、CMS、Parallel等）。</li>
<li><strong>Dalvik</strong>：使用一个简单的GC机制，适合内存有限的设备。</li>
<li><strong>ART</strong>：提供改进的GC机制，包括分代垃圾回收和并发垃圾回收，以减少应用暂停时间。</li>
</ul>
<h4 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h4><ul>
<li><strong>JVM</strong>：在服务器和桌面环境中，性能优化侧重于最大化吞吐量和减少GC暂停时间。</li>
<li><strong>Android虚拟机</strong>：在移动设备上，优化侧重于启动速度，运行效率和响应速度，以及减少内存使用。</li>
</ul>
<h4 id="开发和分发模型："><a href="#开发和分发模型：" class="headerlink" title="开发和分发模型："></a>开发和分发模型：</h4><ul>
<li><strong>JVM</strong>：通常用于开发通用Java应用程序，可以在任何安装了兼容JVM的系统上运行。</li>
<li><strong>Android虚拟机</strong>：用于开发Android应用程序，这些应用程序通过Google Play商店或其他方式分发给Android用户。</li>
</ul>
<p>综上所述，JVM和Android虚拟机虽然都是虚拟机，但是它们在设计上是为了满足不同平台和需求而优化的。JVM更加通用和多功能，而Android虚拟机则是专门为移动设备和Android操作系统优化。</p>
<h3 id="ART-Java-堆组成"><a href="#ART-Java-堆组成" class="headerlink" title="ART Java 堆组成"></a>ART Java 堆组成</h3><p>当 Android 虚拟机启动时，便会创建 Java 堆，后续所有 Java 对象所需要的内存都会从这个堆中分配，所以我们先来说说 Java 堆的组成。Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace</strong>：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。Java 堆的空间是有限的，加起来只有 512M；</p>
<h3 id="Java对象内存申请"><a href="#Java对象内存申请" class="headerlink" title="Java对象内存申请"></a>Java对象内存申请</h3><p>Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<h3 id="Java对象内存释放"><a href="#Java对象内存释放" class="headerlink" title="Java对象内存释放"></a>Java对象内存释放</h3><p>在 Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC。</p>
<p>对于 ART 虚拟机的垃圾回收器来说，<strong>是通过可达性分析来判断一个对象是否可以被回收</strong>。<strong>GarbageCollector</strong> 会对 <strong>space</strong> 中的每一个对象的引用链进行分析，如果这个对象的引用链最终被 <strong>GC Root</strong> 持有，就说明这个对象不可回收。否则，就可以回收。如下图所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们没有被 GC Roots 持有， 因此会被判定为可回收的对象。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9297dd5668e34c8e97422a9dc4ad4f58%7Etplv-k3u1fbpfcp-jj-mark%3A1512%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>GC Root 有下面几项：</p>
<ol>
<li>栈中引⽤的对象：比如应用中主线程的 Handler，它是不会退出的，如果在 Handler 中持有了一个对象，那么这个对象就是被主线程栈所引用的对象，属于 GC Root 可达。这样一来，在 GarbageCollector 执行 GC 时就不会释放这个对象。</li>
<li>静态变量、常量引⽤的对象：被静态变量应用的对象也是属于 GC Root 可达，只有我们手动置为 null 才能释放这个对象。</li>
<li>本地⽅法栈 Native ⽅法引⽤的对象：通过 JNI 调用，传递到 Native 层并被 Native 的函数引用的对象。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>通过上面对 Java 堆的原理的讲解，我们了解了这 2 个知识点：</p>
<ol>
<li>Java 堆的空间是有限的，加起来只有 512M；</li>
<li>只有在切断 Java 对象和 GC Root 的关联后，虚拟机的 GC 机制才会回收该对象。</li>
</ol>
<p>基于这 2 个底层的知识点，我们就可以总结出 Java 堆内存优化的 3 条方法论：</p>
<ol>
<li><strong>减少加载进程</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>及时清理加载进</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>增加</strong> <strong>Java</strong> <strong>堆空间可用大小</strong></li>
</ol>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><ul>
<li>通过new分配新对象时，堆中剩余空间不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>到达阈值</li>
<li>手动调用系统API System.gc()时，会产生一次GC动作。</li>
<li>系统空闲。这个空闲判断条件也很多，比如进到后台，或者消息队列没数据等等。 后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。</li>
<li>启动时候出现gc，主要还是在于内存压力，到达一定的压力水位，就会触发GC</li>
</ul>
<p>C有不同的程度的，内存不足的时候的GC是最深度的，对性能影响也最大。达到不同的预测，GC的程度不一样，刚到达阈值的时候，可能就只是轻度的GC，轻度的就是标记清除，中度的就是复制拷贝回收。</p>
<h3 id="Java堆内存的获取"><a href="#Java堆内存的获取" class="headerlink" title="Java堆内存的获取"></a>Java堆内存的获取</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">loge(<span class="string">&quot;JVM试图使用的最大内存量，即应用程序可以使用的最大堆内存 ：<span class="subst">$&#123;Runtime.getRuntime().maxMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM当前已经从系统获取的内存量，包括已使用的内存和未使用的内存  ：<span class="subst">$&#123;Runtime.getRuntime().totalMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM中未使用的内存量  ：<span class="subst">$&#123;Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM的最大内存减去当前已经被使用的内存，得出的结果是应用程序还可以继续使用的内存量: <span class="subst">$&#123;Runtime.getRuntime().maxMemory() - Runtime.getRuntime().totalMemory() + Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="OOM产生"><a href="#OOM产生" class="headerlink" title="OOM产生"></a>OOM产生</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::IsOutOfMemoryOnAllocation</span><span class="params">([[maybe_unused]] AllocatorType allocator_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">size_t</span> alloc_size, <span class="comment">// 请求分配的内存大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> grow)</span> </span>&#123;  <span class="comment">// 是否允许内存增长 </span></span><br><span class="line">  <span class="type">size_t</span> old_target = target_footprint_.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 获取当前目标内存占用</span></span><br><span class="line">  <span class="comment">// 无限循环，计算新内存占用</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_allocated = num_bytes_allocated_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 在当前已分配的内存基础上增加了新请求分配的内存。</span></span><br><span class="line">    <span class="type">size_t</span> new_footprint = old_allocated + alloc_size;</span><br><span class="line">    <span class="comment">// 判断新占用是否超过限制。UNLIKELY提示编译器该条件发生概率低</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &lt;= old_target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// growth_limit_ ：堆内存的最大值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &gt; growth_limit_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>old_target</code> 相当于是一个可以变动的内存占用警戒线，而 <code>growth_limit_</code> 是不可超越的最大内存使用边界。如果内存使用超出了 <code>old_target</code> 但未到 <code>growth_limit_</code>，程序可能还有一定的弹性空间来调整内存使用；但是一旦超出 <code>growth_limit_</code>，则通常没有余地。</p>
<h3 id="OOM产生路径"><a href="#OOM产生路径" class="headerlink" title="OOM产生路径"></a>OOM产生路径</h3><p><a href="https://juejin.cn/post/7240636469462597690#heading-2">https://juejin.cn/post/7240636469462597690#heading-2</a></p>
<h3 id="ART-GC历史"><a href="#ART-GC历史" class="headerlink" title="ART GC历史"></a>ART GC历史</h3><h4 id="Dalvik-GC-（直到Android-4-4-KitKat）"><a href="#Dalvik-GC-（直到Android-4-4-KitKat）" class="headerlink" title="Dalvik GC （直到Android 4.4 KitKat）"></a>Dalvik GC （直到Android 4.4 KitKat）</h4><ul>
<li>初始的Dalvik虚拟机采用的是“标记-清除”（Mark-Sweep）算法。</li>
<li>在必要时执行“Stop-the-World”（STW）垃圾回收，这意味着所有工作线程都必须暂停，直到垃圾回收过程完成。</li>
</ul>
<h4 id="ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）"><a href="#ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）" class="headerlink" title="ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:"></a>ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:</h4><ul>
<li>引入了“分代GC”（Generational GC），它对对象按照存活时间进行分类，短暂对象和长期对象分别管理，以提高效率。</li>
<li>引入了预编译技术，改善了垃圾回收的性能。</li>
</ul>
<h4 id="ART-GC-（Android-6-0-Nougat）"><a href="#ART-GC-（Android-6-0-Nougat）" class="headerlink" title="ART GC （Android 6.0 Nougat）:"></a>ART GC （Android 6.0 Nougat）:</h4><ul>
<li>ART&#x2F;Dalvik Android团队使用汇编语言重写了整个对象分配过程，进一步提高了效率和性能。</li>
</ul>
<h4 id="ART-GC-（Android-8-0-9-0）"><a href="#ART-GC-（Android-8-0-9-0）" class="headerlink" title="ART GC （Android 8.0 ~ 9.0）:"></a>ART GC （Android 8.0 ~ 9.0）:</h4><ul>
<li>引入了“并发复制GC”（Concurrent Copying GC），称为CMS（Concurrent Mark-Sweep）的改进版本，减少了应用的暂停时间。</li>
</ul>
<h4 id="ART-GC-（Android-10开始）"><a href="#ART-GC-（Android-10开始）" class="headerlink" title="ART GC （Android 10开始）:"></a>ART GC （Android 10开始）:</h4><ul>
<li>重新引入了“分代GC”，并作为“并发复制GC”的一个扩展，进一步优化内存管理和减少暂停时间</li>
</ul>
<p>在 Generational CC 中，堆内存并没有显式地划分为不同的代，而是在运行时 把不同的 region 标记为新生代或者老年代；</p>
<p>下面是JVM对用户空间的划分</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/3a21f3fd821143708a0ea69ca309bad1%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="在这里插入图片描述"></p>
<p>Android虚拟机将堆内存同样分为三个区域：<strong>年轻代，年老代，永久代</strong>，针对年轻代和老年代，ART和Dalvik又做了细分。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/5b4db7c314164ebab2619e5e7efc27e7%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0-20231228163627586.awebp" alt="在这里插入图片描述"></p>
<p><strong>ZygoteSpace：Zygote进程启动过程中创建的所有对象。这些对象是所有进程共享</strong></p>
<p><strong>ImageSpcace：存放预加载的类，Android Framework中通用的类都都是存储在这里</strong></p>
<p><strong>Large Obj Space：存放大于12k的类对象的空间</strong></p>
<p><strong>Main Allooc Space：存放小对象的空间</strong></p>
<p><strong>Non Moving Space&#x2F;Linear Alloc：只读的线性内存空间，主要用来存储虚拟机中在进程生命周期都不会结束清理的永久数据的类对象。</strong></p>
<p>ZygoteSpace和ImageSpace存放共享的预加载的类，这样可以提高启动速度，还有根据对象的大小和特性划分LargeObjSpace，AllocSpace和Non Moving Space可以采用不同的垃圾回收策略，提高gc的效率和性能。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1*bsfQgcHVbxeFsXOGv5onPA-20231228165437394.png" alt="img"></p>
<h3 id="Android中的GC"><a href="#Android中的GC" class="headerlink" title="Android中的GC"></a>Android中的GC</h3><p>Android中的GC是通过<strong>HeapTaskDaemon</strong>线程来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapTaskDaemon</span> <span class="keyword">extends</span> <span class="title class_">Daemon</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式，内部类中创建该类的唯一实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HeapTaskDaemon</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapTaskDaemon</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，设置守护线程的线程名为 &quot;HeapTaskDaemon&quot;。</span></span><br><span class="line">    HeapTaskDaemon() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;HeapTaskDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，用于中断指定的线程。</span></span><br><span class="line">    <span class="comment">// 这个方法会通知 VMRuntime 停止堆任务处理器。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        VMRuntime.getRuntime().stopHeapTaskProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程的核心执行方法。</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，确保线程安全。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果守护线程正在运行，则通知 VMRuntime 启动堆任务处理器。</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line">              VMRuntime.getRuntime().startHeapTaskProcessor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行堆任务。</span></span><br><span class="line">        <span class="comment">// 这个方法可能会执行垃圾收集（GC）或其他与堆管理相关的任务。</span></span><br><span class="line">        VMRuntime.getRuntime().runHeapTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapTaskDaemon 是一个守护线程（程序运行时在后台提供一种通用服务的线程），随着 Zygote 进程启动便会启动，该线程的 run 方法也比较简单，就是执行 runInternal 这个抽象函数，该抽象函数的实现方法中会执行 VMRuntime.getRuntime().runHeapTasks() 方法，runHeapTasks() 函数会执行 RunAllTasks 这个 Native 函数，它位于 <a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/task_processor.cc">task_processor.cc</a> 这个类中。</p>
<p>通过源码一路跟踪下来，可以看到 HeapTaskDaemon 线程的 run 方法中真正做的事情，实际只是在无限循环的调用 GetTask 函数获取 HeapTask 并执行。GetTask 中会不断从 tasks 集合中取出 HeapTask 来执行，并且对于需要延时的 HeapTask ，会阻塞到目标时间。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155739553.png" alt="image-20231229155739553"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155809976.png" alt="image-20231229155809976"></p>
<h3 id="GC导致应用程序卡顿"><a href="#GC导致应用程序卡顿" class="headerlink" title="GC导致应用程序卡顿"></a>GC导致应用程序卡顿</h3><p>GC导致了用户线程的停止，这个机制叫做STW，为了防止出现 GC开始时对象没引用被标记为垃圾，GC过程中对象又被引用这种情况。</p>
<p>回收策略：分代回收 分区回收</p>
<p>垃圾检测算法：引用计数 可达性分析</p>
<p>回收算法：标记复制 标记清除  标记整理</p>
<h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p><strong>标记清除</strong>：</p>
<ul>
<li><p>Mark阶段（标记阶段）：搜索内存中的Java对象（对ART虚拟机而言，就是遍历mirror Object对象），对那些能搜到的对象进行标记。</p>
</li>
<li><p>Sweep阶段（清除阶段）：释放那些没有被标记的对象所占据的内存。</p>
<p>整个过程需要将整个程序暂停，清除完成之后才恢复程序运行，而且这个算法会带来碎片化的问题。</p>
</li>
</ul>
<p><strong>复制算法</strong>：复制算法会将存活的对象复制到一块内存，然后将遗留下来的对象进行清理，这种算法不会产生碎片问题，但是会占用更多的内存，因为要一块空间来复制存活的对象。 年轻代</p>
<p><strong>标记整理</strong>：先从根节点标记哪些是被对象引用的。第二阶段将所有存活的对象压缩移动到内存的另一端，按顺序排放，最后清除所有边界以外的空间。 老年代</p>
<p><strong>分代算法</strong>：分代垃圾回收算法（Generational Garbage Collection）是基于对象生命周期不同的假设来进行垃圾回收的策略。它把对象分为几个“代”，通常至少分为两代：年轻代（Young Generation）和老年代（Old Generation）。</p>
<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><ul>
<li>局部变量表：正在执丸行的函数的参数、临时变量，临时值</li>
<li>方法区中的静态变量：如类的静态变量</li>
<li>方法区中的常量池：如常量池中的常量引用实例</li>
<li>本地方法栈中的变量：NI调用Native方法所引用的实例</li>
<li>同步锁持有的对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2024/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。</p>
<p>通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。</p>
<p>以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load(shop.goodsCount , r1) //指令1，将变量 shop.goodsCount 的值从内存读到寄存器 r1</span><br><span class="line">increment(r1) //指令2，将寄存器 r1 的值加1</span><br><span class="line">store(shop.goodsCount , r1) //指令3，将寄存器 r1 的内容写入变量 shop.goodsCount 所对应的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程 A 在执行完指令1，开始执行或者正在执行指令2时，线程 B 可能已经执行完了指令3，这使得线程 A 当前持有的共享变量 shop.goodsCount 是旧值，当线程 A 执行完指令3时，这就使得线程 B 对共享变量的更新被覆盖了，即造成了更新丢失。</p>
<blockquote>
<p>竞态可以看做是由于访问（读取、更新）同一组共享变量的多个线程所执行的操作被相互交错而导致的。而上述代码中遇到的<strong>更新丢失</strong>和<strong>读到脏数据</strong>问题就是由于竞态的存在而导致的</p>
<p>需要注意的是，竞态的产生前提是涉及到了多个线程和共享变量。如果系统仅包含单个线程，或者不涉及共享变量，那么就不会产生竞态。对于局部变量（包括形式参数和方法体内定义的变量），由于不同的线程访问的是各自的那一份局部变量，<strong>因此局部变量的使用不会导致竞态</strong><br>链接：<a href="https://juejin.cn/post/6899452217528025095">https://juejin.cn/post/6899452217528025095</a></p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程安全问题概括来说表现为三个方面：<strong>原子性、可见性、有序性</strong></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>对于涉及共享变量访问的操作，若该操作从其执行线程以外的其它任意线程来看是不可分割的，那么该操作就是<strong>原子操作</strong>，相应的就称该操作具有<strong>原子性</strong>。</p>
<p>简单来说就是如果当前线程的一块逻辑，相对于其他线程来说要么是已经执行完了要么是还未执行，不会出现执行到一半的情况。</p>
<p>Java 中有两种方式来提供原子性：</p>
<ul>
<li>第一种是使用锁（Lock）。锁具有排他性，它能够保障共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，从而消除了竞态</li>
<li>第二种是利用处理器提供的 CAS 指令。CAS 指令实现原子性的方式与锁在本质上是相同的，差别在于锁通常是在软件这一层面实现的，而 CAS 是直接在硬件（处理器和内存）这一层次实现的，可以被看做“硬件锁”</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的其它线程可能无法立即读取到这个更新的结果，甚至永远也无法读取到，这体现了多线程安全性问题中的一个：可见性。<strong>可见性是指一个线程对共享变量的更新结果对于其它读取相应共享变量的线程而言是否可见的问题。</strong>多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据，而这往往会导致我们的程序出现意想不到的问题。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640.jpg" alt="640"></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排一般分为以下三种：</p>
<ul>
<li><p><strong>编译器优化重排</strong></p>
<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下会出现执行<code>instance.doSomething();</code>时instance还未完成初始化的情况。</p>
<p>使用关键字new创建一个对象，大致分为一下过程：</p>
<ul>
<li>在栈空间创建引用地址</li>
<li>以类文件为模版在堆空间对象分配内存</li>
<li>成员变量初始化</li>
<li>使用构造函数初始化</li>
<li>将引用值赋值给左侧存储变量</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>并发的实现和是否拥有多个处理器无关，即使只有单个处理器也能够通过处理器<strong>时间片分配</strong>技术来实现并发。操作系统通过给每个线程分配一小段占有处理器使用权的时间来供其运行，然后在每个线程的运行时间结束后又快速切换到下一个线程来运行，多个线程以这种断断续续的方式来实现并发并完成各自的任务。</p>
<p>操作系统会分出一个个时间片，每个线程每次运行会分配到若干个时间片，时间片决定了一个线程可以连续占用处理器运行的时间长度，一般是只有几十毫秒，单处理器上的多线程就是通过这种<strong>时间片分配</strong>的方式来实现并发。当一个进程中的一个线程由于其时间片用完或者由于其自身的原因被迫或者主动暂停其运行时，另外一个线程（当前进程中的线程或者其它进程中的线程）就可以被线程调度器选中来占用处理器并开始运行。这种一个线程被剥夺处理器的使用权并暂停运行，另外一个线程被赋予处理器的使用权并开始运行的过程就称为线程上下文切换。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度是指操作系统为线程分配处理器使用权的过程。主要的调度方式有两种：</p>
<ul>
<li>协同式线程调度。在这种策略下，线程的执行时机由线程本身来决定，线程通过主动通知系统切换到另一个线程的方式来让出处理器的使用权。该策略的优点是实现简单，可以通过精准控制线程的执行顺序来避免线程安全性问题。缺点是可能会由于单个线程的代码缺陷问题导致无法切换到下一个线程，最终导致进程被阻塞</li>
<li>抢占式线程调度。这也是 Java 平台使用的线程调度策略。在这种策略下，由操作系统来决定当前处理器时间片交由哪个线程来使用，线程无法决定具体的运行时机和运行顺序。虽然我们可以通过 <code>Thread.yieid()</code> 方法来让出时间片，但是无法主动抢夺时间片，且虽然 Thread 类也提供了设置线程优先级的方法，但线程的具体执行顺序还是取决于其运行系统。该策略的优点是不会由于一个线程的问题导致整个进程被阻塞，且提高了并发性。缺点是实现较为复杂，且会带来多线程安全性问题。</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<p>在没有锁的情况下，当一个Thread创建后，start()调用后就会变成Runnable状态，然后当该线程抢到时间片后，就会Running状态（即开始运行），当执行完毕后便会结束Terminated，当然在运行中如果调用wait()后便会转为等待状态Waiting，然后一直到其他线程调用notify()或者notifyAll()才会被唤醒会，进入Runnable状态，然后抢时间片，重新Running。</p>
<p>如果涉及到锁的时候，当该线程抢到锁后，其他线程便会处于Blocked状态，等到该线程释放锁之后，那些阻塞的线程拿到锁后进入Runnable状态，然后Running：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>线程创建时的内存分配默认大小是1M，也就是1024k</p>
<h2 id="synchronize使用"><a href="#synchronize使用" class="headerlink" title="synchronize使用"></a>synchronize使用</h2><p>先举个线程不安全的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRunnable</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = LockRunnable()</span><br><span class="line">    <span class="keyword">val</span> thread1 = Thread(runnable)</span><br><span class="line">    <span class="keyword">val</span> thread2 = Thread(runnable)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread2.join()</span><br><span class="line">        thread1.join()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    println(LockRunnable.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待两个线程执行完成之后a的值理论上应该是2000，但是实际上值是不确定的。</p>
<p>使用synchronized来保证线程安全</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">           synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">               a++</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<h2 id="synchronize原理"><a href="#synchronize原理" class="headerlink" title="synchronize原理"></a>synchronize原理</h2><p>先看一个知识点，Java对象是在堆区里，它是由对象头、实例数据和对齐填充数据组成的，而一个对象的锁状态信息就是记录在对象头里的。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/2931590af3214062b83e36980a36a0b2.jpeg" alt="在这里插入图片描述"></p>
<p><code>mark word</code>用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32bit，64位系统上长度为64bit。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<p>根据对象锁状态的不同，系统位数所记载的信息也不同。比如无锁状态下前25位就代表hashcode。</p>
<p>来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="comment">//需要同步的代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同步块部分的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: 3: monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit						  // monitorexit指令退出同步块 getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit	</span><br></pre></td></tr></table></figure>

<p>进入到synchronized同步块中，需要通过monitorenter指令获取到对象的monitor（也通常称之为对象锁）后才能往下进行执行，在处理完对应的方法内部逻辑之后通过monitorexit指令来释放所持有的monitor，以供其他并发实体进行获取。</p>
<p>再具体的原理可以看重量级锁的释放锁部分</p>
<h2 id="synchronize锁状态"><a href="#synchronize锁状态" class="headerlink" title="synchronize锁状态"></a>synchronize锁状态</h2><table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody></table>
<p>一个对象其实有四种锁状态,级别由低到高:</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<h4 id="1、无锁"><a href="#1、无锁" class="headerlink" title="1、无锁"></a>1、无锁</h4><p>释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。</p>
<h4 id="2、偏向锁（JDK15被废弃）"><a href="#2、偏向锁（JDK15被废弃）" class="headerlink" title="2、偏向锁（JDK15被废弃）"></a>2、偏向锁（JDK15被废弃）</h4><p>偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在<strong>资源无竞争</strong>情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</p>
<p>当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。</p>
<p>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
<h4 id="3、轻量级锁"><a href="#3、轻量级锁" class="headerlink" title="3、轻量级锁"></a>3、轻量级锁</h4><p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>发现是无锁状态，线程会<strong>把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）</strong> ，然后通过CAS尝试将锁的Mark Word修改为一根指针，指向自己的Displaced Mark Word（Displaced Mark Word与原mark word的内容一模一样，保存了HashCode，GC年龄等信息）</p>
</li>
<li><p>发现处于轻量级锁状态</p>
</li>
</ol>
<ul>
<li>如果轻量级锁的mark word指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功（如果是重入，会将markword改为null，空指针，即0）</li>
<li>如果轻量级锁的markword不是指向自己，锁膨胀，升级为「重量级锁」</li>
</ul>
<p><strong>CAS失败直接膨胀</strong></p>
<h4 id="4、-重量级锁"><a href="#4、-重量级锁" class="headerlink" title="4、 重量级锁"></a>4、 重量级锁</h4><p>由原来线程主动去抢锁对象变成由系统内核来决定最后锁对象分配给谁</p>
<p>从轻量级锁开始膨胀：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>monitor对象的结构：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<ul>
<li>Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构</li>
<li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</li>
<li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li>
<li>Owner：获得锁的线程称为Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
<p>ContentionList，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a><strong>获取锁</strong></h5><blockquote>
<p>对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己</p>
</blockquote>
<p>当一个线程尝试获得重量级锁时</p>
<ul>
<li>首先尝试「自旋」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』</li>
<li>进入cxq后，陷入「死循环」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「死循环」</li>
</ul>
<h5 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h5><p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
<p><strong>自旋逻辑</strong>：trySpin</p>
<p>首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：</p>
<p>开始自旋5000次（假设是第一次开始自旋，上限就为5000）</p>
<ul>
<li>成功，下次+100，下次可以最多自旋5100次</li>
<li>失败，下次- 200，下次可以最多自旋4800次，不会少于1000次</li>
</ul>
<p><strong>死循环</strong></p>
<p>死循环主要是在「阻塞」和「自旋」之间切换</p>
<ul>
<li>park阻塞，注意不会移动到WaitSet中</li>
<li>unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞</li>
</ul>
<p>只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>monitor有个计数器recursions，起初为0，Monitorenter + 1，Monitorexit - 1，减为0会释放锁</p>
<ol>
<li>通过CAS的方式将Monitor结构的Owner修改为nullptr</li>
<li>根据QMode参数的不同，执行不同的逻辑</li>
</ol>
<p>因为QMode默认值为0，我们来看一下<strong>默认的逻辑</strong>：</p>
<ul>
<li>如果EntryList和cxq均为空：什么也不做</li>
<li>如果EntryList非空：就取EntryList首元素唤醒</li>
<li>如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；</li>
</ul>
<p>锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。</p>
<h2 id="wait-notify底层原理"><a href="#wait-notify底层原理" class="headerlink" title="wait&#x2F;notify底层原理"></a>wait&#x2F;notify底层原理</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><ol>
<li>将当前线程包装成ObjectWaiter对象，放入WaitSet中，并调用park挂起</li>
<li>执行「释放锁」的逻辑。</li>
</ol>
<blockquote>
<p>只有notify方法有可能将线程从WaitSet拯救出来，处于WaitSet的线程永远是阻塞状态，不可能参与锁竞争</p>
</blockquote>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>从WaitSet中取出第一个线程，根据Policy的不同，将这个线程放入EntryList或者cxq队列中的起始或末尾位置</p>
<p>默认Policy为2，即：</p>
<ul>
<li>EntryList队列为空，将线程放入EntryList</li>
<li>EntryList队列非空，将线程放入cxq队列的头部位置（栈顶）；</li>
</ul>
<p>强调一下：notify方法只是将线程从WaitSet移动到EntryList或者cxq，不是直接让它开始自旋CAS。</p>
<h2 id="synchronized内存特性"><a href="#synchronized内存特性" class="headerlink" title="synchronized内存特性"></a>synchronized内存特性</h2><p><strong>内存可见性</strong></p>
<ul>
<li><strong>获取锁（进入 <code>synchronized</code> 块）</strong>：当一个线程获取锁并进入 <code>synchronized</code> 块时，它会清空本地内存（如果有的话），然后从主内存中读取共享变量的最新值。</li>
<li><strong>释放锁（退出 <code>synchronized</code> 块）</strong>：当一个线程释放锁并退出 <code>synchronized</code> 块时，它会将在 <code>synchronized</code> 块中对共享变量的所有修改刷新（写回）到主内存中。</li>
</ul>
<p><strong>原子性</strong></p>
<ul>
<li><code>synchronized</code>通过<code>monitorenter</code>和<code>monitorexit</code> 指令来保证原子性</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量</li>
<li>E：旧值</li>
<li>N：新值</li>
</ul>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>可见性</strong>：</p>
<p>第一项是保证此变量对所有线程的可见性，这里的“性”是指<strong>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>禁止指令重排序优化</strong></p>
<p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的<br>执行顺序一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2可能会比步骤1先执行</p>
<p>JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。如下所示：</p>
<blockquote>
<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>
<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>
</blockquote>
<p>当编译器遇到<code>volatile</code>变量的写操作时，会在写操作之前插入一个StoreStore屏障，防止写操作和之前的写操作发生重排；并在写操作之后插入一个StoreLoad屏障，防止写操作和之后的读写操作发生重排。</p>
<p>同样，当编译器遇到<code>volatile</code>变量的读操作时，会在读操作之后插入一个LoadLoad屏障，防止读操作和之后的读操作发生重排。</p>
<p>内存屏障（Memory Barrier），也称为内存栅栏，是一种用于处理器指令的同步机制，可以防止指令重排序。内存屏障主要分为以下四种类型： ，   </p>
<ol>
<li><strong>LoadLoad屏障</strong>：这种屏障确保在其前面的读操作（Load）不会被重排序到其后面的读操作之后。</li>
<li><strong>StoreStore屏障</strong>：这种屏障确保在其前面的写操作（Store）不会被重排序到其后面的写操作之后。</li>
<li><strong>LoadStore屏障</strong>：这种屏障确保在其前面的读操作不会被重排序到其后面的写操作之后。</li>
<li><strong>StoreLoad屏障</strong>：这种屏障确保在其前面的写操作不会被重排序到其后面的读操作之后。</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>) <span class="comment">// true设置为公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientThread</span>(name: String) : Thread(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(currentThread().name + <span class="string">&quot;开始尝试获取锁&quot;</span>)</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;成功获取锁&quot;</span>)</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;完成释放锁&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t1 = ClientThread(<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t2 = ClientThread(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t3 = ClientThread(<span class="string">&quot;线程3&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：					</span><br><span class="line">线程<span class="number">2</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">1</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">3</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">2</span>成功获取锁</span><br><span class="line">线程<span class="number">3</span>成功获取锁</span><br><span class="line">线程<span class="number">2</span>完成释放锁</span><br><span class="line">线程<span class="number">3</span>完成释放锁</span><br><span class="line">线程<span class="number">1</span>成功获取锁</span><br><span class="line">线程<span class="number">1</span>完成释放锁</span><br></pre></td></tr></table></figure>

<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ol>
<li><strong>公平锁</strong>：公平锁是指多个线程按照申请锁的顺序来获取锁。也就是说，锁会被授予等待时间最长的线程。这种方式可以防止资源饥饿，但是在锁的释放和获取之间会产生较大的开销，因此公平锁的整体吞吐量会比非公平锁小。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>类的构造函数可以接受一个布尔值，用来表示这个锁是否是公平的。</li>
<li><strong>非公平锁</strong>：非公平锁是指多个线程获取锁的顺序并不固定，也就是说，有可能新请求的线程比已经在等待的线程更早获取到锁。这种方式可能会导致某些线程等待时间过长甚至无限期等待，也就是所谓的饥饿现象。但是非公平锁的优点是吞吐量大，因为线程获取锁的速度通常比公平锁快，上下文切换次数也少。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>默认就是非公平锁。</li>
</ol>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p>
<p><strong>核心原理：</strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，<strong>AQS中的队列是CLH变体的虚拟双向队列（FIFO）</strong>，AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1ebefeb23a184f2a9b515bf01eb430da%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p>
<p>AQS 中的 CLH 变体等待队列拥有以下特性</p>
<ol>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋（进入一个循环中，不断检查锁是否已经被释放，而不是进入睡眠状态）获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ol>
<h3 id="ReentrantLock与AQS的关联"><a href="#ReentrantLock与AQS的关联" class="headerlink" title="ReentrantLock与AQS的关联"></a>ReentrantLock与AQS的关联</h3><p>追一下ReentrantLock加锁时的源码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>)</span><br><span class="line">lock.lock()</span><br></pre></td></tr></table></figure>

<p>lock()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个sync是FairSync对象或NonfairSync对象，是sync抽象类的实现类。然后看一下Sync的定义，AbstractQueuedSynchronizer就是AQS。下面都以NonfairSync非公平锁为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> <span class="comment">// 公平锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Syn</span> <span class="comment">// 非公平锁</span></span><br></pre></td></tr></table></figure>

<p>sync.lock()的实现看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Sync</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个initialTryLock方法就是用来尝试获取锁的，这个方法尝试获取一个可重入的独占锁，如果成功则返回true，如果失败则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">initialTryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用CAS操作尝试将锁的状态从0（未锁定）改变为1（已锁定）</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁已经被某个线程持有，检查锁的所有者是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">        <span class="comment">// 如果锁的所有者是当前线程，说明这是一个重入操作</span></span><br><span class="line">        <span class="comment">// 获取锁的当前状态并加1，表示锁被重入了一次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查锁的状态是否超过了int的最大值，如果超过，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 将锁的状态设置为新的值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁的所有者不是当前线程，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setState(c)就是设置之前说的那个表示同步状态的state值，如果获取锁成功将锁的所有者设置为当前线程，获取失败的话返回false开始执行 acquire(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AbstractQueuedSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            acquire(<span class="literal">null</span>, arg, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"># NonfairSync</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查锁的状态是否为0（未被锁定）</span></span><br><span class="line">    <span class="comment">// 如果锁的状态为0，使用CAS操作尝试将锁的状态从0改变为传入的acquires值</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁的状态不为0或者CAS操作失败，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会再次重试获取锁，如果获取失败的话就执行acquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">acquire</span><span class="params">(Node node, <span class="type">int</span> arg, <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> interruptible, <span class="type">boolean</span> timed, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些变量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">spins</span> <span class="operator">=</span> <span class="number">0</span>, postSpins = <span class="number">0</span>; <span class="comment">// 用于控制&quot;自旋&quot;的变量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, first = <span class="literal">false</span>; <span class="comment">// interrupted记录线程是否被中断，first记录node是否是队列的第一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// pred记录node的前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个无限循环，直到成功获取锁或者线程被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">                Thread.onSpinWait();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">                <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">                cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点是null，则根据是否共享锁创建相应类型的节点</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果CAS失败，回滚操作</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">            Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">            node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束，调用cancelAcquire方法取消获取锁，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个队列就是上面说的CLH变体的虚拟双向队列，acquire方法开启了一个死循环直到当前线程成功获取锁或者线程被中断才终止循环。</p>
<p>分析for内的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line"><span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(first = (head == pred))) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">    <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cleanQueue();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">        Thread.onSpinWait();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码首先检查当前节点是否是第一个节点，如果不是，并且当前节点有前驱节点，那么就检查前驱节点的状态。如果前驱节点的状态小于0，那么说明前驱节点已经被取消，此时需要调用cleanQueue()方法清理队列，然后继续下一轮循环。</p>
<p>如果前驱节点没有前驱，那么就调用<code>Thread.onSpinWait()</code>方法让出CPU，并继续下一轮循环。<code>Thread.onSpinWait()</code>是Java 9引入的一个新方法，它可以用来提示JVM当前线程正在进行自旋操作，这样JVM可以采取一些优化措施，如减少线程的调度优先级，以避免占用过多的CPU资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line"><span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> acquired;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (shared)</span><br><span class="line">            acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquired = tryAcquire(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">        cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是尝试获取锁。如果<code>node</code>是第一个节点或者没有前驱节点，那么就会尝试获取锁。</p>
<p>在这段代码中，如果锁是共享锁，那么就调用<code>tryAcquireShared(arg)</code>方法尝试获取锁，如果成功获取锁（返回值大于等于0），那么<code>acquired</code>就会被设置为<code>true</code>。如果锁是独占锁，那么就调用<code>tryAcquire(arg)</code>方法尝试获取锁，如果成功获取锁，那么<code>acquired</code>就会被设置为<code>true</code>。</p>
<p>如果在尝试获取锁的过程中发生异常，那么就调用<code>cancelAcquire(node, interrupted, false)</code>方法取消获取，并抛出异常。</p>
<p>这段代码是一个典型的锁获取过程，它使用了Java的并发编程技术来实现线程安全的锁获取。</p>
<p>获取锁之后会进行一个清理的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是在成功获取锁之后进行一系列的操作。如果成功获取了锁（<code>acquired</code>为<code>true</code>），并且当前节点是第一个节点（<code>first</code>为<code>true</code>），那么就会进行一些清理和设置操作。</p>
<p>在代码中，如果成功获取了锁，并且当前节点是第一个节点，那么就会将当前节点的<code>prev</code>属性设置为<code>null</code>，将<code>head</code>设置为当前节点，将前驱节点的<code>next</code>属性设置为<code>null</code>，并将当前节点的<code>waiter</code>属性设置为<code>null</code>。这些操作都是为了清理和设置节点的状态。</p>
<p>接下来，如果获取的是共享锁，那么就会调用<code>signalNextIfShared(node)</code>方法通知下一个等待的节点。如果在获取锁的过程中线程被中断，那么就会调用<code>current.interrupt()</code>方法来中断当前线程。</p>
<p>最后，如果成功获取了锁，那么就返回1，表示成功获取了锁。</p>
<p>这段代码是一个典型的并发编程的代码片段，它使用了Java的并发编程技术来实现线程安全的锁获取和释放。</p>
<p>根据原来的代码流程来看，第一次进来node会是null会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br></pre></td></tr></table></figure>

<p>这个shared默认是false，会给node赋值一个ExclusiveNode实例，然后开始下一个循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExclusiveNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123; &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">volatile</span> Node prev;       <span class="comment">// initially attached via casTail</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;       <span class="comment">// visibly nonnull when signallable</span></span><br><span class="line">      Thread waiter;            <span class="comment">// visibly nonnull when enqueued</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">      。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">    node.waiter = current;  <span class="comment">// 将当前线程设置为节点的等待线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取队列的尾节点</span></span><br><span class="line">    node.setPrevRelaxed(t);  <span class="comment">// 将尾节点设置为当前节点的前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        tryInitializeHead();  <span class="comment">// 如果尾节点为null，尝试初始化头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node)) </span><br><span class="line">        node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果使用CAS设置尾节点失败，回滚操作，将当前节点的前驱设置为null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首相将节点的waiter属性设置为当前线程，然后判断tail，这个tail是队列的尾节点，如果是第一次初始化队列的话会为null，然后就走了tryInitializeHead方法，这个方法内部会通过CAS的方式给tail初始化。</p>
<p><code>casTail(t, node)</code>是一个CAS操作，它尝试将队列的尾节点从<code>t</code>更新为<code>node</code>。如果在这个过程中，其他线程已经修改了尾节点，那么CAS操作会失败，这时就需要进行回滚操作，将当前节点的前驱设置为<code>null</code>。如果CAS操作成功，那么就将当前节点设置为新的尾节点。</p>
<p>看下下面部分的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">    --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">    Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">    node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">long</span> nanos;</span><br><span class="line">    spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">    <span class="keyword">if</span> (!timed)</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">        LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">    node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">    <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，如果当前节点是第一个节点并且<code>spins</code>不为0，那么就减少<code>spins</code>的值，并调用<code>Thread.onSpinWait()</code>方法进行自旋等待，这是一种轻量级的等待方式，相比于阻塞等待，它可以在等待时间较短的情况下减少线程切换的开销。如果当前节点的状态是0，那么就将其状态设置为等待状态。如果当前节点的状态不是0，那么就会更新<code>spins</code>和<code>postSpins</code>的值，并根据是否是定时等待来决定是调用<code>LockSupport.park(this)</code>方法使线程进入阻塞等待状态，还是调用<code>LockSupport.parkNanos(this, nanos)</code>方法使线程进入定时阻塞等待状态。如果等待时间已经过去，那么就跳出循环。然后，清除节点状态。最后，如果线程被中断并且是可中断的，那么就跳出循环。</p>
<p>上面就是一个加锁的逻辑</p>
<p>解锁的话从<strong>unlock</strong>方法入手探索，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#AbstractOwnableSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            signalNext(head);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> #Sync</span><br><span class="line"> <span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// 获取当前锁的状态并减少指定的数量</span></span><br><span class="line">    <span class="comment">// 检查当前线程是否是锁的所有者，如果不是，抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> (c == <span class="number">0</span>);  <span class="comment">// 检查是否可以释放锁（锁的状态是否为0）</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">// 如果可以释放锁，将锁的所有者设置为null</span></span><br><span class="line">    setState(c);  <span class="comment">// 更新锁的状态</span></span><br><span class="line">    <span class="keyword">return</span> free;  <span class="comment">// 返回是否成功释放了锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果tryRelease失败的话就执行signalNext方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 检查头节点是否存在，以及头节点的下一个节点是否存在并且其状态不为0</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);  <span class="comment">// 清除下一个节点的等待状态</span></span><br><span class="line">        LockSupport.unpark(s.waiter);  <span class="comment">// 唤醒下一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是唤醒下一个在等待锁的线程。它首先检查头节点（通常是当前占用锁的线程）是否存在，以及头节点的下一个节点（通常是等待锁的下一个线程）是否存在并且其状态不为0。如果满足这些条件，那么它将清除下一个节点的等待状态，并使用<code>LockSupport.unpark(s.waiter)</code>方法唤醒下一个等待的线程。</p>
<h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><p>原理弄清楚了，顺便总结了几点Synchronized和ReentrantLock的区别：</p>
<ol>
<li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>ReentrantLock#isLocked</code>判断；</li>
<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>Synchronized是不可以被中断的，而<code>ReentrantLock#lockInterruptibly</code>方法是可以被中断的；</li>
<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说），而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>锁实现机制</td>
<td>对象头监视器模式</td>
<td>依赖 AQS</td>
</tr>
<tr>
<td>灵活性</td>
<td>不灵活</td>
<td>支持响应中断、超时、尝试获取锁</td>
</tr>
<tr>
<td>释放锁形式</td>
<td>自动释放锁</td>
<td>显示调用 unlock()</td>
</tr>
<tr>
<td>支持锁类型</td>
<td>非公平锁</td>
<td>公平锁 &amp; 非公平锁</td>
</tr>
<tr>
<td>条件队列</td>
<td>单条件队列</td>
<td>多个条件队列</td>
</tr>
<tr>
<td>是否支持可重入</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>参考连接：</p>
<p><a href="https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23">https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23</a></p>
<p><a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
<p><a href="https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA">https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA</a></p>
<p><a href="https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA">https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA</a></p>
<p><a href="https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2023/12/15/view%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Android-view-绘制流程"><a href="#Android-view-绘制流程" class="headerlink" title="Android view 绘制流程"></a>Android view 绘制流程</h1><h2 id="布局加载过程"><a href="#布局加载过程" class="headerlink" title="布局加载过程"></a>布局加载过程</h2><ul>
<li><p>我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">  		<span class="comment">// 这里调用了PhoneWindow的setContentView方法</span></span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;  </span><br><span class="line">                mDecor = generateDecor();  </span><br><span class="line">                mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">                mDecor.setIsRootNamespace(<span class="literal">true</span>);  </span><br><span class="line">                <span class="comment">//...  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;  </span><br><span class="line">              	<span class="comment">// 这里引入R.layout.screen_simple add到了DecorView上 并将R.id.content传递给mContentParent 可以看下面的源码部分</span></span><br><span class="line">                mContentParent = generateLayout(mDecor);  </span><br><span class="line">                mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">                <span class="keyword">if</span> (mTitleView != <span class="literal">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//根据FEATURE_NO_TITLE隐藏，或者设置mTitleView的值  </span></span><br><span class="line">                    <span class="comment">//...  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);  </span><br><span class="line">                    <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">//设置ActionBar标题、图标神马的；根据FEATURE初始化Actionbar的一些显示  </span></span><br><span class="line">                        <span class="comment">//...  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 先是一系列的属性设置贴了一些平时常用的</span></span><br><span class="line">    <span class="comment">// 取消标题栏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="literal">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置全屏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="literal">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    <span class="comment">// 一系列的窗口属性设置</span></span><br><span class="line">    <span class="comment">// 如：SDK 31 新增的高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowBlurBehindEnabled, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getForcedWindowFlags() &amp; WindowManager.LayoutParams.FLAG_BLUR_BEHIND) == <span class="number">0</span>) &#123;</span><br><span class="line">            params.flags |= WindowManager.LayoutParams.FLAG_BLUR_BEHIND;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        params.setBlurBehindRadius(a.getDimensionPixelSize(</span><br><span class="line">                android.R.styleable.Window_windowBlurBehindRadius, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 整体布局文件</span></span><br><span class="line">    <span class="type">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据一系列判断选择 SDK 中的布局一般默认是 R.layout.screen_simple</span></span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载到DecorView上</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到 screen_simple.xml 布局的内容部分 （R.id.content）</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">DecorView:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="type">int</span> layoutResource)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 通过 LayoutInflater 将 screen_simple.xml 解析成 View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 addView 将 root 添加到 DecorView 上</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前最终的布局层次</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
</li>
</ul>
<p>此时只是完成了基础的activity的DecirView的初始化 我们实现的布局还没有解析到布局上</p>
<p>回头看setContentView()方法，目前上面的部分实现了installDecor()，也就是初始化完成了DecorView 并解析了R.layout.screen_simple到上面，并将里面的FrameLayout（R.id.content）的引用传递出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">    	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">      installDecor();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      mContentParent.removeAllViews();  </span><br><span class="line">  &#125;  </span><br><span class="line">		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">  mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">  <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">      cb.onContentChanged();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面就是解析自己的布局过程，就是下面这行代码开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br></pre></td></tr></table></figure>

<p>往下挖源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater:	</span><br><span class="line">	<span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">    <span class="comment">// 如果开启了调试模式，打印日志，显示正在从哪个资源文件加载视图</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">              + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line">    <span class="comment">// 尝试从预编译的资源中加载视图，如果成功则返回视图 </span></span><br><span class="line">    <span class="comment">// 目前这个方法被禁用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取XML资源解析器</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用解析器，根据root和attachToRoot参数来加载视图</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后关闭解析器</span></span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用同步块，确保多线程环境下的安全性</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// 开始性能追踪，用于调试和性能优化</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上下文和属性集</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root; <span class="comment">// root 赋值给 result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果根视图不为空并且根视图的 ViewRootImpl 不为空，通知渲染器进行昂贵帧的处理</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将解析器推进到第一个START_TAG 也就是根View</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 拿到根 View 名字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点是 &lt;merge&gt;，则需要合并布局</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果根视图为空或者不需要附加到根视图，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行合并布局</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 根据标签创建视图</span></span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图为空且 temp 不为空 且 temp 的 ViewRootImpl 不为空，通知渲染器处理昂贵帧</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span> &amp;&amp; temp.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 布局参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图不为空，则生成根视图的布局参数</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Creating params from root: &quot;</span> + root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初始化布局参数</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要附加到根视图，则设置布局参数给 temp</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; start inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; done inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将创建的根 View 添加到 root 也就是 mContentParent 中</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回传入的根视图还是在 XML 中找到的顶层视图</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="comment">// XML 解析异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                    getParserStateDescription(inflaterContext, attrs)</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要保留对上下文的静态引用</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束性能追踪</span></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">     View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果标签名为 &quot;view&quot;，则尝试获取 &quot;class&quot; 属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不忽略主题属性，则尝试应用主题包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="comment">// 从属性中获取主题信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果主题资源 ID 不为 0，则使用 ContextThemeWrapper 包装上下文</span></span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试直接创建视图  </span></span><br><span class="line">      	<span class="comment">// 这里是使用Factory2创建view </span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">				</span><br><span class="line">       <span class="comment">// 如果创建失败进入 if</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果直接创建失败，则尝试通过其他方式创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 表示 sdk 中的 View (Text、Button...)</span></span><br><span class="line">                    view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 表示自定义 View 或者 support 包中的 View (androidx.appcompat.widget.AppCompatButton...)</span></span><br><span class="line">                    view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 InflateException，则直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ClassNotFoundException，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果是其他异常，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结上述源码：</p>
<p>LayoutInflater::inflate 开启了布局解析，<code>XmlResourceParser parser = res.getLayout(resource);</code>获取了布局解析器，然后<code>inflate(parser, root, attachToRoot);</code> 进入了具体的解析流程。从<code>final View temp = createViewFromTag(root, name, inflaterContext, attrs);</code>进入createViewFromTag方法，然后走下如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">           mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                   view = onCreateView(context, parent, name, attrs);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>tryCreateView是尝试创建view，看看具体代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很简单就是通过mFactory2&#x2F;mFactory来创建view。</p>
<p>其中Activity的父类AppCompatActivity中的构造方法中会执行一个initDelegate()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 添加上下文可用监听器</span></span><br><span class="line">    addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AppCompatDelegate 实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">            <span class="comment">// 安装视图工厂 这里开启了Factory</span></span><br><span class="line">            delegate.installViewFactory();</span><br><span class="line">            <span class="comment">// 调用 AppCompatDelegate 的 onCreate 方法，并传入从 SavedStateRegistry 恢复的状态</span></span><br><span class="line">            delegate.onCreate(getSavedStateRegistry()</span><br><span class="line">                    .consumeRestoredStateForKey(DELEGATE_TAG));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDelegateImpl:</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 这里setFactory2 将this也就是AppCompatDelegateImpl</span></span><br><span class="line">            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                        + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码走完又可以回到这部分了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view;</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用的onCreateView方法的实现应该是在AppCompatDelegateImpl中，看下具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 AppCompatViewInflater 为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mAppCompatViewInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewInflaterClassName</span> <span class="operator">=</span></span><br><span class="line">                a.getString(R.styleable.AppCompatTheme_viewInflaterClass);</span><br><span class="line">        <span class="keyword">if</span> (viewInflaterClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未指定自定义的 ViewInflater 类名，使用默认的 AppCompatViewInflater</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用反射加载自定义的 ViewInflater 类</span></span><br><span class="line">                Class&lt;?&gt; viewInflaterClass =</span><br><span class="line">                        mContext.getClassLoader().loadClass(viewInflaterClassName);</span><br><span class="line">                mAppCompatViewInflater =</span><br><span class="line">                        (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor()</span><br><span class="line">                                .newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 加载失败时，使用默认的 AppCompatViewInflater，并打印错误日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Failed to instantiate custom view inflater &quot;</span></span><br><span class="line">                        + viewInflaterClassName + <span class="string">&quot;. Falling back to default.&quot;</span>, t);</span><br><span class="line">                mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承上下文，用于处理 &lt;include&gt; 标签的情况</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inheritContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (IS_PRE_LOLLIPOP) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 5.0 之前的版本，处理 &lt;include&gt; 标签的继承上下文情况</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector == <span class="literal">null</span>) &#123;</span><br><span class="line">            mLayoutIncludeDetector = <span class="keyword">new</span> <span class="title class_">LayoutIncludeDetector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector.detect(attrs)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前视图是 &lt;include&gt; 的根视图，则继承上下文</span></span><br><span class="line">            inheritContext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 &lt;include&gt; 标签，根据深度或者使用旧的启发式方法来判断是否继承上下文</span></span><br><span class="line">            inheritContext = (attrs <span class="keyword">instanceof</span> XmlPullParser)</span><br><span class="line">                    ? ((XmlPullParser) attrs).getDepth() &gt; <span class="number">1</span></span><br><span class="line">                    : shouldInheritContext((ViewParent) parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AppCompatViewInflater 的 createView 方法创建视图</span></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* 只在 Android 5.0 之前读取 android:theme 属性 */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* 无论何时都读取 app:theme 属性作为后备，基于传统原因 */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* 只有在启用时对上下文进行着色处理 */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又走到了createView方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">originalContext</span> <span class="operator">=</span> context;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can emulate Lollipop&#x27;s android:theme attribute propagating down the view hierarchy</span></span><br><span class="line">      <span class="comment">// by using the parent&#x27;s context</span></span><br><span class="line">      <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">          context = parent.getContext();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">          <span class="comment">// We then apply the theme on the context, if specified</span></span><br><span class="line">          context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">          context = TintContextWrapper.wrap(context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We need to &#x27;inject&#x27; our tint aware Views in place of the standard framework versions</span></span><br><span class="line">      <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">              view = createTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">              view = createImageView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">              view = createButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">              view = createEditText(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">              view = createSpinner(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">              view = createImageButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">              view = createCheckBox(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">              view = createRadioButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">              view = createCheckedTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">              view = createRatingBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">              view = createSeekBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ToggleButton&quot;</span>:</span><br><span class="line">              view = createToggleButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">              <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">              <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">              <span class="comment">// later in this method.</span></span><br><span class="line">              view = createView(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">          <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">          <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">          view = createViewFromTag(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">          checkOnClickListener(view, attrs);</span><br><span class="line">          backportAccessibilityAttributes(context, view, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总结上面：AppCompatActivity 默认设置了 Factory2，并且其实现创建 View 是直接通过 new 的方式，并没有使用反射。</p>
<p>上面一节有个方法需要注意下，就是布局的子view是如果添加到根view的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/LayoutInflater.java</span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    				...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">								</span><br><span class="line">						...</span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数的深度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 逐个 View 解析</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:focusable=&quot;true&quot;, 获取View的焦点</span></span><br><span class="line">            pendingRequestFocus = <span class="literal">true</span>;</span><br><span class="line">            consumeChildElements(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:tag标签</span></span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析include标签，include标签不能作为根布局</span></span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;include /&gt; cannot be the root element&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, context, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// merge标签必须作为根布局</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; must be the root element&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据元素名解析，生成View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 添加解析的View</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果finishInflate为true，则调用onFinishInflate方法</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为AppCompatActivity 默认设置了 Factory2，且Factory2只能设置一次，如果activity集成了AppCompatActivity那么只能通过反射设置Factory2了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory2</span><span class="params">(Factory2 factory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Given factory can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> <span class="title class_">FactoryMerger</span>(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射将mFactorySet重新设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//上面提到过：Android布局加载器使用mFactorySet标记是否设置过Factory，如设置过抛出一次</span></span><br><span class="line">  <span class="comment">//所以需要通过反射设置mFactorySet为false</span></span><br><span class="line">  <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LayoutInflater.class.getDeclaredField(<span class="string">&quot;mFactorySet&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用factory2设置布局加载工厂</span></span><br><span class="line"><span class="type">SkinLayoutInflaterFactory</span> <span class="variable">skinLayoutInflaterFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkinLayoutInflaterFactory</span></span><br><span class="line">  (activity);</span><br><span class="line">LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>

<p><strong>setContentView总结：</strong></p>
<p>在<code>Activity</code>实例创建好并且执行<code>attach()</code>方法的时候，会为<code>Activity</code>创建一个<code>PhoneWindow</code>，接下来就到了<code>onCreate()</code>的生命周期，在调用<code>setContentView()</code>的时候，如果还没有初始化<code>ContentParent</code>，说明是第一次进行<code>setContentView()</code>，那么就会初始化<code>DecorView</code>，还会给<code>DecorView</code>添加一个系统页面样式的<code>子View(R.layout.screen_simple)</code>，那么在系统样式的<code>ViewGroup</code>中，就可以通过<code>id</code>找到用来加载自定义布局的<code>ContentParent</code>，再通过<code>inflate</code>就可以将我们自己写的<code>xml</code>文件<code>(R.layout.main)</code>转化为一颗<code>ViewTree</code>了，这颗<code>ViewTree</code>就在<code>ContentParent</code>里面。</p>
<p>所以<code>setContentView()</code>的作用最终可以总结为：</p>
<ul>
<li><strong>创建<code>DecorView</code></strong></li>
<li><strong>创建<code>ContentParent</code></strong></li>
<li><strong>自定义布局转化为<code>ViewTree</code>，放在<code>ContentParent</code>中</strong></li>
</ul>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA">https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA</a><br><a href="https://www.jianshu.com/p/5a71014e7b1b">https://www.jianshu.com/p/5a71014e7b1b</a></p>
<p><a href="https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11">https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11</a></p>
<p><a href="https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff">https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff</a><br><a href="https://www.jianshu.com/p/8e554406bd15">https://www.jianshu.com/p/8e554406bd15</a></p>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>上面布局解析完之后还不可见，在activity处于<code>onResume()</code>生命周期时才会展示布局。</p>
<p><code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中执行的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isForward, <span class="type">boolean</span> shouldSendCompatFakeFocus, String reason)</span> &#123;</span><br><span class="line">      	...</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">// 这里的decor就是上面setContentView加载的DecorView</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">          	<span class="comment">// 每一个Activity都会对应一个WindowManager对象（Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象）</span></span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">            WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 将DecorView add进WindowManager中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">						。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>wm.addView</code>最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法。这个方法中会调用<code>requestLayout()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 将布局请求安排到消息队列中，以便在下一个消息循环中执行。</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 获取 Looper 并创建同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">          	<span class="comment">// 在 Choreographer 中调度遍历的回调</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这里的mTraversalRunnable是个Runnable对象</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 到这里终于看到了绘制的起点了</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>onResume 总结：</strong></p>
<p>在<code>onResume()</code>中会调用<code>WindowManager</code>中的<code>addView()</code>添加<code>DecorView</code>，当<code>WindowManager</code>管理<code>ViewTree</code>的时候会给<code>ViewTree</code>分配一个<code>ViewRootImpl</code>，<code>ViewRootImpl</code>的第一个作用就是管理<code>ViewTree</code>的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个<code>Activity</code>的情况下，每个<code>Activity</code>都有自己的<code>PhoneWindow</code>、<code>DecorView</code>以及<code>WindowManagerImpl</code>，<code>WindowManagerGlobal</code>持有每个<code>Activity</code>的<code>RootView</code>，<code>mWindowSession</code>和<code>mWindow</code>是用来和<code>WMS</code>进行双向通信的。</p>
<p>看一下performTraversals的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123; </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRootMeasureSpec</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">int</span> rootDimension)</span> &#123; </span><br><span class="line">   <span class="type">int</span> measureSpec; </span><br><span class="line">   <span class="keyword">switch</span> (rootDimension) &#123; </span><br><span class="line">   <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT: </span><br><span class="line">   <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.   </span></span><br><span class="line">   measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY);</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   ...... </span><br><span class="line">  &#125; </span><br><span class="line"> <span class="keyword">return</span> measureSpec; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView是一个FrameLayout下面会直接进入FrameLayout的measure方法，参数就是上面生成的childWidthMeasureSpec和childHeightMeasureSpec。</p>
<h3 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h3><ul>
<li><p><strong>MeasureSpec 的理解</strong></p>
<p>MeasureSpec是一个32位的int值，用于描述View的大小和模式。它的高2位表示模式（mode），低30位表示大小（size）MeasureSpec有三种模式：</p>
<ol>
<li><p>精确模式（<strong>MeasureSpec.EXACTLY</strong>）：在这种模式下，View的大小已经确定，为SpecSize所指定的值。例如，当我们将控件的layout_width或layout_height指定为具体数值或者为<strong>MATCH_PARENT</strong>时，都是控件大小已经确定的情况，都是精确尺寸</p>
</li>
<li><p>最大模式（<strong>MeasureSpec.AT_MOST</strong>）：在这种模式下，父控件给出的是最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。例如，当控件的layout_width或layout_height指定为<strong>WRAP_CONTENT</strong>时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。</p>
</li>
<li><p>未指定模式（<strong>MeasureSpec.UNSPECIFIED</strong>）：在这种模式下，父控件不会干涉子View想要多大的尺寸，子View可以随意使用空间，不受限制。例如，在ScrollView或NestedScrollView中，子View的测量模式可能会被设置为MeasureSpec.UNSPECIFIED，这样子View就可以根据自己的内容来决定自己的大小。</p>
</li>
</ol>
</li>
</ul>
<p><strong>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求</strong></p>
<ul>
<li><p><strong>mode的值</strong></p>
<p>-<strong>2147483648</strong>   对应的二进制表示是 <code>0b10000000000000000000000000011000</code>。在这个二进制中，最低的两位 <code>00</code> 表示测量模式为 <code>AT_MOST</code>。 </p>
<p><strong>1073742099</strong> 对应的二进制表示是 <code>0b10000000000000000000000100100011</code>。在这个二进制中，最低的两位 <code>11</code> 表示测量模式为 <code>EXACTLY</code>。</p>
</li>
<li><p><strong>ViewGroup的Measure</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed, <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，你在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>以LinearLayout为例 解析Measure过程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先分析下Android View 的结构：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>我们写的布局最终会add到上面图片的FrameLayout中。</p>
<p>然后开始FrameLayout的measure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;  </span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>measureChildWithMargins的源码就是上面的ViewGroup的Measure的代码。</p>
<p>上面的performTraversals方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br></pre></td></tr></table></figure>

<p>再结合view视图层次DecorView的下一级是ViewRoot这是个LinearLayout。ViewRoot 是系统的View，它的LayoutParams默认都是match_parent。</p>
<p>根据上面的计算规则：</p>
<p>ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size。</p>
<p><strong>目前ViewRoot的measure方法的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。</strong></p>
<p>measure方法会调用onMeasure方法开启计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinearLayout：</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewRoot的子view有两个ViewStub和id.content.</p>
<p>调用ViewRoot.measure后会调用，LinearLayout 的onMeasure 方法开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用。</p>
<p>根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿<strong>ViewRoot 的MeasureSpec</strong> 和 <strong>android.R.id.content的LayoutParams</strong> 做计算了，计算过程就是调用getChildMeasureSpec的方法。</p>
<p>来看下计算过程，首先ViewRoot.measure的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。content的width和height都是matchparent。那么看下getChildMeasureSpec方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 只看这个分支</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// 根据条件走到这个分支</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 后传递给content的Measure方法</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>id&#x2F;content是个FrameLayout然后又开启了新的计算流程。</p>
<p>这个计算流程就开始计算我们自己写的布局了，再看下原布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先应该是先计算最外面的LinearLayout，根据规则LinearLayout的measure(int widthMeasureSpec, int heightMeasureSpec)的两个MeasureSpec的mode都应该是<strong>EXACTLY</strong></p>
<p>然后开启LinearLayout的onMeasure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后根据LinearLayout的measure结合TextView的LayoutParams计算得到传递给TextView的MeasureSpaec。</p>
<p>这里看看LinearLayout的measure的源码，因为orientation&#x3D;”vertical”所以会走measureVertical(widthMeasureSpec, heightMeasureSpec);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>; <span class="comment">// 总高度，子控件累加总高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大子控件的宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子view测量状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">alternativeMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 没有设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weightedMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allFillParent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 子控件全设置match_parent</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子控件累加总权重（子控件设置了layout_weight）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();<span class="comment">// 子控件总数量</span></span><br><span class="line"><span class="comment">// 这里获取了LinearLayout的Mode</span></span><br><span class="line">  	<span class="comment">// 根据上面分析widthMode都是EXACTLY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matchWidth</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 有子View宽度设置为match_parent</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skippedMeasure</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否跳过重新测量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">baselineChildIndex</span> <span class="operator">=</span> mBaselineAlignedChildIndex; <span class="comment">// 基线子view</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 跟setMeasureWithLargestChildEnabled()有关</span></span><br><span class="line">		<span class="comment">// 当设定为true，所有有设定了weight的子View的最小高度是：最大的View的高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useLargestChild</span> <span class="operator">=</span> mUseLargestChild;</span><br><span class="line"><span class="comment">// 最大子控件的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestChildHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">consumedExcessSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 需要测量的子View总数，不需要测量指的是设定了weight</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nonSkippedChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子view数量开启循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 测量view为null占据的高度，默认返回0</span></span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonSkippedChildCount++;</span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取当前子view的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 处理 weight</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 判断当前子view的height == 0 且 weight &gt; 0  </span></span><br><span class="line">      	<span class="comment">// 根据布局来看 useExcessSpace应该为false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useExcessSpace</span> <span class="operator">=</span> lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 子View的高度是具体的，可以这直接算出来，不需算子View的高度</span></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="literal">true</span>; <span class="comment">// 该子View直接忽略二次计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// useExcessSpace 为false  无法精确计算子View</span></span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">              <span class="comment">// 假设为true的话 让子view的height为WRAP_CONTENT</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">				<span class="comment">// 判断Weight的值，为0则usedHeight为mTotalLength  mTotalLength表示目前为止已经测量过的子视图的总高度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">usedHeight</span> <span class="operator">=</span> totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">          	<span class="comment">// 开始走getChildMeasureSpec流程。 这里是获取TextView的MeasureSpec 然后走它的onMeasure方法</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line">				<span class="comment">// 获取child的高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">          	<span class="comment">// 获取总共的长度 </span></span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                    + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                    + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="literal">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span> lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 底部是否有分割线，计算最高高度</span></span><br><span class="line">    <span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置了 measureWithLargestChild 且 总高度无法确定，需要重新计算 mToatalLength</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 添加padding</span></span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查最小高度</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据heightMeasureSpec计算最后结果，heightSizeAndState存储最终的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSizeAndState</span> <span class="operator">=</span> resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingExcess</span> <span class="operator">=</span> heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 简单来说就是 skippedMeasure为true说明之前的测量被跳过了需要重新测量</span></span><br><span class="line">  	<span class="comment">// 或者使用了Weight属性 要启动二次测量</span></span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">            || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">      	<span class="comment">// 计算总的weight，mWidgetSum是外部设定，totalWeight是首次计算出来的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">remainingWeightSum</span> <span class="operator">=</span> mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">childWeight</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 计算分配的值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> (<span class="type">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">              	<span class="comment">// 剩余分配高度</span></span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">              	<span class="comment">// 剩余比重总和</span></span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                  	<span class="comment">// 子View直接是largestChildHeight</span></span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// 子view是没有height，直接为分配高度</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子View有height，另外还要加上分配的高度</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">              	<span class="comment">// 重新测量子View</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span>  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">          	<span class="comment">// 计算子View的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span></span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">childExtra</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LinearLayout的onMeasure中的child.measure启动了TextView的onMeasure():</p>
<p>源码就不展示了，大概就是根据传入的获取MeasureSpec计算自己的宽度和高度，然后通过setMeasuredDimension方法将获取的值赋值给mMeasuredWidth和mMeasuredHeight。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个值就是layout进行定位的值。</p>
<h3 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h3><p>回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>

<p>measure执行完之后就该执行layout了，mView.getMeasuredWidth()和mView.getMeasuredHeight()就是上个阶段计算得到的值。</p>
<p>还是先看FrameLayout的layout干了啥</p>
<p>FrameLayout没有自己实现layout函数，得看ViewGroup里的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没啥东西，还是得看super.layout(l, t, r, b);的实现，也就是View中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      .....</span><br><span class="line">     <span class="comment">//设置View位于父视图的坐标轴  主要是初始化了四个值  mLeft  mTop  mRight mBottom</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> setFrame(l, t, r, b); </span><br><span class="line">      <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">              ViewDebug.trace(<span class="built_in">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line">          mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">      mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在View中onLayout是空实现，所以回到FrameLayout中看具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> childLeft;</span><br><span class="line">                <span class="type">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                        <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// layout(int l, int t, int r, int b)</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是根据规则获取了child的childLeft和childTop,然后启动child的layout函数。</p>
<p>这里看一下view的坐标系</p>
<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/cc5c57e82f5346e0ad194f914edd0e5d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png" style="zoom: 50%;" />

<p>left和top坐标确定了view左上角的位置，right和bottom坐标确定了右下角的位置。</p>
<p>right - left 为view的宽(width)  bottom - top 为view的高(height)。</p>
<p>Layout流程就这些没啥好说的。</p>
<h3 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h3><p>再回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br></pre></td></tr></table></figure>

<p>FrameLayout和ViewGroup都没有重写draw方法，所以我们看下View中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         *      7. If necessary, draw the default focus highlight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="type">int</span> saveCount;</span><br><span class="line">				<span class="comment">// 绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShowingLayoutBounds()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;re done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程用这张图片概括一下，循环的入口是draw方法。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/webp-20231215160503207" alt="img"></p>
<h1 id="Android-View事件分发"><a href="#Android-View事件分发" class="headerlink" title="Android View事件分发"></a>Android View事件分发</h1><h2 id="分发的事件是什么"><a href="#分发的事件是什么" class="headerlink" title="分发的事件是什么"></a>分发的事件是什么</h2><p>我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的。根据不同动作，主要有以下三种事件类型：<br>1.ACTION_DOWN：<strong>手指刚接触屏幕，按下去的那一瞬间产生该事件</strong><br>2.ACTION_MOVE：<strong>手指在屏幕上移动时候产生该事件</strong><br>3.ACTION_UP：<strong>手指从屏幕上松开的瞬间产生该事件</strong></p>
<p><strong>从ACTION_DOWN开始到ACTION_UP结束我们称为一个事件序列</strong></p>
<p>正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在MotionEvent上来讲无外乎下面两种。<br><strong>1.点击后抬起，也就是单击操作：ACTION_DOWN -&gt; ACTION_UP<br>2.点击后再风骚的滑动一段距离，再抬起：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP</strong></p>
<h2 id="MotionEvent事件分发的三个方法"><a href="#MotionEvent事件分发的三个方法" class="headerlink" title="MotionEvent事件分发的三个方法"></a>MotionEvent事件分发的三个方法</h2><ul>
<li><p><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong><br>通过方法名我们不难猜测，它就是事件分发的重要方法。那么很明显，如果一个MotionEvent传递给了View，那么dispatchTouchEvent方法一定会被调用！<br>返回值：表示是否消费了当前事件。可能是View本身的onTouchEvent方法消费，也可能是子View的dispatchTouchEvent方法中消费。返回true表示事件被消费，本次的事件终止。返回false表示View以及子View均没有消费事件，将调用父View的onTouchEvent方法</p>
</li>
<li><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong><br>事件拦截，当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。特别注意，这是ViewGroup特有的方法，View并没有拦截方法<br>返回值：是否拦截事件传递，返回true表示拦截了事件，那么事件将不再向下分发而是调用View本身的onTouchEvent方法。返回false表示不做拦截，事件将向下分发到子View的dispatchTouchEvent方法。</p>
</li>
<li><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong><br>真正对MotionEvent进行处理或者说消费的方法。在dispatchTouchEvent进行调用。<br>返回值：返回true表示事件被消费，本次的事件终止。返回false表示事件没有被消费，将调用父View的onTouchEvent方法</p>
</li>
</ul>
<p>上面的三个方法可以用以下的伪代码来表示其之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//事件是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev))&#123;<span class="comment">//调用onInterceptTouchEvent判断是否拦截事件</span></span><br><span class="line">        consume = onTouchEvent(ev);<span class="comment">//如果拦截则调用自身的onTouchEvent方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);<span class="comment">//不拦截调用子View的dispatchTouchEvent方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;<span class="comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件分发的具体流程"><a href="#事件分发的具体流程" class="headerlink" title="事件分发的具体流程"></a>事件分发的具体流程</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。那么很明显我们先看Activity的dispatchTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Activity：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getWindow().superDispatchTouchEvent(ev)方法发现是Window类当中的一个抽象方法，Window的唯一实现类是PhoneWindow。那么去看PhoneWindow对应的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneWindow</span></span><br><span class="line">    <span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line">    <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个DecorView就是Window的顶级View，我们通过setContentView设置的View是它的子View，</strong>到这里事件已经被传递到我们的顶级View中，一般是ViewGroup。</p>
<p>看看ViewGroup的dispatchTouchEvent方法实现，代码比较多先看下判断是否拦截事件的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// 在开始新的触摸手势时，丢弃所有以前的状态。由于应用切换、ANR 或其他一些状态更改，框架可能已删除上一个手势的 up 或 cancel 事件。</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里会执行 mFirstTouchTarget = null;  mFirstTouchTarget是用来承载处理事件的子View对象，这个对象非常重要，它决定了ViewGroup是否拦截事件</span></span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否拦截事件的标志位</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">    	   <span class="comment">// 判断是否是ACTION_DOWN事件和mFirstTouchTarget是否为null，如果是ACTION_DOWN事件说明是一个新的事件或者mFirstTouchTarget不为null说明有处理事件的子View，会然后会判断子view是否调用了requestDisallowInterceptTouchEvent方法来禁止ViewGroup拦截，判断通过后会调用onInterceptTouchEvent方法来判断最终是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查触摸事件是否来自鼠标设备</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            <span class="comment">// 检查触摸事件的动作是否为按下（ACTION_DOWN）</span></span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            <span class="comment">// 检查是否按下了主要的鼠标按钮</span></span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            <span class="comment">// 调用isOnScrollbarThumb方法检查是否在滚动条拇指上</span></span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getXDispatchLocation(<span class="number">0</span>), ev.getYDispatchLocation(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">// 如果上述条件都为真，表示需要拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件有一个为假，表示不需要拦截该事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码，通过判断actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN和 mFirstTouchTarget !&#x3D; null判断是否拦截，这里有一点要注意的是，根据逻辑 <strong>如果ViewGroup没有拦截ACTION_DOWN事件的话说明这组事件会有子view处理，所以mFirstTouchTarget 不会为null。否则的话mFirstTouchTarget 为null且不是ACTION_DOWN事件说明之前拦截了ACTION_DOWN事件，则后面的事件直接拦截。</strong></p>
<p><strong>mFirstTouchTarget 是否有值决定了ViewGroup是否拦截ACTION_DOWN以外的事件</strong></p>
<p>假设这里不拦截的话，看后续的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="comment">//对子View进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断1，View可见并且没有播放动画。2，点击事件的坐标落在View的范围内</span></span><br><span class="line">            <span class="comment">//如果上述两个条件有一项不满足则continue继续循环下一个View</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 走到这里说明找到了满足的子View了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里会判断mFirstTouchTarget，因为目前还未将事件传递给子view所以还是null 返回的也会是null</span></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="comment">//如果有子View处理即newTouchTarget 不为null则跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">//dispatchTransformedTouchEvent第三个参数child这里不为null，实际调用的是child的dispatchTouchEvent方法，具体实现可以看下面。 重点方法</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX = ev.getX();</span><br><span class="line">                mLastTouchDownY = ev.getY();</span><br><span class="line">                <span class="comment">//当child处理了点击事件，那么会设置mFirstTouchTarget 在addTouchTarget被赋值，具体实现看下面</span></span><br><span class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//子View处理了事件，然后就跳出了for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     ......</span><br><span class="line">         <span class="comment">// 如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false） </span></span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true，子View为GroupView的话会重复上面的逻辑，不是的话会直接走View的dispatchTouchEvent方法。</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">     	<span class="comment">// 这里给mFirstTouchTarget赋值了，也就是上面说的是否处理了事件看mFirstTouchTarget是否为null</span></span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示ViewGroup进行事件传递的逻辑，在dispatchTransformedTouchEvent中会判断子View是否消费了事件，如果消费了会给mFirstTouchTarget赋值否则mFirstTouchTarget仍为null。</p>
<p>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）。会再次调用dispatchTransformedTouchEvent方法，且传入得child为null。</p>
<p>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">           handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">           handled = child.dispatchTouchEvent(event);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>目前为止ViewGroup的事件处理逻辑分析完了。</p>
<p><strong>结论</strong>：</p>
<blockquote>
<p><strong>ViewGroup会遍历所有子View去寻找能够处理点击事件的子View（可见，没有播放动画，点击事件坐标落在子View内部）最终调用子View的dispatchTouchEvent方法处理事件</strong></p>
</blockquote>
<blockquote>
<p><strong>当子View处理了事件则mFirstTouchTarget 被赋值，并终止子View的遍历。</strong></p>
</blockquote>
<blockquote>
<p><strong>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）那么ViewGroup会去处理这个事件（本质调用View的dispatchTouchEvent去处理）</strong></p>
</blockquote>
<p>如果ViewGrop处理这个事件的话会调用View的dispatchTouchEvent。如果不是ViewGroup处理事件，而是普通的View处理事件的话会直接调用View的dispatchTouchEvent方法。</p>
<p>所以最终都会走到View的dispatchTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">//如果窗口没有被遮盖</span></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            <span class="comment">//当前监听事件</span></span><br><span class="line">            <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">            <span class="comment">//需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件,如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//result为false调用自己的onTouchEvent方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View会先判断是否设置了OnTouchListener，<strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong> <strong>且当前View的dispatchTouchEvent方法就会返回false。</strong><br>当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    ... </span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span></span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p><strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>加一个知识点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">            setLongClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>View的setOnClickListener会默认将View的clickable设置成true。<br>View的setOnLongClickListener同样会将View的longClickable设置成true。</strong></p>
<p><strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong>这里的View的dispatchTouchEvent就会返回false，也就是dispatchTransformedTouchEvent方法会返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的<strong>dispatchTouchEvent是View嵌套调用的</strong>，所以最终的结果会由View层回调到Window层中，看一下原来的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值又会返回到Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个事件循环结束了循环</p>
<p>面试回答的时候为了逻辑清晰，可以定义一个只有一个ViewGroup和View的传递链</p>
<p>Activity - Window - GroupView - View</p>
<p>事件由Activity 开始传递，依次到Window 然后到了GroupView 再到View，事件传递主要的逻辑就是GroupView层和 View层，</p>
<p>首先事件会走到Activity 的dispatchTouchEvent方法，里面会调用Window的superDispatchTouchEvent方法去处理事件。</p>
<p>如果Window没有处理了事件会调用Activity的onTouchEvent方法去消费事件。再Window传递到ViewGroup和ViewGroup传递到View的过程中同样如此，会尝试调用自己的onTouchEvent方法去消费事件。</p>
<p>回单原来的逻辑，目前事件传递到了Window层，Window的superDispatchTouchEvent方法中会调用DecorView的事件分发方法。DecorView就是个FrameLayout，所以事件到了Viewgroup层。</p>
<p>Viewgroup的dispatchTouchEvent方法的逻辑，首先逻辑开始会判断要不要拦截当前事件，判断是否拦截会有两个判断条件。一个是当前的action事件是否为down事件，还有一个就是子View是否处理了事件的标志位。</p>
<p>这里如果是down事件或者标志位不等于null就会调用onInterceptTouchEvent方法判断是否拦截。这里调用onInterceptTouchEvent之前还会有一个标志位的判断，这个标志位是子View通过requestDisallowInterceptTouchEvent来通知父View的。</p>
<p>如果不是down事件且子View是否处理了事件的标志位为null说明之前的down事件被ViewGroup拦截了，所以后面move和up事件都会被拦截。</p>
<p>如果判断不拦截的话就会调用子View的dispatchTouchEvent方法，也就是View类中定义的逻辑。</p>
<p>这个方法首先会判断当前View是否设置了OnTouchListener监听，如果设置了监听且onTouch方法返回了true，那么onTouchEvent不会被调用。如果返回false的话会接着调用onTouchEvent方法。</p>
<p>这个方法会判断clickable和longClickable，只要有一个是true就会消费事件，然后会通过switch case判断事件的类型，再up case中会调用当前view设置的点击事件。</p>
<p>目前一整个事件传递从activity到view消费的这么一个逻辑，其实主要还是再Viewgroup和View传递的逻辑。之前说了View 消费的情况，我下面说一下View不消费的情况。</p>
<p>View不消费的话ViewGroup同样会走View类的dispatchTouchEvent方法的逻辑，然后调用onTouchEvent方法。如果onTouchEvent方法返回false的话事件会返回到Window层然后再返回到Activity层，也就是一开始说的逻辑，会调用activity的onTouchEvent方法。</p>
<h1 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h1><h2 id="自定义-View实现方式"><a href="#自定义-View实现方式" class="headerlink" title="自定义 View实现方式"></a>自定义 View实现方式</h2><p>总结下来有三种：</p>
<ul>
<li>继承某个控件，然后对它的一些功能进行修改，或者删除添加</li>
<li>将多个控件组合在一起形成一个新的View</li>
<li>继承 View &#x2F; ViewGroup 类，重写 <strong><code>onMeasure()</code><strong>、</strong><code>onLayout()</code><strong>、</strong><code>onDraw()</code></strong> 三大方法，从 0 到 1 创造一个新的控件。</li>
</ul>
<p>代码示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaterialEdit</span>(context: Context,attrs:AttributeSet) :</span><br><span class="line">    AppCompatEditText(context,attrs) &#123; <span class="comment">// 定义一个名为 MaterialEdit 的类，继承自 AppCompatEditText</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量和变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_SIZE = <span class="number">12.</span>dp  <span class="comment">// 文本大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_MARGIN = <span class="number">8.</span>dp <span class="comment">// 文本边距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> HORIZONTAL_OFFSET = <span class="number">5.</span>dp <span class="comment">// 水平偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> VERTICAL_OFFSET = <span class="number">23.</span>dp <span class="comment">// 垂直偏移量  浮动标签距离view顶部的向下偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> EXTRA_VERTICAL_OFFSET = <span class="number">16.</span>dp <span class="comment">// 便签动画时的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG) <span class="comment">// 创建一个 Paint 对象，用于绘制文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> floatingLabelShown = <span class="literal">false</span> <span class="comment">// 一个标志，表示浮动标签是否正在显示</span></span><br><span class="line">    <span class="keyword">var</span> useFloatingLabel = <span class="literal">false</span> <span class="comment">// 一个标志，表示是否使用浮动标签</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field != value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                <span class="keyword">if</span> (field) &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop + TEXT_SIZE + TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop - TEXT_SIZE - TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">            <span class="keyword">by</span> lazy &#123;</span><br><span class="line">                ObjectAnimator.ofFloat(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.textSize = TEXT_SIZE <span class="comment">// 设置 Paint 的文本大小</span></span><br><span class="line">        <span class="comment">// 获取自定义属性 useFloatingLabel 的值  会触发 set 方法</span></span><br><span class="line">        <span class="keyword">val</span> typeArray = context.obtainStyledAttributes(attrs,R.styleable.MaterialEdit)</span><br><span class="line">        useFloatingLabel = typeArray.getBoolean(R.styleable.MaterialEdit_useFloatingLabel,<span class="literal">true</span>)</span><br><span class="line">        typeArray.recycle() <span class="comment">// 回收 typeArray</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 EditText 中的文本改变时，执行这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        text: <span class="type">CharSequence</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        start: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthBefore: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthAfter: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮动标签正在显示，且文本变为空，那么隐藏浮动标签</span></span><br><span class="line">        <span class="keyword">if</span> (floatingLabelShown &amp;&amp; text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">false</span></span><br><span class="line">            animator.reverse() <span class="comment">// 执行动画的逆向操作，即隐藏浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果浮动标签没有显示，且文本不为空，那么显示浮动标签</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!floatingLabelShown &amp;&amp; !text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">true</span></span><br><span class="line">            animator.start() <span class="comment">// 开始执行动画，即显示浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个方法中绘制 EditText 的界面</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas) <span class="comment">// 调用父类的 onDraw 方法，绘制 EditText 的主体</span></span><br><span class="line">        paint.alpha = (floatingLabelFraction * <span class="number">0xff</span>).toInt() <span class="comment">// 根据动画的进度，设置 Paint 的透明度</span></span><br><span class="line">        <span class="comment">// 计算当前的垂直位置</span></span><br><span class="line">        <span class="keyword">val</span> currentVerticalValue =</span><br><span class="line">            VERTICAL_OFFSET + EXTRA_VERTICAL_OFFSET * (<span class="number">1</span> - floatingLabelFraction)</span><br><span class="line">        <span class="comment">// 在计算出的位置绘制提示文本</span></span><br><span class="line">        hint?.toString()?.let &#123;</span><br><span class="line">            canvas.drawText(</span><br><span class="line">                it,</span><br><span class="line">                HORIZONTAL_OFFSET,</span><br><span class="line">                currentVerticalValue,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Android-动画"><a href="#Android-动画" class="headerlink" title="Android 动画"></a>Android 动画</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p><strong>帧动画（Frame Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">val frameAnimation = imageView.background as AnimationDrawable</span><br><span class="line">frameAnimation.start()</span><br></pre></td></tr></table></figure>

<p><strong>补间动画（Tween Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">val rotateAnimation = AnimationUtils.loadAnimation(context, R.anim.rotate)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p><strong>属性动画（Property Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">2000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure>

<p><strong>过渡动画（Transition Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup = findViewById(R.id.scene_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> scene1: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene1, context)</span><br><span class="line"><span class="keyword">val</span> scene2: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene2, context)</span><br><span class="line"></span><br><span class="line">TransitionManager.go(scene2, TransitionInflater.from(context).inflateTransition(R.transition.example_transition))</span><br></pre></td></tr></table></figure>

<p><strong>触摸反馈动画（Touch Feedback Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义触摸反馈动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;?android:attr/colorControlHighlight&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/button_normal&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br><span class="line">button.background = ContextCompat.getDrawable(context, R.drawable.ripple)</span><br></pre></td></tr></table></figure>

<p><strong>物理动画（Physics-based Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> springAnimation = SpringAnimation(imageView, DynamicAnimation.ROTATION, <span class="number">0f</span>)</span><br><span class="line">springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW</span><br><span class="line">springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY</span><br><span class="line">springAnimation.start()</span><br></pre></td></tr></table></figure>

<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">   imageView.setBackgroundResource(R.drawable.animation)</span><br><span class="line">   <span class="keyword">val</span> animationDrawable = imageView.background <span class="keyword">as</span> AnimationDrawable</span><br><span class="line">   animationDrawable.start()</span><br></pre></td></tr></table></figure>

<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.ani)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p>补间动画的属性</p>
<p>补间动画（Tween Animation）在 Android 中主要包括四种类型：AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation，它们分别对应透明度、缩放、位移和旋转四种动画效果。</p>
<p>以下是这四种补间动画的主要属性：</p>
<ol>
<li><strong>AlphaAnimation（透明度动画）</strong>：<ul>
<li>fromAlpha：动画开始时视图的透明度（0.0 - 1.0）</li>
<li>toAlpha：动画结束时视图的透明度（0.0 - 1.0）</li>
</ul>
</li>
<li><strong>ScaleAnimation（缩放动画）</strong>：<ul>
<li>fromXScale：动画开始时视图的X轴缩放比例</li>
<li>toXScale：动画结束时视图的X轴缩放比例</li>
<li>fromYScale：动画开始时视图的Y轴缩放比例</li>
<li>toYScale：动画结束时视图的Y轴缩放比例</li>
<li>pivotX：X轴的缩放中心点</li>
<li>pivotY：Y轴的缩放中心点</li>
</ul>
</li>
<li><strong>TranslateAnimation（位移动画）</strong>：<ul>
<li>fromXDelta：动画开始时视图在X轴的位置</li>
<li>toXDelta：动画结束时视图在X轴的位置</li>
<li>fromYDelta：动画开始时视图在Y轴的位置</li>
<li>toYDelta：动画结束时视图在Y轴的位置</li>
</ul>
</li>
<li><strong>RotateAnimation（旋转动画）</strong>：<ul>
<li>fromDegrees：动画开始时视图的旋转角度</li>
<li>toDegrees：动画结束时视图的旋转角度</li>
<li>pivotX：旋转的中心点X坐标</li>
<li>pivotY：旋转的中心点Y坐标</li>
</ul>
</li>
</ol>
<p>以上每种动画类型的属性都可以在 XML 中定义，也可以在代码中动态设置。除了这些特定的属性外，所有的补间动画还有一些共同的属性，例如：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>fillAfter：动画结束后，视图是否保持动画结束时的状态</li>
<li>fillBefore：动画开始前，视图是否保持动画开始时的状态</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatMode：动画的重复模式（重新开始或反向执行）</li>
<li>interpolator：动画的插值器（用于控制动画的速度变化）</li>
</ul>
<p>区域问题</p>
<p>补间动画虽然能对控件做动画 ，但是并没有改变控件内 部 的属性值 。也就是说只是做了动画，它的位置属性啥的都没有变。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>补问动画和逐帧动画统称为视图动画 ，从字面意思 中可以看 出，这两个动画只能对派生自 View 类的控件实例起作用； 而属性动画则不同，从名字 中可以看出它应该是作用于控件属性的 。<strong>正因为属性动画 能够只针对控件的某一个属性来做动画，所以造就了它能单独改变控件某一个属性的值 ，比如颜色 。</strong></p>
<p>属性动画分为ValueAnimator 和 ObjectAnimator 。</p>
<h3 id="ValueAnimator-："><a href="#ValueAnimator-：" class="headerlink" title="ValueAnimator ："></a><strong>ValueAnimator</strong> ：</h3><p>简单使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">   animator.setDuration(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 在这里监听</span></span><br><span class="line">   animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">       <span class="comment">// 可以在这里根据value值对View进行操作</span></span><br><span class="line">       <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">       loge(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   animator.start()</span><br></pre></td></tr></table></figure>

<p>比如用来移动View</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">		<span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(value, value, value + imageView.width, value + imageView.height)</span><br><span class="line">        &#125;</span><br><span class="line">	    animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationStart&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationEnd&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationRepeat&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        animator.start()</span><br><span class="line">	    <span class="comment">//无限次重复的动画必须得在合适的时机cancel</span></span><br><span class="line">        animator.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View就会沿着从左上角到右下角的对角线进行移动。1秒钟完成动画，然后无限次的重复动画。</p>
<h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">animator.interpolator = AccelerateDecelerateInterpolator()</span><br></pre></td></tr></table></figure>

<p>Android SDK 提供了多种内置的插值器：</p>
<ol>
<li><code>LinearInterpolator</code>: 时间和动画进度之间是线性关系，也就是匀速运动。</li>
<li><code>AccelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐加快。</li>
<li><code>DecelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐减慢。</li>
<li><code>AccelerateDecelerateInterpolator</code>: 动画开始时速度逐渐加快，然后在结束时速度逐渐减慢。</li>
<li><code>AnticipateInterpolator</code>: 开始时，先向相反方向改变一段距离，然后再沿正常方向开始动画。</li>
<li><code>OvershootInterpolator</code>: 动画结束时，会超出目标值一些，然后再弹回来。</li>
<li><code>AnticipateOvershootInterpolator</code>: 开始时向相反方向改变，结束时超出目标值，然后再弹回。</li>
<li><code>BounceInterpolator</code>: 动画结束时，会像弹球一样多次弹跳。</li>
<li><code>CycleInterpolator</code>: 动画会循环指定的次数，每次循环都包括一个正向和一个反向的动画。</li>
<li><code>FastOutSlowInInterpolator</code>: 开始时快速，然后慢慢减速。</li>
</ol>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">100</span>, <span class="number">400</span>)</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">        loge(currentValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里currentValue的计算公式为，比如都到了全程的百分二十</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentValue = 100 + (400 -100)x 0.2</span><br></pre></td></tr></table></figure>

<p>这个0.2也就是进度值时插值器里的getinterpolatio方法返回的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getInterpolation</span><span class="params">(<span class="type">float</span> input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>input 参数与任何我们设定的值没有关系，只与时间有关 ，随着时间的推移，动画的进度也自然地增加，input 参数就代表了当前动画的进度，而返回值则表示动画的当前数值进度。</p>
<p>Linearlnterpolator插值器中就直接返回了input</p>
<p>所以自定义插值器只需要实现TimeInterpolator 接口然后自定义getInterpolation方法的返回值就可以了。</p>
<h3 id="Evaluator估值器"><a href="#Evaluator估值器" class="headerlink" title="Evaluator估值器"></a>Evaluator估值器</h3><p>作用：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1705668341835.jpg" alt="1705668341835"></p>
<p>我们通过监昕器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值 。 那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator 。Evaluator 用 于将从插值器返回的数值进度转换成对应的数值。</p>
<p>oflnt（）和ofFloat（）都是系统直接提供的函数 ，所以会有默认的插值器和 Evaluator 可供使用 。</p>
<p>以IntEvaluator为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startInt</span> <span class="operator">=</span> startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>(int)(startInt + fraction * (endValue - startInt))</code>就等价于上面的<code>currentValue = 100 + (400 -100)×进度值</code></p>
<p>自定义Evaluator</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEvaluator</span> : <span class="type">android.animation.TypeEvaluator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Int</span>, endValue: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.setEvaluator(ReverseEvaluator())</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(imageView.left, currentValue, imageView.right, currentValue + imageView.height)</span><br><span class="line">            loge(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br></pre></td></tr></table></figure>

<p>最终实现了View从下到上也就是从终点到起点的运动。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p><strong>ValueAnimator 有一个缺点 ，就是只能对动画中的数值进行计算 。</strong> 如果想对那个个控件执行操作，就需要监听 ValueAnimator 的动画过程，相比于补间动画要烦琐得多 。所以在 ValueAnimator 的基础上派生了 一个类 ObjectAnimator 。ObjectAnimator 是直接针对属性进行改变。 </p>
<p><strong>简单使用</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">    <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView,<span class="string">&quot;alpha&quot;</span>,<span class="number">0f</span>,<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// 一次的动画时常为2000毫秒</span></span><br><span class="line">    animator.setDuration(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">    animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">    animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">    animator.start()</span><br></pre></td></tr></table></figure>

<p>代码设置了imageView的透明度的从0到1的变化动画，ObjectAnimator 做动画，并不是根据控件XML 中的属性来改变的，而是通过指定属性所对应的 set 函数来改变的。View类中定义了alpha的set函数。</p>
<h3 id="ObjectAnimator动画原理"><a href="#ObjectAnimator动画原理" class="headerlink" title="ObjectAnimator动画原理"></a>ObjectAnimator动画原理</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122162025356.png" alt="image-20240122162025356"></p>
<p>​		在 ObjectAnimator 的动画流程中，先通过插值器产生当前进度的百分比，然后再经过 Evaluator 生成对应百分比所对应的数字值 。 这两步与 ValueAnimator 的动画流程是完全一样的，唯一不同的是最后一步，在 ValueAnimator 中，需要通过添加监昕器来监昕当前的数值；而在 ObjectAnimator 中，则先根据属性值拼装成对应的 set 函数的名 字（ 比如这里的scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，得到 setScaleY ），然后通过反射找到对应控件的setScaleY (float scale Y）函数，井将当前的数值作为setScaleY (floatscaleY）函数的参数传入 。</p>
<p>​		第一，拼接 set 函数的方法。<strong>首先强制将属性的第一个字母大写 ，然后与 set 拼接</strong>，就得到对应的 set 函数的名字。注意，只是强制将属性的第一个字母大写 ，后面的部分是保持不变的 。反过来， 如果我们的函数名为 setScalePointX（），那么在写属性时可以写成 scalePointX 或者 ScalePointX，<strong>即第一个字母大小写随意，但是后面的部分必须与set 函数后面部分的大小写保持一致 。找函数这一步是通过反射来实现的。</strong></p>
<p>​		第二，如何确定函数的参数类型？我们知道了如何找到对应的函数名，那么对应方法中的参数类型如何确定呢？我们在介绍 ValueAnimator 的时候说过，动画过程中产生的数值与构造时传入的值类型是一样的。由于 ObjectAnimator 与 ValueAnimator 在插值器和 Evaluator 这两步是完全一样的，而当前的动画数值是在 Evaluator 这一步产生的，所以 ObjectAnimator 的动画中产生的数值类型与构造时传入的值类型也是一样的。</p>
<p>​		第三，调用set 函数以后怎么办 ？从ObjectAnimator 的动画流程中可以看到，ObjectAnimator 只负责把动画过程中的数值传到对应属性的 s et 函数中就结束了。注意，传给set 函数以后就结束了！set 函数就相当于我们在ValueAnimator 中添加的监听器，set 函数中对控件的操作还是需要由我们自己来写的。</p>
<h3 id="自定义-ObjectAnimator-属性"><a href="#自定义-ObjectAnimator-属性" class="headerlink" title="自定义 ObjectAnimator 属性"></a>自定义 ObjectAnimator 属性</h3><p>在自定义View的时候，可以来自定义一个属性来实现动画的载体。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">       <span class="keyword">set</span>(value) &#123;</span><br><span class="line">           field = value</span><br><span class="line">           invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">           <span class="keyword">by</span> lazy &#123;</span><br><span class="line">               ObjectAnimator.ofFloat(</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                   <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中floatingLabelFraction就是自定义的属性，然后再ofFloat方法中的target设置为this。</p>
<p>当且仅当动画只有一个过渡值时，系统才会调用对应属性的 get 函数来得到动画的初始值。如下面</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">&quot;floatingLabelFraction&quot;</span>, <span class="number">1f</span> )</span><br></pre></td></tr></table></figure>

<p>当不存在 get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h3 id="组合动画AnimatorSet"><a href="#组合动画AnimatorSet" class="headerlink" title="组合动画AnimatorSet"></a>组合动画AnimatorSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translation</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  <span class="comment">// 平移动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);  <span class="comment">// 旋转动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 透明度动画 // 创建组合动画的对象 </span></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();  <span class="comment">// 根据需求组合动画 </span></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  <span class="comment">//启动动画 </span></span><br><span class="line">animSet.start()</span><br></pre></td></tr></table></figure>

<p>常用的组合方法</p>
<ul>
<li>AnimatorSet.play(Animator anim)   ：播放当前动画</li>
<li>AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行</li>
<li>AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行</li>
<li>AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行</li>
<li>AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行</li>
</ul>
<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>PropertyValuesHolder 类的含义就是 ，它其 中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内 部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态 的 。在封装成Prope向NaluesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframeO</span> <span class="operator">=</span> Keyframe . ofFloat(Of , <span class="number">1</span>);</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframel</span> <span class="operator">=</span> Keyframe.ofFloat(O.lf , <span class="number">1.</span>lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframe9</span> <span class="operator">=</span> Keyframe .ofFloat(<span class="number">0</span> . <span class="number">9f</span> , l . lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframelO</span> <span class="operator">=</span> Keyframe . ofFloat(l , <span class="number">1</span>) ;</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">frameHolder2</span> <span class="operator">=</span> PropertyValuesHolder . ofKeyframe (” ScaleX”,</span><br><span class="line">scaleXframeO , scaleXframel, scaleXframe9 , scaleXframelO) ;</span><br><span class="line"> <span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(mimage,frameHolderl,frameHolder2,frameHolder3);</span><br><span class="line">        animator.setDuration(lOOO);</span><br><span class="line">        animator.start();</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator 中唯一一个能实现多动画同时播放的方法。</p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>为 View 的动画操作提供一种更加便捷的用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tvText.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> animator = tvText.animate()</span><br><span class="line">    animator.duration=<span class="number">1000</span></span><br><span class="line">    animator.translationX(<span class="number">100f</span>)<span class="comment">//点击一次会向右偏移，再点击没效果</span></span><br><span class="line">    animator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Android 面试题</title>
    <url>/2024/03/08/Android%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="onSaveInstanceState-原理"><a href="#onSaveInstanceState-原理" class="headerlink" title="onSaveInstanceState 原理"></a>onSaveInstanceState 原理</h4><p>当Activity未被允许被系统自动销毁时会调用这个方法，用户主动销毁不会调用。</p>
<p>Activity调用了<code>onStop</code>后，会调用到<code>ActivityThread</code>的<code>callActivityOnSaveInstanceState()</code>方法，把Activity需要保存的数据放入<code>Bundle</code>对象中。然后通过IPC（进程间通信）机制，调用<code>ActivityManagerService</code>的<code>activityStopped</code>方法，将<code>Bundle</code>对象保存到AMS端的<code>ActivityRecord</code>中。</p>
<p>​		安卓3.0之后至9.0之前，OnSaveInstanceState方法在onPause之后onStop之前调用</p>
<p>​		安卓9.0之后OnSaveInstanceState方法在onStop之后调用</p>
<p>​		onRestoreInstanceState的执行时机在onStart之后</p>
<h4 id="onSaveInstanceState-默认保存的数据有哪些"><a href="#onSaveInstanceState-默认保存的数据有哪些" class="headerlink" title="onSaveInstanceState 默认保存的数据有哪些"></a>onSaveInstanceState 默认保存的数据有哪些</h4><p>ui状态(view中都各自重写了保存状态的方法)和fragment的信息</p>
<ul>
<li>Activity 的布局信息，例如 View 的大小、位置、可见性、滚动位置等。</li>
<li>Activity 的视图状态，例如 EditText 中的文本、CheckBox 的选中状态等。</li>
<li>Activity 的系统状态，例如屏幕亮度、音量等。</li>
</ul>
<h4 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期?"></a>Fragment生命周期?</h4><ol>
<li>**onAttach()**：当 Fragment 与 Activity 关联时调用。在这个方法中，你可以获取到 Activity 的引用，因此可以与 Activity 交互。</li>
<li>**onCreate()**：创建 Fragment 时调用。在这里，你可以初始化对 Fragment 生命周期而言重要的组件，这些组件在 Fragment 停止时不需要被清除。</li>
<li>**onCreateView()**：创建 Fragment 的视图层次结构时调用。这是用于为 Fragment 绘制 UI 的地方。</li>
<li>**onViewCreated()**：在 onCreateView() 之后立即调用，表示所有的视图已经被创建完成。这个方法是一个好地方来执行与视图相关的初始化操作，以及访问 Activity 的初始化组件。</li>
<li>**onStart()**：当 Fragment 对用户可见时调用。这与 Activity 的 onStart() 方法类似。</li>
<li>**onResume()**：当 Fragment 处于活动状态并且可以与用户交互时调用。这与 Activity 的 onResume() 方法类似。</li>
<li>**onPause()**：当 Fragment 不再与用户交互时调用。这与 Activity 的 onPause() 方法类似。</li>
<li>**onStop()**：当 Fragment 对用户不再可见时调用。这与 Activity 的 onStop() 方法类似。</li>
<li>**onDestroyView()**：当 Fragment 的视图层次结构被移除时调用。这是清理与视图相关的资源的好地方。</li>
<li>**onDestroy()**：销毁 Fragment 时调用。在这里，你可以清理所有与 Fragment 相关的资源。</li>
<li>**onDetach()**：当 Fragment 与 Activity 解除关联时调用。在这里，你应该清理对 Activity 的所有引用。</li>
</ol>
<h4 id="Fragment怎么主动回收"><a href="#Fragment怎么主动回收" class="headerlink" title="Fragment怎么主动回收?"></a>Fragment怎么主动回收?</h4><p>​		Fragment 的回收通常是由系统管理的,要想主动回收可以使用以下方式：</p>
<p>remove掉</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().remove(fragment).commit();</span><br></pre></td></tr></table></figure>

<p>replace掉</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().replace(R.id.container, newFragment).commit();</span><br></pre></td></tr></table></figure>

<p>Detach掉</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fragmentManager.beginTransaction()</span><br><span class="line">    .detach(fragment)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure>

<p>加入回退栈，然后返回</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().replace(R.id.container, newFragment).addToBackStack(<span class="literal">null</span>).commit();</span><br></pre></td></tr></table></figure>

<h4 id="Fragment-onDestory之后还会内存泄露吗"><a href="#Fragment-onDestory之后还会内存泄露吗" class="headerlink" title="Fragment onDestory之后还会内存泄露吗"></a>Fragment onDestory之后还会内存泄露吗</h4><p>如果被其他长生命周期的对象持有的话，还是会有内存泄漏。</p>
<p>比如，被静态对象引用，Fragment 内部正在做网络请求， Fragment 注册了某些监听器或回调（handler）等。</p>
<h4 id="Fragment切换是用Add吗？-add与replace的区别"><a href="#Fragment切换是用Add吗？-add与replace的区别" class="headerlink" title="Fragment切换是用Add吗？ add与replace的区别"></a>Fragment切换是用Add吗？ add与replace的区别</h4><p><strong>add 方法</strong></p>
<ul>
<li><code>add</code> 方法用于将一个 Fragment 添加到 Activity 的视图容器中。</li>
<li>如果你使用 <code>add</code> 方法添加多个 Fragment，它们会层叠在一起，最后添加的 Fragment 会显示在最上面。</li>
<li>使用 <code>add</code> 方法时，之前添加的 Fragment 不会被销毁，它们的视图层次结构仍然保留，只是不可见。因此，这可能会导致资源浪费，尤其是当有很多 Fragment 叠加时。</li>
</ul>
<p><strong>replace 方法</strong></p>
<ul>
<li><code>replace</code> 方法用于替换容器中的 Fragment。</li>
<li>使用 <code>replace</code> 方法时，容器中先前的 Fragment 会被销毁，它的视图层次结构也会被移除。</li>
<li><code>replace</code> 方法更适合用于切换 Fragment，因为它可以有效地管理 Fragment 的生命周期和资源</li>
</ul>
<h4 id="Fragment与Fragment之间通信方式"><a href="#Fragment与Fragment之间通信方式" class="headerlink" title="Fragment与Fragment之间通信方式"></a>Fragment与Fragment之间通信方式</h4><p>1.通过ViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> message: MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过Fragment Result的API传递数据</p>
<p>​	为了从FragmentB向FragmentA传递数据，首先给fragmentA设置监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    getParentFragmentManager().setFragmentResultListener(<span class="string">&quot;key&quot;</span>, <span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">FragmentResultListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentResult</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Bundle bundle)</span> &#123;</span><br><span class="line">            <span class="comment">// 这里使用的是String，但是任何其他能够被放在Bundle中的数据类型都是支持的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;bundleKey&quot;</span>);</span><br><span class="line">            <span class="comment">//做一些其他事情</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在FragmentB中，生产结果，需要注意的是，FragmentB必须使用和FragmentA一样的FragmentManager，使用相同的<code>requestKey</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        result.putString(<span class="string">&quot;bundleKey&quot;</span>, <span class="string">&quot;result&quot;</span>);</span><br><span class="line">        getParentFragmentManager().setFragmentResult(<span class="string">&quot;requestKey&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​	一旦FragmentA处于<code>STARTED</code>状态，它将会接受到结果并且执行监听回调。</p>
<ol start="3">
<li>使用事件总线EventBus</li>
<li>通过 Activity 作为中介</li>
</ol>
<p>​	这种在发送消息的activity中会持有Activity的引用，需要及时的取消。</p>
<ul>
<li><p>定义一个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnMessageSendListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMessageSend</span><span class="params">(message: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让 Activity 实现这个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), OnMessageSendListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMessageSend</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 通过 FragmentManager 找到接收消息的 Fragment，并调用其方法</span></span><br><span class="line">        <span class="keyword">val</span> fragmentB = supportFragmentManager.findFragmentById(R.id.fragmentB) <span class="keyword">as</span> FragmentB</span><br><span class="line">        fragmentB.updateMessage(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Android9-0版本有哪些大的改动"><a href="#Android9-0版本有哪些大的改动" class="headerlink" title="Android9.0版本有哪些大的改动"></a>Android9.0版本有哪些大的改动</h4><ol>
<li><p>Android 9默认情况下对所有应用启用了HTTPS的强制使用。这意味着，如果应用试图通过HTTP（而不是HTTPS）发送网络请求，那么这些请求将会被默认阻止，除非应用明确地在其网络安全配置中允许HTTP流量。</p>
</li>
<li><p>在9.0 中，不能直接非 <code>Activity</code> 环境中（比如<code>Service</code>，<code>Application</code>）启动 <code>Activity</code>这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="权限更改是在哪个版本改的？存储是在哪个版本改的？"><a href="#权限更改是在哪个版本改的？存储是在哪个版本改的？" class="headerlink" title="权限更改是在哪个版本改的？存储是在哪个版本改的？"></a>权限更改是在哪个版本改的？存储是在哪个版本改的？</h4><ol>
<li><p><strong>动态权限管理（Android 6.0，API 23）：</strong>Android在6.0版本开始引入了动态权限管理，用户可以在运行时授予或拒绝应用的权限，而不是在安装应用时一次性授予所有权限。</p>
</li>
<li><p><strong>分区存储（Android 10，API 29）</strong>：Android 10引入了分区存储，在这个模型中，应用默认只能访问自己的沙盒目录，对于公共目录的访问需要用户在运行时授予权限。requestLegacyExternalStorage标签可以暂时关闭Android10的强制分区存储。</p>
</li>
<li><p><strong>多媒体文件访问（Android 11，API 30）：</strong>Android11 可以使用直接路径访问多媒体文件，文件保存目录还是遵守沙盒机制，只能访问自己的沙盒目录，且requestLegacyExternalStorage标签失效。</p>
</li>
</ol>
<h4 id="Activity的启动模式以及它们的作用？"><a href="#Activity的启动模式以及它们的作用？" class="headerlink" title="Activity的启动模式以及它们的作用？"></a>Activity的启动模式以及它们的作用？</h4><p><strong>standard（标准）</strong></p>
<ul>
<li><strong>行为</strong>：每次启动 <code>Activity</code> 时都会创建一个新的实例，无论这个 <code>Activity</code> 是否已经存在于任务中。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。</li>
<li><strong>用途</strong>：适用于大多数标准的 <code>Activity</code> 行为。如果你的 <code>Activity</code> 需要多次实例化（例如，一个显示列表项详细信息的 <code>Activity</code>），那么标准模式很适合。</li>
</ul>
<p><strong>singleTop（栈顶复用）</strong></p>
<ul>
<li><strong>行为</strong>：如果新的 <code>Activity</code> 已经位于任务栈的顶部，那么不会创建新的实例，而是重用栈顶的实例，并调用其 <code>onNewIntent()</code> 方法。如果不在栈顶，将创建新的实例。</li>
<li><strong>用途</strong>：适用于需要保持最上层实例唯一，但在其他位置可以有多个实例的 <code>Activity</code>。例如，用于处理从多个地方发送的通知，但希望打开的通知详情 <code>Activity</code> 在顶部时不重复创建。</li>
<li><strong>场景：</strong><ol>
<li>要打开的Activity处于栈顶，点击通知栏打开栈顶的Activity</li>
<li>Activity需要启动一个Service，最后Service对栈顶Activity进行操作</li>
</ol>
</li>
</ul>
<p><strong>singleTask（栈内复用）</strong></p>
<ul>
<li><p><strong>行为</strong>：新的 <code>Activity</code> 实例将在单独的任务中启动。如果已存在这样的 <code>Activity</code> 实例，系统会将其调到栈顶而不是创建新的实例，并调用 <code>onNewIntent()</code> 方法。<strong>当一个具有singleTask模式的Activity请求启动后，比如Activity A，首先会根据taskAffinity:去寻找当前是否存在一个对应名字的任务栈。如果不存在，则会创建一个新的Task。如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例。如果有实例存在，那么系统就会把A调到栈顶（将上面的Activity依次出栈）并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中</strong>。</p>
</li>
<li><p><strong>用途</strong>：适用于作为应用中单一入口点的 <code>Activity</code>，如主页。当应用从多个入口点跳转到这个 <code>Activity</code> 时，它保证实例的唯一性。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>登录页面</li>
<li>首页</li>
</ol>
</li>
</ul>
<p><strong>singleInstance（单实例模式）</strong></p>
<ul>
<li><p><strong>行为</strong>：与 <code>singleTask</code> 相似，但保证这个 <code>Activity</code> 实例是全系统唯一的，即它在自己的任务中，不与其他 <code>Activity</code> 共享任务。创建新实例时，会在新的任务栈中。</p>
</li>
<li><p><strong>用途</strong>：适用于那些与应用其余部分彼此独立的模块，例如，一个浮动窗口或者一个启动其他应用的 <code>Activity</code>。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>外部App调用自己客户端程序的Activity</li>
</ol>
</li>
</ul>
<h4 id="taskaffinity-属性"><a href="#taskaffinity-属性" class="headerlink" title="taskaffinity 属性"></a>taskaffinity 属性</h4><p>作用</p>
<ol>
<li><strong>指定任务栈</strong>：<code>taskAffinity</code> 允许开发者指定一个 Activity 应该位于特定的任务栈中。这对于在同一个应用中创建多个独立的任务栈很有用，每个任务栈可以包含一组相关的 Activity，从而实现不同的用户任务。</li>
<li><strong>处理 Intent Flags</strong>：<code>taskAffinity</code> 在处理具有特定 Intent 标志（如 <code>FLAG_ACTIVITY_NEW_TASK</code> 和 <code>FLAG_ACTIVITY_CLEAR_TOP</code>）的 Intent 时起到关键作用。例如，当启动一个新的 Activity 时，如果设置了 <code>FLAG_ACTIVITY_NEW_TASK</code> 标志，并且该 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统将会在一个新的任务栈中启动该 Activity。</li>
<li><strong>分割应用逻辑</strong>：通过使用不同的 <code>taskAffinity</code>，开发者可以将应用的不同部分分割到不同的任务栈中，从而使用户在使用多任务切换功能时能够更清晰地区分应用的不同功能模块。</li>
</ol>
<h4 id="Intent-flag"><a href="#Intent-flag" class="headerlink" title="Intent flag"></a>Intent flag</h4><ol>
<li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，如果这个 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统会在一个新的任务栈中启动该 Activity。如果已经存在一个与该 Activity 具有相同 <code>taskAffinity</code> 的任务栈，那么该 Activity 会被启动到那个任务栈中。</li>
<li>这个标志通常用于从非 Activity 上下文（如 Service 或 BroadcastReceiver）中启动 Activity。</li>
</ul>
<ol start="2">
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
</ol>
<ul>
<li>如果启动的 Activity 已经在当前任务栈中运行，则系统会将该 Activity 上面的所有其他 Activity 出栈。这样，被启动的 Activity 就位于栈顶，成为当前可见的 Activity。</li>
<li>这个标志经常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用，用于清理任务栈并将某个 Activity 置于栈顶。</li>
</ul>
<ol start="3">
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ol>
<ul>
<li>如果被启动的 Activity 已经位于任务栈的顶部，则系统不会创建该 Activity 的新实例。相反，系统会调用该 Activity 的 <code>onNewIntent()</code> 方法，并传入新的 Intent。</li>
<li>这个标志用于避免在任务栈顶部重复创建相同的 Activity。</li>
</ul>
<ol start="4">
<li><code>FLAG_ACTIVITY_CLEAR_TASK</code></li>
</ol>
<ul>
<li>这个标志会清除当前任务栈中的所有 Activity，并创建一个新的任务栈启动指定的 Activity。</li>
<li>通常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用。</li>
</ul>
<ol start="5">
<li><code>FLAG_ACTIVITY_NO_HISTORY</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，该 Activity 不会被添加到任务栈中。一旦用户离开该 Activity，它就会被销毁，无法通过后退按钮回到这个 Activity。</li>
</ul>
<p>上面五个是常用的，下面是不常用的。</p>
<ul>
<li><code>FLAG_ACTIVITY_BROUGHT_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其带到前台，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code>：启动的 Activity 不会出现在最近任务列表中。</li>
<li><code>FLAG_ACTIVITY_FORWARD_RESULT</code>：将当前 Activity 的结果转发给下一个 Activity。</li>
<li><code>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</code>：如果 Activity 是从历史记录中启动的，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_MULTIPLE_TASK</code>：与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用时，允许同一个应用中的多个任务栈拥有相同的 <code>taskAffinity</code>。</li>
<li><code>FLAG_ACTIVITY_NO_ANIMATION</code>：启动 Activity 时不显示动画效果。</li>
<li><code>FLAG_ACTIVITY_NO_USER_ACTION</code>：表明用户没有直接启动这个 Activity，可能是由另一个程序或者系统自动启动的。</li>
<li><code>FLAG_ACTIVITY_PREVIOUS_IS_TOP</code>：如果当前任务栈中的前一个 Activity 应该保持在顶部，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_REORDER_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其移动到栈顶，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</code>：如果 Activity 是从历史记录中启动的，且与当前任务栈不匹配，则重置任务栈以适应该 Activity。</li>
</ul>
<h4 id="taskaffinity-Intent-flag-launchMode"><a href="#taskaffinity-Intent-flag-launchMode" class="headerlink" title="taskaffinity + Intent flag + launchMode"></a>taskaffinity + Intent flag + launchMode</h4><p>FLAG_ACTIVITY_NEW_TASK 和 standard 模式的组合情况可以总结为：</p>
<ul>
<li>standard 没有设置 taskAffinity。此时系统就会去复用或者创建一个默认任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>standard 有设置 taskAffinity。此时又可以分为当前系统是否存在 taskAffinity 关联的任务栈两种情况<ul>
<li>不存在目标任务栈。此时系统就会创建目标任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>存在目标任务栈。此时系统会判断任务栈中是否已经存在目标 Activity 的实例，如果不存在的话则新建一个 Activity 实例入栈。如果存在目标实例的话，则只是将该任务栈转到前台而已，既不会新建 Activity 实例，也不会回调 <code>onNewIntent</code>方法，甚至也不管该 Activity 实例是否处于栈顶，总之只要存在相同实例就不做任何响应。</li>
</ul>
</li>
</ul>
<h4 id="你认为作为一个Android开发应该具备哪些能力，素质"><a href="#你认为作为一个Android开发应该具备哪些能力，素质" class="headerlink" title="你认为作为一个Android开发应该具备哪些能力，素质"></a>你认为作为一个Android开发应该具备哪些能力，素质</h4><p>代码质量，架构设计，业务的理解，技术的掌握，新技术的探索</p>
<h4 id="你认为在Android领域精进，应该再掌握哪些技能"><a href="#你认为在Android领域精进，应该再掌握哪些技能" class="headerlink" title="你认为在Android领域精进，应该再掌握哪些技能"></a>你认为在Android领域精进，应该再掌握哪些技能</h4><p>设计模式，架构的理解，技术宽度。</p>
<h4 id="compose与原生View的区别，优点和缺点"><a href="#compose与原生View的区别，优点和缺点" class="headerlink" title="compose与原生View的区别，优点和缺点"></a>compose与原生View的区别，优点和缺点</h4><p><a href="https://blog.csdn.net/weixin_37438128/article/details/130390554">https://blog.csdn.net/weixin_37438128/article/details/130390554</a></p>
<h4 id="显示Intent和隐式Intent区别"><a href="#显示Intent和隐式Intent区别" class="headerlink" title="显示Intent和隐式Intent区别"></a>显示Intent和隐式Intent区别</h4><p>显示 Intent 是直接指定要启动的 Activity 的一种方式。显示 Intent 的构造方法通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent intent = new Intent(this, SecondActivity.class);</span><br></pre></td></tr></table></figure>

<p>隐式 Intent</p>
<p>隐式 Intent 是通过 Intent Filter 来指定要启动的 Activity 的一种方式。在清单文件中注册指定 Activity 的 action、data 和 category 等属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.SecondActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;!--取别名--&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.example.test.ACTION_START&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<p>隐式 Intent 的构造方法通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));</span><br></pre></td></tr></table></figure>

<p>上述 Intent 会启动所有具有 Intent Filter 中指定 action 和 data 属性的 Activity。</p>
<h4 id="隐式Intent还有什么作用"><a href="#隐式Intent还有什么作用" class="headerlink" title="隐式Intent还有什么作用"></a>隐式Intent还有什么作用</h4><ol>
<li><strong>数据分享</strong>：可以通过隐式 Intent 将数据分享给其他应用。例如，可以使用隐式 Intent 将图片分享到社交媒体应用。</li>
<li><strong>系统功能调用</strong>：可以使用隐式 Intent 调用系统功能。例如，可以使用隐式 Intent 拨打电话、发送短信、打开地图等。</li>
<li><strong>应用间通信</strong>：可以使用隐式 Intent 实现应用间通信。例如，可以使用隐式 Intent 让用户在一个应用中选择另一个应用的某个功能</li>
</ol>
<ul>
<li>启动Service有几种方式，区别</li>
</ul>
<p>Android 中启动 Service 有两种方式：</p>
<ul>
<li><strong>startService()</strong></li>
<li><strong>bindService()</strong></li>
</ul>
<p><strong>startService()</strong> 方法用于启动一个 Service，该 Service 会一直运行在后台，直到被手动停止或系统内存不足而被杀死。<strong>startService()</strong> 方法会调用 Service 的 <strong>onCreate()<strong>、</strong>onStartCommand()</strong> 和 <strong>onDestroy()</strong> 方法。</p>
<p><strong>bindService()</strong> 方法用于启动一个 Service，该 Service 可以与客户端进行通信。<strong>bindService()</strong> 方法会调用 Service 的 <strong>onCreate()<strong>、</strong>onBind()<strong>、</strong>onUnbind()</strong> 和 <strong>onDestroy()</strong> 方法。</p>
<p><strong>两种方式的区别</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">startService()</th>
<th align="left">bindService()</th>
</tr>
</thead>
<tbody><tr>
<td align="left">作用</td>
<td align="left">启动一个后台 Service</td>
<td align="left">启动一个可进行通信的 Service</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td align="left">onCreate()、onStartCommand()、onDestroy()</td>
<td align="left">onCreate()、onBind()、onUnbind()、onDestroy()</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">用于执行后台任务，例如音乐播放、下载等</td>
<td align="left">用于执行需要与客户端进行通信的任务，例如数据库访问、网络通信等</td>
</tr>
</tbody></table>
<p>drive_spreadsheet导出到 Google 表格</p>
<p><strong>示例</strong></p>
<p><strong>startService() 示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        // 执行后台任务</span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line">        return Service.START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Activity 中启动 Service</span><br><span class="line">Intent intent = new Intent(this, MyService.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<p><strong>bindService() 示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        // 返回 IBinder 对象，用于客户端与 Service 进行通信</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在 Activity 中绑定 Service</span><br><span class="line">Intent intent = new Intent(this, MyService.class);</span><br><span class="line">bindService(intent, connection, BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">// 在 Activity 中与 Service 进行通信</span><br><span class="line">MyService.MyBinder binder = (MyService.MyBinder) connection.getBinder();</span><br><span class="line">binder.doSomething();</span><br></pre></td></tr></table></figure>

<h4 id="startService后生命周期的回调，有什么区别"><a href="#startService后生命周期的回调，有什么区别" class="headerlink" title="startService后生命周期的回调，有什么区别"></a>startService后生命周期的回调，有什么区别</h4><ul>
<li><strong>onCreate()</strong> 方法是在 Service 第一次创建时调用的，用于初始化 Service 的状态。</li>
<li><strong>onStartCommand()</strong> 方法是在 Service 启动时调用的，用于执行 Service 的后台任务。</li>
<li><strong>onDestroy()</strong> 方法是在 Service 被销毁时调用的，用于释放 Service 的资源。</li>
</ul>
<h4 id="bindService-方法绑定一个-Service-时"><a href="#bindService-方法绑定一个-Service-时" class="headerlink" title="bindService() 方法绑定一个 Service 时"></a><code>bindService()</code> 方法绑定一个 Service 时</h4><p><strong>onCreate()</strong> 方法和 <code>startService()</code> 后调用的方式相同。</p>
<p><strong>onBind()</strong> 方法是在 Service 与客户端建立连接时调用的，用于返回一个 <code>IBinder</code> 对象，用于客户端与 Service 进行通信。</p>
<p><strong>onUnbind()</strong> 方法是在 Service 与客户端断开连接时调用的，用于释放 Service 与客户端通信的资源。</p>
<p><strong>onDestroy()</strong> 方法和 <code>startService()</code> 后调用的方式相同。</p>
<p><strong>区别</strong></p>
<p><code>startService()</code> 和 <code>bindService()</code> 后生命周期的回调主要有以下区别：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">startService()</th>
<th align="left">bindService()</th>
</tr>
</thead>
<tbody><tr>
<td align="left">调用时机</td>
<td align="left">启动 Service</td>
<td align="left">绑定 Service</td>
</tr>
<tr>
<td align="left">回调次数</td>
<td align="left">一次</td>
<td align="left">多次</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">无</td>
<td align="left"><code>IBinder</code> 对象</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">执行后台任务</td>
<td align="left">执行需要与客户端进行通信的任务</td>
</tr>
</tbody></table>
<h4 id="canvas跟Paint的区别，以及作用？"><a href="#canvas跟Paint的区别，以及作用？" class="headerlink" title="canvas跟Paint的区别，以及作用？"></a><strong>canvas跟Paint的区别，以及作用？</strong></h4><ul>
<li><strong>Canvas</strong> 是 Android 绘图的画布，它提供了绘制图形、文本和位图的方法。Canvas 通常与 View 的 <code>onDraw</code> 方法一起使用，用于自定义绘制 View 的内容。</li>
<li><strong>Paint</strong> 是用于描述绘制属性的对象，它包括颜色、线条样式、字体等绘制信息。Paint 用于定义绘制的样式和效果，然后应用于 Canvas 上的绘制操作。</li>
</ul>
<h4 id="Service有多少种方法启动？"><a href="#Service有多少种方法启动？" class="headerlink" title="Service有多少种方法启动？"></a><strong>Service有多少种方法启动？</strong></h4><p>Service 可以通过以下两种方法启动：</p>
<ol>
<li><p>**startService()**：用于启动服务，服务将一直运行，直到被停止。</p>
</li>
<li><p>**bindService()**：用于绑定服务，允许组件与服务建立连接，但服务会在没有绑定的情况下停止。</p>
<ul>
<li><p><strong>这两种方式有什么区别？</strong></p>
<p>主要区别在于生命周期和通信方式：</p>
<ul>
<li>**startService()**：服务的生命周期独立于组件，无需绑定，可以长时间运行。通常用于执行后台任务。</li>
<li>**bindService()**：服务的生命周期与绑定的组件相关联，当绑定的组件销毁时，服务也会停止。用于与服务进行交互，获取数据等。</li>
</ul>
<h4 id="Service还有什么区别，除了生命周期的区别？"><a href="#Service还有什么区别，除了生命周期的区别？" class="headerlink" title="Service还有什么区别，除了生命周期的区别？"></a><strong>Service还有什么区别，除了生命周期的区别？</strong></h4><p>​	除了生命周期的区别，Service 还可以分为前台服务和普通服务。前台服务通常用于需要在通知栏显示通知的情况，以增加服务的优先级和可见性。</p>
</li>
</ul>
</li>
</ol>
<h4 id="看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"><a href="#看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？" class="headerlink" title="看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"></a><strong>看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？</strong></h4><p>​		Dalvik VM 和 ART 之间的交替发生在 Android 5.0（Lollipop）版本。</p>
<ul>
<li><p><strong>那为什么要做这种交替呢？</strong></p>
<p>从 Dalvik VM 到 ART 的交替是为了改善 Android 应用程序的性能和效率。ART 使用预编译的方式运行应用程序，提供了更快的应用启动和更低的内存占用。</p>
</li>
</ul>
<h4 id="四大引用？"><a href="#四大引用？" class="headerlink" title="四大引用？"></a><strong>四大引用？</strong></h4><p>四种主要的引用类型是：</p>
<ol>
<li><strong>强引用（Strong Reference）</strong>：强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。</li>
<li><strong>软引用（Soft Reference）</strong>：软引用允许在内存不足时回收对象。垃圾回收器会根据内存需求来回收软引用对象。</li>
<li><strong>弱引用（Weak Reference）</strong>：弱引用更弱于软引用，只要没有强引用指向对象，垃圾回收器就可能回收它。</li>
<li><strong>虚引用（Phantom Reference）</strong>：虚引用是最弱的引用类型，它几乎没有直接作用，主要用于管理对象的生命周期。</li>
</ol>
<h4 id="什么情况下用虚引用、弱引用？"><a href="#什么情况下用虚引用、弱引用？" class="headerlink" title="什么情况下用虚引用、弱引用？"></a><strong>什么情况下用虚引用、弱引用？</strong></h4><ul>
<li><p><strong>虚引用</strong> 主要用于跟踪对象被垃圾回收的状态，通常与引用队列（ReferenceQueue）一起使用。当对象被垃圾回收时，会被放入引用队列中，用于执行一些清理操作。</p>
</li>
<li><p><strong>弱引用</strong> 通常用于缓存或缓存敏感数据，当内存不足时，垃圾回收器可能会回收被弱引用引用的对象，允许释放内存。</p>
</li>
<li><p><strong>什么是强引用？</strong></p>
<p>强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。强引用通常用于确保对象不会被提前回收。</p>
</li>
</ul>
<h4 id="APK瘦身你做过的有哪些？"><a href="#APK瘦身你做过的有哪些？" class="headerlink" title="APK瘦身你做过的有哪些？"></a><strong>APK瘦身你做过的有哪些？</strong></h4><p>APK瘦身是减少Android应用包的大小，常见的优化方法包括：</p>
<ol>
<li><strong>资源压缩和混淆</strong>：删除未使用的资源和代码，进行资源压缩和混淆处理。</li>
<li><strong>代码优化</strong>：检查和优化代码，减少冗余和不必要的库和依赖。</li>
<li><strong>图像压缩</strong>：使用工具对图像进行压缩和优化。</li>
<li><strong>延迟加载</strong>：将某些资源和模块延迟加载，只在需要时加载。</li>
<li><strong>分包</strong>：将应用分为多个模块，按需下载。</li>
<li><strong>动态化</strong>：将一些功能以插件或动态加载的方式提供，减少初始安装包的大小。</li>
</ol>
<h4 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h4><p>​		在Android开发中，<code>onNewIntent()</code>是一个生命周期方法，它在活动(Activity)的实例已经存在于任务栈中，且该活动的启动模式为<code>singleTop</code>、<code>singleTask</code>或<code>singleInstance</code>，并且通过Intent再次启动时，会被调用。</p>
<h4 id="每五秒发一个消息的实现方式"><a href="#每五秒发一个消息的实现方式" class="headerlink" title="每五秒发一个消息的实现方式"></a>每五秒发一个消息的实现方式</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>定时器</span><br><span class="line">    <span class="keyword">val</span> timer = Timer()</span><br><span class="line">    timer.schedule(MyTimerTask(), <span class="number">0</span>, <span class="number">5000</span>)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> : <span class="type">TimerTask</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>单线程池</span><br><span class="line"><span class="keyword">val</span> scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>)</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(</span><br><span class="line">            &#123; println(<span class="string">&quot;我爱你中国&quot;</span>) &#125;,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            TimeUnit.SECONDS</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Handler循环发送消息</span><br><span class="line"><span class="keyword">var</span> handler: Handler = <span class="keyword">object</span> : Handler(mainLooper) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            msg?.let &#123; <span class="keyword">super</span>.handleMessage(it) &#125;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>协程作用域</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是你想要执行的代码，例如发送消息的逻辑</span></span><br><span class="line">            println(<span class="string">&quot;发送消息 - <span class="subst">$&#123;Date()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000</span>) <span class="comment">// 暂停5秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止主线程退出</span></span><br><span class="line">    readLine()</span><br><span class="line">    <span class="comment">// 关闭协程作用域</span></span><br><span class="line">    scope.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="广播是安全的吗？"><a href="#广播是安全的吗？" class="headerlink" title="广播是安全的吗？"></a><strong>广播是安全的吗？</strong></h4><p>​		广播是 Android 中一种跨组件通信的方式，但它可以被其他应用程序接收。因此，广播不是完全安全的，需要小心处理敏感信息，可以使用权限来限制广播的接收范围。</p>
<h4 id="Android-中广播的种类"><a href="#Android-中广播的种类" class="headerlink" title="Android 中广播的种类"></a>Android 中广播的种类</h4><ol>
<li><strong>标准广播（Normal Broadcasts）</strong>：这是最常见的广播类型，它是一种完全异步执行的广播。在这种广播中，所有接收器都在同一时间接收到广播消息，但它们的执行顺序是不确定的。这种广播的效率较高，但不能被中断，也无法终止。</li>
<li><strong>有序广播（Ordered Broadcasts）</strong>：这种广播是同步执行的，接收器按照优先级（在 AndroidManifest.xml 中定义）依次接收到广播消息。一个接收器可以在接收到广播后终止它，这样后面优先级较低的接收器就不会收到这条广播消息。</li>
<li><strong>粘性广播（Sticky Broadcasts）</strong>：当发送一个粘性广播后，即使广播已经结束，这个广播的数据仍然会“粘”在系统中，这样后来注册的接收器也可以接收到这条广播的数据。但是，出于安全考虑，粘性广播的使用在新版 Android 中受到了限制。现版本中已经过时</li>
<li><strong>本地广播（Local Broadcasts）</strong>：使用 <code>LocalBroadcastManager</code> 发送的广播只能在应用程序的内部进行通信，不会被系统的其他部分或其他应用程序所接收。这种方式更加高效、安全，适用于不需要与系统或其他应用程序交互的场景。</li>
<li><strong>系统广播（System Broadcasts）</strong>：这些广播由系统发出，例如屏幕关闭、电池电量低、时间改变等。应用程序可以通过注册相应的接收器来监听这些系统事件。</li>
</ol>
<h4 id="必须用全局广播，但又不希望其他一部分app监听到？怎么办？"><a href="#必须用全局广播，但又不希望其他一部分app监听到？怎么办？" class="headerlink" title="必须用全局广播，但又不希望其他一部分app监听到？怎么办？"></a><strong>必须用全局广播，但又不希望其他一部分app监听到？怎么办？</strong></h4><p>使用权限限制广播接收者</p>
<p>​		可以定义一个自定义权限，并要求接收该广播的应用必须具有这个权限。这样，只有声明了相应权限的应用才能接收到广播。</p>
<p><strong>定义权限：</strong> 在 <code>AndroidManifest.xml</code> 中定义一个自定义权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.broadcast&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>发送广播：</strong> 使用 <code>sendBroadcast</code> 方法发送广播，并指定接收者需要的权限：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcast.MY_SECURE_BROADCAST&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from secure broadcast&quot;</span>)</span><br><span class="line">sendBroadcast(intent, <span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>接收广播：</strong> 在接收者的 <code>AndroidManifest.xml</code> 中声明所需的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后正常注册广播接收器。</p>
<ol start="2">
<li>使用动态注册的广播接收者</li>
</ol>
<p>​		另一种方法是在应用内部动态注册广播接收器，并不在 <code>AndroidManifest.xml</code> 中声明。这样，只有你的应用能接收到这个广播，因为其他应用不知道这个广播的存在。</p>
<p><strong>发送广播：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcast.MY_INTERNAL_BROADCAST&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from internal broadcast&quot;</span>)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>

<p><strong>接收广播：</strong> 在你的应用中动态注册广播接收器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> receiver = <span class="keyword">object</span> : BroadcastReceiver() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = intent.getStringExtra(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;InternalBroadcastReceiver&quot;</span>, <span class="string">&quot;Received data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filter = IntentFilter(<span class="string">&quot;com.example.broadcast.MY_INTERNAL_BROADCAST&quot;</span>)</span><br><span class="line">registerReceiver(receiver, filter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在合适的时候注销接收器</span></span><br><span class="line">unregisterReceiver(receiver)</span><br></pre></td></tr></table></figure>

<p>​		这两种方法都可以实现全局广播的发送，同时限制部分应用接收到这个广播。选择哪种方法取决于你的具体需求和应用场景。</p>
<h4 id="SharedPreferences-优缺点"><a href="#SharedPreferences-优缺点" class="headerlink" title="SharedPreferences 优缺点"></a>SharedPreferences 优缺点</h4><p>优点<br> 1.轻量级，以键值对的方式进行存储，使用方便，易于理解。<br> 2.采用的是 <code>XML</code> 文件形式存储在本地，程序卸载后会也会一并被清除，不会残留信息。</p>
<p>缺点<br> 1.由于是对文件 <code>IO</code> 读取，因此在 <code>IO</code> 上的瓶颈是个大问题。<br> 2.多线程场景下效率比较低，因为 <code>get</code> 操作的时候，会锁定 <code>SharedPreferencesImpl</code> 里面的对象，互斥其他操作，而当 <code>put、commit()</code> 和 <code>apply()</code> 操作的时候都会锁住 <code>Editor</code> 的对象，这样的情况下，效率会降低。<br> 3.不支持跨进程通讯。<br> 4.由于每次都会把整个文件加载到内存中，因此，如果 <code>SharedPreferences</code> 文件过大，或者在其中的键值对是大对象的 <code>json</code> 数据则会占用大量内存，读取较慢是一方面，同时也会引发程序频繁<code>GC</code>，导致的界面卡顿。</p>
<h4 id="SharedPreferences-提交apply-和-commit-的区别"><a href="#SharedPreferences-提交apply-和-commit-的区别" class="headerlink" title="SharedPreferences 提交apply() 和 commit()的区别"></a>SharedPreferences 提交apply() 和 commit()的区别</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = getSharedPreferences(<span class="string">&quot;123&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> string = sharedPreferences.getString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line"><span class="keyword">val</span> editor = sharedPreferences.edit()</span><br><span class="line">editor.putString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">editor.commit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>commit()</code> 是同步的，而 <code>apply()</code> 采用异步的方式通常来说效率会更高一些。在不需要返回值的情况下，使用 <code>apply()</code> 方法可以极大的提高性能。**<code>apply()</code> 和 <code>commit()</code> 的区别是在 <code>commit()</code> 把内容同步提交到了硬盘，而 <code>apply()</code> 是先立即把修改提交给了内存，然后开启了一个异步的线程提交到硬盘。**</p>
<h4 id="Android-组件化"><a href="#Android-组件化" class="headerlink" title="Android 组件化"></a>Android 组件化</h4><h4 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h4><h4 id="构建-apk-的过程"><a href="#构建-apk-的过程" class="headerlink" title="构建 apk 的过程"></a>构建 apk 的过程</h4><h4 id="说一下今日头条屏幕适配的原理"><a href="#说一下今日头条屏幕适配的原理" class="headerlink" title="说一下今日头条屏幕适配的原理"></a>说一下今日头条屏幕适配的原理</h4><h4 id="屏幕适配-dp-和-sp-有什么区别-dins-干什么用的"><a href="#屏幕适配-dp-和-sp-有什么区别-dins-干什么用的" class="headerlink" title="屏幕适配 dp 和 sp 有什么区别, dins 干什么用的"></a>屏幕适配 dp 和 sp 有什么区别, dins 干什么用的</h4><h4 id="说一下-RecycleView-三级缓存"><a href="#说一下-RecycleView-三级缓存" class="headerlink" title="说一下 RecycleView 三级缓存"></a>说一下 RecycleView 三级缓存</h4><h4 id="说一下-R8-和-D8-的区别"><a href="#说一下-R8-和-D8-的区别" class="headerlink" title="说一下 R8 和 D8 的区别"></a>说一下 R8 和 D8 的区别</h4><h4 id="AOP-面向切面编程思想"><a href="#AOP-面向切面编程思想" class="headerlink" title="AOP 面向切面编程思想"></a>AOP 面向切面编程思想</h4><h4 id="apk-解析安装过程"><a href="#apk-解析安装过程" class="headerlink" title="apk 解析安装过程"></a>apk 解析安装过程</h4><h4 id="mvvm-比-mpv-好在哪里"><a href="#mvvm-比-mpv-好在哪里" class="headerlink" title="mvvm 比 mpv 好在哪里"></a>mvvm 比 mpv 好在哪里</h4><h4 id="mvp-说一下-mvp-和-mvc-的区别"><a href="#mvp-说一下-mvp-和-mvc-的区别" class="headerlink" title="mvp 说一下 mvp 和 mvc 的区别"></a>mvp 说一下 mvp 和 mvc 的区别</h4><h4 id="mvp-使用中的内存泄漏情况"><a href="#mvp-使用中的内存泄漏情况" class="headerlink" title="mvp 使用中的内存泄漏情况"></a>mvp 使用中的内存泄漏情况</h4><h4 id="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？"><a href="#网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？" class="headerlink" title="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？"></a>网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？</h4><ol>
<li><strong>使用弱引用（WeakReference）</strong>：在回调中使用弱引用来引用 Activity。这样，即使 Activity 被销毁，回调中的弱引用也不会阻止垃圾回收器回收 Activity，从而避免内存泄漏。</li>
<li><strong>取消网络请求</strong>：在 Activity 的 <code>onDestroy</code> 方法中取消所有未完成的网络请求。这样可以确保 Activity 销毁时不会有未完成的网络请求尝试更新 UI。</li>
<li><strong>检查 Activity 状态</strong>：在回调中检查 Activity 的状态，确保 Activity 仍然有效（未被销毁）时才更新 UI。</li>
<li><strong>使用生命周期感知组件（如 LiveData）</strong>：使用 LiveData 等组件可以自动管理与 Activity 生命周期相关的操作，减少内存泄漏的风险。</li>
</ol>
<h4 id="looper-咋停"><a href="#looper-咋停" class="headerlink" title="looper 咋停"></a>looper 咋停</h4><p>​		looper.quit()和looper.quitSafety()，调用 <code>quit()</code> 方法后，<code>Looper</code> 会立即停止处理消息队列中的所有消息。如果希望 <code>Looper</code> 在处理完当前消息后再停止，可以使用 <code>quitSafely()</code> 方法。</p>
<h4 id="handler-内存泄漏如何去避免"><a href="#handler-内存泄漏如何去避免" class="headerlink" title="handler 内存泄漏如何去避免"></a>handler 内存泄漏如何去避免</h4><h4 id="处理消息的，除了用-handler-还用啥"><a href="#处理消息的，除了用-handler-还用啥" class="headerlink" title="处理消息的，除了用 handler 还用啥"></a>处理消息的，除了用 handler 还用啥</h4>]]></content>
  </entry>
  <entry>
    <title>java 面试题</title>
    <url>/2024/03/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="SparseArrary和HashMap比较"><a href="#SparseArrary和HashMap比较" class="headerlink" title="SparseArrary和HashMap比较"></a>SparseArrary和HashMap比较</h4><p><code>SparseArray</code> 使用两个数组来存储数据，避免了 <code>HashMap</code> 中的Integer自动装箱（autoboxing）过程，减少了内存占用。在处理小型数据集时，这种差异尤为明显。但这也就是仅仅的优点了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SparseArray</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> keys:   <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">values</span>: <span class="operator">|</span> A <span class="operator">|</span> B <span class="operator">|</span> C <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>SparseArray的局限性：</p>
<ol>
<li><strong>只适用于整数键</strong>：<code>SparseArray</code> 只能使用整数作为键，而 <code>HashMap</code> 可以使用任何类型的对象作为键。</li>
<li><strong>可能不适合大型数据集</strong>：对于非常大的数据集，<code>SparseArray</code> 的二分查找可能不如 <code>HashMap</code> 的哈希查找高效。</li>
</ol>
<h4 id="ConcurrentHashMap基本原理"><a href="#ConcurrentHashMap基本原理" class="headerlink" title="ConcurrentHashMap基本原理"></a>ConcurrentHashMap基本原理</h4><p>ConcurrentHashMap的get方法是没有使用同步锁的，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点</p>
<h4 id="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥"><a href="#HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥" class="headerlink" title="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?"></a>HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?</h4><p>存取过程：看下图是存的过程，取得过程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxVEh1RWdFR2lhVkV3N0JoazBvVWRDVnNnN2dObG5yYUtuemljUEo2M3JiNDlvNFhRTTJWak5pY2ljdy8" alt="img"></p>
<p>其中对key得hash操作具体得内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原始哈希值 <code>h</code> 的高16位右移16位（<code>h &gt;&gt;&gt; 16</code>），然后与原始哈希值进行异或运算（<code>^</code>）得到hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>一切以算的位置为基础寻找对应的数组节点，然后再遍历红黑树或者链表查找对应的元素。</p>
<p><strong>红黑树与完全二叉树对比：</strong></p>
<p>红黑树查找、插入和删除操作的最坏情况时间复杂度为 O(log n)。而完全二叉树是O(n)。</p>
<p><strong>Hashtable结构：</strong></p>
<p>它对几乎大部分方法都上了synchronized锁，底层结构为数组+链表，因为已经被废弃所以研究没有意义。</p>
<h4 id="Java的concurrent包里有啥："><a href="#Java的concurrent包里有啥：" class="headerlink" title="Java的concurrent包里有啥："></a><strong>Java的concurrent包里有啥：</strong></h4><p><strong>线程池和执行器框架</strong></p>
<ul>
<li><code>Executor</code>：执行已提交的 <code>Runnable</code> 任务的对象的接口。</li>
<li><code>ExecutorService</code>：扩展了 <code>Executor</code> 的接口，提供了更完整的异步任务执行框架。</li>
<li><code>ScheduledExecutorService</code>：扩展了 <code>ExecutorService</code>，支持定时以及周期性任务执行。</li>
<li><code>ThreadPoolExecutor</code>：<code>ExecutorService</code> 的实现类，用于管理和执行线程池中的任务。</li>
<li><code>ScheduledThreadPoolExecutor</code>：<code>ScheduledExecutorService</code> 的实现类，用于执行定时或周期性任务。</li>
</ul>
<p><strong>同步器</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他线程完成操作的同步辅助工具。</li>
<li><code>CyclicBarrier</code>：使一组线程在达到某个屏障时互相等待的同步辅助工具。</li>
<li><code>Semaphore</code>：基于计数的信号量，用于控制对资源的访问。</li>
<li><code>Exchanger</code>：用于在两个线程之间交换数据的同步点。</li>
<li><code>Phaser</code>：提供了一种更灵活的线程同步机制，类似于 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 的结合。</li>
</ul>
<p><strong>并发集合</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的 <code>HashMap</code> 实现。</li>
<li><code>ConcurrentLinkedQueue</code>：基于链接节点的、线程安全的无界队列。</li>
<li><code>ConcurrentSkipListMap</code>：线程安全的、可排序的 <code>Map</code> 实现。</li>
<li><code>ConcurrentSkipListSet</code>：基于 <code>ConcurrentSkipListMap</code> 的 <code>Set</code> 实现。</li>
<li><code>CopyOnWriteArrayList</code>：在写操作时复制底层数组的线程安全 <code>List</code> 实现。</li>
<li><code>CopyOnWriteArraySet</code>：基于 <code>CopyOnWriteArrayList</code> 的 <code>Set</code> 实现。</li>
</ul>
<p><strong>原子变量</strong></p>
<ul>
<li><code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 等：提供原子操作的变量类。</li>
<li><code>AtomicReference</code>：提供对对象引用的原子操作。</li>
<li><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>：提供对数组元素的原子操作。</li>
</ul>
<p><strong>锁</strong></p>
<ul>
<li><code>Lock</code>：锁的基本接口。</li>
<li><code>ReentrantLock</code>：可重入的互斥锁实现。</li>
<li><code>ReadWriteLock</code>：读写锁的接口。</li>
<li><code>ReentrantReadWriteLock</code>：可重入的读写锁实现。</li>
<li><code>StampedLock</code>：提供了一种乐观读锁的实现。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>Future</code>：表示异步计算的结果。</li>
<li><code>Callable</code>：类似于 <code>Runnable</code>，但可以返回结果并抛出异常。</li>
<li><code>FutureTask</code>：<code>Future</code> 的实现类，用于表示异步计算。</li>
<li><code>CompletionService</code>：用于提交一组可调用任务，并以异步方式获取它们的结果。</li>
</ul>
<h4 id="ArrayList-如何保证线程安全？"><a href="#ArrayList-如何保证线程安全？" class="headerlink" title="ArrayList 如何保证线程安全？"></a>ArrayList 如何保证线程安全？</h4><ul>
<li>继承Arraylist，然后重写或按需求编写自己的方法，这些方法要写成synchronized，在这些<br>synchronized的方法中调用ArrayList的方法。</li>
<li>可以使用Collections.synchronizedList()这个函数进行包装</li>
</ul>
<h4 id="请说一说ArrayList、HashMap、LinkedHashMap-？"><a href="#请说一说ArrayList、HashMap、LinkedHashMap-？" class="headerlink" title="请说一说ArrayList、HashMap、LinkedHashMap ？"></a>请说一说ArrayList、HashMap、LinkedHashMap ？</h4><p><strong>ArrayList：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 的底层是一个动态数组，而不是双向链表。初始长度默认为 10。当数组容量不足时，通常扩展为原来的 1.5 倍。</li>
<li><strong>时间复杂度</strong>：获取元素的时间复杂度是 O(1)，因为可以直接通过数组索引来访问。但是插入和删除操作的时间复杂度可能是 O(n)，因为可能需要移动元素来维护数组的连续性。</li>
</ul>
<p><strong>HashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>HashMap</code> 的底层是一个数组，数组中的每个位置（或称为“桶”）包含了一个链表或红黑树（当链表中的元素数量超过某个阈值时，链表会转换为红黑树）来处理哈希冲突。</li>
<li><strong>哈希冲突处理</strong>：当多个键的哈希值相同，或者不同的哈希值经过处理后落在同一个桶中时，这些键值对会以链表的形式存储。在 Java 8 及以后的版本中，链表过长时会转换为红黑树来提高查找效率。</li>
</ul>
<p><strong>LinkedHashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，因此也是基于哈希表，但它还维护了一个双向链表来记录插入顺序或访问顺序。</li>
<li><strong>顺序性</strong>：遍历 <code>LinkedHashMap</code> 时，元素将按照插入顺序（默认）或访问顺序（如果在构造函数中设置）返回。</li>
<li><strong>访问顺序</strong>：在访问顺序模式下，每次 get 或 put 操作都会将被访问的元素移至双向链表的末尾。这种行为使得 <code>LinkedHashMap</code> 可以用来实现像最近最少使用（LRU）缓存策略这样的数据结构。</li>
</ul>
<p><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解LinkedHashMap原理</a></p>
<h4 id="Java中提供了抽象类还有接口，开发中如何去选择呢？"><a href="#Java中提供了抽象类还有接口，开发中如何去选择呢？" class="headerlink" title="Java中提供了抽象类还有接口，开发中如何去选择呢？"></a>Java中提供了抽象类还有接口，开发中如何去选择呢？</h4><p><strong>抽象类的设计目的，是代码复用；接口的设计目的，是对类的行为进行约束。抽象类强调从属关系，接口强调功能。</strong></p>
<p>总结一下异同：</p>
<ol>
<li>关键字不同</li>
<li>一个类可以继承多个接口，只能继承一个抽象类</li>
<li>抽象类有构造方法，接口没有</li>
<li>继承所用的关键字不同</li>
<li><strong>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default且可以使用其他的权限修饰符，可在子类中被重新定义，也可被重新赋值。</strong></li>
<li>抽象类可以继承接口，抽象类可以继承实体类。接口也可以继承接口</li>
</ol>
<p>同：</p>
<p>都可以包含抽象方法</p>
<p>都可以有默认实现的方法</p>
<p>都不能被实例化。</p>
<h4 id="静态内部类是什么？和非静态内部类的区别是什么"><a href="#静态内部类是什么？和非静态内部类的区别是什么" class="headerlink" title="静态内部类是什么？和非静态内部类的区别是什么"></a>静态内部类是什么？和非静态内部类的区别是什么</h4><p>当内部类被static声明，那么在内部类中就无法直接使用外部类的属性。<strong>普通内部类构造方法中实际上会隐式的传递外部类实例对象给内部类。在内部类中使用外部类的属性实际上是通过外部类的实例对象获取的。</strong></p>
<p>因此静态内部类与非静态内部类的区别有：</p>
<ol>
<li>非静态内部类能够访问外部类的静态和非静态成员，静态类只能访问外部类的静态成员。</li>
<li>非静态内部类不能脱离外部类被创建，静态内部类可以。</li>
</ol>
<h4 id="Java中在传参数时是将值进行传递，还是传递引用？"><a href="#Java中在传参数时是将值进行传递，还是传递引用？" class="headerlink" title="Java中在传参数时是将值进行传递，还是传递引用？"></a>Java中在传参数时是将值进行传递，还是传递引用？</h4><p>Java 总是<strong>采用值传递</strong>的方式来处理变量。这意味着当你将一个变量传递给一个方法时，实际上传递的是变量的一个副本，不是变量本身。</p>
<p>对于基本类型（如 <code>int</code>, <code>double</code>, <code>char</code> 等），这意味着方法得到的是基本值的副本。</p>
<p>对于对象，传递的是对象引用的副本，而不是对象本身。</p>
<h4 id="equals和-进行比较的区别"><a href="#equals和-进行比较的区别" class="headerlink" title="equals和&#x3D;&#x3D;进行比较的区别"></a>equals和&#x3D;&#x3D;进行比较的区别</h4><p>equals和&#x3D;&#x3D;的区别，需要分情况讨论：</p>
<ol>
<li>没有重写 equals ，则 equals 和 &#x3D;&#x3D; 是一样的。</li>
<li>如果重写了 equals，则需看 equals 的方法实现。以 String 类为例：</li>
<li>equals 是比较字符串的内容是否一样；</li>
<li>&#x3D;&#x3D; 是比较字符串的堆内存地址是否一样，或者说引用的值是否相等。</li>
</ol>
<h4 id="String-s-new-String-“xxx”-创建了几个String对象"><a href="#String-s-new-String-“xxx”-创建了几个String对象" class="headerlink" title="String s &#x3D; new String(“xxx”);创建了几个String对象?"></a>String s &#x3D; new String(“xxx”);创建了几个String对象?</h4><ol>
<li>由于字符串字面量 <code>&quot;xxx&quot;</code> 出现在代码中，它会被放入 Java 字符串常量池中（如果常量池中还没有一个相同的字符串的话）。</li>
<li><code>new String(&quot;xxx&quot;)</code> 表达式将使用 <code>&quot;xxx&quot;</code> 字符串字面量作为参数创建一个新的 <code>String</code> 对象，并且这个新对象不在常量池中，而是在堆上分配。</li>
</ol>
<p>所以，如果常量池中之前没有 <code>&quot;xxx&quot;</code> 字符串，那么这条语句总共会创建两个字符串对象：一个在常量池中，一个在堆上。如果常量池中已经包含了 <code>&quot;xxx&quot;</code> 字符串，那么这条语句只会在堆上创建一个新的 <code>String</code> 对象。</p>
<p><code>String s = &quot;xxx&quot;;</code>只会创建一个 <code>String</code> 对象，或者一个都不创建。</p>
<h4 id="finally中的代码一定会执行吗？try里有return，finally还执行么"><a href="#finally中的代码一定会执行吗？try里有return，finally还执行么" class="headerlink" title="finally中的代码一定会执行吗？try里有return，finally还执行么"></a>finally中的代码一定会执行吗？try里有return，finally还执行么</h4><p><code>finally</code> 块中的代码几乎总是会被执行，即便 <code>try</code> 块中有 <code>return</code> 语句。<code>finally</code> 块的设计目的就是为了确保重要的清理工作总是会发生，比如关闭文件流或者数据库连接等。</p>
<p>当 <code>try</code> 块中的代码执行了 <code>return</code> 语句后，方法返回之前，<code>finally</code> 块中的代码会先被执行。之后，方法才真正返回。</p>
<p>只有在以下特殊情况下，<code>finally</code> 块不会被执行：</p>
<ul>
<li>在 <code>try</code> 或 <code>catch</code> 块中调用了 <code>System.exit()</code> 方法。</li>
<li>程序或线程崩溃，或者 <code>JVM</code> 由于某些原因挂掉了。</li>
<li>线程在 <code>finally</code> 块执行之前被中断或杀死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java异常机制中，异常Exception与错误Error区别"><a href="#Java异常机制中，异常Exception与错误Error区别" class="headerlink" title="Java异常机制中，异常Exception与错误Error区别"></a>Java异常机制中，异常Exception与错误Error区别</h4><p><code>Exception</code> 和 <code>Error</code> 都是 <code>Throwable</code> 的子类，它们都可以被 <code>throw</code> 和 <code>catch</code>。但它们通常代表着不同类型的问题，并且处理方式也不同。</p>
<p><strong>Exception</strong></p>
<p><code>Exception</code> 类代表了程序可以处理的异常情况。它们通常是由于程序错误或外部环境问题导致的。<code>Exception</code> 可以分为两类：</p>
<ul>
<li><strong>检查型异常（Checked Exceptions）</strong>：这类异常必须在编译时被捕获处理（<code>catch</code>）或者通过方法签名抛出（<code>throws</code>）。这类异常表示可恢复的条件，如 <code>IOException</code> 或 <code>SQLException</code>。</li>
<li><strong>非检查型异常（Unchecked Exceptions）</strong>：也称为运行时异常（<code>RuntimeException</code>），它们不需要显式的捕获处理。这些异常通常是程序逻辑错误，比如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。</li>
</ul>
<p><strong>Error</strong></p>
<p><code>Error</code> 类代表了严重的错误事件，这种情况下，JVM 无法继续运行。它们通常是描述系统级错误，如硬件故障、JVM 错误等。例如，<code>OutOfMemoryError</code> 表示 JVM 没有足够的内存继续执行，<code>StackOverflowError</code> 表示栈空间溢出。</p>
<ul>
<li><strong>不需要显式捕获</strong>：通常情况下，应用程序不应该捕获这类错误。它们是如此基础严重，以至于应用通常无法处理。</li>
<li><strong>预防而非恢复</strong>：对于错误，我们通常要通过编码和测试来预防它们，而不是在运行时尝试恢复。</li>
</ul>
<p>总结：</p>
<ul>
<li><code>Exception</code> 是程序可以预期并尝试恢复的条件。</li>
<li><code>Error</code> 是指在正常情况下，程序不应该尝试捕获的系统级错误。</li>
</ul>
<h4 id="序列Parcelable-Serializable的区别？"><a href="#序列Parcelable-Serializable的区别？" class="headerlink" title="序列Parcelable,Serializable的区别？"></a>序列Parcelable,Serializable的区别？</h4><p><strong>Serializable</strong></p>
<p><code>Serializable</code> 是Java原生序列化接口，其实现简单：</p>
<ul>
<li>只需实现 <code>java.io.Serializable</code> 接口，不需要实现任何方法，即可使类可序列化。</li>
<li>是一个标记接口，它告诉JVM该对象可以被序列化。</li>
<li>使用反射来序列化对象，这个过程相对较慢，并且会随着序列化对象的大小而增加更多的内存开销。</li>
<li>序列化过程会自动进行，不需要手动编写序列化过程。</li>
<li>适用于网络传输或者本地存储。</li>
</ul>
<p><strong>Parcelable</strong></p>
<p><code>Parcelable</code> 是Android特有的序列化机制，其设计目的是为了更高效的序列化，以便在Bundle中传递数据：</p>
<ul>
<li>需要实现 <code>android.os.Parcelable</code> 接口，并手动实现序列化过程。</li>
<li>性能高于 <code>Serializable</code>，因为它使用的是手动添加的序列化方法，不依赖于Java的反射机制。</li>
<li>虽然性能更好，但代码更复杂，因为开发者需要实现 <code>Parcelable</code> 接口的 <code>writeToParcel</code> 和 <code>createFromParcel</code> 方法。</li>
<li>主要用于Intent中在Activity或服务之间传递数据，不推荐用于网络传输或本地存储。</li>
</ul>
<p><strong>区别总结</strong></p>
<ul>
<li><strong>性能</strong>：<code>Parcelable</code> 通常比 <code>Serializable</code> 更快，因为它是为Android优化的。</li>
<li><strong>实现方式</strong>：<code>Serializable</code> 实现起来更简单，<code>Parcelable</code> 更复杂但提供了更好的性能。</li>
<li><strong>用途</strong>：<code>Parcelable</code> 通常用于Android中的IPC传输，<code>Serializable</code> 可用于IPC以及将对象持久化到文件或数据库。</li>
</ul>
<p>因此，在Android中，<strong>当需要在Activity和Fragment之间传递数据时，推荐使用<code>Parcelable</code>，因为它更加高效。如果需要通过网络发送对象或者将对象写入文件，<code>Serializable</code> 可能是一个更好的选择，因为它实现起来更简单，并且是Java平台的标准序列化方式。</strong></p>
<p>对于<code>Parcelable</code>，需要实现<code>Parcelable</code>接口并定义序列化和反序列化的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">User</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Parcelable</code>传递数据的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, AnotherActivity.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane Doe&quot;</span>, <span class="number">25</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;user_key&quot;</span>, user);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>在接收Activity中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getIntent().getParcelableExtra(<span class="string">&quot;user_key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>记住，<code>Parcelable</code>是Android推荐的方式，尤其是在需要频繁地序列化和反序列化，并且在应用内部传递复杂数据结构时。</p>
<h4 id="为什么Intent传递对象为什么需要序列化？"><a href="#为什么Intent传递对象为什么需要序列化？" class="headerlink" title="为什么Intent传递对象为什么需要序列化？"></a>为什么Intent传递对象为什么需要序列化？</h4><p>在Android中使用Intent传输数据除了基本数据类型之外，对于其他类型对象需要此类型实现了Serializable或者Parcelable序列化接口才能进行传输。</p>
<p>Intent传输数据本质上是使用Binder来完成的。Intent启动组件需要借助AMS完成，因此startActivity 会离开当前应用进程，进入AMS所在的system_server进程进行跨进程通信。<strong>这就意味着传输的对象需要在不同进程之间进行传输。为了保护不同进程互不干扰，进程隔离让system_server进程无法直接获取应用进程内存中的对象。</strong>因此必须通过类似于复制的手段，将应用进程的对象传递给system_server进程，再由system_server进程传递给应用中的 OtherActivity 。</p>
<h4 id="kotlin中进行序列化的方式"><a href="#kotlin中进行序列化的方式" class="headerlink" title="kotlin中进行序列化的方式"></a>kotlin中进行序列化的方式</h4><p>在 Kotlin 中，序列化也可以通过两种主要方式实现：使用标准 Java 的 <code>Serializable</code> 接口，或者使用 Kotlin 特有的 <code>Parcelize</code> 插件来实现 <code>Parcelable</code> 接口。</p>
<p><strong>使用 Serializable</strong></p>
<p>与 Java 相同，你可以简单地通过让类实现 <code>Serializable</code> 接口来使类可序列化。Kotlin 代码更加简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlinCopy codeimport java.io.Serializable</span><br><span class="line"></span><br><span class="line">data class User(val name: String, val age: Int) : Serializable</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中，通常推荐使用数据类（<code>data class</code>）来存储序列化数据，因为它们自动为你的字段生成 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。</p>
<p><strong>使用 Parcelable</strong></p>
<p>Kotlin 为 <code>Parcelable</code> 实现提供了一个名为 <code>@Parcelize</code> 的注解，这可以极大简化实现过程。首先，你需要在你的 <code>build.gradle</code> 文件中启用 <code>kotlin-android-extensions</code> 插件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-android-extensions&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以如下定义一个实现 <code>Parcelable</code> 的数据类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"><span class="keyword">import</span> kotlinx.parcelize.Parcelize</span><br><span class="line"></span><br><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) : Parcelable</span><br></pre></td></tr></table></figure>

<p>这样，编译器会自动为你生成所有必要的 <code>Parcelable</code> 实现细节。</p>
<p><strong>注意事项</strong></p>
<p>如果你打算在多个平台上使用序列化，比如在 JVM 和 Android 上，你可能会考虑使用 Kotlin 的 <code>kotlinx.serialization</code> 库，它提供了一个跨平台的序列化框架。</p>
<p>下面是一个使用 <code>kotlinx.serialization</code> 库的例子：</p>
<p>首先，在 <code>build.gradle</code> 文件中添加序列化库的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.2.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以像这样使用 <code>@Serializable</code> 注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.serialization.Serializable</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>这个库提供了丰富的序列化和反序列化选项，包括 JSON、Protobuf 和 CBOR 等格式。这可以是一个在 Kotlin 中进行复杂序列化任务的强大工具。</p>
<h4 id="Java中变量的存储"><a href="#Java中变量的存储" class="headerlink" title="Java中变量的存储"></a>Java中变量的存储</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在 <code>Main</code> 类中，<code>a</code>、<code>s</code> 和 <code>str</code> 被称为实例变量（Instance Variables）或成员变量（Member Variables）。这些变量属于类的每个实例，因此每个 <code>Main</code> 类的对象都会有自己的一份 <code>a</code>、<code>s</code> 和 <code>str</code> 变量的副本。它们的值可以在对象之间独立变化。</p>
<p>​		创建 <code>Main</code> 类的一个实例时，像 <code>a</code> 这样的基本类型实例变量会在堆内存的对象分配区域中为该特定对象分配空间，并存储其值。每个 <code>Main</code> 对象都会有自己的 <code>a</code> 变量副本，它们是相互独立的。</p>
<p>​		</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 基本数据类型的局部变量</span></span><br><span class="line">    <span class="type">Main</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>(); <span class="comment">// 在方法中创建一个对象实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>localVar</code> 是一个基本数据类型的局部变量，它存储在栈内存中。当 <code>myMethod</code> 方法被调用时，<code>localVar</code> 被创建并存储在方法的栈帧中。当 <code>myMethod</code> 方法执行完成后，<code>localVar</code> 会随着栈帧的销毁而销毁。</p>
<p><strong>基本数据类型的局部变量通常存储在栈内存中，而基本数据类型的实例变量（作为对象的一部分）存储在堆内存中。</strong></p>
<p>​		obj是new Main()所创建的对象的引用，对象的引用（通常是一个局部变量）会存储在栈内存中，这个对象及其实例变量会存储在堆内存中。</p>
<h4 id="怎么理解Java中的多态"><a href="#怎么理解Java中的多态" class="headerlink" title="怎么理解Java中的多态"></a>怎么理解Java中的多态</h4><p>​		用白话来说，就是多个对象调用同一个方法，得到不同的结果。</p>
<p><strong>方法重写（Override）：</strong> 子类可以覆盖（重写）父类的方法，实现自己特定的行为。父类引用可以指向子类对象，并且在运行时将调用子类的方法，这称为动态方法调度。这种多态性可以实现基于继承的多态。</p>
<p><strong>接口多态性：</strong> Java中，多个类可以实现同一个接口，然后使用接口类型的引用来引用这些不同的对象，从而实现接口多态性。这允许不同的类以统一的方式执行相同的接口定义的操作。</p>
<h4 id="什么是Java对象，不生成实例就不是对象吗"><a href="#什么是Java对象，不生成实例就不是对象吗" class="headerlink" title="什么是Java对象，不生成实例就不是对象吗"></a>什么是Java对象，不生成实例就不是对象吗</h4><p>​		如果没有生成实例，那么就没有对象。在 Java 中，对象是根据类创建的一个实例。类是一个蓝图，定义了对象的属性和行为。当使用 <code>new</code> 关键字和构造器来创建类的实例时，就创建了一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>person</code> 是一个指向 <code>Person</code> 对象的引用，这个对象有 <code>name</code> 和 <code>age</code> 这两个属性。</p>
<p>​		对象是类的具体实例，它们在内存中占用空间，并拥有实际的状态（属性值）和行为（方法）。在没有创建实例的情况下，只有类的定义，而没有实际的对象。</p>
<h4 id="java中的foreash和普通for循环对比"><a href="#java中的foreash和普通for循环对比" class="headerlink" title="java中的foreash和普通for循环对比"></a>java中的foreash和普通for循环对比</h4><p><strong>普通<code>for</code>循环</strong></p>
<p>普通<code>for</code>循环使用索引来访问元素，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javafor (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    // 访问元素 array[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遍历数组或<code>ArrayList</code>时，普通<code>for</code>循环通常会有更好的性能，因为它直接通过索引访问元素，这在内存中是连续的，因此访问速度快。但是，当遍历<code>LinkedList</code>时，普通<code>for</code>循环的性能会显著下降，因为每次通过索引访问元素都需要从链表头开始遍历，导致时间复杂度为O*(*n方)</p>
<p><strong><code>foreach</code>循环</strong></p>
<p><code>foreach</code>循环是基于迭代器的遍历方式，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javafor (ElementType element : collection) &#123;</span><br><span class="line">    // 访问元素 element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foreach</code>循环在遍历<code>ArrayList</code>时与普通<code>for</code>循环性能相近，但在遍历<code>LinkedList</code>时性能要优于普通<code>for</code>循环，因为它使用迭代器按顺序访问元素，每次调用<code>next()</code>方法的时间复杂度为O*(1)，因此总的时间复杂度为O*(<em>n</em>)</p>
<p>性能比较</p>
<ul>
<li>对于数组或<code>ArrayList</code>，普通<code>for</code>循环通常比<code>foreach</code>循环快，尤其是在数据量较大时</li>
<li>对于<code>LinkedList</code>，<code>foreach</code>循环比普通<code>for</code>循环快得多，因为普通<code>for</code>循环需要从链表头开始遍历以访问每个元素，而<code>foreach</code>循环则不需要</li>
</ul>
<p>结论</p>
<ul>
<li>基于数组实现的集合，使用普通for循环遍历数据</li>
<li>基于链表实现的集合，使用增强型for循环遍历数据</li>
</ul>
<h4 id="Classloader-类加载机制"><a href="#Classloader-类加载机制" class="headerlink" title="Classloader 类加载机制"></a>Classloader 类加载机制</h4><h3 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h3><h4 id="泛型是什么，泛型擦除呢？"><a href="#泛型是什么，泛型擦除呢？" class="headerlink" title="泛型是什么，泛型擦除呢？"></a>泛型是什么，泛型擦除呢？</h4><p>在 Java 中，泛型用于在编译时提供类型检查并消除类型转换的需要。泛型让你可以编写更通用、更安全的代码，因为它们让你在类、接口和方法上定义类型参数。</p>
<p>例如，一个泛型类 <code>Box&lt;T&gt;</code> 可以存储任何类型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个类型参数，它可以在创建 <code>Box</code> 对象时被替换为任何类型，例如 <code>Integer</code>、<code>String</code> 等。</p>
<p><strong>泛型擦除</strong> (Type Erasure)</p>
<p>泛型擦除是 Java 泛型的一种实现机制。在编译时，泛型类型参数会被擦除，替换为它们的边界（如果有的话）或者 <code>Object</code>。这意味着在运行时，泛型信息是不可用的，所有泛型类型都被视为原始类型（raw types）。</p>
<p>例如，考虑以下泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在编译时，泛型类型参数 <code>String</code> 会被擦除，因此在运行时，<code>list</code> 的类型实际上就是 <code>List</code>，而不是 <code>List&lt;String&gt;</code>。</p>
<p>泛型擦除的主要目的是为了确保 Java 泛型的向后兼容性。这意味着使用泛型的 Java 代码可以与不支持泛型的旧版 Java 代码互操作。</p>
<h4 id="List能否转为List"><a href="#List能否转为List" class="headerlink" title="List能否转为List"></a>List<String>能否转为List<Object></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br></pre></td></tr></table></figure>

<p>因此List<String>其实能够强转为List<Object>。但是存在隐患：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br><span class="line">objects.add(<span class="number">123</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码使用objects（List<Object> ）向集合中增加整型数据：123。然后通过 strs获取数据时，因为其类型为List<String>，但是真实数据类型为整型。此时就会发生运行时异常</p>
<h4 id="Java的泛型中super-和-extends-有什么区别？"><a href="#Java的泛型中super-和-extends-有什么区别？" class="headerlink" title="Java的泛型中super 和 extends 有什么区别？"></a>Java的泛型中super 和 extends 有什么区别？</h4><p>? extends T 为上界通配符，也就是说限制类型只能是T 或者 T 的派生类</p>
<p>? super T 为通配符下界，也就是说限制类型只能是T 或者T的超类。</p>
<p>生产使用extends，消费使用super。结合上下界的特点可知：<br>经常读取数据，使用Extends；<br>经常加入数据，使用Super；</p>
<h4 id="注解是什么？有哪些使用场景？"><a href="#注解是什么？有哪些使用场景？" class="headerlink" title="注解是什么？有哪些使用场景？"></a>注解是什么？有哪些使用场景？</h4><p>注解（Annotations）是 Java 提供的一种元数据形式，它允许在代码中添加信息，这些信息可以在编译时、类加载时或运行时被读取和处理。注解本身不会直接影响程序的操作，但它们可以被编译器或运行时环境用来生成额外的代码、执行额外的检查或者在运行时改变行为。</p>
<h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><h4 id="假如只有一个cpu，单核，多线程还有用吗-？"><a href="#假如只有一个cpu，单核，多线程还有用吗-？" class="headerlink" title="假如只有一个cpu，单核，多线程还有用吗 ？"></a>假如只有一个cpu，单核，多线程还有用吗 ？</h4><p>CPU的执行速度要远大于IO的过程，因此在大多数情况下增加一些复杂的CPU计算都比增加一次IO要快。单核CPU可以通过给每个线程分配CPU时间片（时间单元）来实现多线程机制。由于CPU频率很高，故时间单元非常短。所以单核也可以实现多线程机制。</p>
<h4 id="sychronied修饰普通方法和静态方法的区别？什么是可见性"><a href="#sychronied修饰普通方法和静态方法的区别？什么是可见性" class="headerlink" title="sychronied修饰普通方法和静态方法的区别？什么是可见性?"></a>sychronied修饰普通方法和静态方法的区别？什么是可见性?</h4><p>sychronied是Java中并发编程的重要关键字之一。在并发编程中synchronized一直是解决线程安全问<br>题，它可以保证原子性，可见性，以及有序性。</p>
<ul>
<li>原子性：原子是构成物质的基本单位，所以原子的意思代表着—“不可分”。由不可分可知，具有原<br>子性的操作也就是拒绝线程调度器中断。</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到，称为可见性。</li>
<li>有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序中语句的顺序，但是不会影响最终的结果。有序性经典的例子就是利用DCL双重检查创建单例对象。</li>
</ul>
<p>synchronized可以修饰方法，也能够使用 synchronized(obj){} 定义同步代码块。修饰方法：</p>
<ol>
<li>实例方法也就是普通方法，作用于当前实例加锁，进入方法前需要获取当前实例的锁;</li>
<li>静态方法，作用于当前类对象加锁，进入方法前需要获取当前类对象的锁;修饰代码块，指定加锁对象，对给定对象加锁，进入代码块前要获得给定对象的锁。</li>
</ol>
<h4 id="Synchronized在JDK1-6之后做了哪些优化"><a href="#Synchronized在JDK1-6之后做了哪些优化" class="headerlink" title="Synchronized在JDK1.6之后做了哪些优化"></a>Synchronized在JDK1.6之后做了哪些优化</h4><p>jdk1.6以后为了减少获得锁和释放锁带来的性能消耗，对synchronized锁进行了优化，引入了偏向锁、轻量级锁、重量级锁;</p>
<p><strong>Java对象头</strong></p>
<p>对象在虚拟机内存中的布局分为三块区域：对象头、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里。对象头由：存储对象自身的运行时数据的Mark Word 32位系统中4 + 指向类的指针 kClass pointer ,如果是数组对象还会有数组长度 Array Length。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<ul>
<li><p><strong>「偏向锁」</strong>：</p>
<p>当一个线程第一个访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。<strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
</li>
<li><p><strong>「轻量级锁」：</strong></p>
</li>
</ul>
<p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<ul>
<li><strong>「重量级锁」：</strong>这时候的主要操作就在monitor了</li>
</ul>
<p>膨胀过程：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将Contention List中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h4 id="CAS无锁编程的原理"><a href="#CAS无锁编程的原理" class="headerlink" title="CAS无锁编程的原理"></a>CAS无锁编程的原理</h4><p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<ol>
<li><p>在内存地址V当中，存储着值为10的变量</p>
</li>
<li><p>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11。</p>
</li>
<li><p>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
</li>
<li><p>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交<br>失败。因为线程2已经将内存地址V的变量值修改为了11</p>
</li>
<li><p>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A&#x3D;11，B&#x3D;12。<br>这个重新尝试的过程被称为自旋。</p>
</li>
<li><p>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相<br>等的。</p>
</li>
<li><p>线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
</li>
</ol>
<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>ABA问题：CAS 设计机制就是获取某两个时刻(初始预期值和当前内存值)变量值，并进行比较更新，所以说如果<strong>在获取初始预期值和当前内存值这段时间间隔内，变量值由 A 变为 B 再变为 A，那么对于 CAS 来说是不可感知的</strong>，但实际上变量已经发生了变化；解决办法是在每次获取时加版本号，并且每次更新对版本号 +1，这样当发生 ABA 问题时通过版本号可以得知变量被改动过。</p>
<h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>是一个用于构建锁和同步器的框架。它能降低构建锁和同步器的工作量，还可以避免处理多个位置上发生的竞争问题。在基于AQS构建的同步器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS支持独占锁（exclusive）和共享锁(share)两种模式。</p>
<ol>
<li>独占锁：只能被一个线程获取到(Reentrantlock)。</li>
<li>共享锁：可以被多个线程同时获取(CountDownLatch,ReadWriteLock)。</li>
</ol>
<blockquote>
<p>​	无论是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取。state是一个原子的int变量，用来表示锁状态、资源数等</p>
</blockquote>
<p><strong>公平锁的实现</strong></p>
<p>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，<strong>如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</strong>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大</p>
<p><strong>非公平锁的实现</strong></p>
<p><strong>直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h4 id="Synchronized的原理以及与ReentrantLock的区别。"><a href="#Synchronized的原理以及与ReentrantLock的区别。" class="headerlink" title="Synchronized的原理以及与ReentrantLock的区别。"></a>Synchronized的原理以及与ReentrantLock的区别。</h4><p>Synchronized <strong>的原理</strong></p>
<p><code>synchronized</code> 是 Java 中的一个关键字，用于实现线程同步，保证多线线程访问共享资源时的线程安全。<code>synchronized</code> 可以用来修饰方法或代码块。</p>
<ul>
<li><strong>修饰方法</strong>：当一个线程访问某个对象的 synchronized 方法时，该线程会自动获取该对象的锁，其他线程如果也想访问这个对象的 synchronized 方法，就必须等待当前线程释放锁后才能继续执行。</li>
<li><strong>修饰代码块</strong>：可以指定加锁的对象，只有获取到指定对象的锁的线程才能执行这个代码块。</li>
</ul>
<p><code>synchronized</code> 的底层实现主要依赖于 JVM 中的 Monitor（监视器锁）。当一个线程进入 synchronized 修饰的方法或代码块时，它会自动获取 Monitor 的所有权，退出时自动释放 Monitor 的所有权。如果其他线程也想获取这个 Monitor 的所有权，就必须等待当前线程释放。</p>
<p><strong>ReentrantLock</strong></p>
<p><code>ReentrantLock</code> 是 Java 并发包 <code>java.util.concurrent.locks</code> 中的一个类，提供了比 <code>synchronized</code> 更加灵活的锁定机制。<code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，并提供了丰富的功能，如可中断的锁获取、公平锁、锁绑定多个条件等。</p>
<p><strong>Synchronized 与 ReentrantLock 的区别</strong></p>
<ol>
<li><strong>锁的实现方式</strong>：<code>synchronized</code> 是基于 JVM 实现的内置锁机制，而 <code>ReentrantLock</code> 是基于 Java 代码实现的。</li>
<li><strong>锁的获取和释放</strong>：<code>synchronized</code> 自动管理锁的获取和释放，而 <code>ReentrantLock</code> 需要手动获取和释放锁，通常使用 <code>try-finally</code> 语句块确保锁的释放。</li>
<li><strong>等待可中断</strong>：<code>ReentrantLock</code> 提供了一个可以响应中断的锁获取方法（<code>lockInterruptibly()</code>），而 <code>synchronized</code> 不具备这一特性。</li>
<li><strong>公平性</strong>：<code>ReentrantLock</code> 可以设置为公平锁，即按照线程请求锁的顺序来获取锁，而 <code>synchronized</code> 则不保证公平性。</li>
<li><strong>条件变量支持</strong>：<code>ReentrantLock</code> 提供了 <code>Condition</code> 类，支持更加灵活的线程间协调，相当于 Object 类的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法的高级版本。</li>
</ol>
<h4 id="volatile关键字干了什么？（什么叫指令重排）"><a href="#volatile关键字干了什么？（什么叫指令重排）" class="headerlink" title="volatile关键字干了什么？（什么叫指令重排）"></a>volatile关键字干了什么？（什么叫指令重排）</h4><p>volatile是java提供的可以声明在成员属性前的一个关键字。在声明中包含此关键字的作用有：<br><strong>保证内存可见性</strong><br>可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。</p>
<p><strong>禁止指令重排</strong></p>
<p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。</p>
<p>volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，<strong>指令重排序时不能把后面的指令重排序到内存屏障之前，也不能把前面的指令重排序到内存屏障之后。</strong>这样确保了在一个线程修改了 <code>volatile</code> 变量的值后，其他线程能够看到这个修改。</p>
<p><strong>禁止指令重排的原理</strong><br>volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JVM内存屏障插入策略：<br>在每个volatile写操作的前面插入一个StoreStore屏障；<br>在每个volatile写操作的后面插入一个StoreLoad屏障；<br>在每个volatile读操作的后面插入一个LoadLoad屏障；<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<p>代码使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instance&#x3D; new Singleton()并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br><span class="line">instance =memory; <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2。所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">instance =memory; <span class="comment">//3：instance指向刚分配的内存地址，此时对象还未初始化</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br></pre></td></tr></table></figure>

<p>指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</p>
<p>优化后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile-能否保证线程安全？在DCL上的作用是什么？"><a href="#volatile-能否保证线程安全？在DCL上的作用是什么？" class="headerlink" title="volatile 能否保证线程安全？在DCL上的作用是什么？"></a>volatile 能否保证线程安全？在DCL上的作用是什么？</h4><p>volatile无法保证线程安全，只能保证变量的可见性，并不能保证变量操作的原子性。原子性指的是一个或者多个操作在 CPU 执行的过程中不被中断的特性。</p>
<p>因为volatile不能保证变量操作的原子性，所以试图通过volatile来保证线程安全性是不靠谱的。<br>volatile在DCL上的作用是防止对象发生指令重排而引起的异常问题。</p>
<h4 id="volatile和synchronize有什么区别？"><a href="#volatile和synchronize有什么区别？" class="headerlink" title="volatile和synchronize有什么区别？"></a>volatile和synchronize有什么区别？</h4><ul>
<li>volatile 只能作用于变量，synchronized 可以作用于变量、方法、对象。</li>
<li>volatile 只保证了可见性和有序性，无法保证原子性，synchronized 可以保证线程间的有序性（个人猜测是无法保证线程内的有序性，即线程内的代码可能被 CPU 指令重排序）、原子性和可见性。</li>
<li>volatile 线程不阻塞，synchronized 线程阻塞。</li>
<li>volatile 本质是告诉 jvm 当前变量在寄存器中的值是不安全的需要从内存中读取；sychronized 则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞。</li>
<li>volatile标记的变量不会被编译器优化， synchronized标记的变量可以被编译器优化</li>
</ul>
<h4 id="死锁的场景和解决方案"><a href="#死锁的场景和解决方案" class="headerlink" title="死锁的场景和解决方案"></a>死锁的场景和解决方案</h4><p><strong>死锁的定义</strong><br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<p>死锁的发生必须具备以下四个必要条件。</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<h4 id="锁分哪几类？"><a href="#锁分哪几类？" class="headerlink" title="锁分哪几类？"></a>锁分哪几类？</h4><ul>
<li>乐观锁&#x2F;悲观锁</li>
</ul>
<blockquote>
<p>乐观锁：获取数据时认为不会被其他线程修改，所以不会上锁，但是在更新的时候会判断其他线程是否修改此数据，如果被其他线程修改，则会发生自旋。<br>悲观锁：总是假设最坏的情况，获取数据时都认为其他线程会修改，因此在获取数据时都会上锁，<br>这样保证其他线程需要等待获取锁的线程处理完成并且释放锁</p>
</blockquote>
<ul>
<li>独享锁&#x2F;共享锁</li>
</ul>
<blockquote>
<p>独享锁是指该锁一次只能被一个线程所持有。</p>
<p>共享锁是指该锁可被多个线程所持有。</p>
</blockquote>
<ul>
<li>互斥锁&#x2F;读写锁</li>
</ul>
<blockquote>
<p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</p>
<p>互斥锁在Java中的具体实现就是ReentrantLock。<br>读写锁在Java中的具体实现就是ReadWriteLock。</p>
</blockquote>
<ul>
<li>可重入锁</li>
</ul>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。synchronized与ReetrantLock都是可重入锁。可重入锁的一个好处就是可以在一定程度避免死锁。</p>
<p>就是同一个线程内一个加锁方法内部调用另一个加锁方法，内层方法会自动获取锁。</p>
<ul>
<li>公平锁&#x2F;非公平锁</li>
</ul>
<blockquote>
<p>公平锁是指多个线程按照申请锁的顺序获取锁，非公平锁则是指多个线程获取锁的顺序并不是按照申请<br>锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</p>
</blockquote>
<ul>
<li>分段锁</li>
</ul>
<blockquote>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁。</p>
</blockquote>
<ul>
<li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</li>
</ul>
<blockquote>
<p>这三种锁是指锁的状态，偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。<br>降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通<br>过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定<br>次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入<br>阻塞，性能降低。</p>
</blockquote>
<ul>
<li>自旋锁</li>
</ul>
<blockquote>
<p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好<br>处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
</blockquote>
<h4 id="Java多线程对同一个对象进行操作"><a href="#Java多线程对同一个对象进行操作" class="headerlink" title="Java多线程对同一个对象进行操作"></a>Java多线程对同一个对象进行操作</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int tickets = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sellTicket()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟卖票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> synchronized boolean sellTicket() &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tickets--;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出一张票，剩余票数：&quot;</span> + tickets);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 票已售罄！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSelling</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        TicketSeller ticketSeller = new TicketSeller();</span><br><span class="line">        Thread w1 = new Thread(ticketSeller, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread w2 = new Thread(ticketSeller, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread w3 = new Thread(ticketSeller, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？"><a href="#线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？" class="headerlink" title="线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？"></a>线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？</h4><p>不能 会抛异常 start后由创建进入就绪状态，不可逆</p>
<h4 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h4><p>守护线程，也叫Daemon线程，它是一种支持型、服务型线程，主要被用作程序中后台调度以及支持性工作，跟上层业务逻辑基本不挂钩。Java中垃圾回收线程就是一个典型的Daemon线程。</p>
<p><strong>使用标志位退出线程</strong><br>正常情况下线程的run方法执行完之后就会正常退出，如果想要中断执行的话可以在线程执行run方法过程中，通过一个自定义变量来决定是否还需要退出线程，若满足条件，则退出线程，反之继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 定义标志位，使用volatile，保证内存可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">				<span class="comment">// 循环打印运行日志</span></span><br><span class="line">                <span class="keyword">while</span> (!stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; isrunning&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 退出后，打印退出日志</span></span><br><span class="line">                <span class="keyword">if</span> (stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; is stop&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">		<span class="comment">// 让子线程执行100ms后，将stopFlag置为true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stopFlag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？"><a href="#sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？" class="headerlink" title="sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？"></a>sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？</h4><p>sleep、yield与join是线程方法，而wait则是Object方法：</p>
<ul>
<li>sleep ，释放cpu资源，不释放锁资源，如果线程进入sleep的话，释放cpu资源，如果外层包有Synchronize，那么此锁并没有释放掉。</li>
<li>wait，释放cpu资源，也释放锁资源，一般用于锁机制中 肯定是要释放掉锁的，因为notify并不会立即调起此线程，因此cpu是不会为其分配时间片的，也就是说wait 线程进入等待池，cpu不分时间片给它，锁释放掉。</li>
<li>yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li>
<li>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另<br>一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</li>
</ul>
<h4 id="sleep是可中断的么"><a href="#sleep是可中断的么" class="headerlink" title="sleep是可中断的么"></a>sleep是可中断的么</h4><p>sleep是可中断的</p>
<h4 id="怎么保证线程按顺序执行？如何实现线程排队"><a href="#怎么保证线程按顺序执行？如何实现线程排队" class="headerlink" title="怎么保证线程按顺序执行？如何实现线程排队 ?"></a>怎么保证线程按顺序执行？如何实现线程排队 ?</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>, <span class="keyword">private</span> <span class="keyword">val</span> nextLetter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentLetter != letter) &#123;</span><br><span class="line">                    (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).wait()</span><br><span class="line">                &#125;</span><br><span class="line">                print(letter)</span><br><span class="line">                currentLetter = nextLetter</span><br><span class="line">                (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).notifyAll()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = PrintABC(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> b = PrintABC(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> c = PrintABC(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> threadA = Thread(a)</span><br><span class="line">    <span class="keyword">val</span> threadB = Thread(b)</span><br><span class="line">    <span class="keyword">val</span> threadC = Thread(c)</span><br><span class="line"></span><br><span class="line">    threadA.start()</span><br><span class="line">    threadB.start()</span><br><span class="line">    threadC.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kotlin协程实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.Mutex</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.withLock</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printLetter</span><span class="params">(lock: <span class="type">Mutex</span>, condition: <span class="type">Condition</span>, letter: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    lock.withLock &#123;</span><br><span class="line">        <span class="keyword">while</span> (PrintABC.currentLetter != letter) &#123;</span><br><span class="line">            condition.await()</span><br><span class="line">        &#125;</span><br><span class="line">        print(letter)</span><br><span class="line">        PrintABC.currentLetter = <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">            <span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&#x27;B&#x27;</span></span><br><span class="line">            <span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&#x27;C&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> lock: Mutex, <span class="keyword">private</span> <span class="keyword">val</span> conditionA: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionB: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionC: Condition, <span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">                <span class="string">&#x27;A&#x27;</span> -&gt; printLetter(lock, conditionA, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;B&#x27;</span> -&gt; printLetter(lock, conditionB, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;C&#x27;</span> -&gt; printLetter(lock, conditionC, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> lock = Mutex()</span><br><span class="line">    <span class="keyword">val</span> conditionA = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionB = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionC = Condition(lock)</span><br><span class="line"></span><br><span class="line">    launch &#123; PrintABC(lock, conditionA, conditionB, conditionC, <span class="string">&#x27;A&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionB, conditionA, conditionC, <span class="string">&#x27;B&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionC, conditionA, conditionB, <span class="string">&#x27;C&#x27;</span>).run() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="非阻塞式生产者消费者如何实现"><a href="#非阻塞式生产者消费者如何实现" class="headerlink" title="非阻塞式生产者消费者如何实现"></a>非阻塞式生产者消费者如何实现</h4><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>七大参数</p>
<ol>
<li>corePoolSize<br>线程池中的常驻核心线程数</li>
<li>maximumPoolSize<br>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime<br>空闲线程的存活时间。</li>
<li>unit<br>keepAliveTime的单位</li>
<li>workQueue<br>任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory<br>表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</li>
<li>handler：<br>拒绝策略，表示当队列满了并且工作线程大于等于线程池最大线程数（maximumPoolSize）时如<br>何处理</li>
</ol>
<p>使用JDK中自带的线程池可以通过创建ThreadPoolExecutor线程池对象，也能够通过Executors中定义的静态方法。其中Executors静态方法创建的线程池主要有以下类型：</p>
<p>1.newSingleThreadExecutor<br>        创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)<br>适用：一个任务一个任务执行的场景<br>2.newCachedThreadPool<br>        当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。<br>适用:执行很多短期异步的场景</p>
<p>3.newFixedThreadPool<br>        创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)，但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。<br>适用:长期执行的场景</p>
<p>4.NewScheduledThreadPool</p>
<p>​		创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构<br>适用:周期性执行的场景</p>
<h4 id="如何开启一个线程，开启大量线程会有什么问题，如何优化？"><a href="#如何开启一个线程，开启大量线程会有什么问题，如何优化？" class="headerlink" title="如何开启一个线程，开启大量线程会有什么问题，如何优化？"></a>如何开启一个线程，开启大量线程会有什么问题，如何优化？</h4><p>开启线程的方式：</p>
<p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyThread run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口，并实现内部run方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyRunnable run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程内存<br>在Java中每个线程需要分配线程内存，用来存储自身的线程变量。在JDK 1.4中每个线程是256K的内存，<br>在JDK 1.5之后每个线程是1M的内存。</p>
<h4 id="HandlerThread是什么？"><a href="#HandlerThread是什么？" class="headerlink" title="HandlerThread是什么？"></a>HandlerThread是什么？</h4><p><strong>HandlerThread 是一个特殊的线程类，它内部拥有一个 Looper 对象，使得它可以拥有自己的消息循环。这使得 HandlerThread 能够像主线程一样处理消息和任务，非常适合用于需要执行多个任务或频繁操作数据库、文件和网络的场景。</strong></p>
<p><strong>使用场景：</strong> 与普通的 Thread 相比，HandlerThread 的优势在于它可以重复使用来执行多个任务，而不需要每次都创建新的线程。这不仅减少了资源消耗，还可以简化代码，因为你可以通过向 HandlerThread 的 Handler 发送消息来排队执行任务，而不需要手动管理线程的生命周期。这使得 HandlerThread 成为在后台线程中执行串行任务的理想选择。</p>
<h4 id="AsyncTask的原理"><a href="#AsyncTask的原理" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p><code>AsyncTask</code> 是 Android 中用于简化异步操作的一个抽象类。它允许你在后台线程中执行长时间运行的操作，然后在主线程中更新 UI。</p>
<p><code>AsyncTask</code> 是 Android 中用于简化异步操作的一个抽象类。它允许你在后台线程中执行长时间运行的操作，然后在主线程中更新 UI。<code>AsyncTask</code> 的工作原理大致如下：</p>
<ol>
<li><strong>执行任务</strong>：当你创建一个 <code>AsyncTask</code> 的子类并调用 <code>execute()</code> 方法时，**<code>AsyncTask</code> 会在内部使用线程池（<code>Executor</code>）来启动一个新的线程。**</li>
<li><strong>后台处理</strong>：在新线程中，<code>doInBackground(Params...)</code> 方法会被调用。这是你执行长时间运行操作的地方，例如网络请求、数据库操作等。这个方法运行在后台线程中，所以它不会阻塞主线程。</li>
<li><strong>进度更新</strong>：如果你需要在任务执行过程中更新 UI（例如显示进度条），你可以在 <code>doInBackground()</code> 方法中调用 <code>publishProgress(Progress...)</code> 方法。这将触发 <code>onProgressUpdate(Progress...)</code> 方法的调用，该方法运行在主线程中，可以安全地更新 UI。</li>
<li><strong>任务完成</strong>：当 <code>doInBackground()</code> 方法完成后，返回的结果会被传递给 <code>onPostExecute(Result)</code> 方法。这个方法也运行在主线程中，你可以在这里更新 UI 或进行其他操作，以响应任务的完成。</li>
</ol>
<p><code>AsyncTask</code> 的一个重要特点是它提供了一种机制，使得在不同线程中执行的代码能够安全地与 UI 交互。</p>
<p>AsyncTask中的任务在4.0以上是串行执行的，在 AsyncTask 中提交的任务默认都会通过：</p>
<h4 id="Android中操作多线程的方式有哪些？"><a href="#Android中操作多线程的方式有哪些？" class="headerlink" title="Android中操作多线程的方式有哪些？"></a>Android中操作多线程的方式有哪些？</h4><p>常见的实现多线程的手段有五种：<br>第一种：Thread，Runnable<br>第二种：HandlerThread<br>第三种：AsyncTask<br>第四种：Executor<br>第五种：IntentService</p>
<h4 id="Android开发中怎样判断当前线程是否是主线程"><a href="#Android开发中怎样判断当前线程是否是主线程" class="headerlink" title="Android开发中怎样判断当前线程是否是主线程"></a>Android开发中怎样判断当前线程是否是主线程</h4><p>Android开发中, 有时需要判断当前线程到底是主线程, 还是子线程, 例如: 我们在自定义View时, 想要让View重绘, 需要先判断当前线程到底是不是主线程, 然后根据判断结果来决定到底是调用 invalidate()还是 postInvalidate() 方法。<br>在工作中获取当前的主线程，主要是借助Android中的Looper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread();</span><br><span class="line">Looper.getMainLooper().getThread().getId() == Thread.currentThread().getId();</span><br></pre></td></tr></table></figure>

<h4 id="线程间如何通信？"><a href="#线程间如何通信？" class="headerlink" title="线程间如何通信？"></a>线程间如何通信？</h4><p>Handler</p>
<h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><h4 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h4><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403042110717.png" alt="LinkedHashMap 逻辑结构"></p>
<p>其中的head节点和tail节点就像两个对链表操作的指针，不断的按照顺序移动。</p>
<h4 id="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"><a href="#Set底层存放怎么数据，是有序的还是无序的，可以重复吗" class="headerlink" title="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"></a>Set底层存放怎么数据，是有序的还是无序的，可以重复吗</h4><p>Set只是一个接口，其实现类有HashSet无序，TreeSet有序，不过都不允许有重复元素</p>
<p>Set集合不允许存储重复元素的实现原理主要依赖于其底层数据结构的特性。在Java中，Set接口的常用实现类如HashSet和TreeSet，分别使用哈希表和红黑树作为底层数据结构。</p>
<p>HashSet</p>
<p>HashSet是基于HashMap实现的。当向HashSet中添加元素时，HashSet会首先计算元素的hashCode值，然后根据这个hashCode值来找到在哈希表中的存储位置。如果该位置没有元素，则直接存储；如果该位置已经有元素存在，则通过equals方法来检查两个元素是否相等。如果equals方法返回true，表明两个元素相同，新元素就不会被添加到集合中。如果equals方法返回false，表明两个元素不同，新元素会被添加到集合中，这可能会导致哈希冲突，并通过链表或红黑树解决冲突</p>
<p>TreeSet</p>
<p>TreeSet是基于TreeMap实现的，TreeMap是一种红黑树结构。在TreeSet中，元素在插入时会进行排序，排序依据是元素的compareTo方法（如果元素实现了Comparable接口）或者Comparator比较器（如果在TreeSet的构造器中提供了Comparator）。如果两个元素通过compareTo或Comparator比较结果为0，表明两个元素相同，新元素就不会被添加到集合中</p>
<p>总结</p>
<p>无论是HashSet还是TreeSet，它们都不允许存储重复元素。这是通过元素的hashCode和equals方法（对于HashSet）或者compareTo方法（对于TreeSet）来实现的。当添加一个新元素时，这些方法被用来检查新元素是否与集合中已存在的元素相同。如果相同，则新元素不会被添加，从而保证了集合中元素的唯一性</p>
<h4 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h4><p>​		ConcurrentHashMap 使用 Node 数组加链表加红黑树的数据结构。在并发操作时使用synchronized锁住了链表的头节点或红黑树的根节点</p>
<h4 id="ConcurrentHashMap去get元素的时候有加锁吗？"><a href="#ConcurrentHashMap去get元素的时候有加锁吗？" class="headerlink" title="ConcurrentHashMap去get元素的时候有加锁吗？"></a>ConcurrentHashMap去get元素的时候有加锁吗？</h4><p>​		get元素没加锁，增删改查四个种类操作之后查一类的操作没有加锁</p>
<h4 id="Object-finalize了解吗，只要有GC就会调用吗？"><a href="#Object-finalize了解吗，只要有GC就会调用吗？" class="headerlink" title="Object finalize了解吗，只要有GC就会调用吗？"></a>Object finalize了解吗，只要有GC就会调用吗？</h4><p>​		<code>finalize()</code>方法的主要目的是在对象从内存中删除之前释放对象使用的资源。</p>
<p>​		<code>finalize()</code>方法在特定对象的垃圾回收之前被调用，<strong>当垃圾回收器确定不存在对该对象的更多引用时</strong>，对象的垃圾回收器就会调用这个方法。</p>
<p><a href="https://zhuanlan.zhihu.com/p/551713593">https://zhuanlan.zhihu.com/p/551713593</a></p>
<h4 id="Object-notify了解吗，自己平时写代码有用过吗？"><a href="#Object-notify了解吗，自己平时写代码有用过吗？" class="headerlink" title="Object notify了解吗，自己平时写代码有用过吗？"></a>Object notify了解吗，自己平时写代码有用过吗？</h4><p>Java Object 中的 wait() 和 <a href="https://so.csdn.net/so/search?q=notify&spm=1001.2101.3001.7020">notify</a>() 方法和synchronized 实现多线程的同步等待。</p>
<p><a href="https://blog.csdn.net/qq_22076345/article/details/107881591">https://blog.csdn.net/qq_22076345/article/details/107881591</a></p>
<h4 id="反射性能耗在哪里？"><a href="#反射性能耗在哪里？" class="headerlink" title="反射性能耗在哪里？"></a>反射性能耗在哪里？</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">https://pdai.tech/md/java/basic/java-basic-x-reflection.html</a></p>
<h4 id="new-String-内存优化"><a href="#new-String-内存优化" class="headerlink" title="new String()内存优化"></a>new String()内存优化</h4><ol>
<li><strong>直接使用字符串字面量</strong>：在Java中，字符串字面量（如<code>String s = &quot;example&quot;;</code>）会自动被存储在字符串池中。如果你试图创建一个已经在字符串池中存在的字符串，Java会直接返回对现有字符串的引用，而不会创建新的对象。这样可以节省内存。</li>
<li><strong>使用<code>String.intern()</code>方法</strong>：<code>String.intern()</code>方法会返回字符串对象在字符串池中的引用。如果字符串池中已经存在相同的字符串，<code>intern()</code>方法会返回现有字符串的引用；如果字符串池中不存在该字符串，<code>intern()</code>方法会将该字符串添加到字符串池中，然后返回新添加的字符串的引用。</li>
<li><strong>避免使用<code>+</code>操作符进行字符串拼接</strong>：在Java中，使用<code>+</code>操作符进行字符串拼接会在每次拼接时创建新的字符串对象。这可能会导致大量的内存浪费。为了避免这个问题，你可以使用<code>StringBuilder</code>或<code>StringBuffer</code>进行字符串拼接。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>kotlin面试题</title>
    <url>/2024/03/08/Kotlin%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="介绍一下kotlin的标准函数"><a href="#介绍一下kotlin的标准函数" class="headerlink" title="介绍一下kotlin的标准函数"></a>介绍一下kotlin的标准函数</h4><ul>
<li><p>下面是常用的四个标准函数，还有takeIf，takeUnless等等。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image.png" alt="image"></p>
</li>
</ul>
<p>作用：</p>
<ol>
<li><strong>可读性</strong>：标准库函数提供的功能可以用更简洁和具有描述性的方式来表达，这也使得代码更加易于理解和阅读。</li>
<li><strong>更少的样板代码</strong>：由于标准库函数将常见的操作封装在函数内部，因此，开发人员可以通过单行代码完成许多任务，这减少了样板代码的数量，并统一了代码的格式</li>
</ol>
<h4 id="分别应用于哪些场景？"><a href="#分别应用于哪些场景？" class="headerlink" title="分别应用于哪些场景？"></a><strong>分别应用于哪些场景？</strong></h4><ul>
<li><code>let</code> 和 <code>run</code> 通常用于需要对对象执行某些操作并返回结果的场景。</li>
<li><code>with</code> 适用于希望在一个特定对象上执行多个操作的场景。</li>
<li><code>also</code> 通常用于需要对对象进行链式操作并返回对象本身的场景。</li>
<li><code>apply</code> 适用于需要在对象上执行多个操作并返回对象本身的场景</li>
</ul>
<h4 id="kotlin的高级特性有哪些"><a href="#kotlin的高级特性有哪些" class="headerlink" title="kotlin的高级特性有哪些"></a>kotlin的高级特性有哪些</h4><ol>
<li><strong>Null安全</strong>：Kotlin通过内建的null安全支持来消除代码中的NullPointException。</li>
<li><strong>扩展函数</strong>：在Kotlin中，你可以为一个已存在的类添加新的函数，而不需要修改这个类的源代码。这就是扩展函数。</li>
<li><strong>默认参数和命名参数</strong>：Kotlin函数可以有默认参数值，这使得函数更加灵活。</li>
<li><strong>数据类</strong>：只需一个简单的<code>data</code>关键字，Kotlin就会为你生成equals() &#x2F; hashCode() &#x2F; toString()等通用的方法。</li>
<li><strong>Lambda表达式及高阶函数</strong>：Kotlin全面支持函数式编程，包括匿名函数，lambda表达式以及闭包。高阶函数是接受函数作为参数或返回函数的函数。</li>
<li><strong>协程</strong>：本质上，协程是轻量级的线程。它们在某些类似并发的情况下，可以替代线程，可以在一般情况下，可以以更少的开销和更少的复杂性来提供并发性。</li>
<li><strong>类型推断</strong>：Kotlin具有强大的类型推断能力，且语法简洁。这让我们能够写出简洁且类型安全的代码。</li>
<li><strong>集合操作符</strong>：对集合进行操作是日常任务的一部分，Kotlin提供了丰富的集合操作符（包括过滤、映射、归约等）。</li>
<li><strong>操作符重载</strong>：Kotlin允许你为自己的类型提供自定义的操作符。</li>
</ol>
<h4 id="suspend关键字怎么理解"><a href="#suspend关键字怎么理解" class="headerlink" title="suspend关键字怎么理解"></a>suspend关键字怎么理解</h4><p>​		标记一个函数为挂起函数。这种函数可以暂停执行当前的协程，并保存所有局部变量。</p>
<h4 id="使用协程的场景有哪些"><a href="#使用协程的场景有哪些" class="headerlink" title="使用协程的场景有哪些"></a>使用协程的场景有哪些</h4><ol>
<li><p><strong>异步任务</strong>：当任务需要在后台运行，而主线程需要保持空闲以维护UI响应时，这是使用协程的一个主要场景。比如，在Android开发中，网络请求、数据库查询等I&#x2F;O操作是最常使用协程进行异步操作的例子。</p>
</li>
<li><p><strong>并发执行多个任务</strong>：如果你需要同时执行多个任务，并且在所有任务完成后收集结果，那么协程的并发执行功能将非常有用。</p>
<p>在 Android 平台上协程主要就用来解决两个问题：</p>
<ol>
<li>处理耗时任务 (Long running tasks)，这种任务常常会阻塞主线程</li>
<li>保证主线程安全 (Main-safety)，即确保安全地从主线程调用任何 suspend 函数</li>
</ol>
</li>
</ol>
<h4 id="如何取消一个协程"><a href="#如何取消一个协程" class="headerlink" title="如何取消一个协程"></a>如何取消一个协程</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会返回一个Job对象，然后调用它的cancel方法可以取消作用域及其所有子协程。</p>
<h4 id="协程嵌套，子协程出现异常，协程会被取消吗"><a href="#协程嵌套，子协程出现异常，协程会被取消吗" class="headerlink" title="协程嵌套，子协程出现异常，协程会被取消吗"></a>协程嵌套，子协程出现异常，协程会被取消吗</h4><p>​		在Kotlin协程中，异常会自动向上传播，如果一个子协程抛出了异常，那么这个异常会被传递给它的父协程，如果父协程没有处理这个异常，那么这个异常会继续向上传递，直到被一个协程处理，或者传递到了顶层协程，导致整个协程作用域被取消。</p>
<p>解决方案：</p>
<p>使用SupervisorJob</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> supervisorJob = SupervisorJob()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main + supervisorJob)</span><br><span class="line"></span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用supervisorScope</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用async和await</p>
<p>​		子协程使用了<code>async</code>构建器，那么它会捕获所有的异常，并将这些异常封装在<code>Deferred</code>对象中，只有在调用<code>await</code>方法时，这些异常才会被抛出。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchMultipleData</span><span class="params">()</span></span>: List&lt;String&gt; = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> deferredOne = async &#123; fetchData1() &#125;</span><br><span class="line">    <span class="keyword">val</span> deferredTwo = async &#123; fetchData2() &#125;</span><br><span class="line">    listOf(deferredOne.await(), deferredTwo.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常取消子协程，父协程会被取消吗"><a href="#正常取消子协程，父协程会被取消吗" class="headerlink" title="正常取消子协程，父协程会被取消吗"></a>正常取消子协程，父协程会被取消吗</h4><p>​		取消子协程不会自动取消父协程，只有在子协程失败（抛出异常）并且这个失败没有被处理的情况下，父协程才会被取消。</p>
<h4 id="子协程正在异步运行，父协程取消，异步子协程会被取消吗"><a href="#子协程正在异步运行，父协程取消，异步子协程会被取消吗" class="headerlink" title="子协程正在异步运行，父协程取消，异步子协程会被取消吗"></a>子协程正在异步运行，父协程取消，异步子协程会被取消吗</h4><p>​		这是Kotlin协程结构化并发的一个重要特性结构化并发，确保了当父协程结束时，所有子协程也同时结束，避免了可能的资源泄露。</p>
<h4 id="页面中，比如在activity中，你会使用哪种协程"><a href="#页面中，比如在activity中，你会使用哪种协程" class="headerlink" title="页面中，比如在activity中，你会使用哪种协程"></a>页面中，比如在activity中，你会使用哪种协程</h4><p>使用MainScope来创建协程作用域之行协程方法，并在Activity的<code>onDestroy</code>方法中调用<code>myScope.cancel()</code>取消所有未完成的协程，以避免内存泄漏。</p>
<h4 id="协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗"><a href="#协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗" class="headerlink" title="协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗"></a>协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗</h4><p>​		如果没有正确地处理协程的取消，确实可能出现内存泄露。原因在于协程可能会长时间运行，并且关联的上下文可能会长时间引用Activity，阻止Activity被垃圾回收，从而导致内存泄露。为了避免这种情况，通常我们需要在Activity销毁时取消所有的协程。Kotlin库为此提供了一些内置的解决方案。</p>
<p>​		<code>androidx.lifecycle:lifecycle-viewmodel-ktx</code>库提供了<code>ViewModel</code>类，它包含一个被生命周期意识清理工具清理的协程作用域 <code>viewModelScope</code>。在ViewModel中启动的所有协程都应该在该作用域内，这样就可以确保在ViewModel清理时取消所有协程。</p>
<p>​		在activity被关闭时viewModelScope会自动取消所有协程。</p>
<h4 id="如何协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗"><a href="#如何协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗" class="headerlink" title="如何协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗"></a>如何协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗</h4><p>​		静态类的引用会阻止页面被垃圾回收器回收，这样页面的资源就不会被释放，从而导致内存泄漏。</p>
<h4 id="kotlin委托是什么"><a href="#kotlin委托是什么" class="headerlink" title="kotlin委托是什么"></a>kotlin委托是什么</h4><p>​		委托是一种设计模式，基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理</p>
<p>kotlin中为了减少模版代码，也支持委托功能，分为 <code>类委托</code> 和 <code>属性委托</code> 。</p>
<p><strong>类委托</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> kuKe = KuKe()</span><br><span class="line">    <span class="keyword">val</span> leiJun = LeiJun(kuKe)</span><br><span class="line">    leiJun.homeWork</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HomeWork</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KuKe</span>() : HomeWork &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;写作业写作业...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeiJun</span>(<span class="keyword">val</span> homeWork: HomeWork) : HomeWork <span class="keyword">by</span> homeWork</span><br></pre></td></tr></table></figure>

<p>雷军让他同学替他写作业</p>
<p><strong>属性委托</strong></p>
<p><strong>属性委托的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。</strong>原理是将这个属性的<code>get</code>&#x2F;<code>set</code>方法委托给另一个类去实现。</p>
<p>kotlin标准库提供了两个接口用来给属性实现委托</p>
<p><code>thisRef</code> —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；</p>
<p><code>property</code> —— 必须是类型 <code>KProperty&lt;*&gt;</code>或其超类型。</p>
<p><code>value</code> —— 必须与属性同类型或者是它的子类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于val属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyProperty</span>&lt;<span class="type">in R, out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于var属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in R, T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后可以自定义委托属性的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a : <span class="built_in">Int</span> <span class="keyword">by</span> Delegate2()</span><br><span class="line">    println(a)</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate2</span>: <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any?, Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1123</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1123</span></span><br><span class="line">setValue <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>延迟属性</strong> </p>
<p>​		参数默认是SYNCHRONIZED</p>
<p>​		第一次调用 <code>get()</code> 会执行已传递给 <code>lazy()</code> 的 lambda 表达式并记录结果， 后续调用 <code>get()</code> 只是返回记录的结果。它委托了属性的初始化逻辑给 <code>Lazy</code> 类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> student <span class="keyword">by</span> lazy &#123; Student() &#125;</span><br></pre></td></tr></table></figure>

<p><strong>可观察委托</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observableProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;初始值：xxx&quot;</span>)&#123;</span><br><span class="line">    property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;property: <span class="variable">$property</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span> &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    observableProp = <span class="string">&quot;第一次修改值&quot;</span></span><br><span class="line">    observableProp = <span class="string">&quot;第二次修改值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property: <span class="keyword">var</span> observableProp: kotlin.String: 初始值：xxx -&gt; 第一次修改值 </span><br><span class="line">property: <span class="keyword">var</span> observableProp: kotlin.String: 第一次修改值 -&gt; 第二次修改值 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可观察拦截的委托</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vetoableProp: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>)&#123;</span><br><span class="line">    _, oldValue, newValue -&gt;</span><br><span class="line">    <span class="comment">// 如果新的值大于旧值，则生效</span></span><br><span class="line">    newValue &gt; oldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>委托给另一个属性</strong></p>
<p>委托对象可以是</p>
<ul>
<li>顶层属性</li>
<li>同一个类的成员或扩展属性</li>
<li>另一个类的成员或扩展属性</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层属性</span></span><br><span class="line"><span class="keyword">var</span> topLevelInt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassWithDelegate</span>(<span class="keyword">val</span> anotherClassInt: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>(<span class="keyword">var</span> memberInt: <span class="built_in">Int</span>, <span class="keyword">val</span> classWithDelegate: ClassWithDelegate) &#123;</span><br><span class="line">    <span class="keyword">var</span> delegatedInt: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt <span class="comment">// 委托给顶层属性</span></span><br><span class="line">    <span class="keyword">val</span> delegatedClassInt: <span class="built_in">Int</span> <span class="keyword">by</span> classWithDelegate::anotherClassInt <span class="comment">// 委托给其他类的属性</span></span><br><span class="line">    <span class="keyword">val</span> delegatedMemberInt: <span class="built_in">Int</span> <span class="keyword">by</span> ::memberInt <span class="comment">// 委托给类的成员属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展属性 (注意，扩展属性不能有初始化器:原因就是扩展属性本质上不会在类中添加新的字段保存其值，所以没有地方存放初始值。 扩展属性并不能带有初始化器。)</span></span><br><span class="line"><span class="keyword">var</span> AA.extDelegated: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br></pre></td></tr></table></figure>

<p>​		当想要以一种向后兼容的方式重命名一个属性的时候：引入一个新的属性、 使用 <code>@Deprecated</code> 注解来注解旧的属性、并委托其实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="string">&quot;newName&quot;</span>))</span></span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么场景下使用委托"><a href="#什么场景下使用委托" class="headerlink" title="什么场景下使用委托"></a>什么场景下使用委托</h4><p>上面那些延迟初始化啥的</p>
<h4 id="Room与常规写Sql语句有什么区别"><a href="#Room与常规写Sql语句有什么区别" class="headerlink" title="Room与常规写Sql语句有什么区别"></a>Room与常规写Sql语句有什么区别</h4><p>减少模版代码，提供了封装可以与jetpack其他组件结合使用</p>
<h4 id="Kotlin里面init和构造函数那个先执行"><a href="#Kotlin里面init和构造函数那个先执行" class="headerlink" title="Kotlin里面init和构造函数那个先执行"></a>Kotlin里面init和构造函数那个先执行</h4><p>先回答这个问题</p>
<p>init块的代码会被合并到主函数中，如果非要分顺序的话，init块的代码和属性初始化的代码会按着顺序添加到主函数中</p>
<p>主构造函数—&gt; init —&gt; 次构造函数</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-6b5c5f3b80f605afe84080d25cc8be1e_720w.png" alt="img"></p>
<p>其中init代码块和对象类型的属性的初始化会被合并到主构造函数中执行。</p>
<blockquote>
<p>初始化块中的代码实际上会成为主构造函数的一部分。对主构造函数的委托发生在访问次构造函数的第一条语句时，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。</p>
<p>即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块</p>
</blockquote>
<p><strong>Kotlin中的init代码块就相当于Java中的普通代码块，在创建对象的时候代码块会先执行。注意是每次创建都会执行一遍</strong></p>
<p><strong>Kotlin中的伴生对象相当于Java中的Static关键字。<br>伴生对象里的init代码块就相当于Java中的静态代码块。在类加载的时候会优先执行且只会执行一次。</strong></p>
<p>其中java的构造顺序为</p>
<ol>
<li>执行父类的静态代码块，并初始化父类静态成员变量</li>
<li>执行子类的静态代码块，并初始化子类静态成员变量</li>
<li>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量</li>
<li>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</li>
</ol>
<h4 id="kotlin的单例只有object关键字来修饰，是线程安全的吗"><a href="#kotlin的单例只有object关键字来修饰，是线程安全的吗" class="headerlink" title="kotlin的单例只有object关键字来修饰，是线程安全的吗?"></a><strong>kotlin的单例只有object关键字来修饰，是线程安全的吗?</strong></h4><p>​		Kotlin 中使用 <code>object</code> 关键字声明的单例对象是线程安全的。这是因为 Kotlin 在内部使用了懒加载和线程安全的初始化，确保只有一个实例被创建，并且在多线程环境下也能正确工作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		反编译后的Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Java 代码中可以看出来，显然这是一个单例模式。</p>
<ul>
<li><strong>私有构造函数</strong></li>
<li><strong>通过静态字段对外提供实例</strong></li>
<li><strong>静态代码块中直接初始化，线程安全</strong> 。</li>
</ul>
<blockquote>
<p>这里插播一个问题，<strong>static 代码块在何时执行？</strong></p>
</blockquote>
<p>​		首先类加载阶段可以分为<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>、<strong>使用</strong>、<strong>卸载</strong> 七个步骤 。static 代码块就是在 <strong>初始化</strong> 阶段执行的。那么，哪些场景会触发类的初始化呢？有如下几种场景：</p>
<ul>
<li>通过 <code>new</code> 实例化对象</li>
<li>读写一个类的静态字段</li>
<li>调用一个类的静态方法</li>
<li>对类进行反射调用</li>
</ul>
<p>​		按照上面反编译出来的 Java 代码，获得单例对象的方法是 <code>Singleton.INSTANCE</code> ，即调用 <code>Singleon</code> 类的静态字段 <code>INSTANCE</code>，就会触发类的初始化阶段，也就触发了 static 代码块的执行，从而完成了单例对象的实例化。同时，由于类加载过程天生线程安全，所以 <strong>Kotlin 的 object 单例活脱脱的就是一个线程安全的懒汉式单例(访问时初始化)。</strong></p>
<h4 id="扩展函数原理是什么？"><a href="#扩展函数原理是什么？" class="headerlink" title="扩展函数原理是什么？"></a><strong>扩展函数原理是什么？</strong></h4><p>扩展函数会被编译成一个java静态函数，函数的第一个参数就是所被扩展对象调用这个函数时自己本身，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">exty</span><span class="params">(i:<span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$this</span> exty <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的编译后如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">exty</span><span class="params">(<span class="meta">@NotNull</span> String $<span class="built_in">this</span>$exty, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="built_in">this</span>$exty, <span class="string">&quot;$this$exty&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> $<span class="built_in">this</span>$exty + <span class="string">&quot; exty &quot;</span> + i;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>java中的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        exty(s,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="介绍一下委托"><a href="#介绍一下委托" class="headerlink" title="介绍一下委托"></a><strong>介绍一下委托</strong></h4><p>​		在 Kotlin 中，委托是一种设计模式，允许一个类（委托类）将其一些职责委托给另一个类（委托对象），以实现代码的复用和组合。委托可以通过关键字 <code>by</code> 实现。</p>
<h4 id="看你熟悉协程，suspend关键字有啥作用？"><a href="#看你熟悉协程，suspend关键字有啥作用？" class="headerlink" title="看你熟悉协程，suspend关键字有啥作用？"></a><strong>看你熟悉协程，suspend关键字有啥作用？</strong></h4><p>​		<code>suspend</code> 关键字用于标记可以挂起执行的函数。挂起函数可以在不阻塞线程的情况下执行长时间运行的操作，如网络请求或文件读写，以提高程序的性能和响应性。</p>
<h4 id="协程方面除了网络方面，还有什么场景应用？"><a href="#协程方面除了网络方面，还有什么场景应用？" class="headerlink" title="协程方面除了网络方面，还有什么场景应用？"></a><strong>协程方面除了网络方面，还有什么场景应用？</strong></h4><p>除了网络请求，协程还可用于以下场景：</p>
<ol>
<li>文件操作</li>
</ol>
<p>使用协程读取文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">readFile</span><span class="params">(filePath: <span class="type">String</span>)</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    File(filePath).readText()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库访问</li>
</ol>
<p>使用协程执行数据库查询：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserFromDatabase</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: User = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 假设有一个数据库函数 getUserById 来获取用户信息</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@withContext</span> database.getUserById(userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定时任务</li>
</ol>
<p>使用协程定时执行任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span> = GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// 延迟一秒</span></span><br><span class="line">        println(<span class="string">&quot;Timer tick&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>UI 操作</li>
</ol>
<p>在协程中更新 UI（确保在主线程上）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> = withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">// 更新 UI 组件</span></span><br><span class="line">    textView.text = <span class="string">&quot;Updated Text&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>后台任务</li>
</ol>
<p>使用协程执行耗时的后台任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performBackgroundTask</span><span class="params">()</span></span> = withContext(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="comment">// 执行耗时操作</span></span><br><span class="line">    <span class="keyword">val</span> result = heavyComputation()</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Kotlin结合MVVM不知道你有没有这个？"><a href="#Kotlin结合MVVM不知道你有没有这个？" class="headerlink" title="Kotlin结合MVVM不知道你有没有这个？"></a><strong>Kotlin结合MVVM不知道你有没有这个？</strong></h4><p>​		是的，我熟悉将 Kotlin 与 MVVM (Model-View-ViewModel) 架构一起使用，这种架构有助于将应用程序的逻辑分离，并提高代码的可维护性和测试性。</p>
<h4 id="LiveData除了post发送数据，还有什么？"><a href="#LiveData除了post发送数据，还有什么？" class="headerlink" title="LiveData除了post发送数据，还有什么？"></a><strong>LiveData除了post发送数据，还有什么？</strong></h4><p>​		LiveData 除了 <code>postValue</code> 发送数据，还可以使用 <code>setValue</code> 发送数据。</p>
<p>​		区别在于 <code>postValue</code> 可以在非主线程中调用，而 <code>setValue</code> 必须在主线程中使用。</p>
<h4 id="日常工作中，什么情况用post，什么情况用setValue？"><a href="#日常工作中，什么情况用post，什么情况用setValue？" class="headerlink" title="日常工作中，什么情况用post，什么情况用setValue？"></a><strong>日常工作中，什么情况用post，什么情况用setValue？</strong></h4><p>​		通常情况下，应该使用 <code>postValue</code> 来发送 LiveData 的数据，因为它允许在非主线程中进行数据更改。只有在确定当前线程是主线程时才使用 <code>setValue</code>。</p>
<h4 id="怎么取消一个协程？"><a href="#怎么取消一个协程？" class="headerlink" title="怎么取消一个协程？"></a><strong>怎么取消一个协程？</strong></h4><p>​		可以使用协程的 <code>cancel</code> 方法来取消一个协程，或者通过协程的 <code>Job</code> 对象来取消它。</p>
<h4 id="子协程会被取消吗？嵌套情况下？子协程出现异常，父协程会取消吗？"><a href="#子协程会被取消吗？嵌套情况下？子协程出现异常，父协程会取消吗？" class="headerlink" title="子协程会被取消吗？嵌套情况下？子协程出现异常，父协程会取消吗？"></a><strong>子协程会被取消吗？嵌套情况下？子协程出现异常，父协程会取消吗？</strong></h4><p>​		默认情况下，父协程会等待所有子协程完成，但子协程的取消不会导致父协程的取消。父协程只有在所有子协程完成或被取消后才会完成。子协程出现异常不会自动取消父协程，除非父协程明确处理异常。</p>
<h4 id="网速很慢，会不会出现内存泄漏，页面已经销毁情况下？"><a href="#网速很慢，会不会出现内存泄漏，页面已经销毁情况下？" class="headerlink" title="网速很慢，会不会出现内存泄漏，页面已经销毁情况下？"></a><strong>网速很慢，会不会出现内存泄漏，页面已经销毁情况下？</strong></h4><p>​		在页面已经销毁的情况下，网速慢通常不会导致内存泄漏。内存泄漏通常涉及对象引用无法释放，与网速慢无直接关系。</p>
<h4 id="有生命周期监听为什么还会出现内存泄漏？"><a href="#有生命周期监听为什么还会出现内存泄漏？" class="headerlink" title="有生命周期监听为什么还会出现内存泄漏？"></a><strong>有生命周期监听为什么还会出现内存泄漏？</strong></h4><p>​		内存泄漏通常发生在对象仍然被引用，但不再需要的情况下。即使有生命周期监听，如果对对象的引用未能适时解除，仍然可能导致内存泄漏。因此，需要确保在不需要时适时解除对象引用。</p>
<h4 id="kotlin扩展函数的原理"><a href="#kotlin扩展函数的原理" class="headerlink" title="kotlin扩展函数的原理"></a>kotlin扩展函数的原理</h4><pre><code> 先看代码
</code></pre>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 String 类添加一个扩展函数 reverse</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">reverse</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reversed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> original = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">val</span> reversed = original.reverse() <span class="comment">// 使用扩展函数</span></span><br><span class="line">    println(reversed) <span class="comment">// 输出 &quot;olleH&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在底层，Kotlin 编译器会将这个扩展函数转换为一个静态函数，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="comment">// Java 伪代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String $receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>($receiver).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		需要注意的是，扩展函数并不修改原始类的定义，也不会在原始类中添加任何新的成员。它们只是一种语法糖，让你能够以一种看起来像是在调用类的成员函数的方式来调用静态函数。因此，扩展函数的解析是静态的，它们不支持多态，也就是说，它们的调用不是基于接收者对象的运行时类型，而是基于接收者对象在代码中声明的类型。下面举个例子理解这段话。</p>
<p>我们定义一个基类 <code>Animal</code> 和一个派生类 <code>Dog</code>，以及它们各自的成员函数 <code>makeSound</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> = <span class="string">&quot;generic animal sound&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="type">Animal</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> = <span class="string">&quot;bark&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们为 <code>Animal</code> 类和 <code>Dog</code> 类分别定义扩展函数 <code>makeNoise</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">makeNoise</span><span class="params">()</span></span> = <span class="string">&quot;generic animal noise&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Dog.<span class="title">makeNoise</span><span class="params">()</span></span> = <span class="string">&quot;woof&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们创建一个 <code>Animal</code> 类型的变量，但是实际上它引用的是一个 <code>Dog</code> 对象，并尝试调用成员函数和扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myAnimal: Animal = Dog()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    println(myAnimal.makeSound()) <span class="comment">// 输出 &quot;bark&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用扩展函数</span></span><br><span class="line">    println(myAnimal.makeNoise()) <span class="comment">// 输出 &quot;generic animal noise&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>当我们调用成员函数 <code>makeSound</code> 时，输出是 <code>&quot;bark&quot;</code>。这是因为多态的作用，<code>makeSound</code> 的调用是基于 <code>myAnimal</code> 的实际运行时类型（<code>Dog</code>），而不是它的声明类型（<code>Animal</code>）。</li>
<li>然而，当我们调用扩展函数 <code>makeNoise</code> 时，输出是 <code>&quot;generic animal noise&quot;</code>。这是因为扩展函数的调用是基于 <code>myAnimal</code> 的声明类型（<code>Animal</code>），而不是它的实际运行时类型（<code>Dog</code>）。这说明扩展函数不支持多态，它们的调用是静态解析的。</li>
</ul>
<h4 id="什么叫多态？"><a href="#什么叫多态？" class="headerlink" title="什么叫多态？"></a>什么叫多态？</h4><p>​	多态（Polymorphism）是面向对象编程（OOP）的一个核心概念，它指的是同一个方法或属性在不同的对象中可以有不同的实现。多态允许我们以统一的方式处理不同类型的对象，而具体的行为则取决于对象的实际类型。</p>
<p>多态主要有两种形式：</p>
<ol>
<li><strong>编译时多态（静态多态）</strong>：这种多态是在编译时就确定的，主要通过方法重载（Method Overloading）实现。方法重载指的是在同一个类中存在多个同名方法，但它们的参数列表不同。</li>
<li><strong>运行时多态（动态多态）</strong>：这种多态是在运行时才确定的，主要通过方法重写（Method Overriding）和接口实现实现。运行时多态的典型例子是父类引用指向子类对象，通过这个引用调用的方法是子类的方法，而不是父类的方法。这种行为是基于对象的实际运行时类型决定的。</li>
</ol>
<p>具体的例子可以看上面的那个代码示例调用makeSound方法输出的是Dog的实现。</p>
<h4 id="kotlin幕后字段"><a href="#kotlin幕后字段" class="headerlink" title="kotlin幕后字段"></a>kotlin幕后字段</h4><p>属性 or 字段</p>
<p>首先需要理解下属性和字段的区别：</p>
<blockquote>
<p>字段是一个拥有值的类成员变量，可以是只读的或可变的，并可以用任何访问修饰符（例如public或private）进行标记。</p>
<p><strong>属性包含一个私有字段和访问器（getter 和 setter），它也可以是只读或可变的。</strong></p>
</blockquote>
<p>​	 属性是 Kotlin 中的一个高级概念，它封装了字段的访问。一个属性通常由一个字段（幕后字段）、一个 getter 方法和一个可选的 setter 方法组成。在 Kotlin 中，当你定义一个属性时，编译器会自动生成相应的 getter 和 setter 方法（对于 <code>var</code> 属性）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field.capitalize()</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code> 是一个属性，它有一个自定义的 getter 和 setter。<code>field</code> 关键字在这里引用的是属性的幕后字段。</p>
<p>​		字段是类的一个成员，用于存储数据。<strong>在 Kotlin 中，字段通常作为属性的一部分存在，称为幕后字段</strong>（backing field）。你不能直接定义一个字段，<strong>它是由编译器在需要时为属性自动生成的。字段只在属性的访问器（getter 和 setter）中可见，并通过 <code>field</code> 关键字访问。</strong></p>
<p>​		总的来说，属性是 Kotlin 中的一个高级概念，它包含字段、getter 方法和 setter 方法。字段是类的一个低级概念，用于存储数据，通常作为属性的一部分存在。在 Kotlin 中，你通常会直接与属性打交道，而不是直接操作字段。</p>
<p><strong>幕后字段：</strong>指代一个属性背后用于存储数据的字段。在 Kotlin 中，属性通常由一个字段（用于存储数据）、一个 getter 方法（用于访问数据）和一个 setter 方法（用于修改数据）组成。这个用于存储数据的字段就被称为幕后字段。</p>
<p>​		幕后字段只在属性的 getter 和 setter 方法中可用，并且只能通过 <code>field</code> 关键字来访问。不管有没有自定义 getter 和 setter 方法都会生成<code>field</code> 来存储数据。但是如果属性的 getter 和 setter 方法都没有引用 <code>field</code>，那么该属性不会有幕后字段，这句话怎么理解呢？</p>
<p>​		就是这个属性的getter 和 setter 所使用的值都是外部值，看下面代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName: String = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">     <span class="keyword">get</span>() = field.toUpperCase()  <span class="comment">// 引用了 field</span></span><br><span class="line">     <span class="keyword">set</span>(value) &#123;</span><br><span class="line">      field = value.trim()  <span class="comment">// 引用了 field</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastName: String</span><br><span class="line">     <span class="keyword">get</span>() = fullName.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]  <span class="comment">// 没有引用 field</span></span><br><span class="line">     <span class="keyword">set</span>(value) &#123;</span><br><span class="line">     fullName = <span class="string">&quot;<span class="subst">$&#123;fullName.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]&#125;</span> <span class="variable">$value</span>&quot;</span>  <span class="comment">// 没有引用 field</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​	上面的lastName的get和set返回的都是外部值，所以它没有幕后字段，这个<strong>lastName也被称为幕后属性。</strong></p>
<h4 id="kotlin扩展属性"><a href="#kotlin扩展属性" class="headerlink" title="kotlin扩展属性"></a>kotlin扩展属性</h4><p>​	Kotlin 中的扩展属性允许你为现有的类添加新的属性，类似于扩展函数。然而，<strong>由于扩展属性并不会真正地向目标类添加新的字段，因此它们不能有幕后字段。这意味着扩展属性不能直接存储数据，而必须通过自定义的 getter  或 setter 方法来实现。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 String 类添加一个扩展属性 reversed</span></span><br><span class="line"><span class="keyword">val</span> String.reversed: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.reversed()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> original = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    println(original.reversed) <span class="comment">// 使用扩展属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们为 <code>String</code> 类添加了一个只读的扩展属性 <code>reversed</code>，它通过自定义的 getter 方法来返回字符串的反转版本。在底层，Kotlin 编译器会将这个扩展属性转换为一个静态的扩展 getter 函数，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getReversed</span><span class="params">(String $receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>($receiver).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用扩展属性时，原始的字符串实例 <code>original</code> 会被传递给这个静态扩展 getter 函数作为 <code>$receiver</code> 参数。</p>
<p>​		总的来说，扩展属性的原理是通过在编译时将属性访问转换为对相应扩展访问器函数的调用，这些访问器函数是静态的，并接受扩展类型的实例作为参数。</p>
<p>​		由于扩展属性不能有幕后字段，它们必须通过自定义的 getter 和 setter 方法来实现数据承载。也就是说如果想要让扩展属性承载数据必须自定义实现getter 和 setter 方法。举个例子看下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> tagMap = mutableMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Any.tag: String</span><br><span class="line">    <span class="keyword">get</span>() = tagMap[<span class="keyword">this</span>.toString()] ?: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        tagMap[<span class="keyword">this</span>.toString()] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="kotlin扩展属性可以赋值初始值吗？"><a href="#kotlin扩展属性可以赋值初始值吗？" class="headerlink" title="kotlin扩展属性可以赋值初始值吗？"></a>kotlin扩展属性可以赋值初始值吗？</h4><p>​	Kotlin 中的扩展属性不能像普通属性那样直接赋予初始值。这是因为扩展属性本身不存储数据，它们没有幕后字段。如果想要扩展属性表现得像有初始值一样，可以在自定义的 getter 方法中提供一个默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> String.defaultedValue: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="string">&quot;Default Value&quot;</span> <span class="keyword">else</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><p>在 Kotlin 中，线程的创建主要有以下几种方式：</p>
<ol>
<li>使用 Thread 类直接创建</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;Thread is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 Runnable 接口</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;Runnable is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> thread = Thread(runnable)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用匿名类</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">        println(<span class="string">&quot;Anonymous class is running.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用线程池（ExecutorService）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> executor = Executors.newFixedThreadPool(<span class="number">2</span>) <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line"></span><br><span class="line">executor.execute &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;ExecutorService is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown() <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用协程（Coroutine）</li>
</ol>
<p>虽然协程不是传统意义上的线程创建方式，但在 Kotlin 中，它是一种非常流行的并发编程模式，可以用来替代传统的线程操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">        println(<span class="string">&quot;Coroutine is running.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是 Kotlin 中常见的线程创建方式。在实际应用中，选择合适的方式取决于具体的需求和场景。协程提供了更加灵活和高效的并发处理能力，是 Kotlin 中推荐的并发编程模式。</p>
<h4 id="by-lazy的原理"><a href="#by-lazy的原理" class="headerlink" title="by lazy的原理"></a>by lazy的原理</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: <span class="built_in">Int</span> <span class="keyword">by</span> lazy &#123; <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>by lazy底层实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"><span class="comment">// Lazy是一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lazy</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		lazy是一个接口它的实现类有四个，其中InitializedLazyImpl只是负责序列化。看下具体的重载方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (mode) &#123;</span><br><span class="line">        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		根据传入的mode不同会选择不同的实现模式，会选择不同实现类。其中SynchronizedLazyImpl和SafePublicationLazyImpl都是线程安全的不同点在于SafePublicationLazyImpl使用CAS自旋锁进行初始化操作，而SynchronizedLazyImpl是要同步锁的方式进行初始化操作，其他实现一样。UnsafeLazyImpl就是线程不安全的初始化操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个可以被序列化的私有类，实现了 Lazy 接口，用于线程安全的惰性初始化。</span></span><br><span class="line"><span class="comment">// T 是一个协变的类型参数，表示可以接受 T 或其子类型的对象。</span></span><br><span class="line"><span class="comment">// initializer 是一个无参数、返回类型为 T 的函数，用于惰性初始化。</span></span><br><span class="line"><span class="comment">// lock 是一个可选的锁对象，如果不提供，则使用 this 作为锁。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存初始化函数的变量，使用可空类型，初始化后将其设为 null 以释放引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储初始化后的值或表示未初始化的特殊值 UNINITIALIZED_VALUE。</span></span><br><span class="line">    <span class="comment">// 使用 @Volatile 注解保证在多线程环境中的可见性。</span></span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定锁对象，如果未提供 lock 参数，则使用当前对象作为锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 Lazy 接口的 value 属性，提供线程安全的惰性初始化。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> _v1 = _value</span><br><span class="line">            <span class="comment">// 如果 _value 不是 UNINITIALIZED_VALUE，说明已经初始化，直接返回值。</span></span><br><span class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">val</span> _v2 = _value</span><br><span class="line">                <span class="comment">// 再次检查 _value，以防在等待锁的期间已经被其他线程初始化。</span></span><br><span class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果仍未初始化，则调用初始化函数，保存结果，并将初始化函数置为 null。</span></span><br><span class="line">                    <span class="keyword">val</span> typedValue = initializer!!()</span><br><span class="line">                    _value = typedValue</span><br><span class="line">                    initializer = <span class="literal">null</span></span><br><span class="line">                    typedValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 Lazy 接口的 isInitialized 方法，检查是否已经初始化。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _value !== UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 toString 方法，根据是否初始化返回不同的字符串。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (isInitialized()) value.toString() <span class="keyword">else</span> <span class="string">&quot;Lazy value not initialized yet.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在序列化时替换当前对象，确保序列化后的对象是已经初始化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeReplace</span><span class="params">()</span></span>: Any = InitializedLazyImpl(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		 SynchronizedLazyImpl 实现了 Lazy、Serializable 接口，它的 value 属性重载了 Lazy 接口的 value。Lazy 接口的 value 属性用于获取当前 Lazy 实例的延迟初始化值。一旦初始化后，它不得在此 Lazy 实例的剩余生命周期内更改。</p>
<p>​		所以 SynchronizedLazyImpl 的 value 属性只有 get() 方法，没有 set() 方法。value 的 get() 方法会先判断 _value 属性是否是 UNINITIALIZED_VALUE，不是的话会返回  _value 的值。_value 使用<code>@Volatile</code>注解标注，相当于在 Java 中 使用 volatile 修饰 _value 属性。volatile 具有可见性、有序性，因此一旦 _value 的值修改了，其他线程可以看到其最新的值。</p>
<p>​		如果 _value 的值等于 UNINITIALIZED_VALUE，则调用 initializer 来获取值，通过<code>synchronized</code>来保证这个过程是线程安全的。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程面试题</title>
    <url>/2024/03/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="说说对多线程的理解？"><a href="#说说对多线程的理解？" class="headerlink" title="说说对多线程的理解？"></a>说说对多线程的理解？</h4><p>​		多线程是一种并发编程技术，允许程序同时执行多个线程，每个线程独立执行不同的任务。多线程有助于充分利用多核处理器和提高程序性能。然而，多线程编程也引入了一些挑战，如竞态条件、死锁等，需要仔细处理。</p>
<p>​		多线程是指在一个程序中同时运行多个线程（thread），每个线程独立执行不同的任务或代码段。多线程的好处是可以提高程序的并发性和响应性，即在同一时间内执行多个任务或操作，从而提高程序的执行效率和用户体验。</p>
<p>多线程的实现方式通常包括以下步骤：</p>
<ol>
<li>创建线程：程序需要创建多个线程来并发执行不同的任务或操作。</li>
<li>线程同步：多个线程之间需要协调执行顺序、共享资源等，因此需要使用同步机制来保证线程之间的正确性。常用的同步机制包括互斥锁、条件变量、信号量等。</li>
<li>线程调度：操作系统会根据一定的调度策略来分配CPU时间片给不同的线程执行。线程调度的策略通常包括抢占式调度和协作式调度两种方式。</li>
<li>线程结束：线程执行完任务后需要结束，释放占用的资源。线程结束的方式通常有两种，一种是线程自动结束，另一种是线程被其他线程或主线程强制结束。</li>
</ol>
<p>多线程的优点包括：</p>
<ol>
<li>提高程序的响应速度和并发性，能够同时处理多个任务或操作。</li>
<li>提高程序的效率，能够利用多核处理器的并行计算能力。</li>
<li>提高用户体验，能够快速响应用户的操作。</li>
</ol>
<p>多线程的缺点包括：</p>
<ol>
<li>线程之间的同步和数据共享会增加程序的复杂性和难度。</li>
<li>线程的创建、销毁和切换会消耗系统资源，需要考虑线程的数量和调度策略。</li>
<li>线程之间的竞争和死锁等问题容易出现，需要设计合理的同步机制和调度策略。</li>
</ol>
<h4 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全?"></a><strong>怎么保证线程安全?</strong></h4><p>​		保证线程安全的方法包括使用锁（如 synchronized、ReentrantLock）、使用线程安全的数据结构（如 ConcurrentHashMap）、使用原子操作等。这些方法可以防止多个线程同时访</p>
<p>​		问共享数据而导致的竞态条件和数据不一致的问题。线程安全的实现方式取决于具体的应用场景和需求。</p>
<h4 id="保证安全之后，怎么避免出现死锁？"><a href="#保证安全之后，怎么避免出现死锁？" class="headerlink" title="保证安全之后，怎么避免出现死锁？"></a><strong>保证安全之后，怎么避免出现死锁？</strong></h4><p>避免死锁的方法包括：</p>
<ol>
<li><strong>锁的顺序</strong>：确保多个线程获取锁的顺序一致，以减少死锁的可能性。</li>
<li><strong>超时机制</strong>：为获取锁设置超时时间，避免长时间等待。</li>
<li><strong>死锁检测</strong>：定期检测系统中是否存在死锁，并采取措施解除死锁。</li>
<li><strong>使用高级锁</strong>：某些高级锁（如 <code>ReentrantLock</code>）提供了更灵活的控制，可以更容易地避免死锁。</li>
</ol>
<h4 id="除了锁之外，还有什么方法实现多线程的同步问题？"><a href="#除了锁之外，还有什么方法实现多线程的同步问题？" class="headerlink" title="除了锁之外，还有什么方法实现多线程的同步问题？"></a><strong>除了锁之外，还有什么方法实现多线程的同步问题？</strong></h4><p>​		除了锁，还可以使用信号量、条件变量、原子操作、并发数据结构等方法来实现多线程的同步问题。这些方法可以根据具体的场景选择，以提供更好的性能和可维护性。</p>
]]></content>
  </entry>
  <entry>
    <title>网络面试题</title>
    <url>/2024/03/08/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="三次握手是什么？"><a href="#三次握手是什么？" class="headerlink" title="三次握手是什么？"></a><strong>三次握手是什么？</strong></h4><p>​		三次握手是建立TCP连接的过程，具体步骤如下：</p>
<ol>
<li>客户端向服务器发送SYN（同步）请求，请求建立连接。</li>
<li>服务器接收到SYN请求后，回应一个ACK（确认）和自己的SYN，表示接受连接。</li>
<li>客户端接收到服务器的ACK和SYN后，回应一个ACK，表示连接建立成功。</li>
</ol>
<h4 id="三次握手变成两次了？有什么优点缺点？"><a href="#三次握手变成两次了？有什么优点缺点？" class="headerlink" title="三次握手变成两次了？有什么优点缺点？"></a><strong>三次握手变成两次了？有什么优点缺点？</strong></h4><p>​		三次握手变成两次握手是指在建立TCP连接时，客户端不再发送第三次握手的ACK确认，而是在服务器回应第二次握手的SYN时直接发送数据。</p>
<p>优点：</p>
<ul>
<li>减少连接建立的时延，提高连接速度。</li>
<li>减少网络流量，节省带宽。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不够安全，容易受到一些攻击，如SYN洪泛攻击。</li>
<li>不适用于所有场景，只适用于可靠的连接。</li>
</ul>
<h4 id="HTTPS为什么是安全的？"><a href="#HTTPS为什么是安全的？" class="headerlink" title="HTTPS为什么是安全的？"></a><strong>HTTPS为什么是安全的？</strong></h4><p>​		HTTPS（HTTP Secure）是安全的主要因素包括以下几点：</p>
<ol>
<li><strong>加密传输</strong>：HTTPS使用TLS（Transport Layer Security）协议对数据进行加密，使得数据在传输过程中不容易被窃取。</li>
<li><strong>身份验证</strong>：HTTPS使用数字证书来验证服务器的身份，确保用户连接到合法的服务器。</li>
<li><strong>数据完整性</strong>：HTTPS使用哈希函数来检测数据是否被篡改，以保证数据的完整性。</li>
<li><strong>保护隐私</strong>：HTTPS可以隐藏用户的浏览行为和敏感信息，增加隐私保护。</li>
</ol>
<h4 id="除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？"><a href="#除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？" class="headerlink" title="除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？"></a><strong>除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？</strong></h4><p>​		HTTP使用明文传输数据，容易受到中间人攻击，数据被窃取或篡改的风险很高。HTTPS通过加密传输数据，可以有效防止这些风险，提供更高的安全性和隐私保护。</p>
<h4 id="心跳包有了解吗？"><a href="#心跳包有了解吗？" class="headerlink" title="心跳包有了解吗？"></a><strong>心跳包有了解吗？</strong></h4><p>​		心跳包是一种用于保持TCP连接活跃的机制。它是定期发送一个小数据包到远程服务器，以防止连接由于不活动而被断开。心跳包通常用于保持长时间持续的连接，如WebSocket连接，以确保连接不会在空闲时被关闭。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>​		观察者模式用于实现对象之间的一对多依赖关系，其中一个对象（主题或被观察者）状态的改变会通知并影响多个其他对象（观察者)。</p>
<p>​		在Android开发中，观察者模式也经常被广泛应用，尤其在处理用户界面和数据的更新方面。以下是Android中常见的观察者模式的应用场景：</p>
<ol>
<li><strong>LiveData和ViewModel：</strong> Android架构组件中的LiveData和ViewModel是观察者模式的经典应用。LiveData允许数据对象通知观察者（通常是UI界面）数据发生了变化，而ViewModel用于管理UI相关的数据。这使得数据的变化可以自动通知UI进行更新，而无需手动操作。</li>
<li><strong>BroadcastReceiver：</strong> BroadcastReceiver用于在Android应用程序内部或与其他应用程序之间进行通信。它可以用于观察和响应系统事件，例如网络连接更改、短信到达等。当事件发生时，BroadcastReceiver会接收通知并执行相应的操作。</li>
<li><strong>ContentObserver：</strong> ContentObserver是Android的API，用于观察内容提供者（如联系人、日历、短信等）中的数据变化。应用程序可以注册ContentObserver来监听数据变化，以便在数据发生变化时采取适当的行动。</li>
<li><strong>OnClickListener和其他监听器：</strong> Android中的许多UI元素，如按钮，文本框，滑动控件等，都可以通过添加监听器来观察用户的交互动作。当用户执行相应的操作时，监听器会通知应用程序执行相应的逻辑。</li>
</ol>
<p>实际代码演示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> observers = mutableListOf&lt;Observer&lt;T&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.add(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.remove(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyObservers</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        observers.forEach &#123; it.onUpdate(<span class="keyword">data</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userObservable = Observable&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userObserver = <span class="keyword">object</span> : Observer&lt;User&gt; &#123;	</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;User data updated: <span class="subst">$&#123;data.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userObservable.addObserver(userObserver)</span><br><span class="line">    userObservable.notifyObservers(User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>))  <span class="comment">// 输出: User data updated: Alice</span></span><br><span class="line">    userObservable.removeObserver(userObserver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="观察者模式和回调的异同"><a href="#观察者模式和回调的异同" class="headerlink" title="观察者模式和回调的异同"></a>观察者模式和回调的异同</h4><p><strong>观察者模式</strong>：</p>
<ul>
<li>是一种设计模式，用于在对象之间建立一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>
</ul>
<p><strong>回调</strong>：</p>
<ul>
<li>是一种编程技术，允许一个函数（回调函数）作为参数传递给另一个函数，在适当的时候由该函数执行。</li>
<li>回调强调的是单个事件的响应，即一个特定事件发生时执行特定的函数。</li>
</ul>
<p><strong>总结</strong>：</p>
<ol>
<li>观察者模式通常用于实现一对多的通信，而回调通常用于一对一的通信。</li>
<li>观察者模式的观察者通常是事先注册到被观察对象中的，而回调函数是在调用时传递给另一个函数的。</li>
</ol>
<h4 id="观察者模式-多个订阅方，怎么通知到一半怎么中止后面的观察者？"><a href="#观察者模式-多个订阅方，怎么通知到一半怎么中止后面的观察者？" class="headerlink" title="观察者模式  多个订阅方，怎么通知到一半怎么中止后面的观察者？"></a>观察者模式  多个订阅方，怎么通知到一半怎么中止后面的观察者？</h4><p>​		在通知过程中加入一些逻辑来判断是否继续通知后续的观察者。通知是一个遍历队列的过程，可以添加终止逻辑。</p>
<h4 id="讲一讲责任链模式"><a href="#讲一讲责任链模式" class="headerlink" title="讲一讲责任链模式"></a>讲一讲责任链模式</h4><p>​		责任链是属于行为型模式，在这种模式中，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p>​		责任链模式是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。</p>
<p>代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折扣处理器接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DiscountHandler</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextHandler: DiscountHandler? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VIP 会员折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.isVip) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.9</span>, <span class="string">&quot;VIP Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 购买金额折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmountDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.amount &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.95</span>, <span class="string">&quot;Amount Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 购买数量折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuantityDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.97</span>, <span class="string">&quot;Quantity Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折扣请求</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">DiscountRequest</span>(<span class="keyword">val</span> isVip: <span class="built_in">Boolean</span>, <span class="keyword">val</span> amount: <span class="built_in">Double</span>, <span class="keyword">val</span> quantity: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折扣响应</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">DiscountResponse</span>(<span class="keyword">val</span> finalAmount: <span class="built_in">Double</span>, <span class="keyword">val</span> message: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vipHandler = VipDiscountHandler()</span><br><span class="line">    <span class="keyword">val</span> amountHandler = AmountDiscountHandler()</span><br><span class="line">    <span class="keyword">val</span> quantityHandler = QuantityDiscountHandler()</span><br><span class="line"></span><br><span class="line">    vipHandler.nextHandler = amountHandler</span><br><span class="line">    amountHandler.nextHandler = quantityHandler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> request = DiscountRequest(isVip = <span class="literal">true</span>, amount = <span class="number">600.0</span>, quantity = <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">val</span> response = vipHandler.handleDiscount(request)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Final Amount: <span class="subst">$&#123;response.finalAmount&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Message: <span class="subst">$&#123;response.message&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		定义了一个抽象的 <code>DiscountHandler</code> 类，它有一个 <code>handleDiscount</code> 方法用于处理折扣请求，以及一个 <code>nextHandler</code> 属性用于指向链中的下一个处理器。<code>VipDiscountHandler</code>、<code>AmountDiscountHandler</code> 和 <code>QuantityDiscountHandler</code> 是具体的折扣处理器，它们分别处理 VIP 会员折扣、购买金额折扣和购买数量折扣。</p>
<h4 id="责任链模式和策略模式有什么区别"><a href="#责任链模式和策略模式有什么区别" class="headerlink" title="责任链模式和策略模式有什么区别"></a>责任链模式和策略模式有什么区别</h4><p>​		<strong>责任链模式</strong>关注的是请求的发送和处理。它将请求的发送者和接收者解耦，并允许多个对象处理同一个请求，或者说，一个请求可以被一个处理序列处理。处理者通常包含对其后继者的引用，如果一个对象不能处理该请求，它会将相同的请求传递给下一个接收者。</p>
<p>​		<strong>策略模式</strong>使得算法可以独立于使用它的客户而变化。也就是说，它实现了某个操作的策略的切换。在策略模式中，客户知道它正在使用的策略对象。</p>
<h4 id="单例模式的几种创建方式"><a href="#单例模式的几种创建方式" class="headerlink" title="单例模式的几种创建方式"></a>单例模式的几种创建方式</h4><p>懒汉式（线程不安全）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonLazy? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonLazy &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = SingletonLazy()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>懒汉式（线程安全，同步方法）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazySynchronized</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonLazySynchronized? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonLazySynchronized &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = SingletonLazySynchronized()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>双重检查锁定（Double-Check Locking）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonDoubleCheck</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDoubleCheck? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonDoubleCheck &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        instance = SingletonDoubleCheck()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>饿汉式（静态初始化）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonEager = SingletonEager()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>静态内部类（Static Nested Class）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonDirectLazy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonDirectLazy <span class="keyword">by</span> lazy &#123; SingletonDirectLazy() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>枚举（Enum）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.object</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		反编译后的Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
