<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>路由框架原理</title>
    <url>/2024/03/26/ARouter/</url>
    <content><![CDATA[<h4 id="路由表注册"><a href="#路由表注册" class="headerlink" title="路由表注册"></a>路由表注册</h4><p>​		抽出一个Router组件，然后给其他组件暴漏一个接口，用来让每个组件实现自己的路由注册类。然后通过遍历apk文件中的符合要求的包名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">object</span> ApkUtils &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取设备上所有已安装应用的APK文件路径。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 应用上下文。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含所有已安装应用APK路径的列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAllInstalledApkPaths</span><span class="params">(context: <span class="type">Context</span>)</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> apkPaths = mutableListOf&lt;String&gt;()</span><br><span class="line">        <span class="keyword">val</span> packageManager = context.packageManager</span><br><span class="line">        <span class="comment">// 获取设备上安装的所有应用程序</span></span><br><span class="line">        <span class="keyword">val</span> apps = packageManager.getInstalledApplications(PackageManager.GET_META_DATA)</span><br><span class="line"></span><br><span class="line">        apps.forEach &#123; appInfo -&gt;</span><br><span class="line">            <span class="comment">// 检查是否为非系统应用程序</span></span><br><span class="line">            <span class="keyword">if</span> (appInfo.flags and ApplicationInfo.FLAG_SYSTEM == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> apkPath = appInfo.sourceDir <span class="comment">// 获取APK文件的路径</span></span><br><span class="line">                apkPaths.add(apkPath)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> apkPaths</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getClassNameByPackageName</span><span class="params">(context: <span class="type">Context</span>, packageName: <span class="type">String</span>)</span></span>: Set&lt;String&gt; &#123;</span><br><span class="line">        <span class="comment">// 拿到apk当中dex地址</span></span><br><span class="line">    	<span class="keyword">val</span> classNames = mutableSetOf&lt;String&gt;()</span><br><span class="line">    	<span class="keyword">val</span> paths = getSourcePaths(context) </span><br><span class="line"></span><br><span class="line">   	 <span class="keyword">for</span> (path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="keyword">var</span> dexFile: DexFile? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载apk中的dex并遍历获得所有packageName的类</span></span><br><span class="line">             dexFile = DexFile(path)</span><br><span class="line">             <span class="keyword">val</span> dexEntries = dexFile.entries()</span><br><span class="line">           	 <span class="keyword">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class="line">                 	<span class="comment">// com.XXx.xXx.XXX整个APK中给所有的类</span></span><br><span class="line">            	    <span class="keyword">val</span> className = dexEntries.nextElement()</span><br><span class="line">            	    <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">                    classNames.add(className)</span><br><span class="line">         	       &#125;</span><br><span class="line">         	   &#125;</span><br><span class="line">       	 &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        	    e.printStackTrace()</span><br><span class="line">       	 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	 <span class="keyword">try</span> &#123;</span><br><span class="line">            	    dexFile?.close()</span><br><span class="line">           	 &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">           	     e.printStackTrace()</span><br><span class="line">          	  &#125;</span><br><span class="line">      	  &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> classNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这段代码是实现了动态获取各个组件自己的路由注册类，然后调用方法执行注册。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IRouteLoad</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadInto</span><span class="params">(routes: <span class="type">Any</span>)</span></span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> classNames = ClassUtils.getFileNameByPackageName(application, <span class="string">&quot;com.enjoy.routers&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (className <span class="keyword">in</span> classNames) &#123;</span><br><span class="line">            <span class="keyword">val</span> cls = Class.forName(className)</span><br><span class="line">            <span class="keyword">if</span> (IRouteLoad::<span class="keyword">class</span>.java.isAssignableFrom(cls)) &#123;</span><br><span class="line">                <span class="keyword">val</span> load = cls.newInstance() <span class="keyword">as</span> IRouteLoad</span><br><span class="line">                load.loadInto(routes) </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将init方法在Application中执行。</p>
<h4 id="单个组件的注册"><a href="#单个组件的注册" class="headerlink" title="单个组件的注册"></a>单个组件的注册</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRouter</span> : <span class="type">IRouteLoad</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadInto</span><span class="params">(routers: <span class="type">Map</span>&lt;<span class="type">String</span>, Class&lt;<span class="keyword">out</span> Activity&gt;&gt;)</span></span> &#123;</span><br><span class="line">        routers[<span class="string">&quot;/food/main&quot;</span>] = FoodActivity::<span class="keyword">class</span>.java</span><br><span class="line">        routers[<span class="string">&quot;/food/main&quot;</span>] = FoodActivity::<span class="keyword">class</span>.java</span><br><span class="line">        routers[<span class="string">&quot;/food/main&quot;</span>] = FoodActivity::<span class="keyword">class</span>.java</span><br><span class="line">        routers[<span class="string">&quot;/food/main&quot;</span>] = FoodActivity::<span class="keyword">class</span>.java</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注解处理器自动生成上面的注册类，进一步简化使用步骤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Google的自动服务注解，可以自动注册注解处理器</span></span><br><span class="line"><span class="keyword">import</span> com.google.auto.service.AutoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoService(Processor.class)</span> <span class="comment">// 注册注解处理器</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;com.yourpackage.Route&quot;)</span> <span class="comment">// 这里填写你的注解的完整路径</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span> <span class="comment">// 支持的Java版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">// 找到所有使用Route注解的元素</span></span><br><span class="line">            Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(annotation);</span><br><span class="line">            <span class="comment">// 为每一个元素生成代码</span></span><br><span class="line">            <span class="keyword">for</span> (Element element : routeElements) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element <span class="keyword">instanceof</span> TypeElement) &#123;</span><br><span class="line">                    generateClass((TypeElement) element);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">generateClass</span><span class="params">(TypeElement typeElement)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> <span class="string">&quot;com.enjoy.routers&quot;</span>; <span class="comment">// 生成的类所在的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> typeElement.getSimpleName() + <span class="string">&quot;Router&quot;</span>; <span class="comment">// 生成的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">qualifiedName</span> <span class="operator">=</span> typeElement.getQualifiedName().toString(); <span class="comment">// 完整类名</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">classBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        classBuilder.append(<span class="string">&quot;package &quot;</span>).append(packageName).append(<span class="string">&quot;;\n\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;import android.app.Activity;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;import java.util.Map;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;import com.enjoy.router.api.IRouteLoad;\n\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;public class &quot;</span>).append(className)</span><br><span class="line">                .append(<span class="string">&quot; implements IRouteLoad &#123;\n\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;    @Override\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;    public void loadInto(Map&lt;String, Class&lt;? extends Activity&gt;&gt; routes) &#123;\n&quot;</span>)</span><br><span class="line">                <span class="comment">// 这里假设你的Route注解里有一个value()方法返回路由地址</span></span><br><span class="line">                .append(<span class="string">&quot;        routes.put(\&quot;/&quot;</span>).append(typeElement.getAnnotation(Route.class).value())</span><br><span class="line">                .append(<span class="string">&quot;\&quot;, &quot;</span>).append(qualifiedName).append(<span class="string">&quot;.class);\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;    &#125;\n&quot;</span>)</span><br><span class="line">                .append(<span class="string">&quot;&#125;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">JavaFileObject</span> <span class="variable">file</span> <span class="operator">=</span> processingEnv.getFiler().createSourceFile(packageName + <span class="string">&quot;.&quot;</span> + className);</span><br><span class="line">            <span class="keyword">try</span> (java.io.<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> file.openWriter()) &#123;</span><br><span class="line">                writer.write(classBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这个处理器将为每一个使用<code>@Route</code>注解的类生成一个新的路由类。生成的路由类会实现<code>IRouteLoad</code>接口，并在其<code>loadInto</code>方法中将注解定义的路由地址与Activity类关联起来。这是一个编译时代码生成的简单例子，你可能需要根据自己的需求来调整和完善代码。请确保项目中包含了AutoService库，因为这里使用了<code>@AutoService</code>注解来自动注册服务。</p>
<p>参考：</p>
<p><a href="https://juejin.cn/post/6885932290615509000#heading-52">https://juejin.cn/post/6885932290615509000#heading-52</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android ANR</title>
    <url>/2024/03/26/Android%20ANR/</url>
    <content><![CDATA[<h1 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h1><p><a href="https://juejin.cn/post/6973564044351373326?searchId=202402211705271F8C8CC4730F5F3352A2#heading-1">https://juejin.cn/post/6973564044351373326?searchId=202402211705271F8C8CC4730F5F3352A2#heading-1</a></p>
<h2 id="ANR产生的四种类型"><a href="#ANR产生的四种类型" class="headerlink" title="ANR产生的四种类型"></a>ANR产生的四种类型</h2><table>
<thead>
<tr>
<th align="center">ANR类型</th>
<th align="center">超时时间</th>
<th align="center">报错信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入事件（按键、触摸等）</td>
<td align="center">5s</td>
<td align="center">Input event dispatching timed out</td>
</tr>
<tr>
<td align="center">广播BroadcastReceiver</td>
<td align="center">前台10s，后台&#x2F;offload 60s</td>
<td align="center">Receiver during timeout of</td>
</tr>
<tr>
<td align="center">Service服务</td>
<td align="center">Foreground 10s，普通 20s，后台 200s</td>
<td align="center">Timeout executing service</td>
</tr>
<tr>
<td align="center">ContentProvider</td>
<td align="center">10s</td>
<td align="center">timeout publishing content providers</td>
</tr>
</tbody></table>
<h2 id="ANR触发机制"><a href="#ANR触发机制" class="headerlink" title="ANR触发机制"></a>ANR触发机制</h2><p>ANR是一套监控Android应用响应是否及时的机制，可以把发生ANR比作是引爆炸弹，那么整个流程包含三部分组成：</p>
<ol>
<li>埋定时炸弹：中控系统(system_server进程)启动倒计时，在规定时间内如果目标(应用进程)没有干完所有的活，则中控系统会定向炸毁(杀进程)目标。</li>
<li>拆炸弹：在规定的时间内干完工地的所有活，并及时向中控系统报告完成，请求解除定时炸弹，则幸免于难。</li>
<li>引爆炸弹：中控系统立即封装现场，抓取快照，搜集目标执行慢的罪证(traces)，便于后续的案件侦破(调试分析)，最后是炸毁目标。</li>
</ol>
<p>Android通过Handler机制来实现这套机制的，可以看下面的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">timeoutRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果这个 Runnable 被执行，说明操作超时，可能会触发 ANR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作开始时发送延迟消息</span></span><br><span class="line">handler.postDelayed(timeoutRunnable, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作完成时取消延迟消息</span></span><br><span class="line">handler.removeCallbacks(timeoutRunnable);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="ANR的产生就是超时"><a href="#ANR的产生就是超时" class="headerlink" title="ANR的产生就是超时"></a>ANR的产生就是超时</h4><p>长时间无法响应用户输入或无效占用资源，会使用户感觉卡顿的感觉。一般这种情况，会弹出对话框提示用户，可以用来选择关闭应用。</p>
<p>这个超时，由 <strong>AMS和WMS检测</strong>（后面的源码分析可以看到，<a href="https://developer.android.com/training/articles/perf-anr.html">官网</a> 上也有相关说明：AMS和WMS监控应用的响应性），未在规定时间完成特定任务（如5s未响应输入事件、10s内广播接收器未处理完毕），即会引起ANR。</p>
<p>这个超时，一般由<strong>Handler机制 的 延迟发送消息完成</strong>。若超时 则发出消息 产生ANR 告知系统及用户，若在时间内完成，则取消消息队列中的延迟消息。</p>
<h4 id="为什么会导致超时，或者导致ANR？"><a href="#为什么会导致超时，或者导致ANR？" class="headerlink" title="为什么会导致超时，或者导致ANR？"></a>为什么会导致超时，或者导致ANR？</h4><p>UI线程(主线程) 阻塞：如在主线程存取较多数据（I&#x2F;O阻塞），网络阻塞等。也可能是资源不足造成，如CPU负荷、内存或存储不足等导致I&#x2F;O阻塞。</p>
<p>死锁和等待:多线程的死锁和主线程的等待。</p>
<h2 id="input事件导致的ANR"><a href="#input事件导致的ANR" class="headerlink" title="input事件导致的ANR"></a>input事件导致的ANR</h2><p>在事件分发文章研究了input事件的native实现，我们知道在system_server进程，主要运行InputReaderThread<code>和</code>InputDispatcherThread&#96;这两个线程。从名字就可以直到InputReaderThread用来获取事件，InputDispatcherThread用来分发事件。</p>
<p>InputDispatcherThread的执行逻辑类似ui线程通过<code>Looper</code>机制运行，会一直循环一个名为threadLoop的方法，下面是对应的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher-&gt;<span class="built_in">dispatchOnce</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>threadLoop方法只做了一件事就是调用<code>InputDispatcher的dispatchOnce</code>方法，回顾View事件分发章节我们知道InputDispatcher的主要功能是负责将事件派发给合适的窗口和监控ANR事件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化下一次唤醒时间为最大值</span></span><br><span class="line">    <span class="type">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有命令需要处理，优先处理命令</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">haveCommandsLocked</span>()) &#123;</span><br><span class="line">        <span class="comment">// 分发一次内部事件</span></span><br><span class="line">        <span class="built_in">dispatchOnceInnerLocked</span>(&amp;nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理可能的应用程序无响应（ANR）情况，并获取下一次ANR检查的时间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> nextAnrCheck = <span class="built_in">processAnrsLocked</span>();</span><br><span class="line">    <span class="comment">// 更新下一次唤醒时间为最小的时间（即最早的唤醒时间）</span></span><br><span class="line">    nextWakeupTime = std::<span class="built_in">min</span>(nextWakeupTime, nextAnrCheck);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="type">nsecs_t</span> currentTime = <span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算超时时间（毫秒）</span></span><br><span class="line">    <span class="type">int</span> timeoutMillis = <span class="built_in">toMillisecondTimeoutDelay</span>(currentTime, nextWakeupTime);</span><br><span class="line">    <span class="comment">// 使用Looper的pollOnce方法等待事件或超时，进入epoll_wait</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下具体的分发逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有正在发送中的事件，才去取新的事件</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingEvent) &#123;</span><br><span class="line">        <span class="comment">// mInboundQueue为待处理的事件队列</span></span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果没有待处理事件，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!mPendingEvent) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从mInboundQueue队列的头部取出一个事件作为待处理事件</span></span><br><span class="line">            mPendingEvent = mInboundQueue.<span class="built_in">dequeueAtHead</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的事件分发开始了，重置ANR（应用无响应）超时时间</span></span><br><span class="line">        <span class="built_in">resetANRTimeoutsLocked</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据事件类型进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ...: <span class="comment">// 其他事件类型处理</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ...: <span class="comment">// 按键事件处理</span></span><br><span class="line">            done = <span class="built_in">dispatchKeyLocked</span>(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事件分发完成</span></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// 释放当前正在处理的事件，并将其标记为空</span></span><br><span class="line">        <span class="built_in">releasePendingEventLocked</span>();</span><br><span class="line">        <span class="comment">// 强制立刻执行下一轮轮询，不等待</span></span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要的逻辑是：</p>
<ul>
<li>如果有正在发送的event（<code>pendingEvent</code>），则什么都不做，如果没有，则取<code>mInboundQueue</code>头部的事件，用于发送。</li>
<li>调用<code>dispatchKeyLocked</code>方法发送事件。</li>
<li>当发送成功后，释放<code>pendingEvent</code>标志位。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputDispatcher::dispatchKeyLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime, KeyEntry* entry,</span></span></span><br><span class="line"><span class="params"><span class="function">        DropReason* dropReason, <span class="type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个向量来存储输入目标</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找拥有焦点的窗口，以确定目标接收者</span></span><br><span class="line">    <span class="type">int32_t</span> injectionResult = <span class="built_in">findFocusedWindowTargetsLocked</span>(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事件注入还在等待中，则直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有当事件注入成功时，才会执行事件分发</span></span><br><span class="line">    <span class="built_in">dispatchEventLocked</span>(currentTime, entry, inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发完成，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到这一步的事件，不一定可以走到发送的逻辑。因为还需要寻找可执行的焦点，只有当找到了可执行焦点后，事件才会被真正分发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">InputDispatcher::findFocusedWindowTargetsLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> EventEntry* entry, Vector&lt;InputTarget&gt;&amp; inputTargets, <span class="type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查拥有焦点的窗口是否准备好接收更多的输入事件</span></span><br><span class="line">    String8 reason = <span class="built_in">checkWindowReadyForMoreInputLocked</span>(currentTime,</span><br><span class="line">            mFocusedWindowHandle, entry, <span class="string">&quot;focused&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果窗口没有准备好</span></span><br><span class="line">    <span class="keyword">if</span> (!reason.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 处理目标不准备好的情况，可能会触发ANR（应用无响应）处理</span></span><br><span class="line">        <span class="type">int32_t</span> injectionResult = <span class="built_in">handleTargetsNotReadyLocked</span>(currentTime, entry,</span><br><span class="line">                mFocusedApplicationHandle, mFocusedWindowHandle, nextWakeupTime, reason.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回处理结果</span></span><br><span class="line">        <span class="keyword">return</span> injectionResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果代码执行到这里，说明窗口已经准备好接收输入事件</span></span><br><span class="line">    <span class="comment">// 这里应该有进一步的处理逻辑来添加目标到 inputTargets 中（在这个代码片段中省略了）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回成功的结果</span></span><br><span class="line">    <span class="keyword">return</span> INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下具体的检查焦点窗口的分发逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">String8 <span class="title">InputDispatcher::checkWindowReadyForMoreInputLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle, <span class="type">const</span> EventEntry* eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* targetType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取与窗口句柄关联的输入连接</span></span><br><span class="line">    sp&lt;InputChannel&gt; connection = windowHandle-&gt;<span class="built_in">getInputChannel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理不同类型的事件</span></span><br><span class="line">    <span class="keyword">if</span> (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;</span><br><span class="line">        <span class="comment">// 对于按键事件，检查输出队列和等待队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;outboundQueue.<span class="built_in">isEmpty</span>() || !connection-&gt;waitQueue.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果任一队列不为空，则表示窗口还在处理之前的事件，返回一个非空字符串表示窗口未准备好</span></span><br><span class="line">            <span class="keyword">return</span> String8::format(<span class="string">&quot;Window &#x27;%s&#x27; is not ready for more input, &quot;</span></span><br><span class="line">                                   <span class="string">&quot;outboundQueue or waitQueue is not empty.&quot;</span>,</span><br><span class="line">                                   windowHandle-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对于非按键事件，事件等待队列不为空且头事件分发超时500ms</span></span><br><span class="line">        <span class="keyword">if</span> (!connection-&gt;waitQueue.<span class="built_in">isEmpty</span>()</span><br><span class="line">                &amp;&amp; currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime</span><br><span class="line">                        + STREAM_AHEAD_EVENT_TIMEOUT) &#123;</span><br><span class="line">            <span class="comment">// 如果等待队列不为空且头事件分发超时，则返回一个非空字符串表示窗口未准备好</span></span><br><span class="line">            <span class="keyword">return</span> String8::format(<span class="string">&quot;Window &#x27;%s&#x27; is not ready for more input, &quot;</span></span><br><span class="line">                                   <span class="string">&quot;waitQueue head event is timed out.&quot;</span>,</span><br><span class="line">                                   windowHandle-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果代码执行到这里，说明窗口准备好接收更多输入，返回一个空字符串</span></span><br><span class="line">    <span class="keyword">return</span> String8::<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到findFocusedWindowTargetsLocked方法直到如果checkWindowReadyForMoreInputLocked返回的字符串不为空就会走入handleTargetsNotReadyLocked方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">InputDispatcher::handleTargetsNotReadyLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果失败的原因不是因为应用程序未准备好</span></span><br><span class="line">    <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line">        <span class="comment">// 设置等待原因为应用程序未准备好</span></span><br><span class="line">        mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;</span><br><span class="line">        <span class="comment">// 记录等待开始的时间</span></span><br><span class="line">        mInputTargetWaitStartTime = currentTime;</span><br><span class="line">        <span class="comment">// 设置超时时间为当前时间加上5秒</span></span><br><span class="line">        mInputTargetWaitTimeoutTime = currentTime + <span class="number">5000000000</span>; <span class="comment">// 5秒</span></span><br><span class="line">        <span class="comment">// 标记超时未发生</span></span><br><span class="line">        mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 清除等待的应用程序句柄</span></span><br><span class="line">        mInputTargetWaitApplicationHandle.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前时间超过了等待超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;</span><br><span class="line">        <span class="comment">// 进入应用程序无响应(ANR)处理流程</span></span><br><span class="line">        <span class="built_in">onANRLocked</span>(currentTime, mInputTargetWaitApplicationHandle, mFocusedWindowHandle,</span><br><span class="line">                    entry-&gt;eventTime, mInputTargetWaitStartTime, reason);</span><br><span class="line">        <span class="comment">// 强制立即执行下一轮轮询，以执行ANR策略</span></span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="comment">// 返回事件注入待定状态</span></span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他处理逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回成功或其他状态</span></span><br><span class="line">    <span class="keyword">return</span> INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当下一个输入事件调用<code>handleTargetsNotReadyLocked()</code>方法时，如果<code>mInputTargetWaitCause</code>的值还没有被改变，仍然为<code>INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY</code>，则直接进入<code>(currentTime &gt;= mInputTargetWaitTimeoutTime)</code>的判断。如果超时等待时间大于5s，则满足该条件，进入<code>onANRLocked()</code>方法，发送ANR通知。</p>
<p>上面就是大致的input事件触发ANR的流程。但是在Android11开始有了一些变化，之前是第一个输入事件被阻塞了当第二个输入事件进来时才会触发ANR，现在是可以同时发多个事件，并且修改且严格了ANR的校验逻辑。</p>
<p>新版本的逻辑有以下几点不同：</p>
<ul>
<li>增加<code>AnrTracker</code>记录事件的超时时间。</li>
<li>每次回调<code>dispatchOnce</code>都会检查<code>Tracker</code>中记录的事件是否有超时，如果超时则触发ANR。</li>
<li>可以同时发多个<code>Event</code>，但只要有一个超时，则判定为ANR。</li>
<li>当前<code>Event</code>也会触发ANR，因为也会走到检查<code>Tracker</code>中是否有超时<code>Event</code>的逻辑。</li>
</ul>
<p>回头看<code>InputDispatcher的dispatchOnce</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   。。。</span><br><span class="line">    <span class="comment">// 处理可能的应用程序无响应（ANR）情况，并获取下一次ANR检查的时间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> nextAnrCheck = <span class="built_in">processAnrsLocked</span>();</span><br><span class="line">    <span class="comment">// 更新下一次唤醒时间为最小的时间（即最早的唤醒时间）</span></span><br><span class="line">    nextWakeupTime = std::<span class="built_in">min</span>(nextWakeupTime, nextAnrCheck);</span><br><span class="line">	。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processAnrsLocked方法就是在Android11新增的。看下具体的逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">InputDispatcher::processAnrsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> currentTime = <span class="built_in">now</span>();</span><br><span class="line">    <span class="type">nsecs_t</span> nextAnrCheck = LONG_LONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否正在等待一个焦点窗口出现，如果等待时间过长，则引发ANR</span></span><br><span class="line">    <span class="keyword">if</span> (mNoFocusedWindowTimeoutTime.<span class="built_in">has_value</span>() &amp;&amp; mAwaitedFocusedApplication != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTime &gt;= *mNoFocusedWindowTimeoutTime) &#123;</span><br><span class="line">            <span class="comment">// 触发ANR处理</span></span><br><span class="line">            <span class="built_in">onAnrLocked</span>(mAwaitedFocusedApplication);</span><br><span class="line">            <span class="comment">// 清除等待的应用程序</span></span><br><span class="line">            mAwaitedFocusedApplication.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> LONG_LONG_MIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续等待</span></span><br><span class="line">            <span class="type">const</span> <span class="type">nsecs_t</span> millisRemaining = <span class="built_in">ns2ms</span>(*mNoFocusedWindowTimeoutTime - currentTime);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Still no focused window. Will drop the event in %&quot;</span> PRId64 <span class="string">&quot;ms&quot;</span>, millisRemaining);</span><br><span class="line">            nextAnrCheck = *mNoFocusedWindowTimeoutTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有任何连接的ANR到期</span></span><br><span class="line">    nextAnrCheck = std::<span class="built_in">min</span>(nextAnrCheck, mAnrTracker.<span class="built_in">firstTimeout</span>());</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt; nextAnrCheck) &#123;</span><br><span class="line">        <span class="comment">// 最有可能的情况，一切正常。让我们在nextAnrCheck时再次检查</span></span><br><span class="line">        <span class="keyword">return</span> nextAnrCheck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行到这里，说明我们有一个无响应的连接</span></span><br><span class="line">    sp&lt;Connection&gt; connection = <span class="built_in">getConnectionLocked</span>(mAnrTracker.<span class="built_in">firstToken</span>());</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not find connection for entry %&quot;</span> PRId64, mAnrTracker.<span class="built_in">firstTimeout</span>());</span><br><span class="line">        <span class="keyword">return</span> nextAnrCheck;</span><br><span class="line">    &#125;</span><br><span class="line">    connection-&gt;responsive = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 停止唤醒这个无响应的连接</span></span><br><span class="line">    mAnrTracker.<span class="built_in">eraseToken</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">    <span class="comment">// 触发ANR处理</span></span><br><span class="line">    <span class="built_in">onAnrLocked</span>(connection);</span><br><span class="line">    <span class="keyword">return</span> LONG_LONG_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processAnrsLocked</code> 方法首先获取当前时间，并初始化下一次ANR检查时间为最大值。然后，它检查是否正在等待一个焦点窗口出现，如果等待时间过长，则触发ANR处理。接着，它检查是否有任何连接的ANR到期，如果有，则更新下一次ANR检查时间。</p>
<p>onAnrLocked回调到Java层的流程可以看下面这篇文章</p>
<p><a href="http://gityuan.com/2017/01/01/input-anr/">http://gityuan.com/2017/01/01/input-anr/</a></p>
<p>最终所有的ANR都会回调到下面这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(String activityShortComponentName, ApplicationInfo aInfo,</span></span><br><span class="line"><span class="params">            String parentShortComponentName, WindowProcessController parentProcess,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> aboveSystem, TimeoutRecord timeoutRecord,</span></span><br><span class="line"><span class="params">            ExecutorService auxiliaryTaskExecutor, <span class="type">boolean</span> onlyDumpSelf,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isContinuousAnr, Future&lt;File&gt; firstPidFilePromise)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">annotation</span> <span class="operator">=</span> timeoutRecord.mReason; <span class="comment">// ANR的原因</span></span><br><span class="line">        <span class="type">AnrLatencyTracker</span> <span class="variable">latencyTracker</span> <span class="operator">=</span> timeoutRecord.mLatencyTracker; <span class="comment">// ANR延迟跟踪器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mApp.isDebugging()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Skipping debugged app ANR: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; &quot;</span> + annotation);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果应用正在调试，跳过ANR处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mApp.getWindowProcessController().appEarlyNotResponding(annotation, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                mApp.killLocked(<span class="string">&quot;anr&quot;</span>, ApplicationExitInfo.REASON_ANR, <span class="literal">true</span>); <span class="comment">// 提前终止应用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isMonitorCpuUsage()) &#123;</span><br><span class="line">            <span class="comment">// 更新CPU统计信息</span></span><br><span class="line">            updateCpuStatsNowFirstCall = auxiliaryTaskExecutor.submit(() -&gt; &#123;</span><br><span class="line">                mService.updateCpuStatsNow();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skipAnrLocked(annotation)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 如果决定跳过ANR，直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (mProcLock) &#123;</span><br><span class="line">                setNotResponding(<span class="literal">true</span>); <span class="comment">// 标记应用为无响应状态</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_ANR, mApp.userId, mApp.getPid(), mApp.processName,</span><br><span class="line">                    mApp.info.flags, annotation); <span class="comment">// 将ANR事件写入事件日志</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录ANR到主日志</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            info.append(<span class="string">&quot;ANR in &quot;</span>).append(mApp.processName);</span><br><span class="line">            <span class="keyword">if</span> (activityShortComponentName != <span class="literal">null</span>) &#123;</span><br><span class="line">                info.append(<span class="string">&quot; (&quot;</span>).append(activityShortComponentName).append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            info.append(<span class="string">&quot;\nPID: &quot;</span>).append(mApp.getPid());</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                info.append(<span class="string">&quot;\nReason: &quot;</span>).append(annotation);</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.e(TAG, info.toString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mApp.getWindowProcessController().appNotResponding(info.toString(),</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                            mApp.killLocked(<span class="string">&quot;anr&quot;</span>, ApplicationExitInfo.REASON_ANR, <span class="literal">true</span>); <span class="comment">// 终止应用</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                            mService.mServices.scheduleServiceTimeoutLocked(mApp); <span class="comment">// 安排服务超时</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                <span class="comment">// 显示“应用无响应”对话框</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">                msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">                msg.obj = <span class="keyword">new</span> <span class="title class_">AppNotRespondingDialog</span>.Data(mApp, aInfo, aboveSystem, isContinuousAnr);</span><br><span class="line">                mService.mUiHandler.sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要流程如下：<br> 1、写入event log<br> 2、写入 main log<br> 3、生成tracesFile<br> 4、输出ANR logcat（控制台可以看到）<br> 5、如果没有获取到tracesFile，会发一个<code>SIGNAL_QUIT</code>信号，这里看注释是会触发收集线程堆栈信息流程，写入traceFile<br> 6、输出到drapbox<br> 7、后台ANR，直接杀进程<br> 8、错误报告<br> 9、弹出ANR dialog</p>
<h4 id="ANR触发流程小结"><a href="#ANR触发流程小结" class="headerlink" title="ANR触发流程小结"></a>ANR触发流程小结</h4><blockquote>
<p>ANR触发流程，可以比喻为埋炸弹和拆炸弹的过程，<br> 以启动Service为例，Service的onCreate方法调用之前会使用Handler发送延时10s的消息，Service 的onCreate方法执行完，会把这个延时消息移除掉。<br> 假如Service的onCreate方法耗时超过10s，延时消息就会被正常处理，也就是触发ANR，会收集cpu、堆栈等信息，弹ANR Dialog。</p>
</blockquote>
<p>service、broadcast、provider 的ANR原理都是<strong>埋定时炸弹和拆炸弹</strong>原理，</p>
]]></content>
  </entry>
  <entry>
    <title>Fragment相关</title>
    <url>/2024/03/26/Android%20Fragment/</url>
    <content><![CDATA[<h3 id="fragmenet生命周期"><a href="#fragmenet生命周期" class="headerlink" title="fragmenet生命周期"></a>fragmenet生命周期</h3><ol>
<li>**onAttach()**：Fragment与Activity建立关联时调用。</li>
<li>**onCreate()**：Fragment创建时调用。</li>
<li>**onCreateView()**：Fragment创建视图时调用。</li>
<li>**onViewCreated()**：Fragment视图创建完成时调用。</li>
<li>**onStart()**：Fragment开始时调用。</li>
<li>**onResume()**：Fragment恢复时调用。</li>
<li>**onPause()**：Fragment暂停时调用。</li>
<li>**onStop()**：Fragment停止时调用。</li>
<li>**onDestroyView()**：Fragment视图销毁时调用。</li>
<li>**onDestroy()**：Fragment销毁时调用。</li>
</ol>
<h3 id="和Activity结合时得生命周期"><a href="#和Activity结合时得生命周期" class="headerlink" title="和Activity结合时得生命周期"></a>和Activity结合时得生命周期</h3><h4 id="静态引入"><a href="#静态引入" class="headerlink" title="静态引入"></a>静态引入</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">        android:id=<span class="string">&quot;@+id/framelayout&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:name=<span class="string">&quot;com.app.tsmo.TestFragment&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>Activity中onCreate得代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        loge(<span class="string">&quot;MainActivity: onCreate start&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_test)</span><br><span class="line">        loge(<span class="string">&quot;MainActivity: onCreate end&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下打印得日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:20)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onStart ...(TestActivity.kt:26)</span><br><span class="line">MainActivity: onResume ...(TestActivity.kt:49)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>分析下日志得特点：</p>
<p>fragment得onAttach、onCreate、onCreateView、onViewCreated这四个方法是在<code>setContentView(R.layout.activity_test)</code>得时候回调的。</p>
<p>除了onStart、onPause、onStop、onSaveInstanceState、onDestroy方法fragment先回调，onCreate、onResume都是Activity先回调。fragment没有onRestoreInstanceState但有一个onViewStateRestored方法，且onViewStateRestored先执行onRestoreInstanceState后执行.</p>
<p>看下横竖屏切换的日志</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fragment : onPause ...(TestFragment.kt:<span class="number">100</span>)</span><br><span class="line">MainActivity: onPause ...(TestActivity.kt:<span class="number">67</span>)</span><br><span class="line">fragment : onStop ...(TestFragment.kt:<span class="number">112</span>)</span><br><span class="line">MainActivity: onStop ...(TestActivity.kt:<span class="number">55</span>)</span><br><span class="line">fragment : onSaveInstanceState ...(TestFragment.kt:<span class="number">94</span>)</span><br><span class="line">MainActivity: onSaveInstanceState ...(TestActivity.kt:<span class="number">21</span>)</span><br><span class="line">fragment : onDestroyView ...(TestFragment.kt:<span class="number">83</span>)</span><br><span class="line">fragment : onDestroy ...(TestFragment.kt:<span class="number">77</span>)</span><br><span class="line">fragment : onDetach ...(TestFragment.kt:<span class="number">89</span>)</span><br><span class="line">MainActivity: onDestroy ...(TestActivity.kt:<span class="number">61</span>)</span><br><span class="line">MainActivity: onCreate start ...(TestActivity.kt:<span class="number">13</span>)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:<span class="number">27</span>)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:<span class="number">36</span>)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:<span class="number">43</span>)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:<span class="number">66</span>)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:<span class="number">15</span>)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:<span class="number">71</span>)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:<span class="number">106</span>)</span><br><span class="line">MainActivity: onStart ...(TestActivity.kt:<span class="number">26</span>)</span><br><span class="line">MainActivity: onRestoreInstanceState ...(TestActivity.kt:<span class="number">32</span>)</span><br><span class="line">MainActivity: onResume ...(TestActivity.kt:<span class="number">49</span>)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:<span class="number">118</span>)</span><br></pre></td></tr></table></figure>

<p>总结一下横竖屏切换时fragment的生命周期变化</p>
<p>onPause - onStop - onSaveInstanceState - onDestroyView - onDestroy - onDetach - onAttach - onCreate - onCreateView - onViewCreated - onViewStateRestored - onStart - onResume</p>
<p>顺便看一下Activity的生命周期变化</p>
<p>onPause - onStop - onSaveInstanceState - onDestroy - onCreate - onStart - onResume</p>
<h4 id="动态引入"><a href="#动态引入" class="headerlink" title="动态引入"></a>动态引入</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        loge(<span class="string">&quot;MainActivity: onCreate start&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_test)</span><br><span class="line">        supportFragmentManager.beginTransaction().add(R.id.framelayout, TestFragment()).commitNow()</span><br><span class="line">        loge(<span class="string">&quot;MainActivity: onCreate end&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:1</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:16)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onStart ...(TestActivity.kt:27)</span><br><span class="line">MainActivity: onResume ...(TestActivity.kt:50)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>尝试一下在onResume方法中引入TestFragment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:15)</span><br><span class="line">MainActivity: onStart ...(TestActivity.kt:26)</span><br><span class="line">MainActivity: onResume start  ...(TestActivity.kt:49)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onResume end ...(TestActivity.kt:51)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>嗯。。。</p>
<p>动态添加的话生命周期在onResume方法中是不推荐的</p>
<p>那就在onStart中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:15)</span><br><span class="line">MainActivity: onStart start ...(TestActivity.kt:26)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onStart end ...(TestActivity.kt:28)</span><br><span class="line">MainActivity: onResume start  ...(TestActivity.kt:50)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>将commitNow换成commit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:15)</span><br><span class="line">MainActivity: onStart start ...(TestActivity.kt:26)</span><br><span class="line">MainActivity: onStart end ...(TestActivity.kt:28)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onResume start  ...(TestActivity.kt:50)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>没啥参考价值</p>
<ol>
<li><strong>commit()</strong>:<ul>
<li><code>commit()</code>方法安排事务的改变在主线程上的未来某个时间点异步执行。</li>
<li>如果使用了<code>commit()</code>后面紧跟着执行的操作依赖于该事务的完成，那么可能还没有完成，因此可能看不到预期的结果。</li>
<li>由于它是异步的，<code>commit()</code>允许在Activity的状态保存之后执行，但是这种情况下必须结合<code>commitAllowingStateLoss()</code>使用，这样你就表示你愿意承担由此可能导致的状态丢失风险。</li>
<li>可以选择将一个事务加入回退栈，以允许用户导航回前一个Fragment。</li>
</ul>
</li>
<li><strong>commitNow()</strong>:<ul>
<li><code>commitNow()</code>方法是同步执行事务的，当方法被调用时立即执行。</li>
<li>由于<code>commitNow()</code>会立即执行，在调用它之后的代码将会在事务更改后执行，因此可以立即看到改变。</li>
<li><code>commitNow()</code>不能与将事务加入回退栈的操作同时使用，因为它不支持在事务中使用<code>addToBackStack(String name)</code>方法。</li>
<li><code>commitNow()</code>不能在Activity保存状态之后执行，否则会引发<code>IllegalStateException</code>。这通常意味着不能在活动的生命周期回调（如<code>onSaveInstanceState()</code>之后、<code>onResume()</code>中或者之后）中使用<code>commitNow()</code>。</li>
</ul>
</li>
</ol>
<p>简而言之，<code>commit()</code>更常见而且更灵活，适用于大多数组合（特别是当包括动画或者需要回退栈时）。而<code>commitNow()</code>则适用于需要立即执行的情况，但使用时需要更小心，尤其是在处理Activity的生命周期和状态保存的问题上。</p>
<p>重新回到onCreate方法中，使用commit提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:17)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onStart start ...(TestActivity.kt:28)</span><br><span class="line">MainActivity: onStart end ...(TestActivity.kt:29)</span><br><span class="line">MainActivity: onResume start  ...(TestActivity.kt:51)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>和静态引入的区别</p>
<p>静态引入gragment的onAttach、onCreate、onCreateView、onViewCreated都在Activity的onCreate方法中完成，动态引入使用commitNow的话onAttach、onCreate在Activity的onCreate方法中完成，使用commit的话都在Activity的onCreate方法之后执行。</p>
<p>看下横竖屏切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fragment : onPause ...(TestFragment.kt:100)</span><br><span class="line">MainActivity: onPause ...(TestActivity.kt:70)</span><br><span class="line">fragment : onStop ...(TestFragment.kt:112)</span><br><span class="line">MainActivity: onStop ...(TestActivity.kt:58)</span><br><span class="line">fragment : onSaveInstanceState ...(TestFragment.kt:94)</span><br><span class="line">MainActivity: onSaveInstanceState ...(TestActivity.kt:23)</span><br><span class="line">fragment : onDestroyView ...(TestFragment.kt:83)</span><br><span class="line">fragment : onDestroy ...(TestFragment.kt:77)</span><br><span class="line">fragment : onDetach ...(TestFragment.kt:89)</span><br><span class="line">MainActivity: onDestroy ...(TestActivity.kt:64)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">MainActivity: onCreate start ...(TestActivity.kt:13)</span><br><span class="line">MainActivity: onCreate end ...(TestActivity.kt:17)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onAttach ...(TestFragment.kt:27)</span><br><span class="line">fragment : onCreate ...(TestFragment.kt:36)</span><br><span class="line">fragment : onCreateView ...(TestFragment.kt:43)</span><br><span class="line">fragment : onViewCreated ...(TestFragment.kt:66)</span><br><span class="line">fragment : onViewStateRestored ...(TestFragment.kt:71)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">fragment : onStart ...(TestFragment.kt:106)</span><br><span class="line">MainActivity: onStart start ...(TestActivity.kt:28)</span><br><span class="line">MainActivity: onStart end ...(TestActivity.kt:29)</span><br><span class="line">MainActivity: onRestoreInstanceState ...(TestActivity.kt:35)</span><br><span class="line">MainActivity: onResume start  ...(TestActivity.kt:51)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br><span class="line">fragment : onResume ...(TestFragment.kt:118)</span><br></pre></td></tr></table></figure>

<p>在MainActivity: onDestroy之前的没变化，之后的静态的是先Activity的onCreate再onAttach、onCreate,动态的是先fragment的onAttach和onCreate然后再Activity的onCreate。</p>
<p>除了onStart、onPause、onStop、onSaveInstanceState、onDestroy方法fragment先回调，onCreate、onResume都是Activity先回调。fragment没有onRestoreInstanceState但有一个onViewStateRestored方法，且onViewStateRestored先执行onRestoreInstanceState后执行.</p>
<p>这段话得再加个横竖屏切换的话只有onResume是Activity先回调。</p>
<h4 id="静态加载和动态加载的区别体现在哪里？"><a href="#静态加载和动态加载的区别体现在哪里？" class="headerlink" title="静态加载和动态加载的区别体现在哪里？"></a>静态加载和动态加载的区别体现在哪里？</h4><p>静态加载和动态加载的主要区别体现在 <strong>执行加载操作的消息周期不同</strong>：静态加载和布局解析是在同一个 Handler 消息周期中，而动态加载和事务提交不一定在一个 Handler 消息周期中（取决于调用 commit() 还是 commitNow()）。</p>
<h3 id="fragment的状态"><a href="#fragment的状态" class="headerlink" title="fragment的状态"></a>fragment的状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int INITIALIZING = -1;          //  Fragment尚未与Activity附加，它仍然在初始化过程中。</span><br><span class="line">   static final int ATTACHED = 0;               // Fragment已经和宿主Activity绑定，但还没有完成创建过程。</span><br><span class="line">   static final int CREATED = 1;                // Fragment的onCreate()方法已被调用，但其视图尚未被创建。</span><br><span class="line">   static final int VIEW_CREATED = 2;           // Fragment的视图已经被创建了</span><br><span class="line">   static final int AWAITING_EXIT_EFFECTS = 3;  // Fragment正处于退出的状态，可能正在等待退出动画完成。</span><br><span class="line">   static final int ACTIVITY_CREATED = 4;       //  Activity已完成创建过程</span><br><span class="line">   static final int STARTED = 5;                // Fragment进入到了开始状态</span><br><span class="line">   static final int AWAITING_ENTER_EFFECTS = 6; // Fragment正在进入，可能正在等待进入动画或过渡效果完成。</span><br><span class="line">   static final int RESUMED = 7;                //  Fragment已处于活跃状态，能够与用户交互</span><br></pre></td></tr></table></figure>

<h4 id="状态改变"><a href="#状态改变" class="headerlink" title="状态改变"></a>状态改变</h4><p>Activity执行完后通知了Fragment进行状态转移，而Fragment执行了状态转移后对应的回调了生命周期方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#FragmentActivity</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mFragmentLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">        <span class="comment">// 这里进行了状态传递</span></span><br><span class="line">        mFragments.dispatchCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#FragmentController</span><br><span class="line"><span class="keyword">public</span> void dispatchCreate() &#123;</span><br><span class="line">        mHost.mFragmentManager.dispatchCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">最终走到</span><br><span class="line">一个事件分发switch case里，然后调用对应的方法，比如Create</span><br><span class="line">void dispatchOnFragmentCreated(<span class="meta">@NonNull</span> Fragment f,</span><br><span class="line">            <span class="meta">@Nullable</span> Bundle savedInstanceState, boolean onlyRecursive) &#123;</span><br><span class="line">        Fragment parent = mFragmentManager.getParent();</span><br><span class="line">       。。。</span><br><span class="line">        <span class="keyword">for</span> (FragmentLifecycleCallbacksHolder holder : mLifecycleCallbacks) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!onlyRecursive || holder.mRecursive) &#123;</span><br><span class="line">                <span class="comment">// 这里回调了Fragment的onCreate方法</span></span><br><span class="line">                holder.mCallback.onFragmentCreated(</span><br><span class="line">                        mFragmentManager, f, savedInstanceState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="FragmentManager"><a href="#FragmentManager" class="headerlink" title="FragmentManager"></a>FragmentManager</h3><p>FragmentManager，顾名思义是负责管理Fragment的管理类，可以对Fragment进行添加、移除、替换等操作。并且，Fragment也有和Activity类似的任务栈。Fragment可被添加到栈中，也可以出栈。</p>
<h4 id="从Activity中获取FragmentManager"><a href="#从Activity中获取FragmentManager" class="headerlink" title="从Activity中获取FragmentManager"></a>从Activity中获取FragmentManager</h4><p>FragmentActivity或者是继承自FragmentActivity的子类（比如，ApppCompatActivity）都可以获得FragmentManager。获取方法是:<code>getSupportFragmentManager()</code>。</p>
<h4 id="从Fragment上获取FragmentManager"><a href="#从Fragment上获取FragmentManager" class="headerlink" title="从Fragment上获取FragmentManager"></a>从Fragment上获取FragmentManager</h4><p>Fragment除了依附在Activity上，也可以依附在别Fragmet上。这时被依附的Fragment就是父Fragment，依附的Fragment就是子Fragment。<br> 那么管理子Fragment的FragmentManager自然可以从其父Fragment里获取。方法是: <code>getChildFragmentManager()</code>。也好理解，管理子Fragment嘛，自然是getChildFragmentManager。<br> 上面是一个Fragment获取其子Fragment的管理类（ <code>getChildFragmentManager()</code>），而要想获取管理自身的管理类，可以通过<code>getParentFragmentManager()</code>方法实现。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/7be20c4998274a5bbf522d9e48ba3d2b.jpg" alt="Fragment与其持有者（Activity或父Fragment），还有FragmentManager的对应关系"></p>
<h3 id="FragmentTransaction"><a href="#FragmentTransaction" class="headerlink" title="FragmentTransaction"></a>FragmentTransaction</h3><p>FragmentManager是Fragment的管理者，但它还需要一个助手帮它完成Fragment的add、replace等操作。这个助手就是FragmentTransaction。</p>
<p>对Fragment的添加、替换等操作可能会有多个。比如先移除当前FragmentA，再添加FragmentB，这样两个操作通常就被打包一次Transaction，统一提交(commit)。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line">fragmentManager.beginTransaction()</span><br><span class="line">	.remove(fragmentA)</span><br><span class="line">	.add(R.id.fragment_container, FragmentB.class,<span class="literal">null</span>)</span><br><span class="line">    .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">    .addToBackStack(<span class="string">&quot;name&quot;</span>) <span class="comment">// name can be null</span></span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>

<h4 id="FragmentTransaction的获取"><a href="#FragmentTransaction的获取" class="headerlink" title="FragmentTransaction的获取"></a>FragmentTransaction的获取</h4><p>从上面代码可以看出FragmentTransaction是FragmentManager的助手，自然会通过FragmentManager获得。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction()</span><br></pre></td></tr></table></figure>

<h3 id="Fragment之前通信"><a href="#Fragment之前通信" class="headerlink" title="Fragment之前通信"></a>Fragment之前通信</h3><h4 id="利用Fragment-Result的API传递数据"><a href="#利用Fragment-Result的API传递数据" class="headerlink" title="利用Fragment Result的API传递数据"></a>利用Fragment Result的API传递数据</h4><p>为了从FragmentB向FragmentA传递数据，首先给fragmentA设置监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    getParentFragmentManager().setFragmentResultListener(<span class="string">&quot;key&quot;</span>, <span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">FragmentResultListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentResult</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Bundle bundle)</span> &#123;</span><br><span class="line">            <span class="comment">// 这里使用的是String，但是任何其他能够被放在Bundle中的数据类型都是支持的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;bundleKey&quot;</span>);</span><br><span class="line">            <span class="comment">//做一些其他事情</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在FragmentB中，生产结果，需要注意的是，FragmentB必须使用和FragmentA一样的FragmentManager，使用相同的<code>requestKey</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        result.putString(<span class="string">&quot;bundleKey&quot;</span>, <span class="string">&quot;result&quot;</span>);</span><br><span class="line">        getParentFragmentManager().setFragmentResult(<span class="string">&quot;requestKey&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一旦FragmentA处于<code>STARTED</code>状态，它将会接受到结果并且执行监听回调。</p>
<p><strong>怎么保证ragmentB必须使用和FragmentA一样的FragmentManager？</strong></p>
<ol>
<li><p><strong>如果 <code>FragmentB</code> 是 <code>FragmentA</code> 的子 Fragment</strong>：</p>
<ul>
<li>使用 <code>FragmentA</code> 的 <code>childFragmentManager</code> 来添加 <code>FragmentB</code>。这确保了两个 Fragments 都在相同的 Fragment 管理器上下文中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fragmentA.childFragmentManager.beginTransaction()</span><br><span class="line">    .add(R.id.fragment_container, fragmentB)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果 <code>FragmentA</code> 和 <code>FragmentB</code> 都是同一个 Activity 的同级 Fragment</strong>：</p>
<ul>
<li>使用它们共同的 <code>Activity</code> 的 <code>supportFragmentManager</code>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">supportFragmentManager.beginTransaction()</span><br><span class="line">    .add(R.id.fragment_container_A, fragmentA)</span><br><span class="line">    .add(R.id.fragment_container_B, fragmentB)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>FragmentB</code> 使用和 <code>FragmentA</code> 相同 <code>FragmentManager</code> 的示例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentA</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setupFragmentB</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fragmentB = FragmentB()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 FragmentA 的 childFragmentManager 来添加 FragmentB 作为子 Fragment</span></span><br><span class="line">        childFragmentManager.beginTransaction()</span><br><span class="line">            .replace(R.id.fragment_container, fragmentB)</span><br><span class="line">            .commit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentB</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendResultBackToFragmentA</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建结果 Bundle</span></span><br><span class="line">        <span class="keyword">val</span> result = Bundle().apply &#123;</span><br><span class="line">            putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用和 FragmentA 相同的 childFragmentManager 来设置结果</span></span><br><span class="line">        requireParentFragment().childFragmentManager.setFragmentResult(<span class="string">&quot;requestKey&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用ViewModel"><a href="#使用ViewModel" class="headerlink" title="使用ViewModel"></a>使用ViewModel</h4><p>首先，创建一个共享的 <code>ViewModel</code>，这个 <code>ViewModel</code> 将被两个 Fragment 访问：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 LiveData 作为通信的通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> message = MutableLiveData&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置消息的方法，供发送方 Fragment 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setMessage</span><span class="params">(input: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        message.value = input</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察消息的方法，供接收方 Fragment 调用</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMessage</span><span class="params">()</span></span>: LiveData&lt;String&gt; = message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两个 Fragment 中，使用 <code>ViewModelProvider</code> 获取相同的 <code>SharedViewModel</code> 实例。在发送方 Fragment 中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SenderFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">        <span class="comment">// 确保两个 Fragment 使用相同的 Activity 作为 ViewModelStoreOwner</span></span><br><span class="line">        viewModel = ViewModelProvider(requireActivity()).<span class="keyword">get</span>(SharedViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSendButtonClick</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当按钮点击时调用 ViewModel 的 setMessage 方法来发送消息</span></span><br><span class="line">        viewModel.setMessage(<span class="string">&quot;Hello from SenderFragment&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收方 Fragment 中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReceiverFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> viewModel: SharedViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">        <span class="comment">// 确保两个 Fragment 使用相同的 Activity 作为 ViewModelStoreOwner</span></span><br><span class="line">        viewModel = ViewModelProvider(requireActivity()).<span class="keyword">get</span>(SharedViewModel::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察 ViewModel 中的消息 LiveData</span></span><br><span class="line">        viewModel.getMessage().observe(viewLifecycleOwner, &#123; message -&gt;</span><br><span class="line">            <span class="comment">// 当 LiveData 更新时，这里会被调用，可以更新 UI 等</span></span><br><span class="line">            displayMessage(message)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">displayMessage</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 显示接收到的消息或进行其他处理</span></span><br><span class="line">        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Android Handler消息机制</title>
    <url>/2024/03/26/Android%20Handler%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Android-Handler"><a href="#Android-Handler" class="headerlink" title="Android Handler"></a>Android Handler</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		Handler是android在设计之初就封装的 <strong>一套消息创建、传递、处理机制。</strong>用于 <strong>子线程与主线程间的通讯</strong>，实现了一种 <strong>非堵塞的消息传递机制</strong>。</p>
<h2 id="系统创建Handler流程"><a href="#系统创建Handler流程" class="headerlink" title="系统创建Handler流程"></a>系统创建Handler流程</h2><p><strong>ActivityThread</strong> 的 <strong>main函数是APP进程的入口</strong>，main函数里面会执行下面这两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>

<p><code>prepareMainLooper()</code>的作用是创建Looper，下面简单看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Looper</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">// 实现在下面#1.1 false说明looper不能主动停止</span></span><br><span class="line">        prepare(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// #1.2</span></span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># <span class="number">1.1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// #1.4 这里创建一个Looper然后存入ThreadLocal中实现线程绑定</span></span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">1.2</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">// 这里返回当前线程的Looper</span></span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">1.3</span></span><br><span class="line">    sThreadLocal的定义：<span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Looper&gt;();</span><br><span class="line">    每个Thread内部都维护了一个ThreadLocalMap，这个map的key是ThreadLocal,value是set的那个值。</span><br><span class="line">    get的时候，线程都是从自己的变量中取值，所以不存在线程安全问题。</span><br><span class="line">    另外，线程为key也保证了每个线程只有一个Looper，而创建Looper对象时又会创建MessageQueue对象，</span><br><span class="line">    所以间接保证每个线程最多只能有一个MessageQueue。</span><br><span class="line"></span><br><span class="line"># <span class="number">1.4</span></span><br><span class="line"> <span class="comment">// Looper的构造方法中创建了MessageQueue和指定Looper绑定当前线程</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>loop()</code>的作用就是启动looper的消息循环，具体的代码就不贴了大概就是开启了一个死循环，其伪代码类似下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// 不断的取出消息</span></span><br><span class="line">     msg.target.dispatchMessage(msg)<span class="comment">// 不断的进行消息分发</span></span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">return</span>  <span class="comment">// 没有消息表明消息队列正在退出。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Handler流程"><a href="#Handler流程" class="headerlink" title="Handler流程"></a>Handler流程</h2><h3 id="handler使用"><a href="#handler使用" class="headerlink" title="handler使用"></a>handler使用</h3><p>先来上Handler基本使用的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandlerActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> handler: Handler</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_handler)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Handler</span></span><br><span class="line">        handler = MyHandler(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送空消息</span></span><br><span class="line">        handler.sendEmptyMessage(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送带有数据的消息</span></span><br><span class="line">        <span class="keyword">val</span> message = Message.obtain()</span><br><span class="line">        message.what = <span class="number">1</span></span><br><span class="line">        message.arg1 = <span class="number">10</span></span><br><span class="line">        handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟发送空消息</span></span><br><span class="line">        handler.sendEmptyMessageDelayed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟发送带有数据的消息</span></span><br><span class="line">        <span class="keyword">val</span> delayedMessage = Message.obtain()</span><br><span class="line">        delayedMessage.what = <span class="number">1</span></span><br><span class="line">        delayedMessage.arg1 = <span class="number">10</span></span><br><span class="line">        handler.sendMessageDelayed(delayedMessage, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Runnable</span></span><br><span class="line">        handler.post &#123;</span><br><span class="line">            <span class="comment">// 在这里执行后台任务</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟发送 Runnable</span></span><br><span class="line">        handler.postDelayed(&#123;</span><br><span class="line">            <span class="comment">// 在这里执行后台任务</span></span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除指定 what 的消息</span></span><br><span class="line">        handler.removeMessages(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> myRunnable = Runnable &#123;</span><br><span class="line">            <span class="comment">// 任务代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将一个 Runnable 对象（myRunnable）发送到 Handler 关联的线程的消息队列中。这意味着 Runnable 中的代码将在 Handler 所在的线程（通常是主线程）中执行。</span></span><br><span class="line">        handler.post(myRunnable)</span><br><span class="line">        <span class="comment">// 从 Handler 的消息队列中移除指定的 Runnable 对象（myRunnable）。如果这个 Runnable 尚未执行，那么它将不会被执行。</span></span><br><span class="line">        handler.removeCallbacks(myRunnable)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建未一个顶层类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span>(activity: HandlerActivity) : Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activityWeakReference: WeakReference&lt;HandlerActivity&gt; = WeakReference(activity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> activity = activityWeakReference.<span class="keyword">get</span>()</span><br><span class="line">        activity?.let &#123;</span><br><span class="line">            <span class="keyword">when</span> (msg.what) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 处理消息</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 其他 case</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是Handler基本使用的代码了。</p>
<h3 id="handler发送消息"><a href="#handler发送消息" class="headerlink" title="handler发送消息"></a>handler发送消息</h3><p>Handler发送消息的方式有好多种下面列举一下：</p>
<ol>
<li><strong>发送空消息</strong>:<ul>
<li><code>sendEmptyMessage(int what)</code></li>
<li><code>sendEmptyMessageAtTime(int what, long uptimeMillis)</code></li>
<li><code>sendEmptyMessageDelayed(int what, long delayMillis)</code></li>
</ul>
</li>
<li><strong>发送消息对象</strong>:<ul>
<li><code>sendMessage(Message msg)</code></li>
<li><code>sendMessageAtTime(Message msg, long uptimeMillis)</code></li>
<li><code>sendMessageDelayed(Message msg, long delayMillis)</code></li>
</ul>
</li>
<li><strong>发送 Runnable 对象</strong>:<ul>
<li><code>post(Runnable r)</code></li>
<li><code>postAtTime(Runnable r, long uptimeMillis)</code></li>
<li><code>postAtTime(Runnable r, Object token, long uptimeMillis)</code></li>
<li><code>postDelayed(Runnable r, long delayMillis)</code></li>
<li><code>postOnAnimation(Runnable r)</code> (API level 16)</li>
<li><code>postOnAnimationDelayed(Runnable r, long delayMillis)</code> (API level 16)</li>
</ul>
</li>
</ol>
<p>​		在这些方法中，<code>sendEmptyMessage</code>、<code>sendMessage</code> 和 <code>post</code> 是最常用的。<code>sendEmptyMessage</code> 和 <code>sendMessage</code> 用于发送包含数据的 <code>Message</code> 对象，<strong>而 <code>post</code> 用于在 <code>Handler</code> 关联的线程上执行 <code>Runnable</code> 对象。其他方法提供了在特定时间或延迟后发送消息的能力。</strong></p>
<p>​		上面所有的方法最后都会调用到最后其实都是 <strong>sendMessageAtTime</strong>()完成的，这个方法有两个参数（@NonNull Message msg, long uptimeMillis）msg就是要发送的信息，uptimeMillis是当前时间加上要延迟的时间，看下代码更具体的理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    	<span class="comment">// 对queue进行判空</span></span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将消息 <code>msg</code> 安排在将来的某个时间点发送。这个时间点是通过将当前的系统正常运行时间（不包括睡眠时间）与延迟时间 <code>delayMillis</code> 相加来计算得出的。<code>SystemClock.uptimeMillis() + delayMillis</code> 计算出的是<strong>消息应该被发送的具体时间点。</strong></li>
</ul>
<h3 id="将消息插入MessageQueue"><a href="#将消息插入MessageQueue" class="headerlink" title="将消息插入MessageQueue"></a>将消息插入MessageQueue</h3><p>sendMessageAtTime方法最后也是调用到了MessageQueue的enqueueMessage方法，这个MessageQueue就是在handler创建的时候传入的Looper中的或者是当前线程的Looper中的如果有的话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查目标 Handler 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步代码块，确保消息队列的线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;This message is already in use.&quot;</span>);</span><br><span class="line">   		 &#125;</span><br><span class="line">        <span class="comment">// 如果该消息已经标记为死亡（即消息队列正在退出）</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;MessageQueue&quot;</span>, e.getMessage(), e);</span><br><span class="line">            msg.recycle(); <span class="comment">// 回收消息对象以供后续重用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记消息为正在使用状态</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when; <span class="comment">// 设置消息的计划发送时间</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages; <span class="comment">// mMessages 是消息队列的头部</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> needWake; <span class="comment">// 标记是否需要唤醒消息队列</span></span><br><span class="line">        <span class="comment">// 如果消息队列为空，或者当前消息的发送时间早于队列头部的消息</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 新消息成为新的头部  这里就是链表的操作</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg; </span><br><span class="line">            needWake = mBlocked; <span class="comment">// 如果消息队列被阻塞，则需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，遍历消息队列，找到合适的插入位置</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 循环，找到第一个计划发送时间晚于当前消息的节点</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="comment">// 在 prev 和 p 之间插入新消息</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果我们发现一个异步消息，我们不需要唤醒队列</span></span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新消息插入队列</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要，唤醒消息队列</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面就是将消息插入队列的逻辑，下面就该看处理消息的逻辑了。</p>
<h3 id="Looper进行消息分发"><a href="#Looper进行消息分发" class="headerlink" title="Looper进行消息分发"></a>Looper进行消息分发</h3><p>回到上面的那个Looper.loop()方法，这个方法开启了消息队列的轮询。那么就来看下具体的轮询逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Looper</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的 Looper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记开始循环</span></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除调用者的身份，并获取一个标识符</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无限循环，处理消息</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident)) &#123;</span><br><span class="line">            <span class="comment">// 如果 loopOnce 返回 false，则退出循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me, <span class="keyword">final</span> <span class="type">long</span> ident)</span> &#123;</span><br><span class="line">    <span class="comment">// 从消息队列中获取下一个消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// 可能会阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有消息表示消息队列正在退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息派发日志</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Android10开始，可以通过添加observer的方式，监听messsage的执行情况</span></span><br><span class="line">  	<span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">   		 observer.messageDispatched(token, msg);</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="comment">// 处理消息时发生异常</span></span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复线程的身份</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed during message dispatching.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收消息对象</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印消息完成日志</span></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面是Looper中处理消息的逻辑，大致的逻辑就是开启一个死循环然后不断的从mQueue中取出消息然后进行分发。</p>
<p>上面的逻辑可以使用之前的伪代码表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next(); <span class="comment">// 不断的取出消息</span></span><br><span class="line">     msg.target.dispatchMessage(msg)<span class="comment">// 不断的进行消息分发</span></span><br><span class="line">     <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">return</span>  <span class="comment">// 没有消息表明消息队列正在退出。</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，loop中的逻辑就上面这些，处理消息的关键在于从MQ中获取消息。</p>
<h3 id="MessageQueue轮询消息队列"><a href="#MessageQueue轮询消息队列" class="headerlink" title="MessageQueue轮询消息队列"></a>MessageQueue轮询消息队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># MessageQueue </span><br><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果消息循环已经退出并且被销毁，则直接返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 仅在第一次迭代时使用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有超时时间，则刷新挂起的 Binder 命令</span></span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用本地方法等待下一个消息，可能会阻塞</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试检索下一个消息，如果找到则返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 被一个屏障阻塞，寻找队列中下一个异步消息</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 下一个消息还没准备好，设置一个超时时间以便在它准备好时唤醒</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 得到一个消息</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有更多消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在处理完所有挂起的消息后，处理退出消息</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是第一次空闲，则获取要运行的空闲处理器的数量</span></span><br><span class="line">            <span class="comment">// 空闲处理器仅在队列为空或队列中的第一个消息（可能是一个屏障）将来要处理时运行</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有空闲处理器要运行，继续循环并等待</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化空闲处理器数组</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行空闲处理器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// 释放对处理器的引用</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将空闲处理器计数重置为 0，以便不再次运行它们</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在调用空闲处理器的过程中，可能会有新的消息传递过来</span></span><br><span class="line">        <span class="comment">// 因此返回并再次检查挂起的消息，而不需要等待</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nextPollTimeoutMillis</strong>，决定了堵塞与否，以及堵塞的时间，三种情况：</p>
<blockquote>
<p><strong>等于0时</strong>，不堵塞，立即返回，Looper第一次处理消息，有一个消息处理完 ； <strong>大于0时</strong>，最长堵塞等待时间，期间有新消息进来，可能会了立即返回(立即执行)； <strong>等于-1时</strong>，无消息时，会一直堵塞；</p>
</blockquote>
<p>此处没有用java中的wait&#x2F;notify堵塞，而是通过Linux的**<code>epoll机制</code>**来堵塞，原因是需要处理 <strong><code>native侧</code></strong> 的事件。</p>
<p>首先会调用<code>nativePollOnce</code>这个native方法，等<code>nativePollOnce</code>返回后，会去<code>MessageQueue</code>的链表中取下一条待执行的message。</p>
<p>取message的逻辑：</p>
<ul>
<li>取链表头的第一个message（<code>MessageQueue</code>中的message是按照时间顺序排列的，所以第一个就是最近的待执行的message）</li>
<li>如果这个消息是同步屏障，则跳过所有同步消息，直接取下一个异步消息，返回</li>
<li>否则，判断当前message是否到执行时间，如果到执行时间，则直接返回，否则继续调<code>nativePollOnce</code>等待。</li>
</ul>
<h1 id="Handler-进阶"><a href="#Handler-进阶" class="headerlink" title="Handler 进阶"></a>Handler 进阶</h1><h2 id="Linux的epoll机制"><a href="#Linux的epoll机制" class="headerlink" title="Linux的epoll机制"></a>Linux的epoll机制</h2><ul>
<li>epoll：是一种 I&#x2F;O 时间通信机制，是 Linux 内核实现 IO 多路复用的一种方式。</li>
<li>IO 多路复用：在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候 返回，然后对其进行读写操作。</li>
<li>输入输出源：可以是文件（file）、网络（socket）、进程间的管道（pipe），因在 Linux 中 “一切皆文件”，所以都是用文件描述符（fd）来表示</li>
</ul>
<p>IO多路复用举例：网络后台同时收到多个读写请求，一般流程是将这些请求统一的入队处理。这样一个程序并发的处理多个IO事件的方式叫做IO多路复用。<strong>I&#x2F;O 多路复用是一种可以让单个线程处理多个 I&#x2F;O 请求的方法，而不是为每个 I&#x2F;O 操作创建多个线程。</strong>一个常见的例子是网络服务器使用非阻塞 I&#x2F;O 和多路复用来同时处理多个进来的网络请求。</p>
<p>IO 多路复用就是 1 个线程处理 多个 fd 的模式。我们的要求是：这个 “1” 就要尽可能的快，避免一切无效工作，<strong>要把所有的时间都用在处理句柄的 IO 上，不能有任何空转，sleep 的时间浪费。</strong>有没有一种工具，我们把一箩筐的 fd 放到里面，只要有一个 fd 能够读写数据，后台 loop 线程就要立马唤醒，全部马力跑起来。其他时间要把 cpu 让出去？</p>
<p>epoll池就满足了这个需求:</p>
<p>epoll 涉及的系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">epoll_create</span><br><span class="line">epollctl</span><br><span class="line">epollwait</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>epollcreate</code> 负责创建一个池子，一个监控和管理句柄 fd 的池子；</p>
</li>
<li><p><code>epollctl</code> 负责管理这个池子里的 fd 增、删、改；</p>
</li>
<li><p><code>epollwait</code> 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</p>
<pre><code>  epoll 池的内部通过红黑树管理句柄 fd，红黑树的查找时间复杂度为 O(log n)。存储有了就要保证fd可读可写可以及时的回调给 epoll 池。我们直到在 Linux 中 “一切皆文件”，文件描述符知道的有读read，写write等有好多，多路复用就是基于poll描述符实现的，这个是定制监听事件的机制实现。`poll` 的基本用法是提供一个文件描述符数组以及每个文件描述符感兴趣的事件（如读就绪、写就绪、错误等）。调用 `poll` 后，它会阻塞直到以下情况之一发生：
</code></pre>
</li>
</ol>
<ul>
<li>一个或多个文件描述符准备好了相应的操作（如读或写）。</li>
<li>超时发生，如果在调用时指定了超时值。</li>
<li>发生了一个信号中断。</li>
</ul>
<p><strong>这个 poll 事件回调机制则是 epoll 池高效最核心原理。</strong></p>
<p><strong>epoll 池管理的句柄只能是支持了 <code>file_operations-&gt;poll</code> 的文件 fd。换句话说，如果一个“文件”所在的文件系统没有实现 poll 接口，那么就用不了 epoll 机制。</strong></p>
<p>当 fd 满足可读可写的时候就会经过层层回调，最终调用到这个回调函数，把<strong>对应 fd 的结构体</strong>放入就绪队列中，从而把 epoll 从 <code>epoll_wait</code> 出唤醒。</p>
<p><strong>小结下：epoll 之所以做到了高效，最关键的两点：</strong></p>
<ol>
<li>内部管理 fd 使用了高效的红黑树结构管理，做到了增删改之后性能的优化和平衡；</li>
<li>epoll 池添加 fd 的时候，调用 <code>file_operations-&gt;poll</code> ，把这个 fd 就绪之后的回调路径安排好。通过事件通知的形式，做到最高效的运行；</li>
<li>epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；</li>
</ol>
<p>总结一下就</p>
<p><a href="https://zhuanlan.zhihu.com/p/393747291">深入理解 Linux 的 epoll 机制</a></p>
<p><a href="https://sleticalboy.github.io/linux/2021/01/22/linux-epoll-mechanism/">linux epoll 机制</a></p>
<h2 id="epoll机制在MessageQueue中的应用"><a href="#epoll机制在MessageQueue中的应用" class="headerlink" title="epoll机制在MessageQueue中的应用"></a>epoll机制在MessageQueue中的应用</h2><p>上一节讲到epoll机制基于三个调用</p>
<ol>
<li><code>epollcreate</code> 负责创建一个池子，一个监控和管理句柄 fd 的池子；</li>
<li><code>epollctl</code> 负责管理这个池子里的 fd 增、删、改；</li>
<li><code>epollwait</code> 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；</li>
</ol>
<p>下面追一下MessageQueue的底层代码</p>
<p>先看下构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed = quitAllowed;</span><br><span class="line">    	<span class="comment">// 1.1</span></span><br><span class="line">        mPtr = nativeInit(); <span class="comment">//这里调用了第一个native函数，对应native层的android_os_MessageQueue.cpp的				android_os_MessageQueue_nativeInit，记住这个返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">1.1</span></span><br><span class="line"><span class="keyword">static</span> jlong <span class="title function_">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> &#123;</span><br><span class="line">    <span class="comment">//创建native层的MessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="title class_">NativeMessageQueue</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//计数器加1</span></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="comment">//将native层的MessageQueue指针转换成long并返回给java层，也就是java层的mPtr</span></span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeMessateQueue的构造函数</span></span><br><span class="line">NativeMessageQueue::NativeMessageQueue():mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread(); <span class="comment">//从当前Thread中获取Looper</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == NULL) &#123; </span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="title class_">Looper</span>(<span class="literal">false</span>); <span class="comment">//没有就创建</span></span><br><span class="line">        Looper::setForThread(mLooper); <span class="comment">//放入当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 <code>Looper</code> 不是 Java 层的 <code>Looper</code>，而是 Android 系统底层（通常是 C++ 层）的一个实现。虽然它的概念和工作方式与 Java 层的 <code>Looper</code> 类似，都是用于管理一个消息循环（Message Loop），但它是在原生代码层面实现的。</p>
<p>接着我们来看native层Looper的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks): <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">    <span class="comment">//...建立文件描述符</span></span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="comment">//...建立epoll机制</span></span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里建立了epoll机制，看下详细的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果文件描述符已经存在就关闭</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mEpollFd.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个新的epoll文件描述符，并添加到wake管道    </span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem; <span class="comment">//创建一个epoll事件eventItem</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event)); <span class="comment">//将eventItem清空</span></span><br><span class="line">    eventItem.events = EPOLLIN; <span class="comment">//设置这个事件类型为EPOLLIN，也就是可读事件</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>(); 设置文件描述符为唤醒事件</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册唤醒事件到epoll</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册其他事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> Request&amp; request = mRequests.<span class="built_in">valueAt</span>(i);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">        request.<span class="built_in">initEventItem</span>(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epollResult = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了epollcreate和epoll_ctl进行了epoll池创建和注册唤醒事件。</p>
<p>我们发送消息时会走到MessageQueue的enqueueMessage方法然后里面会调用nativeWake这个native方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据ptr取出对应的MessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">//调用wake()函数</span></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接调用了Looper的wake()</span></span><br><span class="line">   mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将唤醒事件的文件描述符mWakeEventFd写入inc，我们通过epoll机制知道，当写入数据的时候，读出端会立刻感知到，</span></span><br><span class="line">    <span class="comment">//也就是说，此时读出端已经知道有数据写入了，也就是有message消息需要处理了，那么在哪处理呢，对了，就在MessageQueue的next()里面，我们去看</span></span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd, &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们在Java层send一个message</li>
<li>最终会调用到java层的MessageQueue的enqueue中</li>
<li>如果需要唤醒就会去调用nativeWake() <strong>这里开始进入native</strong></li>
<li>nativeWake最终会调用到native Looper的wake()</li>
<li>这个wake()最终写入了一个唤醒事件，用于通知有消息写入</li>
</ul>
<p><strong>上面的唤醒逻辑就是在下面在进入epoll等待后如何唤醒的解答。</strong></p>
<p>下面是收消息的逻辑看下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 通过epoll机制，等待消息，或超时唤醒</span></span><br><span class="line">    nativePollOnce(ptr, nextPollTimeoutMills);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">       <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// msg.target == null 表示是同步屏障</span></span><br><span class="line">          <span class="comment">// 如果有同步屏障，则直接跳到下一个异步的消息（同步的消息都过滤掉，先不处理）</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">             prevMsg = msg;</span><br><span class="line">             msg = msg.next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">          <span class="comment">// 如果当前还没到达message的执行时间, 则获取当前的时间差作为timeout</span></span><br><span class="line">          nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// 省略一些链表的操作 prevMsg.next = msg.next; msg.next = null;</span></span><br><span class="line">           <span class="comment">// 直接返回已经到达执行时间的，第一条message</span></span><br><span class="line">           <span class="keyword">return</span> msg;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环一开始调用的代码nativePollOnce，看一下底层实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据ptr取MessageQueue的</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    <span class="comment">//调用MessageQueue的pollOnce()</span></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//看这句就行，又是调用了Looper的pollOnce，看来native的MessageQueue就是个传话的，真正干事的是Looper，这难道就是传说中的代理模式?</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//死循环...</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//死循环结束的条件是result != 0，那就是说如果等于0就一直跑</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等于0就一直跑这个，那就来看这个，pollInner其实是不会返回0的，那也就是说，只要pollInner有返回，就能结束循环</span></span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>来看下最核心的pollInner方法，参数就是java层传递的那个nextPollTimeoutMillis参数:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//result的取值有四种: POLL_WAKE = -1 POLL_CALLBACK = -2 POLL_TIMEOUT = -3 POLL_ERROR = -4</span></span><br><span class="line">    <span class="type">int</span> result = POLL_WAKE; </span><br><span class="line">    <span class="comment">//创建事件集合eventItems，EPOLL_MAX_EVENTS=16</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用epoll_wait()来等待事件，如果有事件，就放入事件集合eventItems中，并返回事件数量，如果没有，就一直等，超时时间为我们传入的timeoutMillis</span></span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    mLock.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果发生的事件小于0，也就是说没有事件处理，就跳转到Done</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有goto到Done，也就是有事件发生，就跑到这里</span></span><br><span class="line">    <span class="comment">//遍历事件集合eventItems</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="comment">//取出文件描述符</span></span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="comment">//取出事件类型</span></span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;<span class="comment">//如果文件描述符为mWakeEventFd</span></span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;<span class="comment">//并且事件类型为EPOLLIN（可读事件）</span></span><br><span class="line">                <span class="comment">//说明有数据可读，就调用awoken()读数据，直到读完为止，</span></span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里就是Done，是从if(eventCount&lt;=0)跳转过来的</span></span><br><span class="line">    Done:;</span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="comment">//mMessageEnvelopes是一个Vector，存放native层的消息</span></span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="comment">//取出第一个MessageEnvelope，MessageEnvelop有收件人Hanlder和消息内容Message，可以理解为jave层的Message </span></span><br><span class="line">        <span class="type">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.<span class="built_in">itemAt</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//判断消息的执行时间，跟java层的那个 if(message.when &lt;= now)类似</span></span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123; <span class="comment">//表示消息已经到了执行时间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//取出Handler</span></span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                <span class="comment">//取出Message</span></span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.<span class="built_in">removeAt</span>(<span class="number">0</span>); <span class="comment">//删除，因为接下来就处理了</span></span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                mLock.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="comment">//处理消息</span></span><br><span class="line">                handler-&gt;<span class="built_in">handleMessage</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">            mLock.<span class="built_in">lock</span>();</span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//消息还没到执行时间</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="comment">//跳出循环，进入下一次轮询，java层是计算等待时间nextPollTimeoutMillis</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理带有Callback()方法的Response事件，执行Reponse相应的回调方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="comment">// 处理请求的回调方法</span></span><br><span class="line">            <span class="type">int</span> callbackResult = response.request.callback-&gt;<span class="built_in">handleEvent</span>(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">removeFd</span>(fd, response.request.seq); <span class="comment">//移除fd</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    mLock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Looper.pollInner</code>主要做如下事情：</p>
<ul>
<li>调用<code>epoll_wait</code>，等待在一些特定的fd上</li>
<li>当epoll_wait返回后（fd发生写入或超时时间到），执行唤醒的事件。<ul>
<li>如果唤醒的是<code>mWakeEventFd</code>，则直接调用awoken方法。</li>
<li>如果唤醒的是之前注册在<code>mRequests</code>中的fd，则将<code>Request</code>生成一个对应的<code>Response</code>，加入<code>mResponses</code>集合</li>
</ul>
</li>
<li>处理native message，执行相应的回调方法</li>
<li>处理<code>mResponses</code>集合中的所有<code>Response</code>事件，调用他们<code>callback</code>的<code>handleEvent</code>回调方法。（点击事件就是在这里被执行的）</li>
</ul>
<p>我们来看看<code>awoken</code>方法。它的逻辑很简单，就是循环读取fd中的全部内容。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">    <span class="type">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nRead = <span class="built_in">read</span>(mWakeReadPipeFd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面总结一下这个流程</p>
<ul>
<li>现在我们调用handler.sendMessageDelay(msg,3000);让一个message在3秒后执行，</li>
<li>MessageQueue.next()查看此message，发现msg.when &gt; now，还不该执行，于是就将nextPollTimeoutMillis &#x3D; 3000,并且将mBlockd &#x3D; true,然后调用nativePollOnce(nextPollTimeoutMillis)去等待，此时native先跑到pollOnce()，result被初始化为0，所以一直在for里面，然后进入pollOnce()，在epoll_wait()死等着。</li>
<li>此时我们又调用handler.sendMessage(msg)，让一个message立即执行。</li>
<li>此时在MessageQueue.enqueueMessage()中，先将这个消息插入到延时3000ms的那个message前面，然后发现when&#x3D;&#x3D;0，于是就将needwake &#x3D; mBlocked，也就是true，于是接着就调用了nativeWake();于是接着进入native层的Looper的wake()里面写入了一个唤醒事件，此时Looper的epoll_wait()就监听到了，于是立刻返回，处理监听事件后就return result，此时pollOnce()里面因为result!&#x3D;0，就返回到了java层， 于是MessageQueue的next就立刻活跃起来，马上拿出刚刚sendMessage(msg)的这个msg开始处理，处理完了到下一个(也就是延时3000ms那个)，发现msg.when &gt; now，就继续第2步的等待，后面如果还有新消息，就重复前面的过程，没有新消息就等待epoll_wait()超时返回，超时时间是3000ms，返回后跟上述步骤基本一样。</li>
</ul>
<p>MessageQueue核心原理：主线程通过<code>Looper</code>中的死循环，不断从<code>MessageQueue</code>中获取待指定的message。</p>
<ul>
<li>如果有到执行时间的消息时，直接执行。</li>
<li>如果还没有到执行时间的消息，会通过epoll_wait等待在mWakeReadPipeFd端口，等待内容写入，超时时间是下一个message执行时间到现在的时间差。<ul>
<li>如果在等待的过程中，有新的消息插入队列，会往<code>mWakeReadPipeFd</code>端口写入数据，这样就能唤醒等待在这个上面的<code>pollInner</code>方法，从而继续执行之后的<code>message</code>。</li>
<li>如果等待的过程中，没有新的消息插入，则会在<code>timeout</code>时间到达的时候，唤醒，处理后面的<code>message</code>。</li>
</ul>
</li>
</ul>
<p><a href="https://juejin.cn/post/6982931925207875620#heading-0">Handler源码分析三 native层</a></p>
<p><a href="https://juejin.cn/post/7200389542758678565#heading-2">从epoll机制看MessageQueue</a></p>
<p><a href="https://sleticalboy.github.io/linux/2021/01/22/linux-epoll-mechanism/">linux epoll 机制</a></p>
<h2 id="Handler同步屏障和异步消息机制"><a href="#Handler同步屏障和异步消息机制" class="headerlink" title="Handler同步屏障和异步消息机制"></a>Handler同步屏障和异步消息机制</h2><p>先看看遇到异步消息时的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ...省略部分代码...</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">       ...省略部分代码...</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="comment">//满足条件说明msg是同步屏障</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                    <span class="comment">// 不断的循环直到找到异步消息</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            ...省略部分代码...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果消息是异步的，则返回 true，这意味着它不受Looper同步障碍的影响。返回值：如果消息是异步的，则为 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAsynchronous</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>异步消息的机制:</p>
<p>​		异步消息跟在同步屏障后面(不一定是紧临)，异步消息会被优先执行。寻找异步消息的过程是先找同步屏障，如果有，就遍历next来找异步消息，同步屏障的特点是msg.target&#x3D;null，异步消息的特点是isAsynchronous &#x3D; true。 eg: <strong>同步屏障是50，异步消息是100，同步屏障前面的1-49会先执行，然后执行到50的时候发现是同步屏障，然后就遍历后续消息，找到异步消息100，取出来执行，然后移除同步屏障50，在继续执行后面的消息51，以此类推。</strong></p>
<p>异步消息的应用：Android Ui绘制</p>
<p>Activity处于<code>onResume()</code>生命周期时才会展示布局。在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中会触发Activity的<code>onResume()</code>生命周期的回调，然后将DecorView add进WindowManager中，最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法，这个方法中会调用<code>requestLayout()</code>开启绘制。</p>
<p>上面是View绘制的一个大概流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewRootImpl</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread(); <span class="comment">//检查当前线程</span></span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>; <span class="comment">//更新标记</span></span><br><span class="line">        scheduleTraversals(); <span class="comment">//开始遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这里检查线程是否是mThread，不是的话就抛出异常，mThread一般是UI线程</span></span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(<span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123; <span class="comment">//不在执行中才执行</span></span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>; <span class="comment">//更新标记为执行中</span></span><br><span class="line">        <span class="comment">//向mHandler的MessageQueue中添加一个同步屏障，一个同步屏障也是一个Message，但是这个Message的target是null，并且后面会有一个异步消息AsynchronousMessage</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//这里是重点！！！，通过Choreographer来post一个消息，//TAG1: CALLBACK_TRAVERSAL，要记住这个TAG</span></span><br><span class="line">        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">        ...省略部分代码...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postSyncBarrier()方法的逻辑就是插入一个同步屏障没啥好说的，主要还是它下面这行代码的逻辑。</p>
<p>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);第一个参数是个int，第二个参数mTraversalRunnable是个Runnable，主要的绘制逻辑就在这个Runnable中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123; <span class="comment">//不在执行中才执行</span></span><br><span class="line">        mTraversalScheduled = <span class="literal">false</span>; <span class="comment">//更新标记为执行中</span></span><br><span class="line">        <span class="comment">//从mHandler的MesssageQueue中移除同步屏障，还记得刚刚添加同步屏障的代码吗</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        <span class="comment">//开始遍历布局</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法对view进行了测量，布局和绘制，我们后面会细讲</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    performMeasure();</span><br><span class="line">    ......</span><br><span class="line">    performLayout();</span><br><span class="line">    ......</span><br><span class="line">    performDraw();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么重点的逻辑就是mChoreographer.postCallback的逻辑，下面看下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Choreographer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallback</span><span class="params">(<span class="type">int</span> callbackType, Runnable action, Object token)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接调用postCallbackDelayed方法，延迟时间设置为0</span></span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayed</span><span class="params">(<span class="type">int</span> callbackType, Runnable action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查action是否为null，如果是，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;action must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查callbackType是否有效，如果无效，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callbackType is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内部方法处理延迟回调</span></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType, Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果启用了调试，打印回调信息</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步锁，确保线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 计算回调应该执行的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">//这是个数组 callbackType是CALLBACK_TRAVERSAL，dueTime=0，action就是那个mTraversalRunnable</span></span><br><span class="line">        <span class="comment">//这里就是将这个mTraversalRunnable保存在CALLBACK_TRAVERSAL对应的集合里了</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果回调的执行时间已到或过期</span></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">// 发送立即处理的handler消息</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果回调还未到执行时间</span></span><br><span class="line">            <span class="comment">// 创建一个消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            <span class="comment">// 设置回调类型</span></span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            <span class="comment">// 设置消息为异步</span></span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 发送消息，让回调在指定时间执行</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码最后我们看到使用mHandler发送了一个message，看下mHandler的构造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    	<span class="comment">// ui线程的looper</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                    doFrame(System.nanoTime(), <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">DisplayEventReceiver</span>.VsyncEventData());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                    doScheduleVsync();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                    doScheduleCallback(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleVsyncLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//来看下scheduleVsync方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleVsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这里直接调用了native的方法，native调用完成会回到</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>native完事后会回调到FrameDisplayEventReceiver.onVsync()里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiverimplements</span> Runnable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper, vsyncSource, CONFIG_CHANGED_EVENT_SUPPRESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>); <span class="comment">//这里的第二个参数是this，意味着msg.callback = this，那么就会跑到自己的run函数 </span></span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//跑到这里了</span></span><br><span class="line">        mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 下面</span></span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">        &#125;</span><br><span class="line">    ...省略计算时间的代码...</span><br><span class="line">    <span class="comment">//下面开始执行事件顺序为: 1 输入事件 2 动画 3 布局</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        <span class="comment">//TAG: CALLBACK_TRAVERSAL，还记得这个TAG吗，我们看这里即可</span></span><br><span class="line">        <span class="comment">// 看下面的代码</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//这里根据callbackType取出所有事件，这里的type是:CALLBACK_TRAVERSAL</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line">        ...省略部分代码...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历取出所有事件，执行，还记得我们之前的那个:mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null)吗？</span></span><br><span class="line">        <span class="comment">//第二个参数就是一个runnable，就会被执行，也就是执行到我们的traversal()里去了，最终就会去测量、布局、绘制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...回收callback...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到这里完成了闭环，c.run(frameTimeNanos)里面执行的就是TraversalRunnable.run()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾上面在同步屏障方面的应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送同步屏障</span></span><br><span class="line">mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line"><span class="comment">// 发送异步消息</span></span><br><span class="line">mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 移除同步屏障</span></span><br><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br></pre></td></tr></table></figure>



<p>到这里记录两个问题：</p>
<ol>
<li>为什么不能在子线程更新ui</li>
</ol>
<p>在上面的代码有看到在ViewRootImpl的requestLayout中会有checkThread这一步骤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewRootImpl</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread(); <span class="comment">//检查当前线程</span></span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>; <span class="comment">//更新标记</span></span><br><span class="line">        scheduleTraversals(); <span class="comment">//开始遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewRootImpl</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (mThread != current) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span></span><br><span class="line">                            + <span class="string">&quot; Expected: &quot;</span> + mThread.getName()</span><br><span class="line">                            + <span class="string">&quot; Calling: &quot;</span> + current.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里对比的是ViewRootImpl的成员mThread和当前线程的，而mThread的赋值是在ViewRootImpl的构造函数中。上面我们也提到ViewRootImpl的创建是在WindowManagerGlobal中。</p>
<blockquote>
<p>在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中会触发Activity的<code>onResume()</code>生命周期的回调，然后将DecorView add进WindowManager中，最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>。</p>
</blockquote>
<p>上面的逻辑是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中的，是在UI线程执行的。所以mThread的值一定是Ui线程。</p>
<ol start="2">
<li>在onCrete方法中可以在子线程中更新ui</li>
</ol>
<p>很简单，在onCreate中还没有进行checkThread检查，直到onResume时才会进行检查。</p>
<p><a href="https://juejin.cn/post/6960112470325198862">Handler源码分析之二 异步消息的处理</a></p>
<h2 id="Hander面试题"><a href="#Hander面试题" class="headerlink" title="Hander面试题"></a>Hander面试题</h2><h4 id="1-为什么要把Looper放在ThreadLocal里面"><a href="#1-为什么要把Looper放在ThreadLocal里面" class="headerlink" title="1.为什么要把Looper放在ThreadLocal里面"></a>1.为什么要把Looper放在ThreadLocal里面</h4><ul>
<li><p>每个线程都有个ThreadLocalMap的成员变量threadLocals，这个变量可以理解为一个HashMap，其中key是ThreadLocal，value是任意类型。</p>
</li>
<li><p>Looper内部有个ThreadLocal静态成员变量sThreadLocal，在prepare()的时候，会先创建一个Looper，然后获取当前线程的ThreadLocalMap，并且把自自己的成员变量sThreadLocal作为key，把这个looper作为值存放进去，可以简单理解为:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Looper</span> <span class="variable">looler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Looper</span>(); <span class="comment">//创建一个looper</span></span><br><span class="line"><span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> Thread.currentThread().getMap(); <span class="comment">//获取当前线程的ThreadLocalMap</span></span><br><span class="line">map.set(sThreadLocal, looper); <span class="comment">//将looper存入当前线程的ThreadLocalMap中</span></span><br></pre></td></tr></table></figure>

<p>Looper获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Looper</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ThreadLocalMap</span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    	<span class="comment">// 获取当前线程的threadLocals成员</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里的this就是当前ThreadLocalMap对象，在Looper类中就是那个sThreadLocal成员</span></span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="comment">// 返回Value 也就是当前线程的looper</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Looper在主线程中死循环，为啥不会ANR？"><a href="#Looper在主线程中死循环，为啥不会ANR？" class="headerlink" title="Looper在主线程中死循环，为啥不会ANR？"></a>Looper在主线程中死循环，为啥不会ANR？</h4><p>没有消息就会进入epoll_wait状态，有新消息或者等待时间到了就会进行唤醒。</p>
<ol start="3">
<li>消息队列中的消息是如何存储的？为什么没有用“常规容器类”</li>
</ol>
<p>利用单链表进行存储，链表是一种非线性，非顺序的物理结构，由n个节点组成。</p>
<p>链表采用的“见缝插针”的存储方式，不需要内存连续，靠next指针关联；</p>
<p>存储的时候是随机的，访问方式是顺序访问；</p>
<h4 id="为什么采用链表结构存储消息，而不是用数组结构？"><a href="#为什么采用链表结构存储消息，而不是用数组结构？" class="headerlink" title="为什么采用链表结构存储消息，而不是用数组结构？"></a>为什么采用链表结构存储消息，而不是用数组结构？</h4><ul>
<li><p>因为我们执行过程中，堆里面可能已经建了很多个对象，如果我们初始化一个数组时候，可能空间不够，也没办法很好的利用碎片空间。</p>
</li>
<li><p>Handler消息存储与读取应该遵循先进先出，一般在队尾增加数据，在队首进行取数据或者删除数据。先发的消息肯定就会先被处理。</p>
</li>
</ul>
<p>但是，Handler中还有比较特殊的情况，比如延时消息。延时消息的存在就让这个队列有些特殊性了，并不能完全保证先进先出，而是需要根据时间来判断，所以Android中采用了链表的形式来实现这个队列，也方便了数据的插入。</p>
<h4 id="具体的消息存储过程？"><a href="#具体的消息存储过程？" class="headerlink" title="具体的消息存储过程？"></a>具体的消息存储过程？</h4><ul>
<li>消息的发送过程，无论是哪种方法发送消息，都会走到sendMessageDelayed方法，最后调用sendMessageAtTime方法。sendMessageDelayed方法主要计算了消息需要被处理的时间，如果delayMillis为0，那么消息的处理时间就是当前时间。</li>
<li>然后就是关键方法MessageQueue的enqueueMessage方法。<ol>
<li>首先设置了Message的when字段，也就是代表了这个消息的处理时间</li>
<li>然后判断当前队列是不是为空，是不是即时消息，是不是执行时间when小于表头的消息时间，满足任意一个，就把当前消息msg插入到表头。</li>
<li>否则，就需要遍历这个队列，也就是链表，找出when小于某个节点的when，找到后插入。</li>
<li>总之，插入消息就是通过消息的执行时间，也就是when字段，来找到合适的位置插入链表。</li>
<li>具体方法就是通过for死循环，使用快慢指针p和prev，每次向后移动一格，直到找到某个节点p的when大于我们要插入消息的when字段，则插入到p和prev之间。或者遍历到链表结束，插入到链表结尾。</li>
<li>所以，MessageQueue就是一个用于存储消息、用链表实现的特殊队列结构</li>
</ol>
</li>
</ul>
<h4 id="MessageQueue没有消息时候会怎样？阻塞之后怎么唤醒呢？说说pipe-epoll机制？"><a href="#MessageQueue没有消息时候会怎样？阻塞之后怎么唤醒呢？说说pipe-epoll机制？" class="headerlink" title="MessageQueue没有消息时候会怎样？阻塞之后怎么唤醒呢？说说pipe&#x2F;epoll机制？"></a>MessageQueue没有消息时候会怎样？阻塞之后怎么唤醒呢？说说pipe&#x2F;epoll机制？</h4><p>当消息不可用或者没有消息的时候就会阻塞在next方法，而阻塞的办法是通过pipe&#x2F;epoll机制</p>
<p>epoll机制是一种IO多路复用的机制，具体逻辑就是一个进程可以监视多个描述符，当某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，这个读写操作是阻塞的。在Android中，会创建一个Linux管道（Pipe）来处理阻塞和唤醒。 当消息队列为空，管道的读端等待管道中有新内容可读，就会通过epoll机制进入阻塞状态。 当有消息要处理，就会通过管道的写端写入内容，唤醒主线程。</p>
<p><a href="https://juejin.cn/post/7265212750364360764?searchId=202402232043542A215F5C7BB932D3002E">一文读懂Handler面试</a></p>
<h4 id="子线程中维护的looper，消息队列无消息的时候处理方案是什么？有什么用，主线程呢？"><a href="#子线程中维护的looper，消息队列无消息的时候处理方案是什么？有什么用，主线程呢？" class="headerlink" title="子线程中维护的looper，消息队列无消息的时候处理方案是什么？有什么用，主线程呢？"></a>子线程中维护的looper，消息队列无消息的时候处理方案是什么？有什么用，主线程呢？</h4><p>消息队列无消息时候，此时Looper会一直阻塞状态。</p>
<p>处理方案：</p>
<ul>
<li><p>在loop机制中有个quit和quitSafely函数，他们调用messageQueue中的quit函数，从而将消息队列中的全部的消息给全部remove掉，然后释放内存；</p>
</li>
<li><p>紧接着就会调运行到quit方法中最后一行nativeWake函数唤醒所有等待的地方。</p>
</li>
<li><p>醒来之后然后继续在阻塞的地方放下执行，发现msg&#x3D;&#x3D;null，直接return null；这个时候looper结束，退出死循环，释放线程。</p>
<p> ​		子线程创建 Looper 并执行 loop() 的线程在任务结束的时候，需要手动调用 quit。否则，线程将由于 loop() 的轮询一直处于可运行状态，CPU 资源无法释放。更有可能因为 Thread 作为 GC Root 持有超出生命周期的实例引发内存泄漏。当 quit 调用后，Looper 不再因为没有 Message 去等待，而是直接取到为 null 的 Message，这将触发轮循死循环的退出。</p>
</li>
</ul>
<h4 id="Handler机制内存泄漏原因？为什么其他的内部类没有说过这个问题？"><a href="#Handler机制内存泄漏原因？为什么其他的内部类没有说过这个问题？" class="headerlink" title="Handler机制内存泄漏原因？为什么其他的内部类没有说过这个问题？"></a>Handler机制内存泄漏原因？为什么其他的内部类没有说过这个问题？</h4><p><strong>主线程 —&gt; threadlocal —&gt; Looper —&gt; MessageQueue —&gt; Message —&gt; Handler —&gt; Activity</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/618e7be8000e4cfc8c990855c92f92b7%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="B1262342-96FF-493D-838F-D70DDE548CA2.png"></p>
<p>  1、handler创建时候就对持有当前Activity得引用，同时message持有对handler的引用。MessageQueue持有Message；Message持有了Handler；handler是匿名内部类，持有this Activity，Activity持有大量内存，就会造成内存泄漏。</p>
<p>  2、 发送一个延迟消息时候，消息被处理前，该消息一直保存在消息队列中，在持续保存这段时间，messageque持有对message的引用，Message持有了handler；在我们的activity中建立一个Handler的实例，该handler实例默认持有了外部的对象acticity的引用，当我们调用acticity的ondestroy方法时，activity销毁了，但是根据可达性分析，我们销毁的activity存在被handler引用，只要handler不被释放，没办法会销毁，就造成了内存泄漏。</p>
<p><strong>解决该办法的两个方法：</strong></p>
<p>1、将handler变为static，就会不会引用activity，因为静态内部类不会持有外部的类的引用。 2、使用弱引用weakreference持有activity；垃圾回收器在回收过程中，不过内存空间够与否，都将弱引用对象进行回收。 3、在外部结束生命周期的ondestroy方法中，清除消息队列中的消息；只要清除该msg，引用就会断开，避免内存泄漏。调用这个方法mHandler.removeCallbacksAndMessages(null)</p>
<p><strong>为什么其他内部类没有这个说法？</strong></p>
<p>因为正常来说其他内部类持有外部类的对象，但是在内部持有外部类的时候没有做耗时操作，也就不存在这种持续引用的，造成内存泄漏。</p>
<h4 id="Handler-的-post-Runnable-与-sendMessage-有什么区别"><a href="#Handler-的-post-Runnable-与-sendMessage-有什么区别" class="headerlink" title="Handler 的 post(Runnable) 与 sendMessage 有什么区别"></a>Handler 的 post(Runnable) 与 sendMessage 有什么区别</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(<span class="meta">@NonNull</span> Runnable r)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>post和sendMessage发送的Message的区别是post的message的callback就是传入的Runnable。下面看下分发时的不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Handler</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// post会走这个方法 实现在下面</span></span><br><span class="line">            handleCallback(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>要知道dispatchMessage方法的调用是在Looper的Loop方法，Loop方法的调用一定是在创建当前Looper的线程执行的。</strong>所以这里<code>message.callback.run()</code>会直接在当前线程执行了run方法的内容。</p>
<p>而正常的sendMessage 方法会走handleMessage(msg)，这里得提到Handler的创建方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> handler1= <span class="keyword">object</span> : Handler()&#123;</span><br><span class="line">       <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> handler2 = Handler(<span class="keyword">object</span> : Handler.Callback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>上面这两个方法就对应了下面这部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">handleMessage(msg);</span><br></pre></td></tr></table></figure>



<h4 id="子线程创建Handler"><a href="#子线程创建Handler" class="headerlink" title="子线程创建Handler"></a>子线程创建Handler</h4><p>**如果子线程中想要进行Handler操作，就必须在子线程中执行prepare() 和 loop()**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的子线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在子线程中准备一个 Looper</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在可以在这个子线程中创建 Handler 了</span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用这个 Handler 来处理消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始循环，处理消息队列</span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>



<h4 id="IdleHandler是啥？有什么使用场景？"><a href="#IdleHandler是啥？有什么使用场景？" class="headerlink" title="IdleHandler是啥？有什么使用场景？"></a>IdleHandler是啥？有什么使用场景？</h4><p>当MessageQueue没有消息的时候，就会阻塞在next方法中，其实在阻塞之前，MessageQueue还会做一件事，就是检查是否存在IdleHandler，如果有，就会去执行它的queueIdle方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里完成了消息处理然后令 nextPollTimeoutMillis = -1;</span></span><br><span class="line"><span class="comment"> * pendingIdleHandlerCount的初始值为-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">              </span><br><span class="line"> </span><br><span class="line">                <span class="comment">//当消息执行完毕，就设置pendingIdleHandlerCount</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">					</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//初始化mPendingIdleHandlers</span></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>\[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//mIdleHandlers转为数组</span></span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历数组，处理每个IdleHandler</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers\[i];</span><br><span class="line">                mPendingIdleHandlers\[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果queueIdle方法返回false，则处理完就删除这个IdleHandler</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line"></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当没有消息处理的时候，就会去处理这个mIdleHandlers集合里面的每个IdleHandler对象，并调用其queueIdle方法。最后根据queueIdle返回值判断是否用完删除当前的IdleHandler。</p>
<p>IdleHandler是怎么加进去的（IdleHandler就是当消息队列里面没有当前要处理的消息了，需要堵塞之前，可以做一些空闲任务的处理。）</p>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIdleHandler</span> <span class="keyword">implements</span> <span class="title class_">MessageQueue</span>.IdleHandler &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里执行一些低优先级的任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 true 表示想要继续接收空闲回调</span></span><br><span class="line">        <span class="comment">// 返回 false 表示不想再接收空闲回调，之后该 IdleHandler 会被移除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程的 Looper 中添加 IdleHandler</span></span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">MyIdleHandler</span>());</span><br></pre></td></tr></table></figure>

<h4 id="Looper-loop-注意事项"><a href="#Looper-loop-注意事项" class="headerlink" title="Looper.loop()注意事项"></a>Looper.loop()注意事项</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">            Looper.prepare()</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;我是子线程&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">            Looper.loop()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>Looper.loop()</code>实际上开始一个阻塞的无限循环，用于从关联的<code>MessageQueue</code>中取出消息并分发到注册的<code>Handler</code>对象进行处理。</p>
<p>所以，当调用 <code>Looper.loop()</code> 时，会阻塞当前线程，并且开始监听来自<code>MessageQueue</code>的消息。如果在 <code>Looper.loop()</code> 之前没有完成需要执行的任务，这些任务就不会执行，因为 <code>Looper.loop()</code> 在未接收到来自 <code>Looper</code> 的 <code>quit()</code> 或 <code>quitSafely()</code> 方法的通知之前，是不会返回的。</p>
<p>这种方法会导致子线程一直无法退出循环，需要通过<code>Looper.myLooper().quit()</code>来主动退出循环</p>
<h4 id="创建Handler时传入的looper是那个线程的最终的消息处理就在那个线程"><a href="#创建Handler时传入的looper是那个线程的最终的消息处理就在那个线程" class="headerlink" title="创建Handler时传入的looper是那个线程的最终的消息处理就在那个线程"></a>创建Handler时传入的looper是那个线程的最终的消息处理就在那个线程</h4><p>在一个线程中创建了 <code>Handler</code> 对象，如果传入的 <code>Looper</code> 来自其他线程，那么当发出任务请求时，这些任务将在 <code>Looper</code> 所在线程的 <code>MessageQueue</code> 中排队，直到 <code>Looper</code> 能够处理它们。当 <code>Looper</code> 处理这些任务时，它们将在 <code>Looper</code> 所在的线程上执行。这就是为什么可以通过更改 <code>Handler</code> 构造方法中的 <code>Looper</code> 参数来改变任务的执行线程。</p>
<p><a href="https://zhuanlan.zhihu.com/p/345819916">临时抱佛脚：IdleHandler 的原理分析和妙用</a></p>
<p><a href="https://juejin.cn/post/7265212750364360764?searchId=20240223215915F89BEAC19E3D27E2B00D">一文读懂Handler面试</a></p>
<p><a href="https://juejin.cn/post/6844904150140977165?searchId=2024022322023002BB5B8812B68CE54751#heading-18">换个姿势，带着问题看Handler</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android JetPack</title>
    <url>/2024/03/26/Android%20Jetpack/</url>
    <content><![CDATA[<h1 id="Android-JetPack"><a href="#Android-JetPack" class="headerlink" title="Android JetPack"></a>Android JetPack</h1><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​		Lifecycle是Google推出的一个可以感知（Activity&#x2F;Fragment）等组件生命周期的一个组件。使用Lifecycle，，可以避免在（Activity&#x2F;Fragment）生命周期函数里写过多的逻辑代码，可以使我们的业务逻辑更加的解耦。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>​		AppComponentActivity和FragmentActivity都是继承了ComponentActivity。ComponentActivity实现了LifecycleOwner接口。在ComponentActivity的onCreate生命周期回调中会添加一个Fragment所以我们就是借助Fragment来实现生命周期的观察的。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>1.Lifecycle是怎样感知生命周期的？</strong></p>
<p>就是在ReportFragment中的各个生命周期都调用了<code>dispatch(Lifecycle.Event event)</code> 方法，传递了不同的<strong>Event</strong>的值</p>
<p><strong>2.Lifecycle是如何处理生命周期的？</strong></p>
<p>通过调用了<code>((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</code>方法，也就是LifecycleRegistry 类来处理这些生命周期。</p>
<p><strong>3.LifecycleObserver的方法是怎么回调是的呢？</strong></p>
<p>LifecycleRegistry 的 handleLifecycleEvent方法，然后会通过层层调用最后通过反射到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解值，来调用对应的方法</p>
<p><strong>4.为什么LifecycleObserver可以感知到Activity的生命周期</strong></p>
<p>LifecycleRegistry调用handleLifecycleEvent方法时会传递Event类型，然后会通过层层调用，最后是通过反射获取注解的值，到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解上对应的Event的值，注意这个值是和Activity&#x2F;Fragment的生命周期的一一对应的，所以就可以感知Activity、Fragment的生命周期了。</p>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>​		<a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 类是一种<a href="https://developer.android.com/topic/architecture/ui-layer/stateholders?hl=zh-cn">业务逻辑或屏幕级状态容器</a>。它用于将状态公开给界面，以及封装相关的业务逻辑。 它的主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态。这意味着在 activity 之间导航时或进行配置更改后（例如旋转屏幕时），界面将无需重新提取数据。</p>
<p>​		<code>ViewModel</code> 可以做到在配置变更后依然持有状态。所以，在现在的开发中，我们开始将 <strong>View数据</strong> 与 逻辑 藏于 <code>ViewModel</code> 中，然后对外部暴漏观察者，比如我们常常会搭配 <code>LiveData</code> 一起使用，以此更容易的保持状态同步。</p>
<p>​		<code>ViewModel</code> 也不是万能，其只能避免配置变更时避免状态丢失。比如如果我们的App是因为 <strong>内存不足</strong> 而被系统<strong>kill</strong> 掉，此时 <code>ViewModel</code> 也会被清除 🔺 。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ul>
<li>原生手动创建ViewModel</li>
</ul>
<p>在 Activity 或 Fragment 中获取 ViewModel 对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel = ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<p><code>ViewModelStore</code>: 负责存储ViewModel.</p>
<p><code>Factory</code>: 负责实例化具体的ViewModel类型.</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>​		ViewModel类自己的代码没多少，要看ViewModelProvider是怎么把它创建出来的。</p>
<p>​		ViewModelProvider的构造方法传入了this也就是当前作用域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> &#123;</span><br><span class="line">    <span class="comment">// 从 owner 获取 ViewModelStore，用于存储 ViewModel 实例</span></span><br><span class="line">    <span class="built_in">this</span>(owner.getViewModelStore(),</span><br><span class="line">        <span class="comment">// 检查 owner 是否实现了 HasDefaultViewModelProviderFactory 接口</span></span><br><span class="line">        <span class="comment">// 如果实现了，则使用 owner 提供的默认 ViewModelProvider.Factory</span></span><br><span class="line">        <span class="comment">// 否则，使用 NewInstanceFactory 的实例</span></span><br><span class="line">        owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h4><p>​		<code>ViewModelStore</code> 是负责维护我们 <code>ViewModel</code> 实例的具体类，内部有一个 <strong>map</strong> 的合集，用于保存我们创建的所有 <code>ViewModel</code> ，并对外提供了 <code>clear()</code> 方法，以 <strong>便于非配置变更时清除缓存</strong> 。</p>
<p>看下getViewModelStore的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># FragmentActivity</span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> FragmentActivity.<span class="built_in">this</span>.getViewModelStore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureViewModelStore();</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensureViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 NonConfigurationInstances 对象。这个对象包含了上一次配置变更时的一些状态信息，也就包括之前创建的ViewModelStore,原理是以静态类的形式存储在内存中</span></span><br><span class="line">            <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span></span><br><span class="line">                    (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从 NonConfigurationInstances 恢复 ViewModelStore</span></span><br><span class="line">                mViewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">                mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		这个方法是ViewModelStoreOwner接口的方法，拥有ViewModelStore的范围。此接口的实现的责任是在配置更改期间保留拥有的 ViewModelStore 并在该作用域将要销毁时调用ViewModelStore.clear() 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewModelStore的数据结构也非常简单，里面是一个HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概括下上面的逻辑：</p>
<p>​		获取ViewModeStore时首先会判断能不能从之前的配置中获得，没有的话再直接创建一个新的ViewModeStore对象。</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>第二个参数Factory，它的获取有个判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">            : NewInstanceFactory.getInstance()</span><br></pre></td></tr></table></figure>

<p>​		这个owner是Fragment和FragmentActivity对象的话一定是实现了HasDefaultViewModelProviderFactory这个接口的。看下它两个在getDefaultViewModelProviderFactory这个方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ComponentActivity</span><br><span class="line"><span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查 Activity 是否已经附加到 Application 实例</span></span><br><span class="line">    <span class="comment">// 如果没有，抛出 IllegalStateException 异常</span></span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否已经有一个默认的 Factory 实例</span></span><br><span class="line">    <span class="comment">// 如果没有，创建一个新的 SavedStateViewModelFactory 实例</span></span><br><span class="line">    <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                <span class="comment">// 提供 Application 实例</span></span><br><span class="line">                getApplication(),</span><br><span class="line">                <span class="comment">// 提供 ViewModelStoreOwner，通常是 Activity 或 Fragment 本身</span></span><br><span class="line">                <span class="built_in">this</span>,</span><br><span class="line">                <span class="comment">// 提供 Intent 中的额外数据作为初始状态，如果 Intent 为 null，则传递 null</span></span><br><span class="line">                getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回默认的 Factory 实例</span></span><br><span class="line">    <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		可见最终返回时是一个SavedStateViewModelFactory对象的实例。</p>
<p>下面继续看ViewModelProvider的get方法，ViewModelProvider这个名字一看就知道是来用于创建和管理 <code>ViewModel</code> 实例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewModelProvider</span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的规范名称，这是一种更易读的形式。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">    <span class="comment">// 如果类是局部的或匿名的，它将没有规范名称，我们不能将其用作ViewModel。</span></span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用默认键和类的规范名称作为键来获取ViewModel实例。</span></span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 从ViewModel存储中获取与键关联的ViewModel。</span></span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取的ViewModel是请求的类的实例，则返回它。</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">// 如果工厂实现了OnRequeryFactory接口，调用onRequery方法。</span></span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取到的ViewModel不为空，但不是请求的类型，则记录警告。</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工厂是KeyedFactory的实例，则使用键和类类型创建新的ViewModel。</span></span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，使用类类型创建新的ViewModel。</span></span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新创建的ViewModel存储到ViewModel存储中。</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="comment">// 返回新创建的ViewModel实例。</span></span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		首先根据类名创建唯一的key，然后先从ViewModelStore的那个map里用key寻找有没有对应的实例。</p>
<p><strong>寻找到对应的实例</strong></p>
<p>​		如果有的话会调用mFactory的onRequery方法。上面说了mFactory是SavedStateViewModelFactory对象的实例。那么看它这个方法的具体实现代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># SavedStateViewModelFactory</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onRequery</span><span class="params">(<span class="meta">@NonNull</span> ViewModel viewModel)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 ViewModel 尚未附加 SavedStateHandleController，则附加一个</span></span><br><span class="line">    attachHandleIfNeeded(viewModel, mSavedStateRegistry, mLifecycle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attachHandleIfNeeded</span><span class="params">(ViewModel viewModel, SavedStateRegistry registry,</span></span><br><span class="line"><span class="params">        Lifecycle lifecycle)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取与 ViewModel 关联的 SavedStateHandleController</span></span><br><span class="line">    <span class="type">SavedStateHandleController</span> <span class="variable">controller</span> <span class="operator">=</span> viewModel.getTag(</span><br><span class="line">            TAG_SAVED_STATE_HANDLE_CONTROLLER);</span><br><span class="line">    <span class="comment">// 检查控制器是否存在且尚未附加</span></span><br><span class="line">    <span class="keyword">if</span> (controller != <span class="literal">null</span> &amp;&amp; !controller.isAttached()) &#123;</span><br><span class="line">        <span class="comment">// 将控制器附加到生命周期和 SavedStateRegistry</span></span><br><span class="line">        controller.attachToLifecycle(registry, lifecycle);</span><br><span class="line">        <span class="comment">// 尝试在生命周期中添加 Recreator 以在进程死亡后重建 ViewModel</span></span><br><span class="line">        tryToAddRecreator(registry, lifecycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码的主要目的是确保 <code>ViewModel</code> 关联的 <code>SavedStateHandleController</code> 被正确地附加到生命周期和状态保存机制中，以便在进程死亡后能够恢复 <code>ViewModel</code> 的状态。也就是处理SavedStateHandle的情况。</p>
<p>​		SavedStateHandle就是为了处理App被杀死后Activity重建后，也能获取到之前保存的状态。本质也是基于<strong>onSaveInstanceState()</strong> 与 <strong>onRestoreInstanceState()</strong> 这两个方法，onSaveInstanceState()方法中调用<code>savedStateRegistry.performSave()</code> 去保存状态。该方法内部会创建一个新的 <strong>Bundle</strong> 对象，用于保存所有状态,然后再调用所有缓存的状态提供者(SavedStateProvider)的 <code>saveState()</code> 方法，从而将所有需要需要保存的状态以 <strong>key-value</strong> 的方式存到 <strong>Bundle</strong> 中去。最后再将这个整体的 <strong>bundle</strong> 存入 <code>onSaveInstanceState()</code> 方法参数提供的 <strong>bundle</strong> 中。然后在创建ViewModel时再取出来。</p>
<p><strong>没有寻找到对应的实例</strong></p>
<p>则调用mFactory的也就是SavedStateViewModelFactory的Create方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 AndroidViewModel 的子类</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAndroidViewModel</span> <span class="operator">=</span> AndroidViewModel.class.isAssignableFrom(modelClass);</span><br><span class="line">    Constructor&lt;T&gt; constructor;</span><br><span class="line">    <span class="comment">// 根据 ViewModel 类型选择合适的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到合适的构造函数，则使用默认的工厂方法创建 ViewModel</span></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SavedStateHandleController</span></span><br><span class="line">    <span class="type">SavedStateHandleController</span> <span class="variable">controller</span> <span class="operator">=</span> SavedStateHandleController.create(</span><br><span class="line">            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T viewmodel;</span><br><span class="line">        <span class="comment">// 根据 ViewModel 类型使用合适的构造函数创建 ViewModel 实例</span></span><br><span class="line">        <span class="keyword">if</span> (isAndroidViewModel) &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(mApplication, controller.getHandle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            viewmodel = constructor.newInstance(controller.getHandle());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为 ViewModel 设置 SavedStateHandleController 标签</span></span><br><span class="line">        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);</span><br><span class="line">        <span class="keyword">return</span> viewmodel;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to access &quot;</span> + modelClass, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A &quot;</span> + modelClass + <span class="string">&quot; cannot be instantiated.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;An exception happened in constructor of &quot;</span></span><br><span class="line">                + modelClass, e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	  判断当前构造函数是不是带 <code>application</code> 或者 <code>SaveStateHandle</code> ，从而调用合适的 <code>newInstance()</code> 方法，最后再将创建好的 <code>ViewModel</code> 添加到 <code>ViewModelStore</code> 的 <strong>缓存</strong> 中。</p>
<h3 id="ViewModel销毁"><a href="#ViewModel销毁" class="headerlink" title="ViewModel销毁"></a>ViewModel销毁</h3><p>​		在初始化Activity时，内部会使用 <code>lifecycle</code> 添加一个生命周期观察者，并监听 <strong>onDestory()</strong> 通知(Act销毁)，如果当前销毁的原因非配置更改导致，则调用 <strong>ViewModeltore.clear()</strong> ，即清空我们的ViewModel缓存列表，从而这也是为什么 <code>ViewModel</code> 不支持非配置更改的实例保存。</p>
<p><a href="https://juejin.cn/post/7186680109384859706?searchId=20240301103914DB08362B8704C36291BF#heading-22">https://juejin.cn/post/7186680109384859706?searchId=20240301103914DB08362B8704C36291BF#heading-22</a></p>
<h3 id="ViewModel怎么实现的配置更改后持久保留相应状态"><a href="#ViewModel怎么实现的配置更改后持久保留相应状态" class="headerlink" title="ViewModel怎么实现的配置更改后持久保留相应状态"></a>ViewModel怎么实现的配置更改后持久保留相应状态</h3><ol>
<li><strong>创建 <code>ViewModel</code> 实例</strong>：当你第一次请求一个 <code>ViewModel</code> 实例时，<code>ViewModelProvider</code>会为你的 <code>Activity</code> 或 <code>Fragment</code> 创建一个新的 <code>ViewModel</code> 实例。这通常是通过调用 ViewModelProvider(this).get(MyViewModel::class.java)实现的。</li>
<li>**关联 <code>ViewModel</code> 实例与 <code>ViewModelStore</code>**：创建的 <code>ViewModel</code> 实例会被存储在与当前 <code>Activity</code> 或 <code>Fragment</code> 相关联的 <code>ViewModelStore</code> 中。这个 <code>ViewModelStore</code> 是 <code>ViewModelStoreOwner</code>（例如 <code>ComponentActivity</code> 或 <code>Fragment</code>）持有的，它负责管理 <code>ViewModel</code> 实例的生命周期。</li>
<li><strong>配置更改发生</strong>：当配置更改（如屏幕旋转）发生时，<code>Activity</code> 会被销毁并重新创建。然而，<code>ViewModelStore</code> 不会随 <code>Activity</code> 一起销毁，而是会被保留下来。</li>
<li><strong>重新获取 <code>ViewModel</code> 实例</strong>：在新创建的 <code>Activity</code> 或 <code>Fragment</code> 中，当再次通过 <code>ViewModelProviders.of(this).get(MyViewModel.class)</code> 请求相同类型的 <code>ViewModel</code> 实例时，<code>ViewModelProviders</code> 会检查当前 <code>ViewModelStore</code> 中是否已经存在该类型的 <code>ViewModel</code> 实例。如果存在，它会返回已经存在的实例，而不是创建一个新的。这样，你就可以继续使用之前的 <code>ViewModel</code> 实例，其中保存的状态也会得到保留。</li>
</ol>
<p>​		通过这种方式，<code>ViewModel</code> 能够在配置更改后持久保留相应状态，从而实现数据的持久性和管理。这也是为什么推荐在 <code>ViewModel</code> 中存储 UI 相关的数据和逻辑，而不是在 <code>Activity</code> 或 <code>Fragment</code> 中直接存储，因为 <code>Activity</code> 和 <code>Fragment</code> 在配置更改时可能会被销毁和重新创建，而 <code>ViewModel</code> 可以跨这些配置更改保持存活。</p>
<h3 id="ViewModelStore-不会随-Activity-一起销毁，而是会被保留下来。怎么做到的？"><a href="#ViewModelStore-不会随-Activity-一起销毁，而是会被保留下来。怎么做到的？" class="headerlink" title="ViewModelStore 不会随 Activity 一起销毁，而是会被保留下来。怎么做到的？"></a><code>ViewModelStore</code> 不会随 <code>Activity</code> 一起销毁，而是会被保留下来。怎么做到的？</h3><p>​		当 <code>Activity</code> 第一次创建时，它会创建一个新的 <code>ViewModelStore</code>。当配置更改发生时，<code>Activity</code> 会通过 <code>onRetainNonConfigurationInstance</code> 方法保留这个 <code>ViewModelStore</code>。然后，当 <code>Activity</code> 被重新创建时，它会检查是否有保留的 <code>ViewModelStore</code>，如果有，它会使用这个保留的 <code>ViewModelStore</code> 而不是创建一个新的。这样，<code>ViewModel</code> 就可以在配置更改后继续存在，而不会随 <code>Activity</code> 的销毁而销毁。</p>
<ol>
<li><strong>对于 Activity</strong>：<ul>
<li>在配置更改发生时，<code>Activity</code> 的 <code>onRetainNonConfigurationInstance</code> 方法会被调用，<code>Activity</code> 可以通过这个方法来保留一个对象。<code>Activity</code> 的实现会将其 <code>ViewModelStore</code> 作为这个保留的对象。</li>
<li>当 <code>Activity</code> 被重新创建时，它会通过 <code>getLastNonConfigurationInstance</code> 方法来获取之前保留的对象，从而恢复 <code>ViewModelStore</code>。</li>
</ul>
</li>
<li><strong>对于 Fragment</strong>：<ul>
<li><code>Fragment</code> 的保留机制稍有不同。<code>Fragment</code> 可以通过设置 <code>setRetainInstance(true)</code> 来指示系统在配置更改时保留 <code>Fragment</code> 实例。这样，<code>Fragment</code> 的 <code>ViewModelStore</code> 也会随之保留。</li>
<li>当 <code>Fragment</code> 被重新创建时，它会附加到新的 <code>Activity</code> 上，但其 <code>ViewModelStore</code> 会保持不变，从而保留了其中的 <code>ViewModel</code> 实例。</li>
</ul>
</li>
</ol>
<h3 id="onRetainNonConfigurationInstance-和onSaveInstanceState-的区别"><a href="#onRetainNonConfigurationInstance-和onSaveInstanceState-的区别" class="headerlink" title="onRetainNonConfigurationInstance() 和onSaveInstanceState()的区别"></a><code>onRetainNonConfigurationInstance()</code> 和onSaveInstanceState()的区别</h3><ol>
<li>颗粒度不一样。<strong>onSaveInstanceState()<strong>是保存到Bundle</strong>中，只能保存</strong>Bundle<strong>能接受的数据类型，比如一些基本类型的数据。而</strong>onRetainNonConfigurationInstance() 可以保存任何类型的数据，数据类型是<strong>Object</strong></li>
<li><strong>onSaveInstanceState()数据最终存储到ActivityManagerService</strong>的ActivityRecord中了，也就是存到<strong>系统进程</strong>中去了。而<strong>onRetainNonConfigurationInstance()</strong> 数据是存储到<strong>ActivityClientRecord</strong>中，也就是存到<strong>应用本身的进程</strong>中了</li>
<li><strong>onSaveInstanceState</strong>存到系统进程中，所以App被杀之后还是能恢复的。而<strong>onRetainNonConfigurationInstance</strong>存到本身进程中，App被杀是没法恢复的。</li>
</ol>
<h3 id="activity被销毁ViewModel怎么监听的？"><a href="#activity被销毁ViewModel怎么监听的？" class="headerlink" title="activity被销毁ViewModel怎么监听的？"></a>activity被销毁ViewModel怎么监听的？</h3><p>​		<code>ViewModel</code> 并不直接监听 <code>Activity</code> 的销毁事件。相反，<code>ViewModel</code> 的生命周期是通过 <code>ViewModelStore</code> 和 <code>ViewModelProvider</code> 来管理的。当 <code>Activity</code> 被销毁时，<code>Activity</code> 的 <code>ViewModelStore</code> 会被清理，这会导致存储在其中的所有 <code>ViewModel</code> 实例被清除。</p>
<p>​		<code>ViewModel</code> 不直接监听 <code>Activity</code> 的销毁，而是通过 <code>ViewModelStore</code> 的清理机制来响应 <code>Activity</code> 生命周期的结束，从而在适当的时候执行清理操作。</p>
<h3 id="ViewModelStore什么时候会被销毁？"><a href="#ViewModelStore什么时候会被销毁？" class="headerlink" title="ViewModelStore什么时候会被销毁？"></a>ViewModelStore什么时候会被销毁？</h3><p><code>ViewModelStore</code> 会在以下情况下被清理：</p>
<ol>
<li><strong>非配置更改的销毁</strong>：当 <code>Activity</code> 或 <code>Fragment</code> 被永久销毁（而不是由于配置更改，如屏幕旋转）时，例如当用户按下返回键或者调用了 <code>finish()</code> 方法，<code>ViewModelStore</code> 会被清理。这意味着存储在 <code>ViewModelStore</code> 中的所有 <code>ViewModel</code> 实例都会被清除，它们的 <code>onCleared()</code> 方法会被调用。</li>
<li><strong>显式调用清理方法</strong>：在一些特殊情况下，开发者可以通过调用 <code>ViewModelStore</code> 的 <code>clear()</code> 方法来显式清理 <code>ViewModelStore</code>。这通常用于特定的清理逻辑，比如在单元测试中。</li>
</ol>
<h3 id="使用ViewModel进行界面间的数据传递"><a href="#使用ViewModel进行界面间的数据传递" class="headerlink" title="使用ViewModel进行界面间的数据传递"></a>使用ViewModel进行界面间的数据传递</h3><h4 id="同一个Activity的fragment-之间共享数据"><a href="#同一个Activity的fragment-之间共享数据" class="headerlink" title="同一个Activity的fragment 之间共享数据"></a>同一个Activity的fragment 之间共享数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SharedViewModel : ViewModel() &#123;</span><br><span class="line">    val sharedData = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ViewModel被Activity引用的话，它的对象就会被保存到这个Activity的ViewModelStore中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentA</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: SharedViewModel <span class="keyword">by</span> viewModels(&#123; requireActivity() &#125;)</span><br><span class="line">    <span class="comment">// 这两种创建方式等价</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> activityViewModels&lt;SharedViewModel&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentB</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: SharedViewModel <span class="keyword">by</span> viewModels(&#123; requireActivity() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Activity与其内部的Fragment进行数据"><a href="#Activity与其内部的Fragment进行数据" class="headerlink" title="Activity与其内部的Fragment进行数据"></a>Activity与其内部的Fragment进行数据</h4><p>与上面同理</p>
<h4 id="不同Activity的fragment-之间共享数据"><a href="#不同Activity的fragment-之间共享数据" class="headerlink" title="不同Activity的fragment 之间共享数据"></a>不同Activity的fragment 之间共享数据</h4><ol>
<li>使用 Application 级别的 ViewModel：<br>你可以创建一个 Application 级别的 ViewModel，这样不同的 Activity 和它们的 Fragment 都可以访问同一个 ViewModel 实例。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span>(application: Application) : AndroidViewModel(application) &#123;</span><br><span class="line">    <span class="keyword">val</span> sharedData = MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> sharedViewModel: SharedViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>, ViewModelProvider.AndroidViewModelFactory.getInstance(<span class="keyword">this</span>))</span><br><span class="line">            .<span class="keyword">get</span>(SharedViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Fragment 中获取 Application 级别的 ViewModel</span></span><br><span class="line"><span class="keyword">val</span> sharedViewModel = (activity?.application <span class="keyword">as</span>? MyApplication)?.sharedViewModel</span><br></pre></td></tr></table></figure>

<h4 id="Activity之间共享数据"><a href="#Activity之间共享数据" class="headerlink" title="Activity之间共享数据"></a>Activity之间共享数据</h4><ol>
<li>两个 Activity 想要共享同一个 ViewModel，就必须从一个 ViewModelStore 中获取。</li>
<li>ViewModel 被两个 Activity 持有，那么一个 Activity 销毁时，ViewModel 并不能销毁，如果销毁掉 ViewModel，那么另一个 Activity 就无法使用 ViewModel。因此要考虑好资源释放的问题，防止内存泄漏。解决方案是：当持有 ViewModel 的所有 Activity 都销毁时，才销毁该 ViewModel，同时销毁创建该 ViewModel 的 ViewModelStore。</li>
<li>每个共享的ViewModel对应一个唯一的ViewModelStore，然后将这个ViewModelStore通过静态map存储为全局的</li>
<li>当这个ViewModel的使用者都销毁后就将对应的ViewModelStore也销毁，可以通过监听activity的lifecycle实现</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存 HashMap，key 为 scopeName，value 为 ViewModelStoreOwner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> cache: HashMap&lt;String, ShareViewModelStoreOwner&gt; = hashMapOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义StoreOwner类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareViewModelStoreOwner</span> : <span class="type">ViewModelStoreOwner</span> &#123;</span><br><span class="line">	<span class="comment">// 创建使用activit集合</span></span><br><span class="line">    <span class="keyword">var</span> activityList = arrayListOf&lt;ComponentActivity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bindHost</span><span class="params">(componentActivity: <span class="type">ComponentActivity</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activityList.contains(componentActivity)) &#123;</span><br><span class="line">            activityList.add(componentActivity)</span><br><span class="line">        &#125;</span><br><span class="line">        componentActivity.lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                    activityList.remove(componentActivity)</span><br><span class="line">                    <span class="keyword">if</span> (activityList.isEmpty()) &#123;</span><br><span class="line">                        cache.entries.find &#123; it.value == <span class="keyword">this</span><span class="symbol">@ShareViewModelStoreOwner</span> &#125;?.also &#123;</span><br><span class="line">                            viewModelStore.clear()</span><br><span class="line">                            cache.remove(it.key)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> viewModelStore: ViewModelStore</span><br><span class="line">        <span class="keyword">get</span>() = ViewModelStore()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> shareViewModel: ShareViewModel =</span><br><span class="line">						ViewModelProvider(cache[<span class="string">&quot;share&quot;</span>]!!)[ShareViewModel::<span class="keyword">class</span>.java]</span><br></pre></td></tr></table></figure>

<p>​	ViewModel使用ViewModelProvider创建，然后需要传入一个 ViewModelStore，这个ViewModelStore就是存储ViewMode的。</p>
<p>多个activity使用同一个ViewModel就需要是从同一个ViewModelStore中创建的对象。</p>
<p>上面可以再优化使用</p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​		<strong>LiveData 是可感知生命周期的，可观察的，数据持有者</strong>。LiveData 可以和生命周期绑定，当 Activity 和 Fragment 处于活跃状态时才进行数据回调，并在 Lifecycle 处于销毁状态（DESTROYED）时自动移除数据监听行为，从而避免了常见的内存泄露和 NPE 问题</p>
<p>​		<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/lifecycle/LiveData"><code>LiveData</code></a> 是一种可观察的数据存储器类。与常规的可观察类不同，<code>LiveData</code> 具有生命周期感知能力，意指它遵循其他应用组件（如 <code>activity</code>、<code>fragment</code> 或 <code>service</code>）的生命周期。这种感知能力可确保 <code>LiveData</code> 仅更新处于活跃生命周期状态的应用组件观察者</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData = MutableLiveData&lt;String&gt;()</span><br><span class="line">liveData.value = <span class="string">&quot;新的值&quot;</span></span><br><span class="line"></span><br><span class="line">liveData.observe(<span class="keyword">this</span>, Observer &#123; value -&gt;</span><br><span class="line">    <span class="comment">// 更新界面</span></span><br><span class="line">    textView.text = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h4><p>看注册监听的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="built_in">super</span> T&gt; observer)</span> &#123;</span><br><span class="line">    <span class="comment">//限定只能在主线程调用 observe 方法</span></span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//当 Lifecycle 已经处于 DESTROYED 状态时，此时进行 observe 是没有意义的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据传入参数构建一个新的代理 Observer</span></span><br><span class="line">    <span class="type">LifecycleBoundObserver</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleBoundObserver</span>(owner, observer);</span><br><span class="line">    <span class="comment">//将 observer 作为 key，wrapper 作为 value 进行存储</span></span><br><span class="line">    <span class="comment">//当 mObservers 不包含该 key 时，调用 putIfAbsent 会返回 null</span></span><br><span class="line">    <span class="comment">//当 mObservers 已包含该 key 时，调用 putIfAbsent 不会存储 key-value，并会返回之前保存的 value</span></span><br><span class="line">    <span class="type">ObserverWrapper</span> <span class="variable">existing</span> <span class="operator">=</span> mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="comment">//走到此步，说明之前 LiveData 内部已经持有了 observer 对象，且该 observer 对象已经绑定了其它的 LifecycleOwner 对象</span></span><br><span class="line">        <span class="comment">//一个 Observer 对象只能和一个 Lifecycle 对象绑定，否则将抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//observer 之前已经和同个 owner 一起传进来过了，此处直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个方法有两个参数LifecycleOwner和Observer，LifecycleOwner的实现类有ComponentActivity和Fragment,Observer是一个接口,里面就一个方法onChanged。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Observer<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">onChanged</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在observe方法中owner是观察者的生命周期所有者，observer是观察者对象。两者一起被封装为一个LifecycleBoundObserver对象，LifecycleBoundObserver是抽象类 ObserverWrapper 的实现类。ObserverWrapper 用于包装外部传进来的 Observer 对象，为子类定义好特定的抽象方法和共用逻辑，主要是提供了共用的状态分发方法。</p>
<h4 id="状态回调"><a href="#状态回调" class="headerlink" title="状态回调"></a>状态回调</h4><p>状态的定义在抽象类Lifecycle的一个枚举类中，共五种</p>
<ul>
<li><code>DESTROYED</code>：销毁状态。此状态后，不会再派发任何事件。</li>
<li><code>INITIALIZED</code>：初始化状态。此状态下，<code>LifecycleOwner</code> 已构造但尚未到 <code>onCreate</code>方法执行。</li>
<li><code>CREATED</code>：创建状态。此状态在两种情况下达到：<code>onCreate</code> 调用后；<code>onStop</code> 调用前。</li>
<li><code>STARTED</code>：启动状态。此状态在两种情况下达到：<code>onStart</code> 调用后；<code>onPause</code> 调用前。</li>
<li><code>RESUMED</code>：恢复状态。此状态在 <code>onResume</code> 调用后达到。</li>
</ul>
<p>​		LifecycleBoundObserver 也实现了 LifecycleEventObserver 接口，从而可以收到 Lifecycle 的每次生命周期事件切换时的事件回调。其整个事件流程是这样的：</p>
<ol>
<li>Lifecycle 的生命周期发生变化，从而回调 onStateChanged 方法</li>
<li>onStateChanged 方法首先判断 Lifecycle 是否已处于 DESTROYED 状态，是的话则直接移除 Observer，整个回调流程结束，否则继续以下流程</li>
<li>onStateChanged 通过 activeStateChanged 方法来判断 Lifecycle 是否从非活跃状态切换到了活跃状态，是的话则调用 dispatchingValue 方法来分发值，dispatchingValue 方法会根据 ObserverWrapper 内部的 mLastVersion 来判断是否有新值需要向外部 Observer 进行回调，是的话则向其回调新值，否则结束流程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title class_">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title class_">LifecycleEventObserver</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="built_in">super</span> T&gt; observer) &#123;</span><br><span class="line">        <span class="built_in">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">shouldBeActive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//只有当 Lifecycle 的当前状态是 STARTED 或者 RESUMED 时</span></span><br><span class="line">        <span class="comment">//才认为 Lifecycle 是处于活跃状态</span></span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LifecycleEventObserver 的实现方法</span></span><br><span class="line">    <span class="comment">//当 Lifecycle 的生命周期状态发生变化时就会调用此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="comment">//如果 Lifecycle 已经处于 DESTROYED 状态了,则主动移除 mObserver</span></span><br><span class="line">        <span class="comment">//这就是 LiveData 可以避免内存泄露最重要的一个点</span></span><br><span class="line">        Lifecycle.<span class="type">State</span> <span class="variable">currentState</span> <span class="operator">=</span> mOwner.getLifecycle().getCurrentState();</span><br><span class="line">        <span class="keyword">if</span> (currentState == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	Lifecycle.<span class="type">State</span> <span class="variable">prevState</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        	<span class="comment">// 此处使用循环，为了保证在处理当前状态过程中状态又发生了改变。</span></span><br><span class="line">        	<span class="comment">// 循环确保捕获并处理这些变化，直到没有更多的状态变化发生。 </span></span><br><span class="line">            <span class="keyword">while</span> (prevState != currentState) &#123;</span><br><span class="line">                prevState = currentState;</span><br><span class="line">                activeStateChanged(shouldBeActive());</span><br><span class="line">                currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detachObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//移除 mObserver</span></span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>当owner的生命周期发生改变会回调到LifecycleBoundObserver的onStateChanged方法</strong>,这个方法里会判断owner是否走到了<code>DESTROYED</code>，走到了会移除这个owner的观察者。不是<code>DESTROYED</code>的话会对状态进行分类处理，当前状态是 STARTED 或者 RESUMED 时认为 Lifecycle 是处于活跃状态，否则是不活跃状态。然后将活跃还是不活跃传入activeStateChanged方法。		</p>
<p>​		activeStateChanged 方法的实现在抽象类ObserverWrapper中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ObserverWrapper</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activeStateChanged</span><span class="params">(<span class="type">boolean</span> newActive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mActive = newActive;</span><br><span class="line">        <span class="comment">//判断当前 LiveData 所有的 Observer 是否都处于非活跃状态</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasInactive</span> <span class="operator">=</span> LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新 LiveData 当前所有处于活跃状态的 Observer 的数量</span></span><br><span class="line">        LiveData.<span class="built_in">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 LiveData 处于活跃状态的 Observer 数量从 0 变成了 1,</span></span><br><span class="line">            <span class="comment">//则回调 onActive 方法</span></span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LiveData.<span class="built_in">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 LiveData 处于活跃状态的 Observer 数量从 1 变成了 0,</span></span><br><span class="line">            <span class="comment">//则回调 onInactive 方法</span></span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">            <span class="comment">//如果 mObserver 变成了活跃状态，则向其回调新值，走到这里说明之前一定是非活跃状态</span></span><br><span class="line">            dispatchingValue(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		上面的onStateChanged方法和activeStateChanged是关于LifecycleOwner 的生命周期发生变化后LiveData的回调处理，在observe这个方法中将观察者observer和观察者的生命周期所有者owner封装了一个LifecycleBoundObserver对象，在方法的最后通过<code>owner.getLifecycle().addObserver(wrapper)</code>将这个对象加入到了owner的观察者列表中。</p>
<blockquote>
<p>状态有三种：</p>
<ul>
<li>销毁：DESTROYED</li>
<li>非活跃：INITIALIZED、CREATED</li>
<li>活跃：STARTED、RESUMED</li>
</ul>
</blockquote>
<p>​		activeStateChanged方法首先会进行判断该状态是否改变，如果是活跃态会调用 dispatchingValue 方法来分发值，dispatchingValue 方法会根据 ObserverWrapper 内部的 mLastVersion 来判断是否有新值需要向外部 Observer 进行回调，是的话则向其回调新值，否则结束流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果是观察者首次订阅会走到这里</span></span><br><span class="line">            <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// LiveData执行了setValue会通知所有观察者</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="built_in">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">considerNotify</span><span class="params">(ObserverWrapper observer)</span> &#123;</span><br><span class="line">    <span class="comment">//如果 observer 处于非活跃状态，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此处判断主要是为了照顾 LifecycleBoundObserver</span></span><br><span class="line">    <span class="comment">//由于 Lifecycle 有可能状态值 State 已经切换到了非活跃状态，但 LifecycleBoundObserver 还未收到事件通知</span></span><br><span class="line">    <span class="comment">//所以为了避免意外情况，此处主动检查 observer 的活跃状态并判断是否需要更新其活跃状态</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 observer 本部的 value 版本号 mLastVersion 来决定是否需要向其进行回调</span></span><br><span class="line">    <span class="comment">//为了避免重复向某个 observer 回调值，所以此处需要判断下</span></span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这个mLastVersion是每个观察者自身维护的在ObserverWrapper内，然后LiveData自身也有一个计数mVersion来标志状态，对比的mLastVersion和mVersion来判断是否需要发送消息。</p>
<p>从dispatchingValue和considerNotify这两个方法的逻辑可以看出LiveData的特点：</p>
<ul>
<li><p>LiveData 只会在 LifecycleOwner 处于活跃状态的时候才进行事件分发。</p>
</li>
<li><p>自主解绑逻辑</p>
<blockquote>
<p>走到DESTORY状态会通过mOwner.getLifecycle().removeObserver(this)解绑监听</p>
</blockquote>
</li>
<li><p>LiveData会保证订阅者总能在值变化的时候观察到最新的值，并且每个<strong>初次订阅的观察者</strong>都会执行一次回调方法。</p>
<blockquote>
<p>这个特点会导致一个粘性事件的问题：数据倒灌</p>
<p>由于 <code>LiveData</code> 会在观察者活跃时将最新的数据通知给观察者，则会产生「<strong>粘性事件</strong>」的情况。</p>
<p>如点击 button 弹出一个 Snackbar，在屏幕旋转时，<code>lifecycleOwner</code> 重建，新的观察者会再次调用 <code>Livedata#observe()</code>，因此 Snackbar 会再次弹出。</p>
</blockquote>
</li>
<li><p>LiveData的合并策略将最新一条之前的事件全部丢弃。</p>
<blockquote>
<p>默认不防抖，<code>setValue()/postValue()</code> 传入相同的值多次调用，观察者的 <code>onChanged()</code> 会被多次调用。</p>
</blockquote>
</li>
<li><p>同一个状态在一个UI刷新周期之内发生两次变动，LiveData只会展示最后一个。</p>
<blockquote>
<p>存在仅有部分 Observer 收到了回调，其它 Observer 又没有的可能性。当单线程连续传值或者多线程同时传值时，假设是先后传 valueA 和 valueB，最终可能只有部分 Observer 接收到了 valueA，所有 Observer 都接收到了 valueB</p>
</blockquote>
</li>
</ul>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> postTask;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">            postTask = mPendingData == NOT_SET;</span><br><span class="line">            mPendingData = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mPostValueRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Object newValue;</span><br><span class="line">            <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">                newValue = mPendingData;</span><br><span class="line">                mPendingData = NOT_SET;</span><br><span class="line">            &#125;</span><br><span class="line">            setValue((T) newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeOnMainThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postToMainThread(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postToMainThread</span><span class="params">(<span class="meta">@NonNull</span> Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMainHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mMainHandler = createAsync(Looper.getMainLooper());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Handler抛回了主线程</span></span><br><span class="line">        mMainHandler.post(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// UI线程</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">        mVersion++;</span><br><span class="line">        mData = value;</span><br><span class="line">        dispatchingValue(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发送消息最后还是调用dispatchingValue，这部分逻辑看上一节。</p>
<h4 id="使用优势"><a href="#使用优势" class="headerlink" title="使用优势"></a>使用优势</h4><p>LiveData被推荐使用的优势 ：</p>
<ol>
<li><strong>数据符合页面状态</strong>：LiveData 遵循观察者的生命周期，确保数据状态与页面状态相符。</li>
<li><strong>不会发生内存泄露</strong>：观察者在销毁时自动取消订阅，避免内存泄露。</li>
<li><strong>防止因 Activity 停止而导致崩溃</strong>：在观察者非活跃状态下不会消费事件。</li>
<li><strong>简化生命周期处理</strong>：自动处理生命周期，无需手动管理。</li>
<li><strong>数据始终保持最新状态</strong>：LiveData 仅持有单个且最新的数据。</li>
<li><strong>资源共享</strong>：可用于不同组件间的数据共享</li>
<li>提供「可读可写」和「仅可读」两个版本收缩权限</li>
</ol>
<p><a href="https://juejin.cn/post/7173494700081414181?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-9">由浅入深，详解 LiveData 的那些事</a></p>
<p><a href="https://juejin.cn/post/7049147565815627789?searchId=20240311223609A4D4BE3FD45BCBFD2D76">Jetpack MVVM 七宗罪之五: 在 Repository 中使用 LiveData</a></p>
<p><a href="https://juejin.cn/post/7007602776502960165?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-2">不做跟风党，LiveData，StateFlow，SharedFlow 使用场景对比</a></p>
<p><a href="https://juejin.cn/post/6847902222345633806?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-3">从源码看 Jetpack（3）- LiveData 源码详解</a></p>
<p><a href="https://juejin.cn/post/6903143273737814029?searchId=20240311223609A4D4BE3FD45BCBFD2D76#heading-14">“终于懂了“系列：Jetpack AAC完整解析（二）LiveData 完全掌握！</a></p>
<h2 id="AppStartup"><a href="#AppStartup" class="headerlink" title="AppStartup"></a>AppStartup</h2><h3 id="三方库初始化"><a href="#三方库初始化" class="headerlink" title="三方库初始化"></a>三方库初始化</h3><p>一般是在Application的onCreate方法中调用三方库的初始化方法传入当前的context。</p>
<h3 id="ContentProvider-的启动过程"><a href="#ContentProvider-的启动过程" class="headerlink" title="ContentProvider 的启动过程"></a>ContentProvider 的启动过程</h3><p>​		<strong>ContentProvider 通常的用法是为当前进程 &#x2F; 远程进程提供内容服务，它们会在应用启动的时候初始化</strong>，正因如此，我们可以利用 ContentProvider 来获得 Context 。</p>
<p>​		ContentProvider#onCreate() 是早于 Application#onCreate() 执行的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    Log.e(<span class="string">&quot;ContextProvider&quot;</span>,<span class="string">&quot;初始化 <span class="variable">$context</span> -- <span class="subst">$&#123;application&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果每个第三方库都自己创建了一个ContentProvider，那么最终我们App的启动速度就会受到比较大的影响。</strong></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将所有用于初始化的ContentProvider合并成一个，从而使App的启动速度变得更快。在组件化中用于初始化组件的application</p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>引入App Startup的库。</p>
</li>
<li><p>自定义一个用于初始化的Initializer。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LitePalInitializer</span> : <span class="type">Initializer</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取application执行 三方库的初始化逻辑</span></span><br><span class="line">        LitePal.initialize(context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dependencies</span><span class="params">()</span></span>: List&lt;Class&lt;<span class="keyword">out</span> Initializer&lt;*&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>将自定义Initializer配置到AndroidManifest.xml当中。定义的顺序就是初始化的顺序</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;androidx.startup.InitializationProvider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;com.example.LitePalInitializer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;androidx.startup&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">applicationContext</span> <span class="operator">=</span> context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">                AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StartupLogger.w(<span class="string">&quot;Deferring initialization because `applicationContext` is null.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StartupException</span>(<span class="string">&quot;Context cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存每个组件的初始化结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; mInitialized = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化此组件</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">doInitialize</span><span class="params">(Class&lt;? extends Initializer&lt;?&gt;&gt; component, Set&lt;Class&lt;?&gt;&gt; initializing)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123; <span class="comment">// 1、对 sLock 加锁</span></span><br><span class="line">            Object result;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、判断 initializing 中存在当前组件，说明存在循环依赖</span></span><br><span class="line">            <span class="keyword">if</span> (initializing.contains(component)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Cannot initialize %s. Cycle detected.&quot;</span>, component.getName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、检查当前组件是否已初始化</span></span><br><span class="line">            <span class="keyword">if</span> (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                <span class="comment">// 当前组件未初始化</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.1 记录正在初始化</span></span><br><span class="line">                initializing.add(component);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.2 通过反射实例化 Initializer 接口实现类</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> component.getDeclaredConstructor().newInstance();</span><br><span class="line">                Initializer&lt;?&gt; initializer = (Initializer&lt;?&gt;) instance;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.3 遍历所依赖的组件</span></span><br><span class="line">                List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt;&gt; dependencies = initializer.dependencies();</span><br><span class="line">                <span class="keyword">if</span> (!dependencies.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Initializer</span>&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                        <span class="comment">// 如果所依赖的组件未初始化，递归执行初始化</span></span><br><span class="line">                        <span class="keyword">if</span> (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                            doInitialize(clazz, initializing); <span class="comment">// 注意：这里将 initializing 作为参数传入</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.4 （到这里，所依赖的组件已经初始化完成）初始化当前组件</span></span><br><span class="line">                result = initializer.create(); <span class="comment">// 假设create方法不需要参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.5 移除正在初始化记录</span></span><br><span class="line">                initializing.remove(component);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1.6 缓存初始化结果</span></span><br><span class="line">                mInitialized.put(component, result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当前组件已经初始化，直接返回</span></span><br><span class="line">                result = mInitialized.get(component);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (T) result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射实例化 Initializer 接口实现类，遍历所依赖的组件，如果所依赖的组件未初始化，递归执行初始化。</p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><ol>
<li>依赖</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(libs.androidx.room.runtime)</span><br><span class="line">implementation(libs.androidx.room.ktx)</span><br><span class="line">kapt(libs.androidx.room.compiler)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建实体类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;user_entity&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">UserEntity</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Dao</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 设置主键冲突之后的策略，这里选择直接覆盖原数据</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除某条数据</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">deleteUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新某条数据</span></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUser</span><span class="params">(userEntity: <span class="type">UserEntity</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查找数据</span></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;select * from user_entity where id=:id&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findUser</span><span class="params">(id: <span class="type">Int</span>)</span></span>: List&lt;UserEntity&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建DataBase</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [UserEntity::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RoomDb</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserDao</span><span class="params">()</span></span>: UserDao</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> sInstance: RoomDb? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DATA_BASE_NAME = <span class="string">&quot;User.db&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: RoomDb? &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                synchronized(RoomDb::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        sInstance = createInstance(context)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: RoomDb? &#123;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(</span><br><span class="line">                context.applicationContext, RoomDb::<span class="keyword">class</span>.java, DATA_BASE_NAME</span><br><span class="line">            ).build()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoomViewModel</span>(<span class="keyword">val</span> application: Application) : AndroidViewModel(application) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testRoom</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> db = RoomDb.getInstance(application)</span><br><span class="line">        db?.getUserDao()?.findUser(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>数据库抽象层</strong>：Room是在SQLite之上的一个抽象层，它提供了更简洁的数据库访问机制，并减少了样板代码的编写。</li>
<li><strong>编译时SQL检查</strong>：Room在编译时会检查你的SQL查询语句，这有助于在早期发现潜在的问题和错误。</li>
<li><strong>LiveData和协程支持</strong>：Room天然支持LiveData和Kotlin协程，flow，这使得在Android应用中实现响应式编程和异步操作变得更加简单和直接。</li>
<li><strong>易用性和减少错误</strong>：通过使用注解和DAO（数据访问对象）模式，Room使得数据库的操作更加简洁明了，同时减少了因手动编写SQL而引入的错误。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Android四大组件</title>
    <url>/2024/03/26/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><ol>
<li>onCreate(Bundle savedInstanceState)</li>
</ol>
<ul>
<li>这是Activity被创建时系统调用的第一个方法。在这里，你应该做所有的静态设置：创建视图，绑定数据到列表等操作。如果有保存的状态，系统会传递给这个方法一个<code>Bundle</code>。</li>
</ul>
<ol start="2">
<li>onStart()</li>
</ol>
<ul>
<li>当Activity对用户可见时，系统会调用这个方法。这可以发生在<code>onCreate()</code>方法结束后，或者在Activity从不可见状态恢复时。</li>
</ul>
<ol start="3">
<li>onRestart()</li>
</ol>
<ul>
<li>如果Activity从停止状态重新开始，就会调用这个方法。它在<code>onStop()</code>之后和<code>onStart()</code>之前调用。</li>
</ul>
<ol start="4">
<li>onResume()</li>
</ol>
<ul>
<li>当Activity准备好与用户互动时，系统会调用这个方法。这时，Activity位于Activity堆栈的顶部，并捕获所有用户输入。大部分的核心功能都在这个方法中实现。</li>
</ul>
<ol start="5">
<li>onPause()</li>
</ol>
<ul>
<li>当系统准备启动或恢复另一个Activity时，系统会调用这个方法。这通常是因为用户正在离开这个Activity，但这个Activity还没有被完全停止或隐藏。在这个方法中，你应该释放或调整那些不需要的资源。</li>
</ul>
<ol start="6">
<li>onStop()</li>
</ol>
<ul>
<li>当Activity不再对用户可见时，系统会调用这个方法。这可能发生因为一个新的Activity启动，或者是这个Activity正在被销毁。</li>
</ul>
<ol start="7">
<li>onDestroy()</li>
</ol>
<ul>
<li>在Activity被销毁之前，系统会调用这个方法。这可以由用户完全结束（例如按下Back键）或系统临时销毁以节省空间引起。在这个方法中，你应该释放所有资源。</li>
</ul>
<ol start="8">
<li>onSaveInstanceState(Bundle outState)</li>
</ol>
<ul>
<li>在Activity开始停止的过程中，系统调用这个方法，以便你可以保存当前Activity的状态。这个状态之后可以在<code>onCreate(Bundle)</code>或<code>onRestoreInstanceState(Bundle)</code>（见下文）中恢复。</li>
</ul>
<ol start="9">
<li>onRestoreInstanceState(Bundle savedInstanceState)</li>
</ol>
<ul>
<li>当Activity在被销毁和重新创建时，系统会调用这个方法。你可以在这个方法中恢复由<code>onSaveInstanceState(Bundle)</code>方法保存的状态。</li>
</ul>
<h3 id="其他的生命周期方法"><a href="#其他的生命周期方法" class="headerlink" title="其他的生命周期方法"></a>其他的生命周期方法</h3><p>运行时权限回调</p>
<ul>
<li>onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)<ul>
<li>用户响应权限请求时调用。</li>
</ul>
</li>
</ul>
<p>Activity结果回调</p>
<ul>
<li>onActivityResult(int requestCode, int resultCode, Intent data)<ul>
<li>从另一个Activity返回结果时调用。</li>
</ul>
</li>
</ul>
<p>配置更改</p>
<ul>
<li>onConfigurationChanged(Configuration newConfig)<ul>
<li>设备配置更改（如屏幕方向、键盘可用性等）时调用。</li>
</ul>
</li>
</ul>
<p>键盘快捷键</p>
<ul>
<li>onKeyDown(int keyCode, KeyEvent event)<ul>
<li>按下键盘按键时调用。</li>
</ul>
</li>
<li>onKeyUp(int keyCode, KeyEvent event)<ul>
<li>释放键盘按键时调用。</li>
</ul>
</li>
<li>onKeyLongPress(int keyCode, KeyEvent event)<ul>
<li>长按键盘按键时调用。</li>
</ul>
</li>
</ul>
<p>触摸屏事件</p>
<ul>
<li>onTouchEvent(MotionEvent event)<ul>
<li>触摸屏事件发生时调用。</li>
</ul>
</li>
</ul>
<h3 id="Activity的启动模式以及它们的作用？"><a href="#Activity的启动模式以及它们的作用？" class="headerlink" title="Activity的启动模式以及它们的作用？"></a>Activity的启动模式以及它们的作用？</h3><p><strong>standard（标准）</strong></p>
<ul>
<li><strong>行为</strong>：每次启动 <code>Activity</code> 时都会创建一个新的实例，无论这个 <code>Activity</code> 是否已经存在于任务中。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。</li>
<li><strong>用途</strong>：适用于大多数标准的 <code>Activity</code> 行为。如果你的 <code>Activity</code> 需要多次实例化（例如，一个显示列表项详细信息的 <code>Activity</code>），那么标准模式很适合。</li>
</ul>
<p><strong>singleTop（栈顶复用）</strong></p>
<ul>
<li><strong>行为</strong>：如果新的 <code>Activity</code> 已经位于任务栈的顶部，那么不会创建新的实例，而是重用栈顶的实例，并调用其 <code>onNewIntent()</code> 方法。如果不在栈顶，将创建新的实例。</li>
<li><strong>用途</strong>：适用于需要保持最上层实例唯一，但在其他位置可以有多个实例的 <code>Activity</code>。例如，用于处理从多个地方发送的通知，但希望打开的通知详情 <code>Activity</code> 在顶部时不重复创建。</li>
<li><strong>场景：</strong><ol>
<li>要打开的Activity处于栈顶，点击通知栏打开栈顶的Activity</li>
<li>Activity需要启动一个Service，最后Service对栈顶Activity进行操作</li>
</ol>
</li>
</ul>
<p><strong>singleTask（栈内复用）</strong></p>
<ul>
<li><p><strong>行为</strong>：新的 <code>Activity</code> 实例将在单独的任务中启动。如果已存在这样的 <code>Activity</code> 实例，系统会将其调到栈顶而不是创建新的实例，并调用 <code>onNewIntent()</code> 方法。<strong>当一个具有singleTask模式的Activity请求启动后，比如Activity A，首先会根据taskAffinity:去寻找当前是否存在一个对应名字的任务栈。如果不存在，则会创建一个新的Task。如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例。如果有实例存在，那么系统就会把A调到栈顶（将上面的Activity依次出栈）并调用它的onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中</strong>。</p>
</li>
<li><p><strong>用途</strong>：适用于作为应用中单一入口点的 <code>Activity</code>，如主页。当应用从多个入口点跳转到这个 <code>Activity</code> 时，它保证实例的唯一性。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>登录页面</li>
<li>首页</li>
</ol>
</li>
</ul>
<p><strong>singleInstance（单实例模式）</strong></p>
<ul>
<li><p><strong>行为</strong>：与 <code>singleTask</code> 相似，但保证这个 <code>Activity</code> 实例是全系统唯一的，即它在自己的任务中，不与其他 <code>Activity</code> 共享任务。创建新实例时，会在新的任务栈中。</p>
</li>
<li><p><strong>用途</strong>：适用于那些与应用其余部分彼此独立的模块，例如，一个浮动窗口或者一个启动其他应用的 <code>Activity</code>。</p>
</li>
<li><p><strong>场景：</strong></p>
<ol>
<li>外部App调用自己客户端程序的Activity</li>
</ol>
</li>
</ul>
<h3 id="Activity横竖屏切换"><a href="#Activity横竖屏切换" class="headerlink" title="Activity横竖屏切换"></a>Activity横竖屏切换</h3><p>竖屏切横屏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onPause </span><br><span class="line">onStop </span><br><span class="line">onSaveInstanceState </span><br><span class="line">onDestroy </span><br><span class="line">onCreate </span><br><span class="line">onStart </span><br><span class="line">onRestoreInstanceState</span><br><span class="line">onResume </span><br></pre></td></tr></table></figure>

<p><strong>设置configChanges这个值可以避免Activity生命周期被回到。</strong>在清单文件中设置configChanges属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:configChanges=&quot;orientation|screenSize&quot;</span><br></pre></td></tr></table></figure>

<p>横竖屏切换的生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onConfigurationChanged</span><br></pre></td></tr></table></figure>

<p>​		只走onConfigurationChanged这一个方法，在横竖屏切换时会命中orientation和screenSize这两个属性。添加后可以避免生命周期回调而只走onConfigurationChanged方法。其他的属性在下面可以查看。</p>
<ul>
<li>orientation：屏幕在纵向和横向间旋转</li>
<li>keyboardHidden：键盘显示或隐藏</li>
<li>screenSize：屏幕大小改变</li>
<li>fontScale：用户变更了首选字母大小</li>
<li>locale：用户选择了不同的语言设定</li>
<li>keyboard：键盘类型变更，如手机从九宫格键盘变为全键盘</li>
<li>touchscreen或navigation：键盘或导航方向变换，一般不会发生这种情况。</li>
</ul>
<p> 参考：</p>
<p><a href="https://www.cnblogs.com/lsgxeva/p/13414171.html">Activity横竖屏切换生命周期</a></p>
<h3 id="Activity跳转生命周期"><a href="#Activity跳转生命周期" class="headerlink" title="Activity跳转生命周期"></a>Activity跳转生命周期</h3><p>当从Activity A跳转到Activity B时：</p>
<ol>
<li><strong>Activity A</strong>:<ul>
<li><code>onPause()</code>：当用户即将离开Activity A时调用。在这个方法中，应停止与用户界面交互的操作，如动画和音乐播放。</li>
</ul>
</li>
<li><strong>Activity B</strong>:<ul>
<li><code>onCreate(Bundle savedInstanceState)</code>：如果Activity B之前没有被创建，系统会调用此方法。</li>
<li><code>onStart()</code>：当Activity B对用户可见时调用。</li>
<li><code>onResume()</code>：当Activity B准备好与用户交互时调用，此时Activity B位于栈顶，并且捕获所有用户输入。</li>
</ul>
</li>
<li><strong>Activity A</strong>:<ul>
<li><code>onStop()</code>：如果Activity B覆盖了Activity A，则在Activity B变得对用户可见之后，系统会调用此方法。如果Activity A不再可见，可以在这里释放或调整资源。</li>
</ul>
</li>
</ol>
<p>当用户按下返回键从Activity B返回到Activity A时：</p>
<ol>
<li><strong>Activity B</strong>:<ul>
<li><code>onPause()</code>：用户即将离开Activity B时调用。</li>
<li><code>onStop()</code>：当Activity B不再对用户可见时调用。</li>
<li><code>onDestroy()</code>：当Activity B即将被销毁时调用。这是释放Activity B占用资源的好时机。</li>
</ul>
</li>
<li><strong>Activity A</strong>:<ul>
<li><code>onRestart()</code>：只有在Activity A由停止状态变为运行状态时才会调用此方法。</li>
<li><code>onStart()</code>：当Activity A再次对用户可见时调用。</li>
<li><code>onResume()</code>：当Activity A准备好与用户交互时调用，此时Activity A位于栈顶，并且捕获所有用户输入。</li>
</ul>
</li>
</ol>
<p>当B无实例，且为透明或半透明时：</p>
<p>​		A.onPause() &gt; B.onCreate() &gt; B.onStart() &gt; B.onResume()。此时从B返回A：B.onPause() &gt; A.onResume() &gt; B.onStop() &gt; B.onDestroy()。</p>
<p>​		透明的B将导致A被B覆盖时不执行A.onStop()方法，B返回A时也不执行A.onRestart() &gt; A.onStart()这两个方法。</p>
<h3 id="Activity之间进行数据传递"><a href="#Activity之间进行数据传递" class="headerlink" title="Activity之间进行数据传递"></a>Activity之间进行数据传递</h3><p><strong>使用Intent</strong></p>
<ul>
<li><p><strong>基本数据类型</strong>：可以通过Intent在Activity之间传递基本数据类型和字符串数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ActivityA.<span class="built_in">this</span>, ActivityB.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可序列化对象</strong>：如果需要传递自定义对象，对象需要实现<code>Serializable</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(<span class="string">&quot;myObject&quot;</span>, mySerializableObject);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Parcelable对象</strong>：比Serializable更高效。自定义对象需要实现<code>Parcelable</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intent.putExtra(<span class="string">&quot;myObject&quot;</span>, myParcelableObject);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用Bundle</strong></p>
<ul>
<li><p>将数据打包在Bundle中，然后通过Intent传递Bundle。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(ActivityA.<span class="built_in">this</span>, ActivityB.class);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用静态变量</strong></p>
<ul>
<li>将需要传递的数据设置为静态变量。这种方式简单但风险较高，因为静态变量的生命周期很长，可能会导致内存泄露。</li>
</ul>
<p><strong>使用全局变量（Application类）</strong></p>
<ul>
<li><p>在自定义Application类中定义全局变量，通过Application实例在Activity之间共享数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((MyApplication) getApplication()).setSomeVariable(<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用单例模式</strong></p>
<ul>
<li>通过单例类在不同Activity间共享数据，这种方式对于共享复杂的数据结构或对象非常有用。</li>
</ul>
<p><strong>使用数据库</strong></p>
<ul>
<li>将数据保存到SQLite数据库或者使用Room数据库，然后在另一个Activity中查询数据。</li>
</ul>
<p><strong>使用文件存储</strong></p>
<ul>
<li>将数据写入内部或外部存储的文件中，然后在另一个Activity中读取这些文件。</li>
</ul>
<p><strong>使用SharedPreferences</strong></p>
<ul>
<li><p>对于需要持久化的少量简单数据，可以使用SharedPreferences在Activity之间共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sharedPref</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;AppName&quot;</span>, Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sharedPref.edit();</span><br><span class="line">editor.putString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">editor.apply();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用ContentProvider</strong></p>
<ul>
<li>如果数据被不同的应用或不同的Activity共享，可以使用ContentProvider作为数据的中心存储方案。</li>
</ul>
<p><strong>使用ActivityResult</strong></p>
<ul>
<li><p>当一个Activity需要从另一个Activity获取结果时，可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startActivityForResult()</span><br></pre></td></tr></table></figure>

<p>启动该Activity，并在后者关闭时返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在ActivityB中设置返回结果</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">returnIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">returnIntent.putExtra(<span class="string">&quot;result&quot;</span>, result);</span><br><span class="line">setResult(Activity.RESULT_OK, returnIntent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用EventBus或其他消息传递库</strong></p>
<ul>
<li>使用EventBus等库在Activity之间异步传递消息或数据。</li>
</ul>
<p><strong>使用Activity Results API</strong></p>
<ol>
<li>注册Activity结果回调</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> startForResult = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">    <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理返回结果</span></span><br><span class="line">        <span class="keyword">val</span> intent = result.<span class="keyword">data</span></span><br><span class="line">        <span class="comment">// 从Intent中获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>启动目标Activity</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TargetActivity::<span class="keyword">class</span>.java)</span><br><span class="line"><span class="comment">// 可以添加额外的数据到Intent中</span></span><br><span class="line">startForResult.launch(intent)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.在目标Activity中设置返回结果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> returnIntent = Intent()</span><br><span class="line"><span class="comment">// 添加数据到Intent</span></span><br><span class="line">setResult(Activity.RESULT_OK, returnIntent)</span><br><span class="line">finish() <span class="comment">// 结束当前Activity，返回到调用者</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="onSaveInstanceState-原理"><a href="#onSaveInstanceState-原理" class="headerlink" title="onSaveInstanceState 原理"></a>onSaveInstanceState 原理</h3><p>当Activity未被允许被系统自动销毁时会调用这个方法，用户主动销毁不会调用。</p>
<p>Activity调用了<code>onStop</code>后，会调用到<code>ActivityThread</code>的<code>callActivityOnSaveInstanceState()</code>方法，把Activity需要保存的数据放入<code>Bundle</code>对象中。然后通过IPC（进程间通信）机制，调用<code>ActivityManagerService</code>的<code>activityStopped</code>方法，将<code>Bundle</code>对象保存到AMS端的<code>ActivityRecord</code>中。</p>
<p>​		安卓3.0之后至9.0之前，OnSaveInstanceState方法在onPause之后onStop之前调用</p>
<p>​		安卓9.0之后OnSaveInstanceState方法在onStop之后调用</p>
<p>​		onRestoreInstanceState的执行时机在onStart之后</p>
<h3 id="onSaveInstanceState-默认保存的数据有哪些"><a href="#onSaveInstanceState-默认保存的数据有哪些" class="headerlink" title="onSaveInstanceState 默认保存的数据有哪些"></a>onSaveInstanceState 默认保存的数据有哪些</h3><p>ui状态(view中都各自重写了保存状态的方法)和fragment的信息</p>
<ul>
<li>Activity 的布局信息，例如 View 的大小、位置、可见性、滚动位置等。</li>
<li>Activity 的视图状态，例如 EditText 中的文本、CheckBox 的选中状态等。</li>
<li>Activity 的系统状态，例如屏幕亮度、音量等。</li>
</ul>
<h3 id="taskaffinity-属性"><a href="#taskaffinity-属性" class="headerlink" title="taskaffinity 属性"></a>taskaffinity 属性</h3><p>作用</p>
<ol>
<li><strong>指定任务栈</strong>：<code>taskAffinity</code> 允许开发者指定一个 Activity 应该位于特定的任务栈中。这对于在同一个应用中创建多个独立的任务栈很有用，每个任务栈可以包含一组相关的 Activity，从而实现不同的用户任务。</li>
<li><strong>处理 Intent Flags</strong>：<code>taskAffinity</code> 在处理具有特定 Intent 标志（如 <code>FLAG_ACTIVITY_NEW_TASK</code> 和 <code>FLAG_ACTIVITY_CLEAR_TOP</code>）的 Intent 时起到关键作用。例如，当启动一个新的 Activity 时，如果设置了 <code>FLAG_ACTIVITY_NEW_TASK</code> 标志，并且该 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统将会在一个新的任务栈中启动该 Activity。</li>
<li><strong>分割应用逻辑</strong>：通过使用不同的 <code>taskAffinity</code>，开发者可以将应用的不同部分分割到不同的任务栈中，从而使用户在使用多任务切换功能时能够更清晰地区分应用的不同功能模块。</li>
</ol>
<h3 id="Intent-flag"><a href="#Intent-flag" class="headerlink" title="Intent flag"></a>Intent flag</h3><ol>
<li><code>FLAG_ACTIVITY_NEW_TASK</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，如果这个 Activity 的 <code>taskAffinity</code> 与当前任务栈不同，系统会在一个新的任务栈中启动该 Activity。如果已经存在一个与该 Activity 具有相同 <code>taskAffinity</code> 的任务栈，那么该 Activity 会被启动到那个任务栈中。</li>
<li>这个标志通常用于从非 Activity 上下文（如 Service 或 BroadcastReceiver）中启动 Activity。</li>
</ul>
<ol start="2">
<li><code>FLAG_ACTIVITY_CLEAR_TOP</code></li>
</ol>
<ul>
<li>如果启动的 Activity 已经在当前任务栈中运行，则系统会将该 Activity 上面的所有其他 Activity 出栈。这样，被启动的 Activity 就位于栈顶，成为当前可见的 Activity。</li>
<li>这个标志经常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用，用于清理任务栈并将某个 Activity 置于栈顶。</li>
</ul>
<ol start="3">
<li><code>FLAG_ACTIVITY_SINGLE_TOP</code></li>
</ol>
<ul>
<li>如果被启动的 Activity 已经位于任务栈的顶部，则系统不会创建该 Activity 的新实例。相反，系统会调用该 Activity 的 <code>onNewIntent()</code> 方法，并传入新的 Intent。</li>
<li>这个标志用于避免在任务栈顶部重复创建相同的 Activity。</li>
</ul>
<ol start="4">
<li><code>FLAG_ACTIVITY_CLEAR_TASK</code></li>
</ol>
<ul>
<li>这个标志会清除当前任务栈中的所有 Activity，并创建一个新的任务栈启动指定的 Activity。</li>
<li>通常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用。</li>
</ul>
<ol start="5">
<li><code>FLAG_ACTIVITY_NO_HISTORY</code></li>
</ol>
<ul>
<li>当使用这个标志启动 Activity 时，该 Activity 不会被添加到任务栈中。一旦用户离开该 Activity，它就会被销毁，无法通过后退按钮回到这个 Activity。</li>
</ul>
<p>上面五个是常用的，下面是不常用的。</p>
<ul>
<li><code>FLAG_ACTIVITY_BROUGHT_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其带到前台，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</code>：启动的 Activity 不会出现在最近任务列表中。</li>
<li><code>FLAG_ACTIVITY_FORWARD_RESULT</code>：将当前 Activity 的结果转发给下一个 Activity。</li>
<li><code>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</code>：如果 Activity 是从历史记录中启动的，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_MULTIPLE_TASK</code>：与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用时，允许同一个应用中的多个任务栈拥有相同的 <code>taskAffinity</code>。</li>
<li><code>FLAG_ACTIVITY_NO_ANIMATION</code>：启动 Activity 时不显示动画效果。</li>
<li><code>FLAG_ACTIVITY_NO_USER_ACTION</code>：表明用户没有直接启动这个 Activity，可能是由另一个程序或者系统自动启动的。</li>
<li><code>FLAG_ACTIVITY_PREVIOUS_IS_TOP</code>：如果当前任务栈中的前一个 Activity 应该保持在顶部，则设置此标志。</li>
<li><code>FLAG_ACTIVITY_REORDER_TO_FRONT</code>：如果 Activity 已经在任务栈中运行，则将其移动到栈顶，而不是启动一个新实例。</li>
<li><code>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</code>：如果 Activity 是从历史记录中启动的，且与当前任务栈不匹配，则重置任务栈以适应该 Activity。</li>
</ul>
<h3 id="taskaffinity-Intent-flag-launchMode"><a href="#taskaffinity-Intent-flag-launchMode" class="headerlink" title="taskaffinity + Intent flag + launchMode"></a>taskaffinity + Intent flag + launchMode</h3><p>FLAG_ACTIVITY_NEW_TASK 和 standard 模式的组合情况可以总结为：</p>
<ul>
<li>standard 没有设置 taskAffinity。此时系统就会去复用或者创建一个默认任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>standard 有设置 taskAffinity。此时又可以分为当前系统是否存在 taskAffinity 关联的任务栈两种情况<ul>
<li>不存在目标任务栈。此时系统就会创建目标任务栈，然后直接在该任务栈上新建一个 Activity 实例入栈</li>
<li>存在目标任务栈。此时系统会判断任务栈中是否已经存在目标 Activity 的实例，如果不存在的话则新建一个 Activity 实例入栈。如果存在目标实例的话，则只是将该任务栈转到前台而已，既不会新建 Activity 实例，也不会回调 <code>onNewIntent</code>方法，甚至也不管该 Activity 实例是否处于栈顶，总之只要存在相同实例就不做任何响应。</li>
</ul>
</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​		Service是Android程序中四大基础组件之一，它和Activity一样都是Context的子类，只不过它没有U界面，是在后台运行的组件。Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在U川线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251549636.jpeg" alt="215302_BuU9_661133"></p>
<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p><strong>启动</strong></p>
<p>Service的启动方式有两种：startService()&#x2F;stopService和bindService()&#x2F;unBindService。</p>
<ol>
<li><p>使用startService()方法启动Service，调用者与Service之间没有关系，即使调用者退出了，Service仍然运行。Service不会自动销毁，需要外部调用stopService()方法或在Service内部调用stopSelf()方法，此时Service的onDestroy()方法被调用。</p>
<p><strong>startService调用一次 startCommand就会调用一次。</strong></p>
<p>首先，定义一个Service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理启动Service的请求</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> START_STICKY; <span class="comment">// 根据需要返回适当的标志</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 本示例中不提供绑定功能，所以返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity中启动Service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">serviceIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">startService(serviceIntent);</span><br></pre></td></tr></table></figure>

<p>当你想停止Service时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stopService(serviceIntent);</span><br></pre></td></tr></table></figure>

<p>或者在Service内部自我停止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stopSelf();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用bindService()方法启动Service，调用者与Service绑定在了一起，调用者一旦销毁，Service也就终止了，调用者需要解绑时可调用unBindService()方法。Service被解绑或调用者销毁时，Service经历onUnbind() &gt; onDestroy()的过程。</p>
</li>
</ol>
<p>​	 定义Service与上面类似，但需要实现<code>onBind()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBoundService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalBinder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line">        MyBoundService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 返回Service实例供客户端调用</span></span><br><span class="line">            <span class="keyword">return</span> MyBoundService.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onUnbind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端解绑时调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onUnbind(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Service中的方法，Activity会调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getServiceData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回服务的数据</span></span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity中绑定Service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MyBoundService myBoundService;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isBound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> &#123;</span><br><span class="line">        <span class="type">LocalBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (MyBoundService.LocalBinder) service;</span><br><span class="line">        myBoundService = binder.getService();</span><br><span class="line">        isBound = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在你可以调用Service中的方法了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> myService.getServiceData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName arg0)</span> &#123;</span><br><span class="line">        isBound = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在 Activity 的 onStart() 或 onResume() 方法中调用</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bindMyService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">bindIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyBoundService.class);</span><br><span class="line">    bindService(bindIntent, connection, Context.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 onPause() 或 onStop() 方法中调用。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unbindMyService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBound) &#123;</span><br><span class="line">        unbindService(connection);</span><br><span class="line">        isBound = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		同一个服务可以用两种方式一同开启，没有先后顺序的要求，MyService的onCreate只会执行一次。 关闭服务需要stopService和unbindService都被调用，也没有先后顺序的影响，MyService的onDestroy也只执行一次。但是如果只用一种方式关闭服务，不论是哪种关闭方式，onDestroy都不会被执行，服务也不会被关闭。</p>
<h3 id="服务的特征"><a href="#服务的特征" class="headerlink" title="服务的特征"></a>服务的特征</h3><ol>
<li>服务在应用进程的<code>主线程执行</code>，启动或绑定服务并不会创建自己的线程，也不会在单独的进程中执行（除非另行指定）。因此，耗时操作应当在服务中创建新的线程来完成，否则容易ANR</li>
<li>启动服务一旦启动，就会<code>无限期运行</code>，直到其调用<code>stopSelf()</code>自行停止或其他组件调用<code>stopServicec()</code>将其停止</li>
<li>在系统资源不足时，系统会根据优先级主动停止服务。其中<code>前台服务</code>拥有较高优先级，一般不会被停止，而<code>后台服务</code>的优先级则与运行时间有关，长时间运行的服务被停止的概率更高。同时，如果服务是由于资源不足而被系统停止，那么在系统资源满足的情况下，服务将被系统重启</li>
<li><code>stopSelf()</code>和<code>stopServicec()</code>并不是将服务立即结束，仅是通知系统尽快销毁而已</li>
</ol>
<p><a href="https://codyi96.github.io/2020/08/02/android-service/#%E5%89%8D%E5%8F%B0%E6%9C%8D%E5%8A%A1">Android前台服务 - Foreground Service</a></p>
<h3 id="前后台服务的区别"><a href="#前后台服务的区别" class="headerlink" title="前后台服务的区别"></a>前后台服务的区别</h3><p><strong>前台服务：</strong></p>
<ul>
<li><strong>用户可见性</strong>：前台服务必须显示一个持续的通知，用户可以在系统的状态栏中看到这个通知。这意味着用户随时都知道服务正在运行。</li>
<li><strong>优先级</strong>：前台服务被视为对用户或系统有明显好处的操作，因此拥有较高的进程优先级，系统不太可能因为需要内存而终止它们。</li>
<li><strong>用例</strong>：前台服务通常用于用户积极参与的操作，如音乐播放、文件下载或GPS导航。</li>
</ul>
<p><strong>后台服务：</strong></p>
<ul>
<li><strong>用户可见性</strong>：后台服务不会有任何可见的用户界面或通知（除非在Android 8.0及以上版本，后台服务也需要发出通知）。用户可能完全不知道服务正在运行。</li>
<li><strong>优先级</strong>：后台服务的优先级较低，当系统需要释放资源时，它们可能是首先被终止的进程。</li>
<li><strong>用例</strong>：后台服务用于不需要用户即时了解进展的任务，如应用数据的同步或处理任务。</li>
</ul>
<p>​		从Android 8.0（API级别26）开始，对后台执行有了新的限制，后台应用无法随意启动服务。如果应用在后台需要执行操作，必须使用JobScheduler、WorkManager或者将服务转为前台服务。这些限制主要是为了优化应用的性能和手机的电池使用时长</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251645677.png" alt="image-20240325164553638"></p>
<h3 id="后台应用不允许默默启动后台服务"><a href="#后台应用不允许默默启动后台服务" class="headerlink" title="后台应用不允许默默启动后台服务"></a>后台应用不允许默默启动后台服务</h3><p>​		自Android 8.0（API 26）开始，Android系统开始执行严格的<a href="https://developer.android.com/about/versions/oreo/background">后台执行限制</a>，后台应用不允许默默启动后台服务，只能启动前台服务，而前台应用则可以自由创建前台服务和后台服务。应用进入后台时，有一个持续数分钟的窗口期，在窗口期内仍然可以创建和使用前台&#x2F;后台Service。窗口期结束后，应用被视为处于空闲状态，系统将停止应用的后台Service，就像服务调用了自己的<code>stopSelf()</code>方法一样。</p>
<blockquote>
<p>如果满足以下任意条件，应用将被视为处于前台：</p>
<ul>
<li>具有可见 Activity（不管该 Activity 已启动还是已暂停）</li>
<li>具有前台 Service</li>
<li>另一个前台应用已关联到该应用（不管是通过绑定到其中一个 Service，还是通过使用其中一个内容提供程序）。例如，如果另一个应用绑定到该应用的 Service，那么该应用处于前台：<ul>
<li>IME</li>
<li>壁纸 Service</li>
<li>通知侦听器</li>
<li>语音或文本 Service</li>
</ul>
</li>
</ul>
<p>如果以上条件均不满足，应用将被视为处于后台。</p>
</blockquote>
<h3 id="创建一个前台服务"><a href="#创建一个前台服务" class="headerlink" title="创建一个前台服务"></a>创建一个前台服务</h3><p>​		前台服务一般需要先通过<code>startForegroundService()</code>启动一个后台服务，同时该方法向系统发送信号，表明服务将会自行提升前台。启动服务后，该服务需要在<code>五秒内</code>调用自己的<code>startForeground()</code>方法显式提升服务至前台。而正是这个<code>startForeground()</code>方法，唤起了本文开头的那个烦人的系统通知。</p>
<p><strong>通知栏权限</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.POST_NOTIFICATIONS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>动态请求权限</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkPermission</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> manager = getSystemService(NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">    <span class="comment">// 检测该应用是否有通知权限</span></span><br><span class="line">    <span class="keyword">when</span> (manager.areNotificationsEnabled()) &#123;</span><br><span class="line">        <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">            showNotification()</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, <span class="string">&quot;点击了通知按钮&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">false</span> -&gt; &#123;</span><br><span class="line">            requestPermissionLauncher.launch(</span><br><span class="line">                Manifest.permission.POST_NOTIFICATIONS)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		一些特定类型的应用即使没有显式地获取通知权限（<code>POST_NOTIFICATIONS</code>，这个权限在Android 13（API级别 33）引入），也能在通知栏显示内容，主要因为它们使用的是<strong>媒体播放控制通知</strong>（通常称为媒体通知），这种通知由系统的媒体会话（Media Session）管理。</p>
<p>​		这里的关键是<strong>媒体会话</strong>和<strong>音频焦点</strong>。当应用播放媒体内容并正确地使用了<code>MediaSession</code> API时，Android系统会自动处理媒体播放通知，即使应用没有被授予通知权限。这是因为媒体播放控制被视为系统级别的功能，它允许用户在锁屏界面、通知栏、甚至是其他设备（如连接的智能手表）上控制媒体播放。</p>
<p><strong>步骤 1: 创建服务类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleForegroundService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NOTIFICATION_ID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHANNEL_ID</span> <span class="operator">=</span> <span class="string">&quot;ForegroundServiceChannel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        createNotificationChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里你可以执行你的任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建通知</span></span><br><span class="line">        <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationCompat</span>.Builder(<span class="built_in">this</span>, CHANNEL_ID)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;Example Foreground Service&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;This is a running foreground service.&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_notification)</span><br><span class="line">            <span class="comment">// 可以设置通知点击事件等</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始让服务运行在前台</span></span><br><span class="line">        startForeground(NOTIFICATION_ID, notification);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 前台服务通常不提供绑定，但是如果要提供，则返回一个接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通知渠道（对于API级别26+是必需的）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createNotificationChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="type">NotificationChannel</span> <span class="variable">serviceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(</span><br><span class="line">                CHANNEL_ID,</span><br><span class="line">                <span class="string">&quot;Foreground Service Channel&quot;</span>,</span><br><span class="line">                NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> getSystemService(NotificationManager.class);</span><br><span class="line">            manager.createNotificationChannel(serviceChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 清理资源（如果有的话）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保替换<code>R.drawable.ic_notification</code>为你实际的图标资源ID。</p>
<p><strong>步骤 2: 在AndroidManifest.xml中声明服务</strong></p>
<p>在<code>&lt;application&gt;</code>标签内，添加对服务的声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.ExampleForegroundService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 启动服务</strong></p>
<p>在你的Activity或其他组件中，启动前台服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">serviceIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ExampleForegroundService.class);</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    startForegroundService(serviceIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    startService(serviceIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		从Android 8.0开始，你必须在应用组件（如Activity）调用<code>startService()</code>后的几秒内通过调用<code>startForeground()</code>将服务提升为前台状态。</p>
<h3 id="如何提高service的优先级？"><a href="#如何提高service的优先级？" class="headerlink" title="如何提高service的优先级？"></a>如何提高service的优先级？</h3><ol>
<li><p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority &#x3D; “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时实用于广播。</p>
</li>
<li><p>使用前台服务（Foreground Service）</p>
<p>将服务转变为前台服务是提高服务优先级的最有效方式。前台服务必须显示一个持续的通知，这意味着用户始终能够看到该服务正在运行。因为前台服务对用户来说是可见的，系统会赋予它们更高的优先级，以减少它们被杀死的机会</p>
</li>
</ol>
<h3 id="Service-的-onStartCommand-方法有几种返回值-各代表什么意思"><a href="#Service-的-onStartCommand-方法有几种返回值-各代表什么意思" class="headerlink" title="Service 的 onStartCommand 方法有几种返回值?各代表什么意思?"></a>Service 的 onStartCommand 方法有几种返回值?各代表什么意思?</h3><p>有四种返回值,不同值代表的意思如下:</p>
<ul>
<li>**START_STICKY:**如果 service 进程被 kill 掉,保留 service 的状态为开始状态,但不保留递送的 intent 对象。随 后系统会尝试重新创建 service,由于服务状态为开始状态,所以创建服务后一定会调用 onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到 service,那么参数 Intent 将为 null。</li>
<li>**START_NOT_STICKY:**“非粘性的”。使用这个返回值时,如果在执行完 onStartCommand 后,服务被异常 kill 掉,系统不会自动重启该服务。</li>
<li>**START_REDELIVER_INTENT:**重传 Intent。使用这个返回值时,如果在执行完 onStartCommand 后,服务被异 常 kill 掉,系统会自动重启该服务,并将 Intent 的值传入。</li>
<li><strong>START_STICKY_COMPATIBILITY:</strong> START_STICKY 的兼容版本,但不保证服务被 kill 后一定能重启。</li>
</ul>
<h3 id="Service里面可以弹Toast"><a href="#Service里面可以弹Toast" class="headerlink" title="Service里面可以弹Toast"></a>Service里面可以弹Toast</h3><h3 id="Service里面显示Dialog"><a href="#Service里面显示Dialog" class="headerlink" title="Service里面显示Dialog"></a>Service里面显示Dialog</h3><p>Dialog通常需要一个有效的Activity上下文才能显示。尝试在Service中直接创建和显示Dialog会遇到问题，因为Service没有属于自己的窗口。如果你尝试这样做，很可能会导致应用崩溃，抛出一个<code>android.view.WindowManager$BadTokenException</code>。</p>
<p>要从Service中安全地显示Dialog，可以采取以下策略之一：</p>
<ol>
<li><p><strong>通过发送广播或使用回调将显示Dialog的任务传递给一个Activity。</strong> 这是最安全的方法，因为Dialog将在正确的上下文中显示。</p>
</li>
<li><p><strong>使用系统级别的Alert Dialog。</strong> 如果你确实需要从Service中直接显示Dialog，你可以使用<code>SYSTEM_ALERT_WINDOW</code>权限来创建一个系统级别的Alert Dialog。从Android 6.0（API级别23）开始，用户必须在应用设置中手动为应用授予这一权限。</p>
<ul>
<li><p>首先，在<code>AndroidManifest.xml</code>中声明权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntentService</span> <span class="keyword">extends</span> <span class="title class_">IntentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyIntentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;MyIntentService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理传入的Intent</span></span><br><span class="line">        <span class="comment">// 这个方法在单独的工作线程上执行，可以执行耗时任务</span></span><br><span class="line">        <span class="comment">// 这里执行后台任务</span></span><br><span class="line">        <span class="comment">// 例如：下载文件、上传数据、处理数据等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ACTION_DOWNLOAD&quot;</span>.equals(action)) &#123;</span><br><span class="line">            <span class="comment">// 执行下载操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在实现上，IntentService封装了HandlerThread和Handler。当IntentService被第一次启动时，它的onCreate()方法会被调用，onCreat()方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行。</p>
<p>​		<a href="https://www.cnblogs.com/DMingO/p/13391435.html">看完这一篇，再也不怕被问IntentService的原理</a></p>
<h3 id="JobIntentService"><a href="#JobIntentService" class="headerlink" title="JobIntentService"></a>JobIntentService</h3><p>​		<code>JobIntentService</code> 是 Android 开发中用于执行后台任务的一个类，它是 <code>Service</code> 的一个抽象子类。在 Android O（API 级别 26）引入后台执行限制之后，<code>JobIntentService</code> 成为了实现兼容旧版 Android 设备并且遵循新版系统后台服务限制的一个好方法。</p>
<p>​		JobIntentService是Android 8.0 新加入的类，它也是继承自Service。JobIntentService用于执行加入到队列中的任务。对Android 8.0及以上的系统，JobIntentService的任务将被分发到JobScheduler.enqueue执行，对于8.0以下的系统，任务仍旧会使用Context.startService执行。</p>
<p>主要特点</p>
<ul>
<li><strong>向后兼容</strong>：<code>JobIntentService</code> 可以在 Android O 之前的版本上作为普通的 <code>Service</code> 运行，在 Android O 及以后的版本上，则通过 <code>JobScheduler</code> 来安排任务。</li>
<li><strong>简化任务调度</strong>：通过封装 <code>JobScheduler</code> 的使用细节，<code>JobIntentService</code> 使得调度和执行后台任务变得更简单。</li>
</ul>
<p><strong><code>JobScheduler</code> 模式（API 级别 &gt;&#x3D; 26，即 Android O 及以后）</strong></p>
<p>​		从 Android O 开始，为了降低后台服务对电池寿命的影响，系统对后台服务的启动施加了严格的限制。<code>JobIntentService</code> 针对这一变化，采用了 <code>JobScheduler</code> 来调度任务。在这种模式下：</p>
<ol>
<li>当调用 <code>enqueueWork()</code> 方法时，<code>JobIntentService</code> 不会直接启动服务，而是创建一个代表任务的 <code>JobInfo</code> 对象。</li>
<li><strong>这个 <code>JobInfo</code> 对象随后被提交给 <code>JobScheduler</code>，后者负责根据系统的调度策略来执行这个任务。</strong></li>
<li><code>JobScheduler</code> 考虑多个因素来决定什么时候执行任务，如设备充电状态、网络连接状态和系统闲置状态等，从而更高效地利用系统资源，并降低对电池寿命的影响。</li>
</ol>
<p><strong>核心思想</strong></p>
<p>​		<code>JobIntentService</code> 的设计思想是利用 <code>JobScheduler</code> 在 Android O 及以后版本上提供的新机制，同时保持与旧版本的兼容性。它通过内部判断当前运行的 Android 版本，自动选择最合适的方式来执行任务。这种设计允许开发者编写一套代码，就能在不同版本的 Android 设备上高效且合规地执行后台任务。</p>
<p><strong>总结</strong></p>
<p>​		<code>JobIntentService</code> 的实现原理体现了 Android 系统发展过程中对于后台服务使用的不断调整和优化。通过一个统一的接口，它在不同版本的 Android 上实现了任务执行的最佳实践，尽管如此，随着 <code>WorkManager</code> 的引入，Google 推荐使用更加灵活且功能强大的 <code>WorkManager</code> 来替代 <code>JobIntentService</code>，以满足现代 Android 应用对后台任务管理的需求。</p>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>​		BroadcastReceiver直译为”广播接收者”，主要用来接收来自系统和应用中的广播。在Android系统中，广播体现在方方面面，例如开机广播、网络状态广播、电池电量广播等等。</p>
<ul>
<li>Broadcast Receiver（广播接收器），属于Android四大组件之一</li>
<li>在Android开发中，Broadcast Receiver的应用场景非常多。广播，是一个全局的监听器，属于Android四大组件。</li>
</ul>
<p>　　Android 广播分为两个角色：广播发送者，广播接收者。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>用于监听&#x2F;接收应用发出的广播消息，并做出响应。</p>
</li>
<li><p>应用场景</p>
<p>a不同组件之间通信（包括应用内&#x2F;不同应用之间)</p>
<p>b.与Android系统在特定情况下的通信如当电话呼入时、网络可用时</p>
<p>c.多线程通信</p>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Android中的广播使用了设计模式中的观察者模式：基于消息的发布&#x2F;订阅事件模型。</p>
<p>　　因此，Android将广播的发送者和接收者解耦，使得系统方便集成，更易扩展。</p>
<p>　　模型中有3个角色：</p>
<p>　　i.消息订阅者（广播接收者）</p>
<p>　　ii.消息发布者（广播发布者）</p>
<p>　　iii.消息中心（AMS，即Activity Manager Service）</p>
<p>　　<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251854168.png" alt="img"></p>
<p> 原理描述：</p>
<ul>
<li>广播接收者 通过Binder机制在AMS注册</li>
<li>广播发送者通过Binder机制向AMS发送广播</li>
<li>AMS根据广播发送者要求，在已注册列表中，寻找合适的广播接收者。寻找依据：IntentFilter&#x2F;Permission</li>
<li>AMS将广播发送到合适的广播接收者相应的消息循环队列中</li>
<li>广播接收者通过消息循环拿到此广播，并回调onReceiver()</li>
</ul>
<p>特别注意：</p>
<p>　　广播发送者和广播接收者的执行是异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到；</p>
<p>　　</p>
<h3 id="静态广播和动态广播的区别"><a href="#静态广播和动态广播的区别" class="headerlink" title="静态广播和动态广播的区别"></a>静态广播和动态广播的区别</h3><p><strong>静态广播（Static Broadcast）</strong></p>
<ol>
<li>定义广播接收器</li>
</ol>
<p>首先，创建一个继承自 <code>BroadcastReceiver</code> 的类，并重写 <code>onReceive</code> 方法。这个方法将在接收到广播时被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javaCopy codepublic class MyStaticReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        // 在这里处理接收到的广播，例如，启动一个服务、显示通知等</span><br><span class="line">        Log.d(&quot;MyStaticReceiver&quot;, &quot;Received broadcast in MyStaticReceiver: &quot; + intent.getAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>AndroidManifest.xml</code> 中声明</li>
</ol>
<p>接下来，在应用的 <code>AndroidManifest.xml</code> 文件中声明这个广播接收器，并指定它应该接收的广播类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlCopy code&lt;application</span><br><span class="line">    ...&gt;</span><br><span class="line">    &lt;receiver android:name=&quot;.MyStaticReceiver&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>

<p>​		这个例子中，广播接收器将在设备完成启动后接收一个广播。当此 <code>App</code>首次启动时，系统会<strong>自动</strong>实例化<code>mBroadcastReceiver</code>类，并注册到系统中。</p>
<p><strong>动态广播（Dynamic Broadcast）</strong></p>
<ol>
<li>定义广播接收器</li>
</ol>
<p>动态广播接收器也是继承自 <code>BroadcastReceiver</code> 的类，实现方法与静态广播接收器相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDynamicReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理接收到的广播，例如，更新UI、启动服务等</span></span><br><span class="line">        Log.d(<span class="string">&quot;MyDynamicReceiver&quot;</span>, <span class="string">&quot;Received broadcast in MyDynamicReceiver: &quot;</span> + intent.getAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注册和注销广播接收器</li>
</ol>
<p>动态注册广播接收器通常在一个应用组件（如 <code>Activity</code>）中完成。需要注意的是，你应该在适当的时候注销广播接收器，避免造成内存泄露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyDynamicReceiver</span> <span class="variable">myDynamicReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDynamicReceiver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        <span class="comment">// 注册广播接收器</span></span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">        registerReceiver(myDynamicReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        <span class="comment">// 注销广播接收器</span></span><br><span class="line">        unregisterReceiver(myDynamicReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyDynamicReceiver</code> 会在 <code>MyActivity</code> 活跃时接收网络连接改变的广播。</p>
<p>​		通过这些代码示例可以看到静态和动态广播在定义、注册方式以及使用场景上的区别。<strong>静态广播主要用于应用需要在未运行时响应系统事件的情况，而动态广播则适用于应用在运行时根据特定事件执行操作。</strong></p>
<p><strong>总结：</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403251906046.png" alt="示意图"></p>
<h3 id="广播的种类"><a href="#广播的种类" class="headerlink" title="广播的种类"></a>广播的种类</h3><ul>
<li>普通广播（<code>Normal Broadcast</code>）</li>
<li>系统广播（<code>System Broadcast</code>）</li>
<li>有序广播（<code>Ordered Broadcast</code>）</li>
<li>粘性广播（<code>Sticky Broadcast</code>）</li>
<li>App应用内广播（<code>Local Broadcast</code>）</li>
</ul>
<p><strong>标准广播</strong>（Normal Broadcast）</p>
<p>发送标准广播</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_STANDARD_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some data&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>接收标准广播，在 <code>AndroidManifest.xml</code> 中注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyStandardReceiver&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.example.broadcast.MY_STANDARD_BROADCAST&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>广播接收器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStandardReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;MyStandardReceiver&quot;</span>, <span class="string">&quot;Received standard broadcast with data: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态广播同理</p>
<p><strong>有序广播</strong>（Ordered Broadcast）</p>
<ul>
<li>定义<br> 发送出去的广播被广播接收者按照先后顺序接收</li>
</ul>
<blockquote>
<p>有序是针对广播接收者而言的</p>
</blockquote>
<ul>
<li>广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者）<ol>
<li>按照Priority属性值从大-小排序；</li>
<li>Priority属性相同者，动态注册的广播优先；</li>
</ol>
</li>
<li>特点<ol>
<li>接收广播按顺序接收</li>
<li>先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播；</li>
<li>先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播</li>
</ol>
</li>
<li>具体使用<br> 有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sendOrderedBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>发送有序广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_ORDERED_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some data&quot;</span>);</span><br><span class="line">sendOrderedBroadcast(intent, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>接收有序广播：</p>
<p>注册和接收标准广播的方式类似，但可以在 <code>AndroidManifest.xml</code> 中为接收器指定优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name=<span class="string">&quot;.MyOrderedReceiver&quot;</span> android:priority=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.example.broadcast.MY_ORDERED_BROADCAST&quot;</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p><strong>系统广播</strong></p>
<p>Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播</p>
<p><strong>粘性广播</strong>（Sticky Broadcast）</p>
<p>粘性广播因安全和性能问题，在Android 5.0（API 级别 21）及之后的版本中不再支持自定义使用。因此，这里不提供具体示例。对于需要此类功能的场景，建议使用其他通信方式，如使用 <code>ViewModel</code> 和 <code>LiveData</code> 或者 <code>EventBus</code>。</p>
<p><strong>本地广播</strong>（Local Broadcasts）</p>
<p>背景<br> Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）</p>
<p>冲突<br> 可能出现的问题：</p>
<ul>
<li>其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；</li>
<li>其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息；<br> 即会出现安全性 &amp; 效率性的问题。</li>
</ul>
<p>解决方案：<br> 使用App应用内广播（Local Broadcast）</p>
<ul>
<li><p>具体使用1 - 将全局广播设置成局部广播</p>
<ol>
<li>注册广播时将exported属性设置为<em>false</em>，使得非本App内部发出的此广播不被接收；</li>
<li>在广播发送和接收时，增设相应权限permission，用于权限验证；</li>
<li>发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。</li>
</ol>
<blockquote>
<p>通过**intent.setPackage(packageName)**指定报名</p>
</blockquote>
</li>
<li><p>具体使用2 - 使用封装好的LocalBroadcastManager类<br> 使用方式上与全局广播几乎相同，只是注册&#x2F;取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例</p>
</li>
</ul>
<blockquote>
<p>注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册</p>
</blockquote>
<p>发送本地广播：</p>
<p>首先，确保项目中已经添加了 Support Library，因为 <code>LocalBroadcastManager</code> 是其中的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.broadcast.MY_LOCAL_BROADCAST&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some local data&quot;</span>);</span><br><span class="line">LocalBroadcastManager.getInstance(<span class="built_in">this</span>).sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p>接收本地广播，注册本地广播接收器通常在 <code>Activity</code> 或 <code>Fragment</code> 的生命周期内完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStart();</span><br><span class="line">    <span class="comment">// 创建 IntentFilter</span></span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.example.broadcast.MY_LOCAL_BROADCAST&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册本地广播接收器</span></span><br><span class="line">    LocalBroadcastManager.getInstance(<span class="built_in">this</span>).registerReceiver(myLocalReceiver, filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br><span class="line">    <span class="comment">// 注销本地广播接收器</span></span><br><span class="line">    LocalBroadcastManager.getInstance(<span class="built_in">this</span>).unregisterReceiver(myLocalReceiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地广播接收器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">BroadcastReceiver</span> <span class="variable">myLocalReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;MyLocalReceiver&quot;</span>, <span class="string">&quot;Received local broadcast with data: &quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。"><a href="#LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。" class="headerlink" title="LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。"></a>LocalBroadcastManager实现原理：是应用内广播，利用Handler实现。</h3><ul>
<li>使用了单例模式，并且将外部传入的Context转换成了Application的Context，避免造成内存泄露。</li>
<li>在构造方法中创建了Handler，实质是通过Handler进行发送和接受消息的。</li>
<li>创建Handler时，传入了主线程的Looper，说明这个Handler是在主线程创建的，即广播接收者是在主线程接收消息的，所以不能在onReceiver（）中做耗时操作。</li>
</ul>
<p>注意：对于LocalBroadcastManager发送的广播，只能通过LocalBroadcastManager动态注册，不能静态注册。</p>
<p><strong>特别注意：</strong></p>
<ul>
<li><p>如果BroadcastReceiver在onReceiver（）方法中在10秒内没有执行完成，会造成ANR异常。</p>
</li>
<li><p>对于不同注册方式的广播接收者回调方法onReceive（）返回的Context是不一样的：</p>
<p>  静态注册：context为ReceiverRestrictedContext。</p>
<p>  动态注册：context为Activity的Context。</p>
<p>  LocalBroadcastManager的动态注册：context为Application的Context。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/carson_ho/article/details/52973504">Carson带你学Android：手把手教你学会广播组件-BroadcastReceiver</a></p>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​		<code>ContentProvider</code> 是 Android 平台上的一个核心组件，用于在不同的应用之间共享数据。它提供了一种封装数据和数据源的机制，允许一个应用访问另一个应用的数据，同时还可以保证数据的安全性和隐私性。通过 <code>ContentProvider</code>，应用可以对外共享其数据，或从其他应用获取数据，而不需要直接访问其他应用的数据库或文件系统。</p>
<p><strong>启动</strong></p>
<p>①  启动入口为ActivityThread.main():创建ActivityThread实例并创建主线程消息队列</p>
<p>②  ActivityThread.attach():远程调用AMS.attachApplication并提供ApplicationThread用于和AMS通信</p>
<p>③  AMS.attschApplication()通过ActivityThread.bindApplication()方法和Handler H来调回ActivityThread.handleBindApplication()</p>
<p>④  ActivityThread.handleBindApplication():先创建Application、再去加载ContentProvider，最后回调Application.onCreate()</p>
<h3 id="ContentProvider是如何实现实现数据共享的？"><a href="#ContentProvider是如何实现实现数据共享的？" class="headerlink" title="ContentProvider是如何实现实现数据共享的？"></a><strong>ContentProvider是如何实现实现数据共享的？</strong></h3><p>​		自定义一个类继承ContentProvider然后覆写query、insert、update、delete等方法，还需要再清单文件中注册。把自己的数据通过uri的形式共享出去 。</p>
<p><strong>步骤 1: 创建自定义 <code>ContentProvider</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomProvider</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化你的数据源，这里仅作示例，实际应用中可能是数据库或其他存储形式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数据源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回 true 表示初始化成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span><br><span class="line"><span class="params">                        String[] selectionArgs, String sortOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理查询请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 示例代码，实际开发中需要返回查询结果的 Cursor 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(Uri uri)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 URI 返回 MIME 类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(Uri uri, ContentValues values)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理插入请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 示例代码，实际开发中需要返回新插入数据的 Uri</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理删除请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 示例代码，实际开发中需要返回删除的行数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span><br><span class="line"><span class="params">                      String[] selectionArgs)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理更新请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 示例代码，实际开发中需要返回更新的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在 AndroidManifest.xml 中注册 <code>ContentProvider</code></strong></p>
<p>将自定义的 <code>ContentProvider</code> 注册到应用的 AndroidManifest.xml 文件中。你需要提供一个唯一的 <code>authorities</code> 属性来标识你的 <code>ContentProvider</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;manifest xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    <span class="keyword">package</span>=<span class="string">&quot;your.package.name&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        ...&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;provider</span><br><span class="line">            android:name=<span class="string">&quot;.MyCustomProvider&quot;</span></span><br><span class="line">            android:authorities=<span class="string">&quot;your.package.name.myprovider&quot;</span></span><br><span class="line">            android:exported=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        &lt;/provider&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>​		将 <code>your.package.name</code> 替换成自己的应用包名，<code>MyCustomProvider</code> 替换成你的 <code>ContentProvider</code> 类名。<code>authorities</code> 属性是 <code>ContentProvider</code> 的唯一标识符，用于构建访问数据的 URI。</p>
<p>数据访问示例</p>
<p>其他应用可以通过 <code>ContentResolver</code> 使用 URI 访问你的 <code>ContentProvider</code> 中的数据。例如，如果他们想查询你的提供者，他们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">contentUri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;content://your.package.name.myprovider/table_name&quot;</span>);</span><br><span class="line"><span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> getContentResolver().query(contentUri, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&quot;content://your.package.name.myprovider/table_name&quot;</code> 是访问数据的 URI。<code>&quot;table_name&quot;</code> 应该被你希望访问的数据表名或数据类型所替换。</p>
<h3 id="为什么要用ContentProvider？与sql的实现上有什么区别？"><a href="#为什么要用ContentProvider？与sql的实现上有什么区别？" class="headerlink" title="为什么要用ContentProvider？与sql的实现上有什么区别？"></a><strong>为什么要用ContentProvider？与sql的实现上有什么区别？</strong></h3><p>ContentProvider屏蔽了数据存储的细节，内部实现对数据用户完全透明，用户只需要关心操作数据的uri就行。ContentProvider实现了不同app是之间数据共享。ContentProvider可以对本地文件进行增删改查的操作。</p>
<p>Sql也有增删改查等方法，但是只能查询本应用下的数据库。</p>
<h3 id="ContentProvider运行在主线程，为什么不会影响主线程的UI操作？"><a href="#ContentProvider运行在主线程，为什么不会影响主线程的UI操作？" class="headerlink" title="ContentProvider运行在主线程，为什么不会影响主线程的UI操作？"></a><strong>ContentProvider运行在主线程，为什么不会影响主线程的UI操作？</strong></h3><p>ContentProvider的onCreate是运行在UI线程的，而增删改查是运行在线程池中的工作线程的，所以调用这几个操作并不会阻塞主线程，但可能会阻塞调用者所在的主线程。</p>
<p>所以调用ContentProvider的操作任然要放到子线程中去做。最然直接的增删改查是在工作线程，但系统会让你的调用线程等待这个异步的操作完成，才可以继续之后的工作。</p>
<h3 id="ContentProvider的好处、设计目的？"><a href="#ContentProvider的好处、设计目的？" class="headerlink" title="ContentProvider的好处、设计目的？"></a><strong>ContentProvider的好处、设计目的？</strong></h3><ol>
<li><p>隐藏了数据的实现方式，对外提供统一的数据访问接口</p>
</li>
<li><p>更好的数据访问权限管理。不同的URI对应不同的权限，只有符合权限要求的组件才能访问到ContentProvider的具体操作。</p>
</li>
<li><p>ContentProvider封装了跨进程共享的逻辑，我们只需要URI即可访问数据。由系统来管理ContentProvider的创建、生命周期及访问线程的分配，简化我们在应用间共享数据的方式，我们只管通过ContentResolver访问ContentProvider所提示的数据接口，而不需要担心他所在的进程是启动还是未启动</p>
</li>
</ol>
<h3 id="为什么要使用ContentResolver类与ContentProvider进行交互？"><a href="#为什么要使用ContentResolver类与ContentProvider进行交互？" class="headerlink" title="为什么要使用ContentResolver类与ContentProvider进行交互？"></a><strong>为什么要使用ContentResolver类与ContentProvider进行交互？</strong></h3><p>一般情况下，一个应用可能会使用多个ContentProvider，若要了解每个ContentProvider再进行不同的实现完成数据交互，操作成本大且难度高。</p>
<p>ContentResolver就是对素有的ContentProvider仅从统一管理，通过URI可操作不同的ContentProvider中的数据，外部进程通过COntentReslover类完成与ContentProvider交互</p>
<h3 id="ContentProvider访问媒体文件"><a href="#ContentProvider访问媒体文件" class="headerlink" title="ContentProvider访问媒体文件"></a>ContentProvider访问媒体文件</h3><p>​		要通过 <code>ContentProvider</code> 访问媒体文件（如图片、视频等），通常会使用 Android 系统提供的 <code>MediaStore</code>。<code>MediaStore</code> 是一个内置的 <code>ContentProvider</code>，用于管理媒体文件的共享存储。</p>
<p><strong>步骤 1: 添加必要的权限</strong></p>
<p>在 <code>AndroidManifest.xml</code> 中添加读取存储的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>从 Android 6.0（API 级别 23）开始，<strong>还需要在运行时请求这个权限。</strong></p>
<p><strong>步骤 2: 运行时请求权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_EXTERNAL_STORAGE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] PERMISSIONS_STORAGE = &#123;</span><br><span class="line">    Manifest.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">verifyStoragePermissions</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">    <span class="comment">// Check if we have read permission</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">permission</span> <span class="operator">=</span> ActivityCompat.checkSelfPermission(activity, Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (permission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t have permission so prompt the user</span></span><br><span class="line">        ActivityCompat.requestPermissions(</span><br><span class="line">                activity,</span><br><span class="line">                PERMISSIONS_STORAGE,</span><br><span class="line">                REQUEST_EXTERNAL_STORAGE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 查询媒体文件</strong></p>
<p>使用 <code>ContentResolver</code> 查询 <code>MediaStore</code> 中的数据了。以下示例展示如何查询设备上的图片：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ImageInfo&gt; <span class="title function_">queryImages</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;ImageInfo&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ContentResolver</span> <span class="variable">contentResolver</span> <span class="operator">=</span> getContentResolver();</span><br><span class="line"></span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">            MediaStore.Images.Media._ID,</span><br><span class="line">            MediaStore.Images.Media.DISPLAY_NAME,</span><br><span class="line">            MediaStore.Images.Media.SIZE</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> contentResolver.query(uri, projection, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nameColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeColumn</span> <span class="operator">=</span> cursor.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> cursor.getLong(idColumn);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(nameColumn);</span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> cursor.getLong(sizeColumn);</span><br><span class="line"></span><br><span class="line">            <span class="type">Uri</span> <span class="variable">contentUri</span> <span class="operator">=</span> ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id);</span><br><span class="line">            images.add(<span class="keyword">new</span> <span class="title class_">ImageInfo</span>(id, name, size, contentUri));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;QueryImages&quot;</span>, <span class="string">&quot;Error querying images&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>记得在适当的时机（如用户同意权限请求后）调用 <code>queryImages()</code> 方法。</li>
<li>由于这些操作可能涉及大量的数据查询，<strong>在后台线程中执行查询操作，以避免阻塞主线程。</strong></li>
<li>上面的代码示例没有处理运行时权限的用户响应。在实际应用中，应该在 <code>onRequestPermissionsResult</code> 中根据用户是否授权采取相应的行动。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MVC MVP MVVM MVI</title>
    <url>/2024/03/26/Android%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/</url>
    <content><![CDATA[<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC三层对应的关系：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1645b7389d014b6f%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1645b73891f5ff8c%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="img"></p>
<p>视图层(View) 对应于xml布局文件和java代码动态view部分，控制层(Controller) MVC中Android的控制层是由Activity来承担的，Activity本来主要是作为初始化页面，展示数据的操作，但是因为XML视图功能太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担的功能过多。模型层(Model) 针对业务模型，建立的数据结构和相关的类，它主要负责网络请求，数据库处理，I&#x2F;O的操作。</p>
<p>总结概括:</p>
<p>将数据的处理逻辑抽出来封装成一个Model。可以看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Model</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">getUserInfo</span><span class="params">(String uid,Callback1&lt;UserInfo&gt; callback)</span>&#123;</span><br><span class="line">        UserInfo userInfo= <span class="keyword">new</span> <span class="title class_">HttpUtil</span>&lt;UserInfo&gt;().get(uid);</span><br><span class="line">        callback.onCallBack(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"># Activity</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getUserInfo</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        sampleModel.getUserInfo(uid, <span class="keyword">new</span> <span class="title class_">Callback1</span>&lt;SampleModel.UserInfo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCallBack</span><span class="params">(SampleModel.UserInfo userInfo)</span>&#123;</span><br><span class="line">                <span class="comment">// 通过接口回调的形式获取返回的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具有一定的分层，model彻底解耦，controller和view并没有解耦</li>
<li>层与层之间的交互尽量使用回调或者使用消息机制去完成，尽量避免直接持有</li>
<li>controller和view在android中无法做到彻底分离，但在代码逻辑层面一定要分清</li>
<li>业务逻辑被放置在model层，能够更好的复用和修改增加业务</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP与MVC的区别在于Model和View之间的通讯，都是通过Presenter完成。MVP架构是基于MVC的改进，将MVC的中Controller独立出来作为Presenter。它们的关系入下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1645b738c9d09633%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.awebp" alt="mvp.png"></p>
<p>google的MVP实现方案是把业务逻辑放在presenter中，弱化Model。xml和Activity还是作为视图层， 视图层接收到页面数据，调用Presenter进行业务逻辑处理，Presenter调用Model进行数据处理，Model回传数据给Presenter，Presenter回传数据给View。数据的回传通过接口回调的方式来实现。Presenter相当于一个控制器，控制了数据的来源和去处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVPPresenter</span> &#123;</span><br><span class="line"></span><br><span class="line">    MVPModel model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MVPPresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        model = <span class="keyword">new</span> <span class="title class_">MVPModel</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IView iView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setiView</span><span class="params">(IView iView)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.iView = iView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String account, String pwd)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loginResult</span> <span class="operator">=</span> model.login(account, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (loginResult)&#123;</span><br><span class="line">            iView.loginSuccess();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            iView.loginFail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，Presenter中会持有View的引用。</p>
<p>有一个面试题就是MVP内存泄漏问题：</p>
<p>MVP 会出现内存泄漏是因为 Presenter 层持有 View 对象，一般我们会把 Activity 做为 View 传递到 Presenter，Presenter 持有 View对象且如果在执行耗时操作时，关闭了Activity，会导致Presenter一直持有Activity的对象，造成内存泄漏。</p>
<p>解决办法：Activity onDestroy() 方法中调用 Presenter 中的方法，把 View 置为 null</p>
<p>MVP架构的优缺点：</p>
<p>优点：</p>
<p>Model与View完全分离，彻底解耦。</p>
<p>view由Activity承担，Presenter做业务，结构清晰。</p>
<p>Presenter复用，可以将一个Presenter用于多个视图，而不用改变Presenter的逻辑。</p>
<p>缺点：</p>
<p>三层模式造成代码结构复杂。</p>
<p>View 层和 Presenter 层的关联关系写的不好，会导致内存泄漏和性能问题。</p>
<p>接口爆炸。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM 模式改动在于中间的 Presenter 改为 ViewModel，MVVM 同样将代码划分为三个部分：</p>
<ul>
<li><strong>View：</strong> Activity 和 Layout XML 文件，与 MVP 中 View 的概念相同；View只负责展示数据和用户交互，</li>
<li><strong>Model：</strong> 负责管理业务数据逻辑，如网络请求、数据库处理，与 MVP 中 Model 的概念相同；Model负责数据的获取和存储。</li>
<li><strong>ViewModel：</strong> 存储视图状态，负责处理表现逻辑，并将数据设置给可观察数据容器。 ViewModel负责处理业务逻辑和数据转换</li>
</ul>
<p>​		在实现细节上，View 和 Presenter 从双向依赖变成 View 单向依赖 ViewModel，但 ViewModel 不会直接向 View 回调，而是让 View 通过观察者的模式去监听数据的变化，有效规避了 MVP 双向依赖的缺点。</p>
<p>MVVM 本身也存在一些缺点：</p>
<ul>
<li><strong>多数据流：</strong> View 与 ViewModel 的交互分散，缺少唯一修改源，不易于追踪；</li>
<li><strong>LiveData 膨胀：</strong> 复杂的页面需要定义多个 MutableLiveData，并且都需要暴露为不可变的 LiveData。</li>
</ul>
<p>​		MVVM 和 MVP 的思想是相同的，最本质的概念就是 Activity 里做的事情太多了，所以要把 Activity 中与 UI 无关的部分抽离出来，交给别人做。这个 “别人” 在 MVP 里叫作 Presenter，在 MVVM 里叫作 ViewModel。而不论是 MVP 中的约定接口，还是 ViewModel 里的观察者模式，这些都是实现上的细节而已。</p>
<p>观察者模式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储观察者的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> observers = mutableListOf&lt;Observer&lt;T&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.add(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.remove(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyObservers</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        observers.forEach &#123; it.onUpdate(<span class="keyword">data</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userObservable = Observable&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userObserver = <span class="keyword">object</span> : Observer&lt;User&gt; &#123;	</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;User data updated: <span class="subst">$&#123;data.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userObservable.addObserver(userObserver)</span><br><span class="line">    userObservable.notifyObservers(User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>))  <span class="comment">// 输出: User data updated: Alice</span></span><br><span class="line">    userObservable.removeObserver(userObserver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MVVM与MVP对比"><a href="#MVVM与MVP对比" class="headerlink" title="MVVM与MVP对比"></a>MVVM与MVP对比</h3><ul>
<li><p>模型层(Model) 与MVP中的Model层一致，负责与数据库和网络层通信，获取并存储数据。与MVP的区别在于Model层不再通过回调通知业务逻辑层数据改变，而是通过观察者模式实现。</p>
</li>
<li><p>视图(View) 负责将Model层的数据做可视化的处理，同时与ViewModel层交互。</p>
</li>
<li><p>视图模型(ViewModel) 主要负责业务逻辑的处理，同时与 Model 层 和 View层交互。与MVP的Presenter相比，<strong>ViewModel不再依赖View</strong>，使得解耦更加彻底。</p>
</li>
</ul>
<p>​		MVVM架构的本质是数据驱动，它的最大的特点是<strong>单向依赖</strong>。MVVM架构通过观察者模式让ViewModel与View解耦，实现了View依赖ViewModel，ViewModel依赖Model的单向依赖。		</p>
<p>​		通过观察者模式实现了View &rarr; ViewModel &rarr; Model的单向依赖。</p>
<p><a href="https://juejin.cn/post/7072020104212381732?searchId=2024022021121262D69DA346203EBBDF9A">Android Jetpack 开发套件 #5 Android UI 架构演进：从 MVC 到 MVP、MVVM、MVI</a></p>
<p><a href="https://juejin.cn/post/7147215414538272776?searchId=2024022021121262D69DA346203EBBDF9A#heading-8">Android 架构思想与 MVVM 框架封装</a></p>
<h2 id="MVI"><a href="#MVI" class="headerlink" title="MVI"></a>MVI</h2><p><strong>Model：</strong> 不是MVC、MVP里M所代指的数据层，而是指<strong>表征</strong> <strong>UI</strong> <strong>状态的聚合对象</strong>。Model是不可变的，Model与呈现出的UI是一一对应的关系。</p>
<p><strong>View：</strong>和MVC、MVP里做代指的V一样，指渲染UI的单元，可以是Activity或者View。可以接收用户的交互意图，会根据新的Model响应式地绘制UI。</p>
<p><strong>Intent：</strong>不是传统的Android设计里的Intent，一般指用户与UI交互的意图，如按钮点击。<strong>Intent是改变Model的唯一来源</strong>。</p>
<p>MVI 与前者的主要区别不在于强调严格的单向数据流，而在于从命令式的开发模式，转变为响应式的开发模式。</p>
<blockquote>
<p><strong>单向数据流</strong>：界面变化是数据流的末端，界面消费上游产生的数据，并随上游数据的变化进行刷新。若用数据流来理解界面刷新，就必须抽象出两个“数据”。</p>
<p>第一个数据是从界面发出的<strong>事件（意图）</strong>，即 MVI 中 I（Intent）。在 MVP 和 MVVM 中，界面发出的事件是通过一个 Presenter&#x2F;ViewModel 的函数调用实现的，这是命令式的。为了实现响应式编程，需把这个函数调用转换成一个数据，即<code>Intent</code>。</p>
<p>第二个数据是返回给界面的<strong>状态</strong>，即 MVI 中的 M（Model），它通常被称为状态<code>State</code>，从字面就可以感觉到界面状态是会时刻发生变化的。</p>
</blockquote>
<p>​		其实就是MVVM+单数据流，将vm的所有变更都定义到state里面。 所以相对于mvvm来说这个MVI是做了加法。 做加法的坏处在于很容易沉醉在过度设计中。 对于app来说很多时候MVC也够用了，负责交互多的可以使用mvvm mvp。</p>
<p>​		<strong>MVI 模式的改动在于将 View 和 ViewModel 之间的多数据流改为基于 ViewState 和Intent的单数据流。</strong>MVI 将代码分为以下四个部分：</p>
<ul>
<li><strong>View：</strong> Activity 和 Layout XML 文件，与 MVVM 中 View 的概念相同；</li>
<li><strong>Intent：</strong> 定义数据操作，是将数据传到 Model 的唯一来源，相比 MVVM 是新的概念；</li>
<li><strong>ViewModel：</strong> 存储视图状态，负责处理表现逻辑，并将 ViewState 设置给可观察数据容器；</li>
<li><strong>ViewState：</strong> 一个数据类，包含页面状态和对应的数据。state的定义与业务相关。</li>
</ul>
<blockquote>
<p><strong>响应式编程</strong>：我们现在常写的代码就是命令式，if条件满足就会走里面的case。而响应式编程是一种面向<strong>数据流</strong>和<strong>变化传播</strong>的<strong>声明式</strong>编程范式，</p>
<p>数据流”和“变化传播”是相互解释的：有数据流动，就意味着变化会从上游传播到下游。变化从上游传播到下游，就形成了数据流。</p>
<p>“声明式”意思是定义流上数据变换的逻辑并不是立刻执行，只有当数据流流动起来之后才会执行。</p>
</blockquote>
<p>Intent 就是在提示你，将原先命令式的函数调用转换成一个事件数据，用<code>响应式编程</code>的方式进行事件到状态的变换，并且还得保证界面状态有<code>唯一可信数据源</code>，这样界面的刷新就形成了一条<code>单向数据流</code>。</p>
<p>所以只要满足“响应式编程”、“单向数据流”、“唯一可信数据源”这三个原则的都可以称之为 MVI。不管使用的是 ViewModel 还是 Presenter。<strong>MVI 关心的不是具体的界面状态持有者，而是整个更新界面数据链路的流动方式和方向。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、ViewModel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>: <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mModel = MainModel()</span><br><span class="line">    <span class="keyword">val</span> mIntent = Channel&lt;MainIntent&gt;(Channel.UNLIMITED)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = MutableStateFlow&lt;MainViewState&gt;(MainViewState.Idle)</span><br><span class="line">    <span class="keyword">val</span> state: StateFlow&lt;MainViewState&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            mIntent.consumeAsFlow().collect &#123;</span><br><span class="line">                <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                    <span class="keyword">is</span> MainIntent.FetchNew -&gt; fetchNews()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            _state.value = MainViewState.Loading</span><br><span class="line">            _state.value = <span class="keyword">try</span> &#123;</span><br><span class="line">                MainViewState.News(mModel.fetchNews())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                MainViewState.Error(e.localizedMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、ViewState</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">MainViewState</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> Idle : MainViewState()</span><br><span class="line">    <span class="keyword">object</span> Loading : MainViewState()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">News</span>(<span class="keyword">val</span> news: List&lt;New&gt;) : MainViewState()</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Error</span>(<span class="keyword">val</span> error: String?) : MainViewState()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、Intent</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">MainIntent</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> FetchNew : MainIntent()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4、View</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mainViewModel: MainViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">observeViewModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            mainViewModel.state.collect &#123;</span><br><span class="line">                <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                    <span class="keyword">is</span> MainViewState.Idle -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">is</span> MainViewState.Loading -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">is</span> MainViewState.News -&gt; &#123;</span><br><span class="line">                        renderList(it.news)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">is</span> MainViewState.Error -&gt; &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">renderList</span><span class="params">(news: <span class="type">List</span>&lt;<span class="type">New</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MVI和MVVM对比"><a href="#MVI和MVVM对比" class="headerlink" title="MVI和MVVM对比"></a>MVI和MVVM对比</h3><p>​		在MVVM的基础上封装了聚合的UiState，然后将View层的事件封装成事件流。从架构层面来说的话，MVI架构下ViewModel的实现对View层屏蔽，只能通过发送Intent来驱动事件。而MVI架构下，Intent是驱动UI变化的唯一来源，并且表征UI状态的值收敛在一个变量里。</p>
<p><a href="https://juejin.cn/post/7031726493906829319?searchId=2024031118324076E557B5EED382D6FC41#heading-12">用Kotlin Flow解决Android开发中的痛点问题</a></p>
<p><a href="https://juejin.cn/post/7058903426893086734">MVI架构模式？到底是谁在卷？《官方架构指南升级》</a></p>
<p><a href="https://juejin.cn/post/7072020104212381732?searchId=2024022021121262D69DA346203EBBDF9A#heading-5">Android Jetpack 开发套件 #5 Android UI 架构演进：从 MVC 到 MVP、MVVM、MVI</a></p>
<p><a href="https://juejin.cn/post/7144737325698777096#heading-5">写业务不用架构会怎么样？（一）</a></p>
<p><a href="https://juejin.cn/post/7087717477246369805?searchId=20240220214340DD637841005180BB5DD1">Android 架构之 MVI 雏形 | 响应式编程 + 单向数据流 + 唯一可信数据源</a></p>
<p><a href="https://juejin.cn/post/7177619630050000954?searchId=2024031216310771AB22842B74E9535181#heading-15">Android App封装 ——架构（MVI + kotlin + Flow）</a></p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><a href="https://juejin.cn/post/6844904147641171981#heading-3">Android组件化开发思想与实践</a></p>
<p><a href="https://juejin.cn/post/7033954652315975688?searchId=20240308162534784A3A2A74C05F26CA76#heading-42">Android 手把手带你搭建一个组件化项目架构</a></p>
<p><a href="https://juejin.cn/post/7142297951023415332?searchId=20240308193805665EE07B2CFA25437278">Android组件化开发，其实就这么简单</a></p>
<p><a href="https://github.com/ByteYuhb/anna_music_app">组件化架构实现网络云音乐app</a></p>
<h3 id="组件化的目的"><a href="#组件化的目的" class="headerlink" title="组件化的目的"></a>组件化的目的</h3><p>Android项目组件化的目的主要有以下几个：</p>
<p><strong>1、提高编译运行速度</strong></p>
<p>​		当我们的项目随着版本的不断迭代，随之增加的功能会越来越多，业务也会变得越来越复杂，最终会导致代码量急剧上升，相关的三方sdk也会不断的涌入，以至于，更改一处，就要全量编译运行，有时候甚至会出现，改一行而等10分钟的情况，非常的耗时，大大降低了开发效率。</p>
<p>​		而采取了组件化的方式后，相关业务模块，进行单独抽取，使得每个业务模块可以独立当做App存在，和其他模块，互不关联影响，在编译运行时期，只考虑本模块即可，从而减少了代码的编译量，提高了编译运行速度，节约了开发时间。</p>
<p><strong>2、业务拆解，完全解耦</strong></p>
<p>​		单独的业务模块进行抽取成一个独立的组件，也就是相互不关联的Module，在各自的模块中书写相关的代码，做到，业务拆解，人员拆解，实现真正的解耦。</p>
<p><strong>3、功能复用，节约开发时间</strong></p>
<p>​		所谓的功能复用，不仅仅是同项目之间的复用，更是以后同样功能模块的复用，比如A项目中有一个直播模块，后面开发的B项目也有，完全可以移植过来复用，无非就是UI等简单逻辑的修改。</p>
<p><strong>4、责任明确，分工明确</strong></p>
<p>​		组件化的项目，各个业务单独成Module，在独自的Module中开发相关的业务需求，相对于糅合到一个模块中的项目来说，业务之间拆分更加明确，更加清晰，我负责哪个业务，就去哪个组件下去写，使得所负责的任务清晰明确，后续定位问题，也能够第一时间发现并修改。</p>
<p><strong>以下是一些常见的 Android 组件化方案:</strong></p>
<ul>
<li><strong>模块化:</strong> 将项目划分为不同的模块，每个模块可以独立开发、测试和发布。</li>
<li><strong>插件化:</strong> 将功能代码封装成插件，可以动态加载和卸载。</li>
<li><strong>路由:</strong> 通过路由机制来跳转到不同的功能模块。</li>
</ul>
<h3 id="组件化需要解决的问题"><a href="#组件化需要解决的问题" class="headerlink" title="组件化需要解决的问题"></a>组件化需要解决的问题</h3><ul>
<li><p>组件分层：怎么将一个项目分成多个组件、组件间的依赖关系是怎么样的?</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403081955567.webp" alt="img"></p>
</li>
<li><p>组件单独运行和集成调试：组件是如何独立运行和集成调试的？</p>
</li>
<li><p>组件间通信:主项目与组件、组件与组件之间如何通信就变成关键?</p>
<p><strong>组件之间数据传递</strong></p>
<p>数据之间的传递，如果是页面单纯的传递数据，直接可以使用ARouter提供的传递方式，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/test/test&quot;</span>)</span><br><span class="line">            .withLong(<span class="string">&quot;key1&quot;</span>, <span class="number">666L</span>)</span><br><span class="line">            .withString(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;888&quot;</span>)</span><br><span class="line">            .withObject(<span class="string">&quot;key4&quot;</span>, new Test(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>))</span><br><span class="line">            .navigation();</span><br></pre></td></tr></table></figure>

<p>如果不是页面之间的传递，那么就需要我们自己定义接口或者通过中间层common来实现了，当然了需要进行逻辑处理。</p>
</li>
<li><p>组件化关键是如何划分组件，解耦</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Android编译流程</title>
    <url>/2024/03/26/Android%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Android-APK打包流程"><a href="#Android-APK打包流程" class="headerlink" title="Android APK打包流程"></a>Android APK打包流程</h2><h3 id="资源文件编译"><a href="#资源文件编译" class="headerlink" title="资源文件编译"></a>资源文件编译</h3><p><code>apk</code>资源包含:</p>
<ul>
<li>工程中<code>res</code>目录下的所有文件</li>
<li><code>assets</code>目录下的文件</li>
<li><code>AndroidManifest.xml</code></li>
</ul>
<h3 id="AIDL文件编译"><a href="#AIDL文件编译" class="headerlink" title="AIDL文件编译"></a><code>AIDL</code>文件编译</h3><p>它是<code>Google</code>为了帮助我们进行进程间通信的简便写法，最后还是需要被解析编译为<code>java</code>文件，而做这个工作的就是<code>aidl</code>工具，存在于<code>sdk/build-tools</code>目录。</p>
<p><strong>这个阶段的主要的工作就是将项目中的<code>aidl</code>文件编译为<code>java</code>文件</strong>。</p>
<h3 id="Java与Kotlin文件编译"><a href="#Java与Kotlin文件编译" class="headerlink" title="Java与Kotlin文件编译"></a><code>Java</code>与<code>Kotlin</code>文件编译</h3><ul>
<li><p>通过<code>Java Compiler</code> 编译项目中所有的<code>Java</code>代码，包括<code>R.java</code>、<code>.aidl</code>文件生成的<code>.java</code>文件、<code>Java</code>源文件，生成<code>.class</code>文件。在对应的<code>build</code>目录下可以找到相关的代码</p>
</li>
<li><p>通过<code>Kotlin Compiler</code>编译项目中的所有<code>Kotlin</code>代码，生成<code>.class文件</code></p>
</li>
</ul>
<p>注解处理器(<code>APT</code>,<code>KAPT</code>)生成代码也是在这个阶段生成的。当注解的生命周期被设置为<code>CLASS</code>的时候，就代表该注解会在编译<code>class</code>文件的时候生效，并且生成<code>java</code>源文件和<code>Class</code>字节码文件。</p>
<h3 id="Class文件打包成DEX"><a href="#Class文件打包成DEX" class="headerlink" title="Class文件打包成DEX"></a>Class文件打包成DEX</h3><p>这一步就是将<code>.class</code>文件打包成<code>dex</code>文件。Class是Java虚拟机识别的二级制文件，ART虚拟机识别的文件是dex文件。</p>
<blockquote>
<p><code>AGP 3.X</code> 以后，<code>Google</code> 分别引入 <code>D8</code> 编译器和 <code>R8</code> 工具作为默认的 <code>DEX</code> 编译器和混淆压缩工具。</p>
<p>在<code>AGP3.0.1</code>之后,<code>D8</code>编译器取代了<code>Dx</code>，用于将<code>class</code>文件打包成<code>DEX</code>，<code>D8</code>编译器编译更快、时间更短；<code>DEX</code> 编译时占用内容更小；生成的<code>dex</code>文件大小更小；同时拥有相同或者是更好的运行时性能；</p>
<p>在<code>AGP3.4.0</code>之后，默认开启<code>R8</code>，<code>R8</code> 是 <code>ProGuard</code> 的替代工具，用于代码的压缩（<code>shrinking</code>）和混淆（<code>obfuscation</code>）</p>
</blockquote>
<h3 id="生成APK包"><a href="#生成APK包" class="headerlink" title="生成APK包"></a>生成<code>APK</code>包</h3><p>在资源文件与代码文件都编译完成后，接下来就是生成<code>apk</code>包了，将<code>manifest</code>文件、<code>resources</code>文件、<code>dex</code>文件、<code>assets</code>文件等等打包成一个压缩包，也就是<code>apk</code>文件。</p>
<p>在<code>AGP3.6.0</code>之后，使用<code>zipflinger</code>作为默认打包工具来构建<code>APK</code>，以提高构建速度</p>
<h3 id="zipalign（对齐处理）"><a href="#zipalign（对齐处理）" class="headerlink" title="zipalign（对齐处理）"></a><code>zipalign</code>（对齐处理）</h3><p><code>zipalign</code>会对<code>apk</code>中未压缩的数据进行4字节对齐，对齐的主要过程是将<code>APK</code>包中所有的资源文件距离文件起始偏移为4字节整数倍，对齐后就可以使用<code>mmap</code>函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。</p>
<p>签名工具的不同带来的对齐处理的顺序不同：</p>
<ul>
<li>如果使用的是 <code>apksigner</code>，只能在为 <code>APK</code> 文件签名之前执行 <code>zipalign</code>。</li>
<li>如果使用的是 <code>jarsigner</code>，只能在为 <code>APK</code> 文件签名之后执行 <code>zipalign</code>。</li>
</ul>
<h3 id="对APK进行签名"><a href="#对APK进行签名" class="headerlink" title="对APK进行签名"></a>对<code>APK</code>进行签名</h3><p>在生成APK文件之后，必须对该<code>apk</code>文件进行签名，否则无法被安装。</p>
<p>之前大家比较熟知的签名工具是<code>JDK</code>提供的<code>jarsigner</code>，而<code>apksigner</code>是<code>Google</code>专门为<code>Android</code>提供的签名和签证工具。</p>
<p>其区别就在于<code>jarsigner</code>只能进行<code>v1</code>签名，而<code>apksigner</code>可以进行<code>v2</code>、<code>v3</code>、<code>v4</code>签名。</p>
<p><strong><code>V2</code>签名</strong></p>
<p><code>Android7.0</code>之后，<code>Google</code>推出了<code>V2</code>签名，解决<code>V1</code>签名速度慢以及签名不完整的问题。</p>
<p>apk本质上是一个压缩包，而压缩包文件格式一般分为三块：</p>
<p>文件数据区，中央目录，中央目录结束节。</p>
<p>而<code>V2</code>要做的就是，在文件中插入一个<code>APK</code>签名分块，位于中央目录部分之前，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/ab68a4f6847a41ca983100b0c832af95%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p>
<p>这样处理之后，文件签名完成就无法修改了，这也是为什么<code>ZipAlign</code>对齐只能在<code>ApkSigner</code>签名之前执行的原因。</p>
<h2 id="Android-APK打包过程中的Task"><a href="#Android-APK打包过程中的Task" class="headerlink" title="Android APK打包过程中的Task"></a>Android APK打包过程中的<code>Task</code></h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aidl 转换aidl文件为java文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>compileDebugAidl</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成BuildConfig文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>generateDebugBuildConfig</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取gradle中配置的资源文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>generateDebugResValues</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge资源文件，AAPT2 编译阶段</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>mergeDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge assets文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>mergeDebugAssets</span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>compressDebugAssets</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge所有的manifest文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>processDebugManifest</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成R文件 AAPT2 链接阶段</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>processDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译kotlin文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>compileDebugKotlin</span><br><span class="line"></span><br><span class="line"><span class="comment">//javac 编译java文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>compileDebugJavaWithJavac</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换class文件为dex文件</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>dexBuilderDebug</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包成apk并签名</span></span><br><span class="line">&gt; <span class="attr">Task :</span><span class="attr">app:</span>packageDebug</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Android 插件化</title>
    <url>/2024/03/26/Android%E6%8F%92%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Android-插件化"><a href="#Android-插件化" class="headerlink" title="Android 插件化"></a>Android 插件化</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="跨进程通信"><a href="#跨进程通信" class="headerlink" title="跨进程通信"></a>跨进程通信</h3><p><strong>共享内存（Shared Memory)</strong> 共享内存方式实现进程间通信依靠的是申请一块内存区域，然后将这块内存映射到进程空间中，这样两个进程都可以直接访问这块内存。在进行进程间通信时，两个进程可以利用这块内存空间进行数据交换。通过这样的方式，减少了数据的赋值操作，因此共享内存实现进程间通信在速度上有明显优势。</p>
<p><strong>管道（Pipe）</strong> 管道也是操作系统中常见的一种进程间通信方式，Windows系统进程间的通信依赖于此种方式实现。在进行进程间通信时，会在两个进程间建立一根拥有读（read）写(write)功能的管道,一个进程写数据，另一个进程可以读取数据，从而实现进程间通信问题。</p>
<p><strong>UDS（UNIX Domain Socket）</strong> UDS也被称为IPC Socket，但它有别于network 的Socket。UDS的内部实现不依赖于TCP&#x2F;IP协议，而是基于本机的“安全可靠操作”实现。UDS这种进程间通信方式在Android中用到的也是比较多的。</p>
<p><strong>Binder</strong> Binder是Android中独有的一种进程间通信方式。它底层依靠mmap,只需要一次数据拷贝，把一块物理内存同时映射到内核和目标进程的用户空间。</p>
<blockquote>
<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享</p>
</blockquote>
<p>无论是哪种进程间通信，都是需要一个进程提供数据，一个进程获取数据。因此，我们可以把提供数据的一端称为服务端，把获取数据的一端称为客户端。</p>
<h3 id="使用Binder实现进程间通信"><a href="#使用Binder实现进程间通信" class="headerlink" title="使用Binder实现进程间通信"></a>使用Binder实现进程间通信</h3><p>先上一个示例代码</p>
<p>​	创建一个服务Service作为通信中的服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_CODE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Binder</span> <span class="variable">mBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, <span class="meta">@NonNull</span> Parcel data, <span class="meta">@Nullable</span> Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            <span class="keyword">if</span> (code == REQUEST_CODE) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> data.readString();</span><br><span class="line">                <span class="comment">// 根据姓名查询学生成绩并将成绩写入到返回数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">studentGrade</span> <span class="operator">=</span> getStudentGrade(name);</span><br><span class="line">                <span class="keyword">if</span> (reply != <span class="literal">null</span>)</span><br><span class="line">                    reply.writeInt(studentGrade);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据姓名查询学生成绩</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>.equals(name) ? <span class="number">90</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在manifest中注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.GradeService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:process</span>=<span class="string">&quot;:server&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.server.gradeservice&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建Activity来作为通信中客户端</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// 远程服务的Binder代理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mRemoteBinder: IBinder? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServiceConnection: ServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(componentName: <span class="type">ComponentName</span>, iBinder: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 获取远程服务的Binder代理</span></span><br><span class="line">            mRemoteBinder = iBinder</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(componentName: <span class="type">ComponentName</span>)</span></span> &#123;</span><br><span class="line">            mRemoteBinder = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;CommitTransaction&quot;</span>, <span class="string">&quot;ClickableViewAccessibility&quot;</span>, <span class="string">&quot;WrongConstant&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test)</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_bind_service).setOnClickListener &#123; view: View? -&gt; bindGradeService() &#125;</span><br><span class="line">        <span class="comment">// 查询学生成绩</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_find_grade).setOnClickListener &#123; view: View? -&gt;</span><br><span class="line">            <span class="keyword">val</span> grade = getStudentGrade(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            ToastUtil.show(<span class="string">&quot;张三的成绩是：<span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定远程服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindGradeService</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> action = <span class="string">&quot;android.intent.action.server.gradeservice&quot;</span></span><br><span class="line">        <span class="keyword">val</span> intent = Intent(action)</span><br><span class="line">        intent.setPackage(packageName)</span><br><span class="line">        <span class="comment">// 以绑定的方式启动Service</span></span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从远程服务查询学生成绩</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStudentGrade</span><span class="params">(name: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建用于传递数据的 Parcel 对象</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = Parcel.obtain()</span><br><span class="line">    <span class="comment">// 创建用于接收远程服务返回数据的 Parcel 对象</span></span><br><span class="line">    <span class="keyword">val</span> reply = Parcel.obtain()</span><br><span class="line">    <span class="comment">// 初始化学生成绩为0</span></span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将学生姓名写入传递数据的 Parcel</span></span><br><span class="line">    <span class="keyword">data</span>.writeString(name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查远程 Binder 是否已经绑定，若未绑定则抛出异常</span></span><br><span class="line">        checkNotNull(mRemoteBinder) &#123; <span class="string">&quot;Need Bind Remote Server...&quot;</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过远程 Binder 执行远程调用（transact），传递数据 Parcel，接收回复数据 Parcel，0为标记位</span></span><br><span class="line">        mRemoteBinder!!.transact(REQUEST_CODE, <span class="keyword">data</span>, reply, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从回复数据 Parcel 中读取学生成绩</span></span><br><span class="line">        grade = reply.readInt()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line">        <span class="comment">// 处理远程调用异常</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回查询到的学生成绩</span></span><br><span class="line">    <span class="keyword">return</span> grade</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用代理模式优化代码"><a href="#使用代理模式优化代码" class="headerlink" title="使用代理模式优化代码"></a>使用代理模式优化代码</h3><p>代理模式：代理类充当被代理对象的包装器，以控制对被代理对象的访问。通过代理类可以在包装时定义许多其他事件。下面的BinderProxy就是代理类，GradeBinder是代理对象，通过BinderProxy控制对GradeBinder的访问。</p>
<p>先定义统一的接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IGradeInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 查询成绩接口</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getStudentGrade</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义binder继承类且继承上面的接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GradeBinder</span> : <span class="type">Binder</span>(), IGradeInterface &#123;</span><br><span class="line">    <span class="comment">// 实现功能的具体逻辑</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStudentGrade</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span> == name) <span class="number">90</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">    <span class="comment">// 在 Binder 服务端的 onTransact 方法中处理远程调用请求</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTransact</span><span class="params">(code: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Parcel</span>, reply: <span class="type">Parcel</span>?, flags: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 判断请求码是否为学生成绩查询请求</span></span><br><span class="line">    <span class="keyword">if</span> (code == GradeService.REQUEST_CODE) &#123;</span><br><span class="line">        <span class="comment">// 从传递数据 Parcel 中读取学生姓名</span></span><br><span class="line">        <span class="keyword">val</span> name = <span class="keyword">data</span>.readString()</span><br><span class="line">        <span class="comment">// 调用服务端方法查询学生成绩</span></span><br><span class="line">        <span class="keyword">val</span> studentGrade = getStudentGrade(name!!)</span><br><span class="line">        <span class="comment">// 将查询到的学生成绩写入回复数据 Parcel</span></span><br><span class="line">        reply?.writeInt(studentGrade)</span><br><span class="line">        <span class="comment">// 返回 true 表示成功处理了远程调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若请求码不是学生成绩查询请求，则交给父类处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, <span class="keyword">data</span>, reply, flags)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义GradeBinder的代理类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinderProxy</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(binder: IBinder) : IGradeInterface &#123;</span><br><span class="line">    <span class="comment">// 被代理的Binder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder: IBinder?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        mBinder = binder</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Binder读取成绩</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStudentGrade</span><span class="params">(name: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = Parcel.obtain()</span><br><span class="line">        <span class="keyword">val</span> reply = Parcel.obtain()</span><br><span class="line">        <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">        <span class="keyword">data</span>.writeString(name)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkNotNull(mBinder) &#123; <span class="string">&quot;Need Bind Remote Server...&quot;</span> &#125;</span><br><span class="line">            <span class="comment">// 这里会调用GradeBinder的onTransact方法</span></span><br><span class="line">            mBinder.transact(GradeService.REQUEST_CODE, <span class="keyword">data</span>, reply, <span class="number">0</span>)</span><br><span class="line">            grade = reply.readInt()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: RemoteException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grade</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化Binder代理类的对象</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">asInterface</span><span class="params">(iBinder: <span class="type">IBinder</span>?)</span></span>: IGradeInterface? &#123;</span><br><span class="line">            <span class="keyword">if</span> (iBinder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (iBinder <span class="keyword">is</span> IGradeInterface) &#123;</span><br><span class="line">                loge(<span class="string">&quot;当前进程&quot;</span>)</span><br><span class="line">                <span class="comment">// 如果是同一个进程的请求，则直接返回Binder</span></span><br><span class="line">                iBinder</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;远程进程&quot;</span>)</span><br><span class="line">                <span class="comment">// 如果是跨进程查询则返回Binder的代理对象</span></span><br><span class="line">                BinderProxy(iBinder)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GradeService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> REQUEST_CODE=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GradeBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="comment">// 此处可能是BinderProxy也可能是GradeBinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mBinderProxy: IGradeInterface? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServiceConnection: ServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(componentName: <span class="type">ComponentName</span>, iBinder: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 连接服务成功，根据是否跨进程获取BinderProxy或者GradeBinder实例</span></span><br><span class="line">            mBinderProxy = BinderProxy.asInterface(iBinder)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(componentName: <span class="type">ComponentName</span>)</span></span> &#123;</span><br><span class="line">            mBinderProxy = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;CommitTransaction&quot;</span>, <span class="string">&quot;ClickableViewAccessibility&quot;</span>, <span class="string">&quot;WrongConstant&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test)</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_bind_service).setOnClickListener &#123; view: View? -&gt; bindGradeService() &#125;</span><br><span class="line">        <span class="comment">// 查询学生成绩</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_find_grade).setOnClickListener &#123; view: View? -&gt;</span><br><span class="line">            <span class="keyword">val</span> grade = mBinderProxy?.getStudentGrade(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            ToastUtil.show(<span class="string">&quot;张三的成绩是：<span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定远程服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindGradeService</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> action = <span class="string">&quot;android.intent.action.server.gradeservice&quot;</span></span><br><span class="line">        <span class="keyword">val</span> intent = Intent(action)</span><br><span class="line">        intent.setPackage(packageName)</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用AIDL来实现同样的逻辑"><a href="#使用AIDL来实现同样的逻辑" class="headerlink" title="使用AIDL来实现同样的逻辑"></a>使用AIDL来实现同样的逻辑</h3><p>​		AIDL生成的那一坨代码其实就是上面的代码。<strong>即AIDL的原理其实就是使用了代理模式对Binder的使用进行了优化</strong>，使用AIDL保证了代码的整洁，同时也省去了自己编写繁琐的代理类相关代码。</p>
<p>在项目的目录鼠标右键创建AIDL文件，新版本的AS需要在<code>build.gradle(app)</code> 添加 <code>buildFeatures&#123;aidl = true&#125;</code>，创建一个名为IGradeService的AIDL文件，并添加一个getStudentGrade的方法。接着Rebuild一下项目后IDE就会自动生成AIDL的代码了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IGradeService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">            </span><br><span class="line">    int getStudentGrade(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在build&#x2F;generated&#x2F;aidl_source_output_dir&#x2F;DevDebug&#x2F;out&#x2F;com.app.tsmo.aidl.IGradeService目录下会看到生成的AIDL的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AIDL 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGradeService</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface &#123;</span><br><span class="line">  <span class="comment">// 默认实现类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">com</span>.app.tsmo.aidl.IGradeService &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AIDL 接口中定义的基本类型的演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat, <span class="type">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">      <span class="comment">// 默认实现为空，需要在具体的实现中重写该方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 默认实现返回0，需要在具体的实现中重写该方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 默认返回空，具体实现中可能需要返回实际的 IBinder 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stub是一个Binder，相当于上一章中的GradeBinder</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.app.tsmo.aidl.IGradeServic &#123;</span><br><span class="line">    <span class="comment">/** 构造并将 Stub 与接口关联 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 IBinder 对象转换为 com.app.tsmo.aidl.IGradeService 接口，</span></span><br><span class="line"><span class="comment">     * 如果需要则生成代理对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.app.tsmo.aidl.IGradeService <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.app.tsmo.aidl.IGradeService))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.app.tsmo.aidl.IGradeService)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.app.tsmo.aidl.IGradeService.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">      java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">      <span class="keyword">if</span> (code &gt;= android.os.IBinder.FIRST_CALL_TRANSACTION &amp;&amp; code &lt;= android.os.IBinder.LAST_CALL_TRANSACTION) &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">          <span class="comment">// 解析基本类型参数，并调用实现类的 basicTypes 方法</span></span><br><span class="line">          <span class="type">int</span> _arg0;</span><br><span class="line">          _arg0 = data.readInt();</span><br><span class="line">          <span class="type">long</span> _arg1;</span><br><span class="line">          _arg1 = data.readLong();</span><br><span class="line">          <span class="type">boolean</span> _arg2;</span><br><span class="line">          _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">          <span class="type">float</span> _arg3;</span><br><span class="line">          _arg3 = data.readFloat();</span><br><span class="line">          <span class="type">double</span> _arg4;</span><br><span class="line">          _arg4 = data.readDouble();</span><br><span class="line">          java.lang.String _arg5;</span><br><span class="line">          _arg5 = data.readString();</span><br><span class="line">          <span class="built_in">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getStudentGrade: &#123;</span><br><span class="line">          <span class="comment">// 解析参数，并调用实现类的 getStudentGrade 方法</span></span><br><span class="line">          java.lang.String _arg0;</span><br><span class="line">          _arg0 = data.readString();</span><br><span class="line">          <span class="type">int</span> <span class="variable">_result</span> <span class="operator">=</span> <span class="built_in">this</span>.getStudentGrade(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeInt(_result);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binder的代理类，相当于上一章中的BinderProxy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.app.tsmo.aidl.IGradeService &#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">      Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * AIDL 接口中定义的基本类型的演示</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat, <span class="type">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeInt(anInt);</span><br><span class="line">          _data.writeLong(aLong);</span><br><span class="line">          _data.writeInt(((aBoolean)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">          _data.writeFloat(aFloat);</span><br><span class="line">          _data.writeDouble(aDouble);</span><br><span class="line">          _data.writeString(aString);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 这里是代理的查询的方法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        <span class="type">int</span> _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeString(name);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_getStudentGrade, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          _reply.readException();</span><br><span class="line">          _result = _reply.readInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了远程调用的事务码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_basicTypes</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_getStudentGrade</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接口描述符</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.app.tsmo.aidl.IGradeService&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * AIDL 接口中定义的基本类型的演示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat, <span class="type">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取学生成绩的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStudentGrade</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码：</p>
<p>​		发现IGradeService接口中有一个名为Stub的内部类，它继承了Binder，并实现了IGradeService接口，并且它的内部有一个asInterface的方法，这个方法与我们上一章BinderProxy中的asInterface一致，只是写的位置不同而已。另外在Stub的onTranscation方法的TRANSACTION_getStudentGrade条件中的代码与GradeBinder的onTranscation方法代码是一样的。</p>
<p>服务端代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AidlGradeService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现 Stub 的 getStudentGrade 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder: IBinder = <span class="keyword">object</span> : IGradeService.Stub() &#123;</span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">basicTypes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            anInt: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aLong: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aBoolean: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aFloat: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aDouble: <span class="type">Double</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            aString: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(RemoteException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStudentGrade</span><span class="params">(name: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span> == name) <span class="number">90</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:name</span>=<span class="string">&quot;.aidl.AidlGradeService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:process</span>=<span class="string">&quot;:server&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.server.gradeservice&quot;</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Activity中使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mBinderProxy: IGradeService? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServiceConnection: ServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(componentName: <span class="type">ComponentName</span>, iBinder: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 连接服务后，根据是否跨进程获取Binder或者Binder的代理对象</span></span><br><span class="line">            mBinderProxy = IGradeService.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(componentName: <span class="type">ComponentName</span>)</span></span> &#123;</span><br><span class="line">            mBinderProxy = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;CommitTransaction&quot;</span>, <span class="string">&quot;ClickableViewAccessibility&quot;</span>, <span class="string">&quot;WrongConstant&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test)</span><br><span class="line">        <span class="comment">// 绑定服务</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_bind_service).setOnClickListener &#123; view: View? -&gt; bindGradeService() &#125;</span><br><span class="line">        <span class="comment">// 查询学生成绩</span></span><br><span class="line">        findViewById&lt;View&gt;(R.id.btn_find_grade).setOnClickListener &#123; view: View? -&gt;</span><br><span class="line">            <span class="keyword">val</span> grade = mBinderProxy?.getStudentGrade(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            ToastUtil.show(<span class="string">&quot;张三的成绩是：<span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定远程服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindGradeService</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> action = <span class="string">&quot;android.intent.action.server.gradeservice&quot;</span></span><br><span class="line">        <span class="keyword">val</span> intent = Intent(action)</span><br><span class="line">        intent.setPackage(packageName)</span><br><span class="line">        bindService(intent, mServiceConnection, BIND_AUTO_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AIDL就是对通过代理模式调用binder的系统封装。生成文件中的Stub是代理对象，Proxy是代理类。</p>
<p>​		上面的代码示例：使用的时候通过intent启动服务AidlGradeService,在服务里面以匿名类的形式实现了IGradeService.Stub()同时也实现了具体的查询方法getStudentGrade的逻辑。在activity中调用时是通过<code>IGradeService.Stub.asInterface(iBinder);</code>来获取的IGradeService接口的对象，然后调用接口的getStudentGrade方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.app.tsmo.aidl.IGradeService <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span>&#123;</span><br><span class="line">    <span class="comment">// 检查传入的 IBinder 对象是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果为空，直接返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询指定描述符匹配的本地接口IGradeService</span></span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="comment">// 如果查询到本地接口并且是指定 AIDL 接口的实例，则直接返回该IGradeService实例</span></span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.app.tsmo.aidl.IGradeService))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.app.tsmo.aidl.IGradeService)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果查询到的本地接口为空或不是指定 IGradeService的实例，则创建并返回 IGradeService 接口的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.app.tsmo.aidl.IGradeService.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>要知道代理模式不是代替了实现，而是对代理对象的访问进行了控制，最终的实现逻辑还是在代理对象中。</strong>而AIDL中的逻辑实现是以匿名内部类的形式实现代理对象的过程中定义的,这部分可以看看AidlGradeService中的实现。也就是<code>mBinderProxy?.getStudentGrade(&quot;张三&quot;)</code>这段代码最终的调用逻辑还是在AidlGradeService中。</p>
<p>IGradeService.Stub.asInterface()这个函数很奇妙  </p>
]]></content>
  </entry>
  <entry>
    <title>Android 虚拟机min</title>
    <url>/2023/12/15/Android%E8%99%9A%E6%8B%9F%E6%9C%BAmin/</url>
    <content><![CDATA[<h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p>每个 Android 应用在启动时都会创建一个新的进程，和一个对应的运行时环境实例，当中包括堆（Heap）的分配和垃圾回收等功能。在操作系统中，每个进程都有自己的独立地址空间，这包括了堆、栈、代码和数据段。</p>
<p>一个运行中的程序（进程）的内存空间被划分为几个区域，每个区域有特定的用途和属性：</p>
<ol>
<li><strong>栈（Stack）</strong>：<ul>
<li>栈是由编译器自动管理的内存区域，用于存储程序执行时的函数调用信息。</li>
<li>它包括函数的参数值、返回地址以及局部变量等。</li>
<li>栈的特点是后进先出（LIFO）的数据结构，每当一个函数被调用时，它的信息就被推入（push）栈中，当函数调用完成后，这些信息就会被弹出（pop）栈。</li>
<li>分配时机：栈空间通常在程序开始执行时由操作系统自动分配，随着函数的调用和返回，会动态地增长和缩减。</li>
<li>分配者：操作系统负责分配一个初始栈空间给进程，并在运行时对栈进行管理。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>堆是用于动态内存分配的区域，程序在运行时可以从堆上分配或释放内存。</li>
<li>在C语言中，动态内存分配是通过<code>malloc</code>、<code>calloc</code>、<code>realloc</code>和<code>free</code>等函数实现的。</li>
<li>在Android开发中，Java虚拟机（JVM）或其他运行环境（如Dalvik虚拟机或Android Runtime, ART）管理堆内存，程序员通常不需要手动管理这部分内存，因为垃圾回收器会自动回收不再使用的对象。</li>
<li>分配时机：堆空间的分配是在程序运行时根据需要进行的，通常是程序员通过代码请求分配。</li>
<li>分配者：在C和C++等语言中，是由程序员通过调用<code>malloc</code>、<code>new</code>等函数显式申请的。在Java、C#等使用垃圾回收机制的语言中，由虚拟机或运行时环境负责管理。</li>
</ul>
</li>
<li><strong>BSS段（Block Started by Symbol）</strong>：<ul>
<li>BSS段用于存储程序中的未初始化的全局变量和静态变量。</li>
<li>在程序启动时，BSS段会被操作系统初始化为零或空指针。</li>
<li>分配时机：BSS段的空间分配发生在程序启动时，在程序被加载到内存时自动分配。</li>
<li>分配者：操作系统在加载程序时，会根据可执行文件的信息为BSS段分配内存，并将其初始化为零。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>数据段用来存储程序中已初始化的全局变量和静态变量。</li>
<li>这些变量的初始值存储在程序的可执行文件中，并在程序加载到内存时被初始化。</li>
<li>分配时机：数据段也是在程序启动时分配的，当程序被加载到内存时进行。</li>
<li>分配者：操作系统根据程序的可执行文件内容，在加载程序时为数据段分配内存，并赋予初始值。</li>
</ul>
</li>
<li><strong>程序代码区（Text Segment 或 Code Segment）</strong>：<ul>
<li>程序代码区，也称为文本段，包含了程序的机器指令代码。</li>
<li>这部分内存通常是只读的，以防止程序在运行时被意外修改。</li>
<li>它对应的是程序源代码文件中的实际指令和函数定义。</li>
<li>分配时机：程序代码区的分配同样发生在程序启动时，即当程序被加载到内存中时。</li>
<li>分配者：操作系统根据可执行文件中的代码段来分配内存，并将程序代码加载到这一段内存中。</li>
</ul>
</li>
</ol>
<h3 id="JVM、ART、DVM-的区别"><a href="#JVM、ART、DVM-的区别" class="headerlink" title="JVM、ART、DVM 的区别"></a>JVM、ART、DVM 的区别</h3><p>Java虚拟机（JVM）和Android虚拟机（如Dalvik虚拟机和Android Runtime，ART）都是为了运行基于Java语言编写的程序而设计的，但它们在设计理念、架构和运行环境上存在一些关键区别：</p>
<h4 id="功能原理："><a href="#功能原理：" class="headerlink" title="功能原理："></a>功能原理：</h4><p><strong>JVM</strong>：</p>
<p>我们写的java文件,经过编译生成.class文件,然后经过java虚拟机类加载 就成了.class类,也就是我们运行时访问的XXX.class类。JVM底层会将字节码转换为机器码,然后运行在CPU内.也可以这么理解:<strong>JVM就是个转换器,他将我们写的代码转换为CPU可以识别的代码,然后运行在CPU内</strong>。</p>
<p>或者说: JVM将CPU可以识别的代码,翻译成我们认识的java代码,让我们来写,我们写完后,它再负责翻译回去,让CPU执行。不同平台有不同的JVM,所以我们写一套代码,就能转换成不同平台的机器码,也就可以运行在不同平台上,这就是java跨平台的原理.</p>
<p><strong>DVM</strong>：</p>
<p>在app启动后,我们执行到对应功能的时候,就将这部分功能对应的代码 转换为 机器码,保存起来然后执行,可以理解为:<strong>用到才转换,所以也被称为JIT(just in time)</strong>.</p>
<p>优点：节省内存</p>
<p>缺点：执行速度慢</p>
<p><strong>ART</strong>：</p>
<p>主要有两个改善的地方.</p>
<ul>
<li><p>1 将转换为机器码的过程提前到了安装apk的时候.</p>
</li>
<li><p>2 内存分配方式和垃圾回收机制做了极大的优化.</p>
<p>DVM是基于JIT实现的,也就是边编译边执行,在运行到对应功能的时候,才将代码转换为机器码,然后交给CPU去执行.</p>
<p>而ART则不然,ART是在app安装的时候,就提前将所有代码转换为机器码保存下来,等到执行的时候,直接取出来在CPU中执行,也就是说,<strong>ART将转换为机器码这件事提前了. 所以叫做AOT(ahead of time)</strong>.</p>
</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>JVM</strong>：</p>
<ul>
<li>基于堆栈，每个线程都有自己的方法调用栈，栈帧中存储局部变量和操作数。</li>
<li>运行标准Java字节码，通常以<code>.class</code>文件的形式存在。</li>
<li>可在多种操作系统上运行，是跨平台的。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li><p>Dalvik有自己的字节码，不使用Java字节码</p>
</li>
<li><p>基于寄存器，更适合于资源受限的系统，如移动设备。</p>
</li>
<li><p>执行专为Dalvik设计的.dex格式文件，这是一种紧凑、针对Dalvik优化的字节码格式。</p>
</li>
<li><p>ART通过预编译（AOT编译）将应用程序转换为本机代码，从而提高性能。Dalvik采用的是JIT即时编译技术。</p>
</li>
<li><p>专门为Android系统设计，不是通用的跨平台解决方案。</p>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>JVM</strong>：</p>
<ul>
<li>采用即时编译（JIT）技术，在程序运行时将字节码编译成本地代码，实现性能优化。</li>
<li>服务器和桌面环境中的JVM会进行大量的性能优化以提高吞吐量和减少延迟。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li>Dalvik使用JIT编译，但受限于移动设备的性能和电池寿命的限制。</li>
<li>ART使用AOT编译，应用程序在安装时就被编译成本地代码，并在运行时进行JIT编译优Java虚拟机（JVM）和Android虚拟机（主要是指Dalvik虚拟机和Android运行时ART）都是为了在不同的硬件和操作系统平台上运行编译后的代码而设计的，但它们在设计哲学、实现方式和优化目标上有所不同。</li>
</ul>
<p>以下是JVM和Android虚拟机（Dalvik和ART）的一些主要区别：</p>
<h4 id="目标平台："><a href="#目标平台：" class="headerlink" title="目标平台："></a>目标平台：</h4><ul>
<li><strong>JVM</strong>：设计用于运行跨平台的Java应用程序，通常安装在个人电脑、服务器和大型系统上。</li>
<li><strong>Android虚拟机</strong>：专门为低功耗、有限内存的移动设备设计。</li>
</ul>
<h4 id="执行代码格式："><a href="#执行代码格式：" class="headerlink" title="执行代码格式："></a>执行代码格式：</h4><ul>
<li><strong>JVM</strong>：执行Java字节码，通常是<code>.class</code>文件或<code>.jar</code>文件中的代码。</li>
<li><strong>Dalvik</strong>：执行为Android优化的Dex（Dalvik Executable）格式代码。</li>
<li><strong>ART</strong>：虽然也支持Dex格式，但在应用安装时会将Dex编译成系统特定的本地机器码。</li>
</ul>
<h4 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h4><ul>
<li><strong>JVM</strong>：主要使用即时编译（JIT），应用程序在运行时编译成本地代码。</li>
<li><strong>Dalvik</strong>：使用解释执行，但也有JIT编译提高性能。</li>
<li><strong>ART</strong>：使用预先编译（AOT），在安装时将应用编译成本地代码，以及在运行时通过JIT进行优化。</li>
</ul>
<h4 id="垃圾回收（GC）："><a href="#垃圾回收（GC）：" class="headerlink" title="垃圾回收（GC）："></a>垃圾回收（GC）：</h4><ul>
<li><strong>JVM</strong>：提供多种垃圾回收器，可根据应用需求选择（如G1、CMS、Parallel等）。</li>
<li><strong>Dalvik</strong>：使用一个简单的GC机制，适合内存有限的设备。</li>
<li><strong>ART</strong>：提供改进的GC机制，包括分代垃圾回收和并发垃圾回收，以减少应用暂停时间。</li>
</ul>
<h4 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h4><ul>
<li><strong>JVM</strong>：在服务器和桌面环境中，性能优化侧重于最大化吞吐量和减少GC暂停时间。</li>
<li><strong>Android虚拟机</strong>：在移动设备上，优化侧重于启动速度，运行效率和响应速度，以及减少内存使用。</li>
</ul>
<h4 id="开发和分发模型："><a href="#开发和分发模型：" class="headerlink" title="开发和分发模型："></a>开发和分发模型：</h4><ul>
<li><strong>JVM</strong>：通常用于开发通用Java应用程序，可以在任何安装了兼容JVM的系统上运行。</li>
<li><strong>Android虚拟机</strong>：用于开发Android应用程序，这些应用程序通过Google Play商店或其他方式分发给Android用户。</li>
</ul>
<p>综上所述，JVM和Android虚拟机虽然都是虚拟机，但是它们在设计上是为了满足不同平台和需求而优化的。JVM更加通用和多功能，而Android虚拟机则是专门为移动设备和Android操作系统优化。</p>
<h3 id="ART-Java-堆组成"><a href="#ART-Java-堆组成" class="headerlink" title="ART Java 堆组成"></a>ART Java 堆组成</h3><p>当 Android 虚拟机启动时，便会创建 Java 堆，后续所有 Java 对象所需要的内存都会从这个堆中分配，所以我们先来说说 Java 堆的组成。Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace</strong>：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。Java 堆的空间是有限的，加起来只有 512M；</p>
<h3 id="Java对象内存申请"><a href="#Java对象内存申请" class="headerlink" title="Java对象内存申请"></a>Java对象内存申请</h3><p>Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<h3 id="Java对象内存释放"><a href="#Java对象内存释放" class="headerlink" title="Java对象内存释放"></a>Java对象内存释放</h3><p>在 Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC。</p>
<p>对于 ART 虚拟机的垃圾回收器来说，<strong>是通过可达性分析来判断一个对象是否可以被回收</strong>。<strong>GarbageCollector</strong> 会对 <strong>space</strong> 中的每一个对象的引用链进行分析，如果这个对象的引用链最终被 <strong>GC Root</strong> 持有，就说明这个对象不可回收。否则，就可以回收。如下图所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们没有被 GC Roots 持有， 因此会被判定为可回收的对象。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9297dd5668e34c8e97422a9dc4ad4f58%7Etplv-k3u1fbpfcp-jj-mark%3A1512%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>GC Root 有下面几项：</p>
<ol>
<li>栈中引⽤的对象：比如应用中主线程的 Handler，它是不会退出的，如果在 Handler 中持有了一个对象，那么这个对象就是被主线程栈所引用的对象，属于 GC Root 可达。这样一来，在 GarbageCollector 执行 GC 时就不会释放这个对象。</li>
<li>静态变量、常量引⽤的对象：被静态变量应用的对象也是属于 GC Root 可达，只有我们手动置为 null 才能释放这个对象。</li>
<li>本地⽅法栈 Native ⽅法引⽤的对象：通过 JNI 调用，传递到 Native 层并被 Native 的函数引用的对象。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>通过上面对 Java 堆的原理的讲解，我们了解了这 2 个知识点：</p>
<ol>
<li>Java 堆的空间是有限的，加起来只有 512M；</li>
<li>只有在切断 Java 对象和 GC Root 的关联后，虚拟机的 GC 机制才会回收该对象。</li>
</ol>
<p>基于这 2 个底层的知识点，我们就可以总结出 Java 堆内存优化的 3 条方法论：</p>
<ol>
<li><strong>减少加载进程</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>及时清理加载进</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>增加</strong> <strong>Java</strong> <strong>堆空间可用大小</strong></li>
</ol>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><ul>
<li>通过new分配新对象时，堆中剩余空间不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>到达阈值</li>
<li>手动调用系统API System.gc()时，会产生一次GC动作。</li>
<li>系统空闲。这个空闲判断条件也很多，比如进到后台，或者消息队列没数据等等。 后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。</li>
<li>启动时候出现gc，主要还是在于内存压力，到达一定的压力水位，就会触发GC</li>
</ul>
<p>C有不同的程度的，内存不足的时候的GC是最深度的，对性能影响也最大。达到不同的预测，GC的程度不一样，刚到达阈值的时候，可能就只是轻度的GC，轻度的就是标记清除，中度的就是复制拷贝回收。</p>
<h3 id="Java堆内存的获取"><a href="#Java堆内存的获取" class="headerlink" title="Java堆内存的获取"></a>Java堆内存的获取</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">loge(<span class="string">&quot;JVM试图使用的最大内存量，即应用程序可以使用的最大堆内存 ：<span class="subst">$&#123;Runtime.getRuntime().maxMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM当前已经从系统获取的内存量，包括已使用的内存和未使用的内存  ：<span class="subst">$&#123;Runtime.getRuntime().totalMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM中未使用的内存量  ：<span class="subst">$&#123;Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM的最大内存减去当前已经被使用的内存，得出的结果是应用程序还可以继续使用的内存量: <span class="subst">$&#123;Runtime.getRuntime().maxMemory() - Runtime.getRuntime().totalMemory() + Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="OOM产生"><a href="#OOM产生" class="headerlink" title="OOM产生"></a>OOM产生</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::IsOutOfMemoryOnAllocation</span><span class="params">([[maybe_unused]] AllocatorType allocator_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">size_t</span> alloc_size, <span class="comment">// 请求分配的内存大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> grow)</span> </span>&#123;  <span class="comment">// 是否允许内存增长 </span></span><br><span class="line">  <span class="type">size_t</span> old_target = target_footprint_.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 获取当前目标内存占用</span></span><br><span class="line">  <span class="comment">// 无限循环，计算新内存占用</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_allocated = num_bytes_allocated_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 在当前已分配的内存基础上增加了新请求分配的内存。</span></span><br><span class="line">    <span class="type">size_t</span> new_footprint = old_allocated + alloc_size;</span><br><span class="line">    <span class="comment">// 判断新占用是否超过限制。UNLIKELY提示编译器该条件发生概率低</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &lt;= old_target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// growth_limit_ ：堆内存的最大值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &gt; growth_limit_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>old_target</code> 相当于是一个可以变动的内存占用警戒线，而 <code>growth_limit_</code> 是不可超越的最大内存使用边界。如果内存使用超出了 <code>old_target</code> 但未到 <code>growth_limit_</code>，程序可能还有一定的弹性空间来调整内存使用；但是一旦超出 <code>growth_limit_</code>，则通常没有余地。</p>
<h3 id="OOM产生路径"><a href="#OOM产生路径" class="headerlink" title="OOM产生路径"></a>OOM产生路径</h3><p><a href="https://juejin.cn/post/7240636469462597690#heading-2">https://juejin.cn/post/7240636469462597690#heading-2</a></p>
<h3 id="ART-GC历史"><a href="#ART-GC历史" class="headerlink" title="ART GC历史"></a>ART GC历史</h3><h4 id="Dalvik-GC-（直到Android-4-4-KitKat）"><a href="#Dalvik-GC-（直到Android-4-4-KitKat）" class="headerlink" title="Dalvik GC （直到Android 4.4 KitKat）"></a>Dalvik GC （直到Android 4.4 KitKat）</h4><ul>
<li>初始的Dalvik虚拟机采用的是“标记-清除”（Mark-Sweep）算法。</li>
<li>在必要时执行“Stop-the-World”（STW）垃圾回收，这意味着所有工作线程都必须暂停，直到垃圾回收过程完成。</li>
</ul>
<h4 id="ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）"><a href="#ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）" class="headerlink" title="ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:"></a>ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:</h4><ul>
<li>引入了“分代GC”（Generational GC），它对对象按照存活时间进行分类，短暂对象和长期对象分别管理，以提高效率。</li>
<li>引入了预编译技术，改善了垃圾回收的性能。</li>
</ul>
<h4 id="ART-GC-（Android-6-0-Nougat）"><a href="#ART-GC-（Android-6-0-Nougat）" class="headerlink" title="ART GC （Android 6.0 Nougat）:"></a>ART GC （Android 6.0 Nougat）:</h4><ul>
<li>ART&#x2F;Dalvik Android团队使用汇编语言重写了整个对象分配过程，进一步提高了效率和性能。</li>
</ul>
<h4 id="ART-GC-（Android-8-0-9-0）"><a href="#ART-GC-（Android-8-0-9-0）" class="headerlink" title="ART GC （Android 8.0 ~ 9.0）:"></a>ART GC （Android 8.0 ~ 9.0）:</h4><ul>
<li>引入了“并发复制GC”（Concurrent Copying GC），为CMS（Concurrent Mark-Sweep）的改进版本，减少了应用的暂停时间。</li>
</ul>
<h4 id="ART-GC-（Android-10开始）"><a href="#ART-GC-（Android-10开始）" class="headerlink" title="ART GC （Android 10开始）:"></a>ART GC （Android 10开始）:</h4><ul>
<li>重新引入了“分代GC”，并作为“并发复制GC”的一个扩展，进一步优化内存管理和减少暂停时间</li>
</ul>
<p>在 Generational CC 中，堆内存并没有显式地划分为不同的代，而是在运行时 把不同的 region 标记为新生代或者老年代；</p>
<p>下面是JVM对用户空间的划分</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/3a21f3fd821143708a0ea69ca309bad1%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="在这里插入图片描述"></p>
<p>Android虚拟机将堆内存同样分为三个区域：<strong>年轻代，年老代，永久代</strong>，针对年轻代和老年代，ART和Dalvik又做了细分。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/5b4db7c314164ebab2619e5e7efc27e7%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0-20231228163627586.awebp" alt="在这里插入图片描述"></p>
<p><strong>ZygoteSpace：Zygote进程启动过程中创建的所有对象。这些对象是所有进程共享</strong></p>
<p><strong>ImageSpcace：存放预加载的类，Android Framework中通用的类都都是存储在这里</strong></p>
<p><strong>LargeObj Space：存放大于12k的类对象的空间</strong></p>
<p><strong>Main Allooc Space：存放小对象的空间</strong></p>
<p><strong>Non Moving Space&#x2F;Linear Alloc：只读的线性内存空间，主要用来存储虚拟机中在进程生命周期都不会结束清理的永久数据的类对象。</strong></p>
<p>ZygoteSpace和ImageSpace存放共享的预加载的类，这样可以提高启动速度，还有根据对象的大小和特性划分LargeObjSpace，AllocSpace和Non Moving Space可以采用不同的垃圾回收策略，提高gc的效率和性能。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1*bsfQgcHVbxeFsXOGv5onPA-20231228165437394.png" alt="img"></p>
<h3 id="Android中的GC"><a href="#Android中的GC" class="headerlink" title="Android中的GC"></a>Android中的GC</h3><p>Android中的GC是通过<strong>HeapTaskDaemon</strong>线程来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapTaskDaemon</span> <span class="keyword">extends</span> <span class="title class_">Daemon</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式，内部类中创建该类的唯一实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HeapTaskDaemon</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapTaskDaemon</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，设置守护线程的线程名为 &quot;HeapTaskDaemon&quot;。</span></span><br><span class="line">    HeapTaskDaemon() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;HeapTaskDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，用于中断指定的线程。</span></span><br><span class="line">    <span class="comment">// 这个方法会通知 VMRuntime 停止堆任务处理器。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        VMRuntime.getRuntime().stopHeapTaskProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程的核心执行方法。</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，确保线程安全。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果守护线程正在运行，则通知 VMRuntime 启动堆任务处理器。</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line">              VMRuntime.getRuntime().startHeapTaskProcessor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行堆任务。</span></span><br><span class="line">        <span class="comment">// 这个方法可能会执行垃圾收集（GC）或其他与堆管理相关的任务。</span></span><br><span class="line">        VMRuntime.getRuntime().runHeapTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapTaskDaemon 是一个守护线程（程序运行时在后台提供一种通用服务的线程），随着 Zygote 进程启动便会启动，该线程的 run 方法也比较简单，就是执行 runInternal 这个抽象函数，该抽象函数的实现方法中会执行 VMRuntime.getRuntime().runHeapTasks() 方法，runHeapTasks() 函数会执行 RunAllTasks 这个 Native 函数，它位于 <a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/task_processor.cc">task_processor.cc</a> 这个类中。</p>
<p>通过源码一路跟踪下来，可以看到 HeapTaskDaemon 线程的 run 方法中真正做的事情，实际只是在无限循环的调用 GetTask 函数获取 HeapTask 并执行。GetTask 中会不断从 tasks 集合中取出 HeapTask 来执行，并且对于需要延时的 HeapTask ，会阻塞到目标时间。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155739553.png" alt="image-20231229155739553"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155809976.png" alt="image-20231229155809976"></p>
<h3 id="GC导致应用程序卡顿"><a href="#GC导致应用程序卡顿" class="headerlink" title="GC导致应用程序卡顿"></a>GC导致应用程序卡顿</h3><p>GC导致了用户线程的停止，这个机制叫做STW，为了防止出现 GC开始时对象没引用被标记为垃圾，GC过程中对象又被引用这种情况。</p>
<p>回收策略：分代回收 分区回收</p>
<p>垃圾检测算法：引用计数 可达性分析</p>
<p>回收算法：标记复制 标记清除  标记整理</p>
<h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p><strong>标记清除</strong>：</p>
<ul>
<li><p>Mark阶段（标记阶段）：搜索内存中的Java对象（对ART虚拟机而言，就是遍历mirror Object对象），对那些能搜到的对象进行标记。</p>
</li>
<li><p>Sweep阶段（清除阶段）：释放那些没有被标记的对象所占据的内存。</p>
<p>整个过程需要将整个程序暂停，清除完成之后才恢复程序运行，而且这个算法会带来碎片化的问题。</p>
</li>
</ul>
<p><strong>复制算法</strong>：复制算法会将存活的对象复制到一块内存，然后将遗留下来的对象进行清理，这种算法不会产生碎片问题，但是会占用更多的内存，因为要一块空间来复制存活的对象。 年轻代</p>
<p><strong>标记整理</strong>：先从根节点标记哪些是被对象引用的。第二阶段将所有存活的对象压缩移动到内存的另一端，按顺序排放，最后清除所有边界以外的空间。 老年代</p>
<p><strong>分代算法</strong>：分代垃圾回收算法（Generational Garbage Collection）是基于对象生命周期不同的假设来进行垃圾回收的策略。它把对象分为几个“代”，通常至少分为两代：年轻代（Young Generation）和老年代（Old Generation）。</p>
<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><ul>
<li>局部变量表：正在执丸行的函数的参数、临时变量，临时值</li>
<li>方法区中的静态变量：如类的静态变量</li>
<li>方法区中的常量池：如常量池中的常量引用实例</li>
<li>本地方法栈中的变量：NI调用Native方法所引用的实例</li>
<li>同步锁持有的对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Android 面试题</title>
    <url>/2024/03/08/Android%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="Fragment生命周期"><a href="#Fragment生命周期" class="headerlink" title="Fragment生命周期?"></a>Fragment生命周期?</h4><ol>
<li>**onAttach()**：当 Fragment 与 Activity 关联时调用。在这个方法中，你可以获取到 Activity 的引用，因此可以与 Activity 交互。</li>
<li>**onCreate()**：创建 Fragment 时调用。在这里，你可以初始化对 Fragment 生命周期而言重要的组件，这些组件在 Fragment 停止时不需要被清除。</li>
<li>**onCreateView()**：创建 Fragment 的视图层次结构时调用。这是用于为 Fragment 绘制 UI 的地方。</li>
<li>**onViewCreated()**：在 onCreateView() 之后立即调用，表示所有的视图已经被创建完成。这个方法是一个好地方来执行与视图相关的初始化操作，以及访问 Activity 的初始化组件。</li>
<li>**onStart()**：当 Fragment 对用户可见时调用。这与 Activity 的 onStart() 方法类似。</li>
<li>**onResume()**：当 Fragment 处于活动状态并且可以与用户交互时调用。这与 Activity 的 onResume() 方法类似。</li>
<li>**onPause()**：当 Fragment 不再与用户交互时调用。这与 Activity 的 onPause() 方法类似。</li>
<li>**onStop()**：当 Fragment 对用户不再可见时调用。这与 Activity 的 onStop() 方法类似。</li>
<li>**onDestroyView()**：当 Fragment 的视图层次结构被移除时调用。这是清理与视图相关的资源的好地方。</li>
<li>**onDestroy()**：销毁 Fragment 时调用。在这里，你可以清理所有与 Fragment 相关的资源。</li>
<li>**onDetach()**：当 Fragment 与 Activity 解除关联时调用。在这里，你应该清理对 Activity 的所有引用。</li>
</ol>
<h4 id="Fragment怎么主动回收"><a href="#Fragment怎么主动回收" class="headerlink" title="Fragment怎么主动回收?"></a>Fragment怎么主动回收?</h4><p>​		Fragment 的回收通常是由系统管理的,要想主动回收可以使用以下方式：</p>
<p>remove掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().remove(fragment).commit();</span><br></pre></td></tr></table></figure>

<p>replace掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().replace(R.id.container, newFragment).commit();</span><br></pre></td></tr></table></figure>

<p>Detach掉</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">fragmentManager.beginTransaction()</span><br><span class="line">    .detach(fragment)</span><br><span class="line">    .commit()</span><br></pre></td></tr></table></figure>

<p>加入回退栈，然后返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction().replace(R.id.container, newFragment).addToBackStack(<span class="literal">null</span>).commit();</span><br></pre></td></tr></table></figure>

<h4 id="Fragment-onDestory之后还会内存泄露吗"><a href="#Fragment-onDestory之后还会内存泄露吗" class="headerlink" title="Fragment onDestory之后还会内存泄露吗"></a>Fragment onDestory之后还会内存泄露吗</h4><p>如果被其他长生命周期的对象持有的话，还是会有内存泄漏。</p>
<p>比如，被静态对象引用，Fragment 内部正在做网络请求， Fragment 注册了某些监听器或回调（handler）等。</p>
<h4 id="Fragment切换是用Add吗？-add与replace的区别"><a href="#Fragment切换是用Add吗？-add与replace的区别" class="headerlink" title="Fragment切换是用Add吗？ add与replace的区别"></a>Fragment切换是用Add吗？ add与replace的区别</h4><p><strong>add 方法</strong></p>
<ul>
<li><code>add</code> 方法用于将一个 Fragment 添加到 Activity 的视图容器中。</li>
<li>如果你使用 <code>add</code> 方法添加多个 Fragment，它们会层叠在一起，最后添加的 Fragment 会显示在最上面。</li>
<li>使用 <code>add</code> 方法时，之前添加的 Fragment 不会被销毁，它们的视图层次结构仍然保留，只是不可见。因此，这可能会导致资源浪费，尤其是当有很多 Fragment 叠加时。</li>
</ul>
<p><strong>replace 方法</strong></p>
<ul>
<li><code>replace</code> 方法用于替换容器中的 Fragment。</li>
<li>使用 <code>replace</code> 方法时，容器中先前的 Fragment 会被销毁，它的视图层次结构也会被移除。</li>
<li><code>replace</code> 方法更适合用于切换 Fragment，因为它可以有效地管理 Fragment 的生命周期和资源</li>
</ul>
<h4 id="Fragment与Fragment之间通信方式"><a href="#Fragment与Fragment之间通信方式" class="headerlink" title="Fragment与Fragment之间通信方式"></a>Fragment与Fragment之间通信方式</h4><p>1.通过ViewModel</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> message: MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过Fragment Result的API传递数据</p>
<p>​	为了从FragmentB向FragmentA传递数据，首先给fragmentA设置监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    getParentFragmentManager().setFragmentResultListener(<span class="string">&quot;key&quot;</span>, <span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">FragmentResultListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFragmentResult</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Bundle bundle)</span> &#123;</span><br><span class="line">            <span class="comment">// 这里使用的是String，但是任何其他能够被放在Bundle中的数据类型都是支持的</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;bundleKey&quot;</span>);</span><br><span class="line">            <span class="comment">//做一些其他事情</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	在FragmentB中，生产结果，需要注意的是，FragmentB必须使用和FragmentA一样的FragmentManager，使用相同的<code>requestKey</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        result.putString(<span class="string">&quot;bundleKey&quot;</span>, <span class="string">&quot;result&quot;</span>);</span><br><span class="line">        getParentFragmentManager().setFragmentResult(<span class="string">&quot;requestKey&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​	一旦FragmentA处于<code>STARTED</code>状态，它将会接受到结果并且执行监听回调。</p>
<ol start="3">
<li>使用事件总线EventBus</li>
<li>通过 Activity 作为中介</li>
</ol>
<p>​	这种在发送消息的activity中会持有Activity的引用，需要及时的取消。</p>
<ul>
<li><p>定义一个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OnMessageSendListener</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMessageSend</span><span class="params">(message: <span class="type">String</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让 Activity 实现这个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(), OnMessageSendListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMessageSend</span><span class="params">(message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 通过 FragmentManager 找到接收消息的 Fragment，并调用其方法</span></span><br><span class="line">        <span class="keyword">val</span> fragmentB = supportFragmentManager.findFragmentById(R.id.fragmentB) <span class="keyword">as</span> FragmentB</span><br><span class="line">        fragmentB.updateMessage(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Android9-0版本有哪些大的改动"><a href="#Android9-0版本有哪些大的改动" class="headerlink" title="Android9.0版本有哪些大的改动"></a>Android9.0版本有哪些大的改动</h4><ol>
<li><p>Android 9默认情况下对所有应用启用了HTTPS的强制使用。这意味着，如果应用试图通过HTTP（而不是HTTPS）发送网络请求，那么这些请求将会被默认阻止，除非应用明确地在其网络安全配置中允许HTTP流量。</p>
</li>
<li><p>在9.0 中，不能直接非 <code>Activity</code> 环境中（比如<code>Service</code>，<code>Application</code>）启动 <code>Activity</code>这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标志FLAG_ACTIVITY_NEW_TASK</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, TestActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="权限更改是在哪个版本改的？存储是在哪个版本改的？"><a href="#权限更改是在哪个版本改的？存储是在哪个版本改的？" class="headerlink" title="权限更改是在哪个版本改的？存储是在哪个版本改的？"></a>权限更改是在哪个版本改的？存储是在哪个版本改的？</h4><ol>
<li><p><strong>动态权限管理（Android 6.0，API 23）：</strong>Android在6.0版本开始引入了动态权限管理，用户可以在运行时授予或拒绝应用的权限，而不是在安装应用时一次性授予所有权限。</p>
</li>
<li><p><strong>分区存储（Android 10，API 29）</strong>：Android 10引入了分区存储，在这个模型中，应用默认只能访问自己的沙盒目录，对于公共目录的访问需要用户在运行时授予权限。requestLegacyExternalStorage标签可以暂时关闭Android10的强制分区存储。</p>
</li>
<li><p><strong>多媒体文件访问（Android 11，API 30）：</strong>Android11 可以使用直接路径访问多媒体文件，文件保存目录还是遵守沙盒机制，只能访问自己的沙盒目录，且requestLegacyExternalStorage标签失效。</p>
</li>
</ol>
<h4 id="你认为作为一个Android开发应该具备哪些能力，素质"><a href="#你认为作为一个Android开发应该具备哪些能力，素质" class="headerlink" title="你认为作为一个Android开发应该具备哪些能力，素质"></a>你认为作为一个Android开发应该具备哪些能力，素质</h4><p>代码质量，架构设计，业务的理解，技术的掌握，新技术的探索</p>
<h4 id="你认为在Android领域精进，应该再掌握哪些技能"><a href="#你认为在Android领域精进，应该再掌握哪些技能" class="headerlink" title="你认为在Android领域精进，应该再掌握哪些技能"></a>你认为在Android领域精进，应该再掌握哪些技能</h4><p>设计模式，架构的理解，技术宽度。</p>
<h4 id="compose与原生View的区别，优点和缺点"><a href="#compose与原生View的区别，优点和缺点" class="headerlink" title="compose与原生View的区别，优点和缺点"></a>compose与原生View的区别，优点和缺点</h4><p><a href="https://blog.csdn.net/weixin_37438128/article/details/130390554">https://blog.csdn.net/weixin_37438128/article/details/130390554</a></p>
<h4 id="显示Intent和隐式Intent区别"><a href="#显示Intent和隐式Intent区别" class="headerlink" title="显示Intent和隐式Intent区别"></a>显示Intent和隐式Intent区别</h4><p>显示 Intent 是直接指定要启动的 Activity 的一种方式。显示 Intent 的构造方法通常如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, SecondActivity.class);</span><br></pre></td></tr></table></figure>

<p>隐式 Intent</p>
<p>隐式 Intent 是通过 Intent Filter 来指定要启动的 Activity 的一种方式。在清单文件中注册指定 Activity 的 action、data 和 category 等属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--取别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.test.ACTION_START&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>隐式 Intent 的构造方法通常如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(Intent.ACTION_VIEW);</span><br><span class="line">intent.setData(Uri.parse(<span class="string">&quot;http://www.baidu.com&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上述 Intent 会启动所有具有 Intent Filter 中指定 action 和 data 属性的 Activity。</p>
<h4 id="隐式Intent还有什么作用"><a href="#隐式Intent还有什么作用" class="headerlink" title="隐式Intent还有什么作用"></a>隐式Intent还有什么作用</h4><ol>
<li><strong>数据分享</strong>：可以通过隐式 Intent 将数据分享给其他应用。例如，可以使用隐式 Intent 将图片分享到社交媒体应用。</li>
<li><strong>系统功能调用</strong>：可以使用隐式 Intent 调用系统功能。例如，可以使用隐式 Intent 拨打电话、发送短信、打开地图等。</li>
<li><strong>应用间通信</strong>：可以使用隐式 Intent 实现应用间通信。例如，可以使用隐式 Intent 让用户在一个应用中选择另一个应用的某个功能</li>
</ol>
<h4 id="启动Service有几种方式，区别"><a href="#启动Service有几种方式，区别" class="headerlink" title="启动Service有几种方式，区别"></a>启动Service有几种方式，区别</h4><p>Android 中启动 Service 有两种方式：</p>
<ul>
<li><strong>startService()</strong></li>
<li><strong>bindService()</strong></li>
</ul>
<p><strong>startService()</strong> 方法用于启动一个 Service，该 Service 会一直运行在后台，直到被手动停止或系统内存不足而被杀死。<strong>startService()</strong> 方法会调用 Service 的 <strong>onCreate()<strong>、</strong>onStartCommand()</strong> 和 <strong>onDestroy()</strong> 方法。</p>
<p><strong>bindService()</strong> 方法用于启动一个 Service，该 Service 可以与客户端进行通信。<strong>bindService()</strong> 方法会调用 Service 的 <strong>onCreate()<strong>、</strong>onBind()<strong>、</strong>onUnbind()</strong> 和 <strong>onDestroy()</strong> 方法。</p>
<p><strong>两种方式的区别</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">startService()</th>
<th align="left">bindService()</th>
</tr>
</thead>
<tbody><tr>
<td align="left">作用</td>
<td align="left">启动一个后台 Service</td>
<td align="left">启动一个可进行通信的 Service</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td align="left">onCreate()、onStartCommand()、onDestroy()</td>
<td align="left">onCreate()、onBind()、onUnbind()、onDestroy()</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">用于执行后台任务，例如音乐播放、下载等</td>
<td align="left">用于执行需要与客户端进行通信的任务，例如数据库访问、网络通信等</td>
</tr>
</tbody></table>
<p>drive_spreadsheet导出到 Google 表格</p>
<p><strong>示例</strong></p>
<p><strong>startService() 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行后台任务</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Service.START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Activity 中启动 Service</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>

<p><strong>bindService() 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回 IBinder 对象，用于客户端与 Service 进行通信</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Activity 中绑定 Service</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line">bindService(intent, connection, BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Activity 中与 Service 进行通信</span></span><br><span class="line">MyService.<span class="type">MyBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (MyService.MyBinder) connection.getBinder();</span><br><span class="line">binder.doSomething();</span><br></pre></td></tr></table></figure>

<h4 id="startService后生命周期的回调，有什么区别"><a href="#startService后生命周期的回调，有什么区别" class="headerlink" title="startService后生命周期的回调，有什么区别"></a>startService后生命周期的回调，有什么区别</h4><ul>
<li><strong>onCreate()</strong> 方法是在 Service 第一次创建时调用的，用于初始化 Service 的状态。</li>
<li><strong>onStartCommand()</strong> 方法是在 Service 启动时调用的，用于执行 Service 的后台任务。</li>
<li><strong>onDestroy()</strong> 方法是在 Service 被销毁时调用的，用于释放 Service 的资源。</li>
</ul>
<h4 id="bindService-方法绑定一个-Service-时"><a href="#bindService-方法绑定一个-Service-时" class="headerlink" title="bindService() 方法绑定一个 Service 时"></a><code>bindService()</code> 方法绑定一个 Service 时</h4><p><strong>onCreate()</strong> 方法和 <code>startService()</code> 后调用的方式相同。</p>
<p><strong>onBind()</strong> 方法是在 Service 与客户端建立连接时调用的，用于返回一个 <code>IBinder</code> 对象，用于客户端与 Service 进行通信。</p>
<p><strong>onUnbind()</strong> 方法是在 Service 与客户端断开连接时调用的，用于释放 Service 与客户端通信的资源。</p>
<p><strong>onDestroy()</strong> 方法和 <code>startService()</code> 后调用的方式相同。</p>
<p><strong>区别</strong></p>
<p><code>startService()</code> 和 <code>bindService()</code> 后生命周期的回调主要有以下区别：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">startService()</th>
<th align="left">bindService()</th>
</tr>
</thead>
<tbody><tr>
<td align="left">调用时机</td>
<td align="left">启动 Service</td>
<td align="left">绑定 Service</td>
</tr>
<tr>
<td align="left">回调次数</td>
<td align="left">一次</td>
<td align="left">多次</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">无</td>
<td align="left"><code>IBinder</code> 对象</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">执行后台任务</td>
<td align="left">执行需要与客户端进行通信的任务</td>
</tr>
</tbody></table>
<h4 id="canvas跟Paint的区别，以及作用？"><a href="#canvas跟Paint的区别，以及作用？" class="headerlink" title="canvas跟Paint的区别，以及作用？"></a><strong>canvas跟Paint的区别，以及作用？</strong></h4><ul>
<li><p><strong>Canvas</strong> 是 Android 绘图的画布，它提供了绘制图形、文本和位图的方法。Canvas 通常与 View 的 <code>onDraw</code> 方法一起使用，用于自定义绘制 View 的内容。屏幕显示与 Canvas 根本不是一个概念！ Canvas 是一个很虚幻的概念，相当于一个透明图层。每次在 Canvas 上画图时 （调用 draw:XXX 系列函 数），都会先产生一个透明图层，然后在这个图层上画图，画完之后覆盖在屏幕上显示。</p>
<p>在调用 canvas.drawRect(rectl , paint_green）；时， 产生一个 Canvas 透明图层，由于当时还没有对坐标系进行平移，所以坐标原点是（0, 0） ；在 Canvas 上画好之后，覆盖到屏幕上显示出来。</p>
<p>在调用 canvas.drawRect(rectl, paint_red）；时，又会产生一个全新 的 Canvas 透明图层，</p>
<blockquote>
<p>(1）当每次调用 draw:XXX 系列函数来绘图时，都会产生一个全新的 Canvas 透明图层 。</p>
<p>(2） 如果在调用 draw:XXX 系列函数前，调用平移、旋转等函数对 Canvas 进行了操作，那么这个操作是不可逆的 。每次产生的画布的最新位置都是这些操作后的位置 。</p>
<p>(3）在 Canvas 图层与屏幕合成时，超出屏幕范围的图像是不会显示出来的 。</p>
</blockquote>
</li>
<li><p><strong>Paint</strong> 是用于描述绘制属性的对象，它包括颜色、线条样式、字体等绘制信息。Paint 用于定义绘制的样式和效果，然后应用于 Canvas 上的绘制操作。</p>
</li>
</ul>
<h4 id="Service有多少种方法启动？"><a href="#Service有多少种方法启动？" class="headerlink" title="Service有多少种方法启动？"></a><strong>Service有多少种方法启动？</strong></h4><p>Service 可以通过以下两种方法启动：</p>
<ol>
<li><p>**startService()**：用于启动服务，服务将一直运行，直到被停止。</p>
</li>
<li><p>**bindService()**：用于绑定服务，允许组件与服务建立连接，但服务会在没有绑定的情况下停止。</p>
<ul>
<li><p><strong>这两种方式有什么区别？</strong></p>
<p>主要区别在于生命周期和通信方式：</p>
<ul>
<li>**startService()**：服务的生命周期独立于组件，无需绑定，可以长时间运行。通常用于执行后台任务。</li>
<li>**bindService()**：服务的生命周期与绑定的组件相关联，当绑定的组件销毁时，服务也会停止。用于与服务进行交互，获取数据等。</li>
</ul>
<h4 id="Service还有什么区别，除了生命周期的区别？"><a href="#Service还有什么区别，除了生命周期的区别？" class="headerlink" title="Service还有什么区别，除了生命周期的区别？"></a><strong>Service还有什么区别，除了生命周期的区别？</strong></h4><p>​	除了生命周期的区别，Service 还可以分为前台服务和普通服务。前台服务通常用于需要在通知栏显示通知的情况，以增加服务的优先级和可见性。</p>
</li>
</ul>
</li>
</ol>
<h4 id="看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"><a href="#看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？" class="headerlink" title="看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？"></a><strong>看到你还熟悉DalvikVM和ART，请问这两个虚拟机在哪个版本做的交替？</strong></h4><p>​		Dalvik VM 和 ART 之间的交替发生在 Android 5.0（Lollipop）版本。</p>
<ul>
<li><p><strong>那为什么要做这种交替呢？</strong></p>
<p>从 Dalvik VM 到 ART 的交替是为了改善 Android 应用程序的性能和效率。ART 使用预编译的方式运行应用程序，提供了更快的应用启动和更低的内存占用。</p>
</li>
</ul>
<h4 id="四大引用？"><a href="#四大引用？" class="headerlink" title="四大引用？"></a><strong>四大引用？</strong></h4><p>四种主要的引用类型是：</p>
<ol>
<li><strong>强引用（Strong Reference）</strong>：强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。</li>
<li><strong>软引用（Soft Reference）</strong>：软引用允许在内存不足时回收对象。垃圾回收器会根据内存需求来回收软引用对象。</li>
<li><strong>弱引用（Weak Reference）</strong>：弱引用更弱于软引用，只要没有强引用指向对象，垃圾回收器就可能回收它。</li>
<li><strong>虚引用（Phantom Reference）</strong>：虚引用是最弱的引用类型，它几乎没有直接作用，主要用于管理对象的生命周期。</li>
</ol>
<h4 id="什么情况下用虚引用、弱引用？"><a href="#什么情况下用虚引用、弱引用？" class="headerlink" title="什么情况下用虚引用、弱引用？"></a><strong>什么情况下用虚引用、弱引用？</strong></h4><ul>
<li><p><strong>虚引用</strong> 主要用于跟踪对象被垃圾回收的状态，通常与引用队列（ReferenceQueue）一起使用。当对象被垃圾回收时，会被放入引用队列中，用于执行一些清理操作。</p>
</li>
<li><p><strong>弱引用</strong> 通常用于缓存或缓存敏感数据，当内存不足时，垃圾回收器可能会回收被弱引用引用的对象，允许释放内存。</p>
</li>
<li><p><strong>什么是强引用？</strong></p>
<p>强引用是最普通的引用类型，如果一个对象具有强引用，垃圾回收器不会回收它，即使内存不足。强引用通常用于确保对象不会被提前回收。</p>
</li>
</ul>
<h4 id="APK瘦身你做过的有哪些？"><a href="#APK瘦身你做过的有哪些？" class="headerlink" title="APK瘦身你做过的有哪些？"></a><strong>APK瘦身你做过的有哪些？</strong></h4><p>APK瘦身是减少Android应用包的大小，常见的优化方法包括：</p>
<ol>
<li><strong>资源压缩和混淆</strong>：删除未使用的资源和代码，进行资源压缩和混淆处理。</li>
<li><strong>代码优化</strong>：检查和优化代码，减少冗余和不必要的库和依赖。</li>
<li><strong>图像压缩</strong>：使用工具对图像进行压缩和优化。</li>
<li><strong>延迟加载</strong>：将某些资源和模块延迟加载，只在需要时加载。</li>
<li><strong>分包</strong>：将应用分为多个模块，按需下载。</li>
<li><strong>动态化</strong>：将一些功能以插件或动态加载的方式提供，减少初始安装包的大小。</li>
</ol>
<h4 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h4><p>​		在Android开发中，<code>onNewIntent()</code>是一个生命周期方法，它在活动(Activity)的实例已经存在于任务栈中，且该活动的启动模式为<code>singleTop</code>、<code>singleTask</code>或<code>singleInstance</code>，并且通过Intent再次启动时，会被调用。</p>
<h4 id="每五秒发一个消息的实现方式"><a href="#每五秒发一个消息的实现方式" class="headerlink" title="每五秒发一个消息的实现方式"></a>每五秒发一个消息的实现方式</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>定时器</span><br><span class="line">    <span class="keyword">val</span> timer = Timer()</span><br><span class="line">    timer.schedule(MyTimerTask(), <span class="number">0</span>, <span class="number">5000</span>)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MyTimerTask</span> : <span class="type">TimerTask</span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>单线程池</span><br><span class="line"><span class="keyword">val</span> scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>)</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(</span><br><span class="line">            &#123; println(<span class="string">&quot;我爱你中国&quot;</span>) &#125;,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            TimeUnit.SECONDS</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Handler循环发送消息</span><br><span class="line"><span class="keyword">var</span> handler: Handler = <span class="keyword">object</span> : Handler(mainLooper) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            msg?.let &#123; <span class="keyword">super</span>.handleMessage(it) &#125;</span><br><span class="line">            println(<span class="string">&quot;我爱你中国&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.sendEmptyMessage(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        handler.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>协程作用域</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default)</span><br><span class="line">    scope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是你想要执行的代码，例如发送消息的逻辑</span></span><br><span class="line">            println(<span class="string">&quot;发送消息 - <span class="subst">$&#123;Date()&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">5000</span>) <span class="comment">// 暂停5秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止主线程退出</span></span><br><span class="line">    readLine()</span><br><span class="line">    <span class="comment">// 关闭协程作用域</span></span><br><span class="line">    scope.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="广播是安全的吗？"><a href="#广播是安全的吗？" class="headerlink" title="广播是安全的吗？"></a><strong>广播是安全的吗？</strong></h4><p>​		广播是 Android 中一种跨组件通信的方式，但它可以被其他应用程序接收。因此，广播不是完全安全的，需要小心处理敏感信息，可以使用权限来限制广播的接收范围。</p>
<h4 id="Android-中广播的种类"><a href="#Android-中广播的种类" class="headerlink" title="Android 中广播的种类"></a>Android 中广播的种类</h4><ol>
<li><strong>标准广播（Normal Broadcasts）</strong>：这是最常见的广播类型，它是一种完全异步执行的广播。在这种广播中，所有接收器都在同一时间接收到广播消息，但它们的执行顺序是不确定的。这种广播的效率较高，但不能被中断，也无法终止。</li>
<li><strong>有序广播（Ordered Broadcasts）</strong>：这种广播是同步执行的，接收器按照优先级（在 AndroidManifest.xml 中定义）依次接收到广播消息。一个接收器可以在接收到广播后终止它，这样后面优先级较低的接收器就不会收到这条广播消息。</li>
<li><strong>粘性广播（Sticky Broadcasts）</strong>：当发送一个粘性广播后，即使广播已经结束，这个广播的数据仍然会“粘”在系统中，这样后来注册的接收器也可以接收到这条广播的数据。但是，出于安全考虑，粘性广播的使用在新版 Android 中受到了限制。现版本中已经过时</li>
<li><strong>本地广播（Local Broadcasts）</strong>：使用 <code>LocalBroadcastManager</code> 发送的广播只能在应用程序的内部进行通信，不会被系统的其他部分或其他应用程序所接收。这种方式更加高效、安全，适用于不需要与系统或其他应用程序交互的场景。</li>
<li><strong>系统广播（System Broadcasts）</strong>：这些广播由系统发出，例如屏幕关闭、电池电量低、时间改变等。应用程序可以通过注册相应的接收器来监听这些系统事件。</li>
</ol>
<h4 id="必须用全局广播，但又不希望其他一部分app监听到？怎么办？"><a href="#必须用全局广播，但又不希望其他一部分app监听到？怎么办？" class="headerlink" title="必须用全局广播，但又不希望其他一部分app监听到？怎么办？"></a><strong>必须用全局广播，但又不希望其他一部分app监听到？怎么办？</strong></h4><p>使用权限限制广播接收者</p>
<p>​		可以定义一个自定义权限，并要求接收该广播的应用必须具有这个权限。这样，只有声明了相应权限的应用才能接收到广播。</p>
<p><strong>定义权限：</strong> 在 <code>AndroidManifest.xml</code> 中定义一个自定义权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.broadcast&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>发送广播：</strong> 使用 <code>sendBroadcast</code> 方法发送广播，并指定接收者需要的权限：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcast.MY_SECURE_BROADCAST&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from secure broadcast&quot;</span>)</span><br><span class="line">sendBroadcast(intent, <span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>接收广播：</strong> 在接收者的 <code>AndroidManifest.xml</code> 中声明所需的权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcast.MY_BROADCAST_PERMISSION&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后正常注册广播接收器。</p>
<ol start="2">
<li>使用动态注册的广播接收者</li>
</ol>
<p>​		另一种方法是在应用内部动态注册广播接收器，并不在 <code>AndroidManifest.xml</code> 中声明。这样，只有你的应用能接收到这个广播，因为其他应用不知道这个广播的存在。</p>
<p><strong>发送广播：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcast.MY_INTERNAL_BROADCAST&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello from internal broadcast&quot;</span>)</span><br><span class="line">sendBroadcast(intent)</span><br></pre></td></tr></table></figure>

<p><strong>接收广播：</strong> 在你的应用中动态注册广播接收器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> receiver = <span class="keyword">object</span> : BroadcastReceiver() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = intent.getStringExtra(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;InternalBroadcastReceiver&quot;</span>, <span class="string">&quot;Received data: <span class="variable">$data</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filter = IntentFilter(<span class="string">&quot;com.example.broadcast.MY_INTERNAL_BROADCAST&quot;</span>)</span><br><span class="line">registerReceiver(receiver, filter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在合适的时候注销接收器</span></span><br><span class="line">unregisterReceiver(receiver)</span><br></pre></td></tr></table></figure>

<p>​		这两种方法都可以实现全局广播的发送，同时限制部分应用接收到这个广播。选择哪种方法取决于你的具体需求和应用场景。</p>
<h4 id="SharedPreferences-优缺点"><a href="#SharedPreferences-优缺点" class="headerlink" title="SharedPreferences 优缺点"></a>SharedPreferences 优缺点</h4><p>优点<br> 1.轻量级，以键值对的方式进行存储，使用方便，易于理解。<br> 2.采用的是 <code>XML</code> 文件形式存储在本地，程序卸载后会也会一并被清除，不会残留信息。</p>
<p>缺点<br> 1.由于是对文件 <code>IO</code> 读取，因此在 <code>IO</code> 上的瓶颈是个大问题。<br> 2.多线程场景下效率比较低，因为 <code>get</code> 操作的时候，会锁定 <code>SharedPreferencesImpl</code> 里面的对象，互斥其他操作，而当 <code>put、commit()</code> 和 <code>apply()</code> 操作的时候都会锁住 <code>Editor</code> 的对象，这样的情况下，效率会降低。<br> 3.不支持跨进程通讯。<br> 4.由于每次都会把整个文件加载到内存中，因此，如果 <code>SharedPreferences</code> 文件过大，或者在其中的键值对是大对象的 <code>json</code> 数据则会占用大量内存，读取较慢是一方面，同时也会引发程序频繁<code>GC</code>，导致的界面卡顿。</p>
<h4 id="SharedPreferences-提交apply-和-commit-的区别"><a href="#SharedPreferences-提交apply-和-commit-的区别" class="headerlink" title="SharedPreferences 提交apply() 和 commit()的区别"></a>SharedPreferences 提交apply() 和 commit()的区别</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">val</span> sharedPreferences = getSharedPreferences(<span class="string">&quot;123&quot;</span>, Context.MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> string = sharedPreferences.getString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line"><span class="keyword">val</span> editor = sharedPreferences.edit()</span><br><span class="line">editor.putString(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">editor.commit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>commit()</code> 是同步的，而 <code>apply()</code> 采用异步的方式通常来说效率会更高一些。在不需要返回值的情况下，使用 <code>apply()</code> 方法可以极大的提高性能。**<code>apply()</code> 和 <code>commit()</code> 的区别是在 <code>commit()</code> 把内容同步提交到了硬盘，而 <code>apply()</code> 是先立即把修改提交给了内存，然后开启了一个异步的线程提交到硬盘。**</p>
<h4 id="Android-组件化"><a href="#Android-组件化" class="headerlink" title="Android 组件化"></a>Android 组件化</h4><h4 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h4><h4 id="构建-apk-的过程"><a href="#构建-apk-的过程" class="headerlink" title="构建 apk 的过程"></a>构建 apk 的过程</h4><h4 id="说一下今日头条屏幕适配的原理"><a href="#说一下今日头条屏幕适配的原理" class="headerlink" title="说一下今日头条屏幕适配的原理"></a>说一下今日头条屏幕适配的原理</h4><h4 id="屏幕适配-dp-和-sp-有什么区别-dins-干什么用的"><a href="#屏幕适配-dp-和-sp-有什么区别-dins-干什么用的" class="headerlink" title="屏幕适配 dp 和 sp 有什么区别, dins 干什么用的"></a>屏幕适配 dp 和 sp 有什么区别, dins 干什么用的</h4><h4 id="说一下-RecycleView-三级缓存"><a href="#说一下-RecycleView-三级缓存" class="headerlink" title="说一下 RecycleView 三级缓存"></a>说一下 RecycleView 三级缓存</h4><h4 id="说一下-R8-和-D8-的区别"><a href="#说一下-R8-和-D8-的区别" class="headerlink" title="说一下 R8 和 D8 的区别"></a>说一下 R8 和 D8 的区别</h4><h4 id="AOP-面向切面编程思想"><a href="#AOP-面向切面编程思想" class="headerlink" title="AOP 面向切面编程思想"></a>AOP 面向切面编程思想</h4><h4 id="apk-解析安装过程"><a href="#apk-解析安装过程" class="headerlink" title="apk 解析安装过程"></a>apk 解析安装过程</h4><h4 id="mvvm-比-mpv-好在哪里"><a href="#mvvm-比-mpv-好在哪里" class="headerlink" title="mvvm 比 mpv 好在哪里"></a>mvvm 比 mpv 好在哪里</h4><h4 id="mvp-说一下-mvp-和-mvc-的区别"><a href="#mvp-说一下-mvp-和-mvc-的区别" class="headerlink" title="mvp 说一下 mvp 和 mvc 的区别"></a>mvp 说一下 mvp 和 mvc 的区别</h4><h4 id="mvp-使用中的内存泄漏情况"><a href="#mvp-使用中的内存泄漏情况" class="headerlink" title="mvp 使用中的内存泄漏情况"></a>mvp 使用中的内存泄漏情况</h4><h4 id="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？"><a href="#网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉-activity，此时如果回调回来是否会造成内存泄漏或者-crash？" class="headerlink" title="网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？"></a>网络请求在弱网情况下发出请求，在回调还没回来之前关闭掉 activity，此时如果回调回来是否会造成内存泄漏或者 crash？</h4><ol>
<li><strong>使用弱引用（WeakReference）</strong>：在回调中使用弱引用来引用 Activity。这样，即使 Activity 被销毁，回调中的弱引用也不会阻止垃圾回收器回收 Activity，从而避免内存泄漏。</li>
<li><strong>取消网络请求</strong>：在 Activity 的 <code>onDestroy</code> 方法中取消所有未完成的网络请求。这样可以确保 Activity 销毁时不会有未完成的网络请求尝试更新 UI。</li>
<li><strong>检查 Activity 状态</strong>：在回调中检查 Activity 的状态，确保 Activity 仍然有效（未被销毁）时才更新 UI。</li>
<li><strong>使用生命周期感知组件（如 LiveData）</strong>：使用 LiveData 等组件可以自动管理与 Activity 生命周期相关的操作，减少内存泄漏的风险。</li>
</ol>
<h4 id="looper-咋停"><a href="#looper-咋停" class="headerlink" title="looper 咋停"></a>looper 咋停</h4><p>​		looper.quit()和looper.quitSafety()，调用 <code>quit()</code> 方法后，<code>Looper</code> 会立即停止处理消息队列中的所有消息。如果希望 <code>Looper</code> 在处理完当前消息后再停止，可以使用 <code>quitSafely()</code> 方法。</p>
<h4 id="handler-内存泄漏如何去避免"><a href="#handler-内存泄漏如何去避免" class="headerlink" title="handler 内存泄漏如何去避免"></a>handler 内存泄漏如何去避免</h4><h4 id="处理消息的，除了用-handler-还用啥"><a href="#处理消息的，除了用-handler-还用啥" class="headerlink" title="处理消息的，除了用 handler 还用啥"></a>处理消息的，除了用 handler 还用啥</h4><ul>
<li>将Handler声明为静态内部类或者一个单独的外部类，并持有对Activity的弱引用（WeakReference），而不是直接使用匿名类或非静态内部类。</li>
<li>在组件（如Activity或Fragment）的生命周期结束时（如<code>onDestroy</code>），调用<code>Handler.removeCallbacksAndMessages(null)</code>方法移除所有的回调和消息。这样可以防止已经排队的消息或者延迟执行的任务在组件销毁后继续持有组件的引用。</li>
<li>使用View.post()方法</li>
</ul>
<h4 id="Android原生和H5交互"><a href="#Android原生和H5交互" class="headerlink" title="Android原生和H5交互"></a>Android原生和H5交互</h4><p><strong>JavaScript 调用原生代码：</strong></p>
<ul>
<li><p>注入window</p>
<p>Android WebView 通过 addJavascriptInterface(Object object, String name) 方法，提供了向 Web 端全局 window 注入对象的能力，通过这个对象可以调用 Native 提供的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addJavascriptInterface(JsBridge(<span class="built_in">this</span><span class="meta">@MainActivity</span>, webView), <span class="string">&quot;JsBridge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsBridge</span>(<span class="keyword">private</span> val activity: Activity, <span class="keyword">private</span> val webView: WebView) &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@JavascriptInterface</span>  </span><br><span class="line">    fun <span class="title function_">webCallNative</span><span class="params">(message: String)</span> &#123;  </span><br><span class="line">        Log.e(<span class="string">&quot;JsBridge&quot;</span>, <span class="string">&quot;webCallNative: $&#123;Thread.currentThread().name&#125;&quot;</span>)  </span><br><span class="line">        Toast.makeText(activity, message, Toast.LENGTH_SHORT).show()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码注入了名叫 JsBridge 的全局对象，在 Web 端可以直接这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">window.JsBridge.webCallNative(<span class="string">&quot;webCallNative&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意 Native 端注入对象的方法需要添加 @JavascriptInterface （API 17 可用）注解，才可以暴露给 Web 调用。</p>
</li>
<li><p>使用shouldOverrideUrlLoading 拦截请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        url = URLDecoder.decode(url, <span class="string">&quot;UTF-8&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; <span class="comment">// 如果是返回数据  </span></span><br><span class="line">        webView.handlerReturnData(url);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123;</span><br><span class="line">        webView.flushMessageQueue();  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码也直接说明了通信原理，在 Web 端加载携带数据的指定格式的 url，在 Native 端通过 shouldOverrideUrlLoading 拦截并解析以获取数据，完成通信。</p>
<p>在网页的 JavaScript 代码中，通过特定的协议（如 <code>scheme://host/method?params</code>）发起请求，这通常通过修改 <code>window.location</code> 或使用 <code>iframe.src</code> 实现</p>
<p>Web 端通常使用 iFrame.src 来，开源的 JsBridge 也是如此：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bizMessagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="built_in">encodeURIComponent</span>(messageQueueSt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Native 调用 Web:</strong></p>
<p>Native 调用 Web，直接利用 WebView 的系统能力执行 JS 代码即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleMessage</span>(<span class="params">message</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;handleMessage: &quot;</span> + message)  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nativeCallWeb&quot;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>H5 中定义了 handleMessage() 方法，返回值是一个字符串。现在要从 Native 端去调用的话，可以通过  WebView.evaluateJavascript(String script, ValueCallback<String> resultCallback) 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.evaluateJavascript(<span class="string">&quot;javascript:window.handleMessage(&#x27;Hello&#x27;)&quot;</span>) &#123;  </span><br><span class="line">    Log.e(<span class="string">&quot;JsBridge&quot;</span>, <span class="string">&quot;receive from web: $it&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/hip0nRQSLiUNeBsUi7ROHQ">如何实现JsBridge？怎么实现回调？</a></p>
<p><a href="https://juejin.cn/post/7293728293768855587">APP与H5通信-JsBridge</a></p>
<h4 id="Android中如何请求权限、如何知道请求权限的结果、权限请求封装"><a href="#Android中如何请求权限、如何知道请求权限的结果、权限请求封装" class="headerlink" title="Android中如何请求权限、如何知道请求权限的结果、权限请求封装"></a>Android中如何请求权限、如何知道请求权限的结果、权限请求封装</h4><p>​		传统方式，直接在业务类中，调用activity或者fragment的<code>requestPermissions(@NonNull String[] permissions, int requestCode)</code>，然后在activity或者fragment的<code>onRequestPermissionResult()</code>中方法获取请求结果。这种方式缺陷在于会存在大量的模板代码。</p>
<p>以相机权限为例：<br>先在清单文件中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后进行代码请求：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 权限尚未授予，需要请求权限</span></span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                <span class="keyword">this</span>, arrayOf(Manifest.permission.CAMERA), REQUEST_CODE_CAMERA</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 权限已经授予，可以执行需要权限的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            REQUEST_CODE_CAMERA -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;权限被授予&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 权限被拒绝，需要处理权限拒绝的情况</span></span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;权限被拒绝&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式就是代理Fragment</p>
<p>通过一个Fragment来代理然后再将结果回调回去。</p>
<h4 id="使用静态变量或单例类来共享数据时的问题"><a href="#使用静态变量或单例类来共享数据时的问题" class="headerlink" title="使用静态变量或单例类来共享数据时的问题"></a>使用静态变量或单例类来共享数据时的问题</h4><ul>
<li>线程安全问题：</li>
</ul>
<p><strong>多线程访问：</strong> 如果多个线程同时访问和修改静态变量或单例类中的数据，可能会导致数据不一致或竞态条件。可以使用同步机制（如 <code>synchronized</code> 关键字或 <code>ReentrantLock</code>）来确保一次只有一个线程可以修改数据。</p>
<ul>
<li>内存泄漏问题：</li>
</ul>
<p><strong>持有 Context 引用：</strong> 如果单例类或静态变量持有了 Context（特别是 Activity 或 View 的引用），那么很容易导致内存泄漏。</p>
<h4 id="Android优化"><a href="#Android优化" class="headerlink" title="Android优化"></a>Android优化</h4><p><a href="http://www.notex.cc/2020-04-24/android-optimization/">http://www.notex.cc/2020-04-24/android-optimization/</a></p>
<h4 id="Android的Activity-、-Window-、-View之间的关系"><a href="#Android的Activity-、-Window-、-View之间的关系" class="headerlink" title="Android的Activity 、 Window 、 View之间的关系"></a>Android的Activity 、 Window 、 View之间的关系</h4><p>​		Activity就像是一扇贴着窗花的窗口，Window就想上窗口上面的玻璃，而View对象就像一个个贴在玻璃上的窗花。</p>
<p>​		Activity会调用PhoneWindow的setContentView()将layout布局添加到DecorView上，而此时的DecorView就是那个最底层的View。然后通过LayoutInflater.infalte()方法加载布局生成View对象并通过addView()方法添加到Window上，（一层一层的叠加到Window上）所以，Activity其实不是显示视图，Window才是真正的显示视图。</p>
<blockquote>
<p>注：一个Activity构造的时候只能初始化一个Window(PhoneWindow)，另外这个PhoneWindow有一个View容器 mContentParent，这个View容器是一个ViewGroup，是最初始的跟视图，然后通过addView方法将View一个个层叠到mContentParent上，这些层叠的View最终放在Window这个载体上面。</p>
</blockquote>
<h4 id="SharedPreferences的缺点"><a href="#SharedPreferences的缺点" class="headerlink" title="SharedPreferences的缺点"></a>SharedPreferences的缺点</h4><p><a href="https://juejin.cn/post/6932277268110639112#heading-1">一文读懂 SharedPreferences 的缺陷及一点点思考</a></p>
<h4 id="前台service和其他service的区别"><a href="#前台service和其他service的区别" class="headerlink" title="前台service和其他service的区别"></a>前台service和其他service的区别</h4><p>前台Service：</p>
<ul>
<li><strong>用户可见性</strong>：前台Service会在系统的通知区域显示一个通知，用户可以看到Service正在运行。这意味着前台Service几乎不会被系统杀死，因为用户明显可以看到它的存在和作用，这对于执行对用户来说重要的操作（如播放音乐或GPS导航）是必需的。</li>
<li><strong>系统优先级</strong>：前台Service通常有较高的优先级，系统不太可能在内存不足时杀死它。这提供了一种执行长时间运行任务的可靠方式，即使应用不在前台。</li>
<li><strong>启动方式</strong>：启动前台Service需要调用<code>startForegroundService</code>（在Android 8.0及以上版本），并在Service创建后的五秒内调用<code>startForeground()</code>，以创建一个持续的用户可见通知。</li>
</ul>
<p>后台Service（或非前台Service）：</p>
<ul>
<li><strong>用户可见性</strong>：后台Service在运行时不会在通知区域显示，用户可能不知道Service正在运行。因为没有用户可见的指示，所以这种Service对于不需要用户直接交云或不影响用户当前操作的任务来说是合适的。</li>
<li><strong>系统优先级</strong>：后台Service有较低的优先级，当系统需要释放内存时，可能会被系统杀死。从Android Oreo（API 级别 26）开始，对后台执行有了更多限制，以优化系统性能和电池寿命。</li>
<li><strong>启动方式</strong>：可以通过调用<code>startService</code>来启动后台Service。但是，从Android 8.0开始，应用在后台时不能启动后台Service，尝试这样做会导致<code>IllegalStateException</code>。</li>
</ul>
<p>总结：</p>
<p>选择前台Service还是后台Service取决于应用的具体需求和系统对后台执行的限制。如果任务对用户来说很重要，并且用户应该意识到这个任务正在执行（如音乐播放），则应使用前台Service。如果任务可以在不影响用户体验的情况下静默运行，并且不需要持续运行，那么后台Service可能更合适。然而，考虑到Android系统对后台执行的严格限制，开发者应该谨慎使用后台Service，并探索其他保持应用行为高效的方法，如使用<code>WorkManager</code>来安排异步任务。</p>
<h4 id="那个生命周期方法可以获取某个View宽高信息"><a href="#那个生命周期方法可以获取某个View宽高信息" class="headerlink" title="那个生命周期方法可以获取某个View宽高信息"></a>那个生命周期方法可以获取某个View宽高信息</h4><p>​		由于布局过程可能在<code>Activity</code>的<code>onCreate()</code>、<code>onStart()</code>或<code>onResume()</code>方法之后完成，这些生命周期方法不保证视图已经被测量和布局。所以，直接在这些方法中查询视图的大小可能不会得到正确的结果。</p>
<p>解决的四种方法</p>
<ul>
<li><p>onWindowFocusChanged</p>
<p>该方法的含义是：View已经初始化完毕了，宽&#x2F;高已经准备好了，所以此时去获取宽&#x2F;高是没有问题的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">    <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">        <span class="comment">// 现在可以安全地获取视图的宽高了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>使用View.post(Runnable)方法</strong>：可以将一个<code>Runnable</code>对象发布到视图的事件队列中，这样可以确保<code>Runnable</code>在视图布局完成后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myView.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">        <span class="comment">// 使用视图的宽高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ViewTreeObserver.OnGlobalLayoutListener</strong>：此监听器在视图树的全局布局状态或视图树中视图的可视状态发生改变时被调用。这是一个非常可靠的方式来获取视图尺寸，尤其是当<strong>需要获取自定义视图或动态添加到视图树中的视图的尺寸时。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ViewTreeObserver</span> <span class="variable">viewTreeObserver</span> <span class="operator">=</span> myView.getViewTreeObserver();</span><br><span class="line">viewTreeObserver.addOnGlobalLayoutListener(<span class="keyword">new</span> <span class="title class_">ViewTreeObserver</span>.OnGlobalLayoutListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onGlobalLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 移除监听器以防重复调用</span></span><br><span class="line">        myView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> myView.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> myView.getHeight();</span><br><span class="line">        <span class="comment">// 使用视图的宽高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Android11分区存储强制执行"><a href="#Android11分区存储强制执行" class="headerlink" title="Android11分区存储强制执行"></a>Android11分区存储强制执行</h4><p><strong>访问文件和媒体</strong></p>
<ul>
<li><strong>应用私有目录</strong>：应用可以在其私有目录（内部存储和外部存储中的 <code>Android/data/</code> 目录）无需任何权限地自由读写文件。</li>
<li><strong>媒体文件访问</strong>：应用可以通过媒体存储 API（如 <code>MediaStore</code>）访问音乐、视频和图片等媒体文件，但对于用户的其他文件类型，如文档和下载项，访问将受到限制。<strong>Android11可以使用<code>直接文件路径</code>访问访问媒体文件。</strong>也就是说有两种访问方式媒体存储 API和原生路径。但是写的话还是得使用媒体存储 API。</li>
<li><strong>文件管理器访问</strong>：应用可以使用系统文件选择器（<code>Intent.ACTION_OPEN_DOCUMENT</code>、<code>Intent.ACTION_CREATE_DOCUMENT</code>）让用户选择特定文件，而无需直接访问文件系统。</li>
</ul>
<p><strong>权限变化</strong></p>
<ul>
<li><strong>存储权限</strong>：<code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限的作用被限制。在分区存储模式下，即使应用被授予这些权限，对非媒体文件的访问也受到限制。</li>
<li><strong>管理所有文件的权限</strong>（<code>MANAGE_EXTERNAL_STORAGE</code>）：应用可以请求此权限以获得对整个外部存储的访问权限，但Google Play对此类应用的审查非常严格，只有满足特定用例（如文件管理器、备份还原应用）的应用才可能被批准。</li>
</ul>
<p><strong>外部存储根目录</strong></p>
<ul>
<li>直接在外部存储的根目录创建文件或访问文件将不再可行，除非应用具有特殊权限，如 <code>MANAGE_EXTERNAL_STORAGE</code></li>
</ul>
<p><strong>可以访问的目录</strong></p>
<p><strong>应用专属目录</strong></p>
<ul>
<li><strong>内部存储上的应用专属目录</strong>：通过 <code>Context.getFilesDir()</code> 获取的目录，用于存储应用的私有数据。</li>
<li>外部存储上的应用专属目录：<ul>
<li>通过 <code>Context.getExternalFilesDir()</code> 获取的目录，用于存储应用的私有数据，但在用户卸载应用时会被清除。该方法可以接受一个参数来指定特定类型的目录（如 <code>Environment.DIRECTORY_PICTURES</code>），但这些目录是应用私有的。</li>
<li>通过 <code>Context.getExternalCacheDir()</code> 获取的目录，主要用于存储临时缓存数据。</li>
</ul>
</li>
</ul>
<p><strong>公共目录</strong></p>
<p>对于公共文件存储，应用可以在特定的公共目录中保存文件，这些目录主要包括媒体文件（图片、视频、音频等）和下载文件。</p>
<ul>
<li><strong>图片、视频和音频</strong>：应用可以通过 <code>MediaStore</code> API 在 <code>MediaStore.Images.Media.EXTERNAL_CONTENT_URI</code>、<code>MediaStore.Video.Media.EXTERNAL_CONTENT_URI</code> 和 <code>MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</code> 对应的媒体库中添加媒体文件。</li>
<li><strong>下载文件</strong>：应用可以使用 <code>DownloadManager</code> 或系统文件选择器保存文件到下载目录。如果使用 <code>DownloadManager</code>，文件会自动保存到系统的下载文件夹，无需特殊权限。若通过系统文件选择器（<code>Intent.ACTION_CREATE_DOCUMENT</code>），用户可以选择保存文件的具体位置。</li>
</ul>
<p><strong>特殊权限</strong></p>
<p>请求 <code>MANAGE_EXTERNAL_STORAGE</code> 权限后可以无限制的访问目录。</p>
<h4 id="Activity-Results-API"><a href="#Activity-Results-API" class="headerlink" title="Activity Results API"></a>Activity Results API</h4><p>常用合约：</p>
<ol>
<li><strong>StartActivityForResult</strong> - 启动一个Activity，等待用户操作完成后返回结果。</li>
<li><strong>RequestMultiplePermissions</strong> - 请求多个权限。</li>
<li><strong>RequestPermission</strong> - 请求单个权限。</li>
<li><strong>TakePicturePreview</strong> - 启动相机应用拍照并返回缩略图。</li>
<li><strong>TakePicture</strong> - 启动相机拍照并将照片保存到提供的Uri中。</li>
<li><strong>TakeVideo</strong> - 启动相机录制视频并将视频保存到提供的Uri中。</li>
<li><strong>PickContact</strong> - 选择联系人。</li>
<li><strong>CreateDocument</strong> - 创建一个新文档，并将其保存到提供的Uri中。</li>
<li><strong>OpenDocument</strong> - 打开文档。</li>
<li><strong>OpenMultipleDocuments</strong> - 打开多个文档。</li>
<li><strong>OpenDocumentTree</strong> - 打开文档树，允许用户选择一个目录（而不是单个文件）。</li>
<li><strong>GetContent</strong> - 获取内容，如选择图库中的图片。</li>
<li><strong>GetMultipleContents</strong> - 获取多个内容项，例如同时选择多张图库中的图片。</li>
</ol>
<p><strong>1. StartActivityForResult</strong></p>
<p>用于启动另一个<code>Activity</code>，等待返回结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册启动Activity的回调</span></span><br><span class="line"><span class="keyword">val</span> startForResult = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">    <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理返回结果</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = result.<span class="keyword">data</span></span><br><span class="line">        <span class="comment">// 使用返回的Intent数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动Activity</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, TargetActivity::<span class="keyword">class</span>.java)</span><br><span class="line">startForResult.launch(intent)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>RequestMultiplePermissions</li>
</ol>
<p>请求多个权限。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册请求多个权限的回调</span></span><br><span class="line"><span class="keyword">val</span> requestMultiplePermissions = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) &#123; permissions : Map&lt;String, <span class="built_in">Boolean</span>&gt; -&gt;</span><br><span class="line">    permissions.entries.forEach &#123;</span><br><span class="line">        <span class="keyword">val</span> permissionName = it.key</span><br><span class="line">        <span class="keyword">val</span> isGranted = it.value</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isGranted) &#123;</span><br><span class="line">            <span class="comment">// 权限被授予</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 权限被拒绝</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求权限</span></span><br><span class="line">requestMultiplePermissions.launch(arrayOf(Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>RequestPermission</li>
</ol>
<p>请求单个权限。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册请求单个权限的回调</span></span><br><span class="line"><span class="keyword">val</span> requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestPermission()) &#123; isGranted -&gt;</span><br><span class="line">    <span class="keyword">if</span> (isGranted) &#123;</span><br><span class="line">        <span class="comment">// 权限被授予的操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 权限被拒绝的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求权限</span></span><br><span class="line">requestPermissionLauncher.launch(Manifest.permission.CAMERA)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>TakePicturePreview</li>
</ol>
<p>启动相机应用拍照并返回缩略图。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册拍照并获取缩略图的回调</span></span><br><span class="line"><span class="keyword">val</span> takePicturePreviewLauncher = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) &#123; bitmap -&gt;</span><br><span class="line">    <span class="comment">// 使用返回的缩略图Bitmap</span></span><br><span class="line">    imageView.setImageBitmap(bitmap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍照</span></span><br><span class="line">takePicturePreviewLauncher.launch(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>TakePicture</li>
</ol>
<p>启动相机拍照并将照片保存到指定Uri中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备保存图片的Uri</span></span><br><span class="line"><span class="keyword">val</span> imageUri: Uri = ... <span class="comment">// 创建或获取一个Uri</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拍照的回调</span></span><br><span class="line"><span class="keyword">val</span> takePictureLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) &#123; isSuccess -&gt;</span><br><span class="line">    <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">        <span class="comment">// 照片成功保存到Uri</span></span><br><span class="line">        imageView.setImageURI(imageUri)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 拍照失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍照并保存</span></span><br><span class="line">takePictureLauncher.launch(imageUri)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>TakeVideo</li>
</ol>
<p>启动相机录制视频并将视频保存到指定Uri中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备保存视频的Uri</span></span><br><span class="line"><span class="keyword">val</span> videoUri: Uri = ... <span class="comment">// 创建或获取一个Uri</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册录制视频的回调</span></span><br><span class="line"><span class="keyword">val</span> takeVideoLauncher = registerForActivityResult(ActivityResultContracts.TakeVideo()) &#123; uri -&gt;</span><br><span class="line">    <span class="comment">// 使用返回的视频Uri</span></span><br><span class="line">    <span class="keyword">if</span> (uri != <span class="literal">null</span>) &#123;</span><br><span class="line">        videoView.setVideoURI(uri)</span><br><span class="line">        videoView.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 录制视频并保存</span></span><br><span class="line">takeVideoLauncher.launch(videoUri)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2023/12/15/Android%20View%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Android-view-绘制流程"><a href="#Android-view-绘制流程" class="headerlink" title="Android view 绘制流程"></a>Android view 绘制流程</h1><h2 id="布局加载过程"><a href="#布局加载过程" class="headerlink" title="布局加载过程"></a>布局加载过程</h2><ul>
<li><p>我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">  		<span class="comment">// 这里调用了PhoneWindow的setContentView方法</span></span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;  </span><br><span class="line">                mDecor = generateDecor();  </span><br><span class="line">                mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">                mDecor.setIsRootNamespace(<span class="literal">true</span>);  </span><br><span class="line">                <span class="comment">//...  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;  </span><br><span class="line">              	<span class="comment">// 这里引入R.layout.screen_simple add到了DecorView上 并将R.id.content传递给mContentParent 可以看下面的源码部分</span></span><br><span class="line">                mContentParent = generateLayout(mDecor);  </span><br><span class="line">                mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">                <span class="keyword">if</span> (mTitleView != <span class="literal">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//根据FEATURE_NO_TITLE隐藏，或者设置mTitleView的值  </span></span><br><span class="line">                    <span class="comment">//...  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);  </span><br><span class="line">                    <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">//设置ActionBar标题、图标神马的；根据FEATURE初始化Actionbar的一些显示  </span></span><br><span class="line">                        <span class="comment">//...  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 先是一系列的属性设置贴了一些平时常用的</span></span><br><span class="line">    <span class="comment">// 取消标题栏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="literal">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置全屏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="literal">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    <span class="comment">// 一系列的窗口属性设置</span></span><br><span class="line">    <span class="comment">// 如：SDK 31 新增的高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowBlurBehindEnabled, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getForcedWindowFlags() &amp; WindowManager.LayoutParams.FLAG_BLUR_BEHIND) == <span class="number">0</span>) &#123;</span><br><span class="line">            params.flags |= WindowManager.LayoutParams.FLAG_BLUR_BEHIND;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        params.setBlurBehindRadius(a.getDimensionPixelSize(</span><br><span class="line">                android.R.styleable.Window_windowBlurBehindRadius, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 整体布局文件</span></span><br><span class="line">    <span class="type">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据一系列判断选择 SDK 中的布局一般默认是 R.layout.screen_simple</span></span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载到DecorView上</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到 screen_simple.xml 布局的内容部分 （R.id.content）</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">DecorView:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="type">int</span> layoutResource)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 通过 LayoutInflater 将 screen_simple.xml 解析成 View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 addView 将 root 添加到 DecorView 上</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前最终的布局层次</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
</li>
</ul>
<p>此时只是完成了基础的activity的DecirView的初始化 我们实现的布局还没有解析到布局上</p>
<p>回头看setContentView()方法，目前上面的部分实现了installDecor()，也就是初始化完成了DecorView 并解析了R.layout.screen_simple到上面，并将里面的FrameLayout（R.id.content）的引用传递出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">    	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">      installDecor();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      mContentParent.removeAllViews();  </span><br><span class="line">  &#125;  </span><br><span class="line">		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">  mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">  <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">      cb.onContentChanged();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面就是解析自己的布局过程，就是下面这行代码开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br></pre></td></tr></table></figure>

<p>往下挖源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater:	</span><br><span class="line">	<span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">    <span class="comment">// 如果开启了调试模式，打印日志，显示正在从哪个资源文件加载视图</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">              + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line">    <span class="comment">// 尝试从预编译的资源中加载视图，如果成功则返回视图 </span></span><br><span class="line">    <span class="comment">// 目前这个方法被禁用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取XML资源解析器</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用解析器，根据root和attachToRoot参数来加载视图</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后关闭解析器</span></span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用同步块，确保多线程环境下的安全性</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// 开始性能追踪，用于调试和性能优化</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上下文和属性集</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root; <span class="comment">// root 赋值给 result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果根视图不为空并且根视图的 ViewRootImpl 不为空，通知渲染器进行昂贵帧的处理</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将解析器推进到第一个START_TAG 也就是根View</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 拿到根 View 名字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点是 &lt;merge&gt;，则需要合并布局</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果根视图为空或者不需要附加到根视图，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行合并布局</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 根据标签创建视图</span></span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图为空且 temp 不为空 且 temp 的 ViewRootImpl 不为空，通知渲染器处理昂贵帧</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span> &amp;&amp; temp.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 布局参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图不为空，则生成根视图的布局参数</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Creating params from root: &quot;</span> + root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初始化布局参数</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要附加到根视图，则设置布局参数给 temp</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; start inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; done inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将创建的根 View 添加到 root 也就是 mContentParent 中</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回传入的根视图还是在 XML 中找到的顶层视图</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="comment">// XML 解析异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                    getParserStateDescription(inflaterContext, attrs)</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要保留对上下文的静态引用</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束性能追踪</span></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">     View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果标签名为 &quot;view&quot;，则尝试获取 &quot;class&quot; 属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不忽略主题属性，则尝试应用主题包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="comment">// 从属性中获取主题信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果主题资源 ID 不为 0，则使用 ContextThemeWrapper 包装上下文</span></span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试直接创建视图  </span></span><br><span class="line">      	<span class="comment">// 这里是使用Factory2创建view </span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">				</span><br><span class="line">       <span class="comment">// 如果创建失败进入 if</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果直接创建失败，则尝试通过其他方式创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 表示 sdk 中的 View (Text、Button...)</span></span><br><span class="line">                    view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 表示自定义 View 或者 support 包中的 View (androidx.appcompat.widget.AppCompatButton...)</span></span><br><span class="line">                    view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 InflateException，则直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ClassNotFoundException，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果是其他异常，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结上述源码：</p>
<p>LayoutInflater::inflate 开启了布局解析，<code>XmlResourceParser parser = res.getLayout(resource);</code>获取了布局解析器，然后<code>inflate(parser, root, attachToRoot);</code> 进入了具体的解析流程。从<code>final View temp = createViewFromTag(root, name, inflaterContext, attrs);</code>进入createViewFromTag方法，然后走下如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">           mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                   view = onCreateView(context, parent, name, attrs);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>tryCreateView是尝试创建view，看看具体代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很简单就是通过mFactory2&#x2F;mFactory来创建view。</p>
<p>其中Activity的父类AppCompatActivity中的构造方法中会执行一个initDelegate()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 添加上下文可用监听器</span></span><br><span class="line">    addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AppCompatDelegate 实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">            <span class="comment">// 安装视图工厂 这里开启了Factory</span></span><br><span class="line">            delegate.installViewFactory();</span><br><span class="line">            <span class="comment">// 调用 AppCompatDelegate 的 onCreate 方法，并传入从 SavedStateRegistry 恢复的状态</span></span><br><span class="line">            delegate.onCreate(getSavedStateRegistry()</span><br><span class="line">                    .consumeRestoredStateForKey(DELEGATE_TAG));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDelegateImpl:</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 这里setFactory2 将this也就是AppCompatDelegateImpl</span></span><br><span class="line">            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                        + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码走完又可以回到这部分了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view;</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用的onCreateView方法的实现应该是在AppCompatDelegateImpl中，看下具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 AppCompatViewInflater 为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mAppCompatViewInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewInflaterClassName</span> <span class="operator">=</span></span><br><span class="line">                a.getString(R.styleable.AppCompatTheme_viewInflaterClass);</span><br><span class="line">        <span class="keyword">if</span> (viewInflaterClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未指定自定义的 ViewInflater 类名，使用默认的 AppCompatViewInflater</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用反射加载自定义的 ViewInflater 类</span></span><br><span class="line">                Class&lt;?&gt; viewInflaterClass =</span><br><span class="line">                        mContext.getClassLoader().loadClass(viewInflaterClassName);</span><br><span class="line">                mAppCompatViewInflater =</span><br><span class="line">                        (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor()</span><br><span class="line">                                .newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 加载失败时，使用默认的 AppCompatViewInflater，并打印错误日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Failed to instantiate custom view inflater &quot;</span></span><br><span class="line">                        + viewInflaterClassName + <span class="string">&quot;. Falling back to default.&quot;</span>, t);</span><br><span class="line">                mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承上下文，用于处理 &lt;include&gt; 标签的情况</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inheritContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (IS_PRE_LOLLIPOP) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 5.0 之前的版本，处理 &lt;include&gt; 标签的继承上下文情况</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector == <span class="literal">null</span>) &#123;</span><br><span class="line">            mLayoutIncludeDetector = <span class="keyword">new</span> <span class="title class_">LayoutIncludeDetector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector.detect(attrs)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前视图是 &lt;include&gt; 的根视图，则继承上下文</span></span><br><span class="line">            inheritContext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 &lt;include&gt; 标签，根据深度或者使用旧的启发式方法来判断是否继承上下文</span></span><br><span class="line">            inheritContext = (attrs <span class="keyword">instanceof</span> XmlPullParser)</span><br><span class="line">                    ? ((XmlPullParser) attrs).getDepth() &gt; <span class="number">1</span></span><br><span class="line">                    : shouldInheritContext((ViewParent) parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AppCompatViewInflater 的 createView 方法创建视图</span></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* 只在 Android 5.0 之前读取 android:theme 属性 */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* 无论何时都读取 app:theme 属性作为后备，基于传统原因 */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* 只有在启用时对上下文进行着色处理 */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又走到了createView方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">originalContext</span> <span class="operator">=</span> context;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can emulate Lollipop&#x27;s android:theme attribute propagating down the view hierarchy</span></span><br><span class="line">      <span class="comment">// by using the parent&#x27;s context</span></span><br><span class="line">      <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">          context = parent.getContext();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">          <span class="comment">// We then apply the theme on the context, if specified</span></span><br><span class="line">          context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">          context = TintContextWrapper.wrap(context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We need to &#x27;inject&#x27; our tint aware Views in place of the standard framework versions</span></span><br><span class="line">      <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">              view = createTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">              view = createImageView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">              view = createButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">              view = createEditText(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">              view = createSpinner(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">              view = createImageButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">              view = createCheckBox(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">              view = createRadioButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">              view = createCheckedTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">              view = createRatingBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">              view = createSeekBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ToggleButton&quot;</span>:</span><br><span class="line">              view = createToggleButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">              <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">              <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">              <span class="comment">// later in this method.</span></span><br><span class="line">              view = createView(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">          <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">          <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">          view = createViewFromTag(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">          checkOnClickListener(view, attrs);</span><br><span class="line">          backportAccessibilityAttributes(context, view, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总结上面：AppCompatActivity 默认设置了 Factory2，并且其实现创建 View 是直接通过 new 的方式，并没有使用反射。</p>
<p>上面一节有个方法需要注意下，就是布局的子view是如果添加到根view的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/LayoutInflater.java</span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    				...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">								</span><br><span class="line">						...</span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数的深度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 逐个 View 解析</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:focusable=&quot;true&quot;, 获取View的焦点</span></span><br><span class="line">            pendingRequestFocus = <span class="literal">true</span>;</span><br><span class="line">            consumeChildElements(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:tag标签</span></span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析include标签，include标签不能作为根布局</span></span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;include /&gt; cannot be the root element&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, context, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// merge标签必须作为根布局</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; must be the root element&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据元素名解析，生成View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 添加解析的View</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果finishInflate为true，则调用onFinishInflate方法</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为AppCompatActivity 默认设置了 Factory2，且Factory2只能设置一次，如果activity集成了AppCompatActivity那么只能通过反射设置Factory2了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory2</span><span class="params">(Factory2 factory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Given factory can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> <span class="title class_">FactoryMerger</span>(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射将mFactorySet重新设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//上面提到过：Android布局加载器使用mFactorySet标记是否设置过Factory，如设置过抛出一次</span></span><br><span class="line">  <span class="comment">//所以需要通过反射设置mFactorySet为false</span></span><br><span class="line">  <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LayoutInflater.class.getDeclaredField(<span class="string">&quot;mFactorySet&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用factory2设置布局加载工厂</span></span><br><span class="line"><span class="type">SkinLayoutInflaterFactory</span> <span class="variable">skinLayoutInflaterFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkinLayoutInflaterFactory</span></span><br><span class="line">  (activity);</span><br><span class="line">LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>

<p><strong>setContentView总结：</strong></p>
<p>在<code>Activity</code>实例创建好并且执行<code>attach()</code>方法的时候，会为<code>Activity</code>创建一个<code>PhoneWindow</code>，接下来就到了<code>onCreate()</code>的生命周期，在调用<code>setContentView()</code>的时候，如果还没有初始化<code>ContentParent</code>，说明是第一次进行<code>setContentView()</code>，那么就会初始化<code>DecorView</code>，还会给<code>DecorView</code>添加一个系统页面样式的<code>子View(R.layout.screen_simple)</code>，那么在系统样式的<code>ViewGroup</code>中，就可以通过<code>id</code>找到用来加载自定义布局的<code>ContentParent</code>，再通过<code>inflate</code>就可以将我们自己写的<code>xml</code>文件<code>(R.layout.main)</code>转化为一颗<code>ViewTree</code>了，这颗<code>ViewTree</code>就在<code>ContentParent</code>里面。</p>
<p>所以<code>setContentView()</code>的作用最终可以总结为：</p>
<ul>
<li><strong>创建<code>DecorView</code></strong></li>
<li><strong>创建<code>ContentParent</code></strong></li>
<li><strong>自定义布局转化为<code>ViewTree</code>，放在<code>ContentParent</code>中</strong></li>
</ul>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA">https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA</a><br><a href="https://www.jianshu.com/p/5a71014e7b1b">https://www.jianshu.com/p/5a71014e7b1b</a></p>
<p><a href="https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11">https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11</a></p>
<p><a href="https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff">https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff</a><br><a href="https://www.jianshu.com/p/8e554406bd15">https://www.jianshu.com/p/8e554406bd15</a></p>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>上面布局解析完之后还不可见，在Activity处于<code>onResume()</code>生命周期时才会展示布局。</p>
<p>​		<code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中回调的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<h3 id="onResume"><a href="#onResume" class="headerlink" title="**onResume **"></a>**onResume **</h3><p>​		在<code>onResume()</code>中会调用<code>WindowManager</code>中的<code>addView()</code>添加<code>DecorView</code>，当<code>WindowManager</code>管理<code>ViewTree</code>的时候会给<code>ViewTree</code>分配一个<code>ViewRootImpl</code>，<code>ViewRootImpl</code>的第一个作用就是管理<code>ViewTree</code>的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个<code>Activity</code>的情况下，每个<code>Activity</code>都有自己的<code>PhoneWindow</code>、<code>DecorView</code>以及<code>WindowManagerImpl</code>，<code>WindowManagerGlobal</code>持有每个<code>Activity</code>的<code>RootView</code>，<code>mWindowSession</code>和<code>mWindow</code>是用来和<code>WMS</code>进行双向通信的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isForward, <span class="type">boolean</span> shouldSendCompatFakeFocus, String reason)</span> &#123;</span><br><span class="line">      	...</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">// 这里的decor就是上面setContentView加载的DecorView</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">          	<span class="comment">// 每一个Activity都会对应一个WindowManager对象（Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象）</span></span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">            WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 将DecorView add进WindowManager中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">						。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		上面的<code>wm.addView</code>最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法。这个方法中会调用<code>requestLayout()</code>。</p>
<h3 id="ViewRootImpl的requestLayout-方法"><a href="#ViewRootImpl的requestLayout-方法" class="headerlink" title="ViewRootImpl的requestLayout()方法"></a>ViewRootImpl的requestLayout()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 将布局请求安排到消息队列中，以便在下一个消息循环中执行。</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 获取 Looper 并创建同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">          	<span class="comment">// 调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即在下一个VSync到来时会执行TraversalRunnable--&gt;doTraversal()---&gt;performTraversals()--&gt;绘制流程。</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的mTraversalRunnable是个Runnable对象</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">		  <span class="comment">// 到这里终于看到了绘制的起点了</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要有以下逻辑：</p>
<ol>
<li>首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。</li>
<li>然后把当前线程的消息队列Queue添加了<strong>同步屏障</strong>，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。</li>
<li>调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即<strong>在下一个VSync到来时会执行TraversalRunnable–&gt;doTraversal()—&gt;performTraversals()–&gt;绘制流程</strong>。</li>
</ol>
<blockquote>
<p>vsync信号是由底层发出的。上层有个类监听vsync的信号，当接收到信号时，就会通过Choreographer向消息队列发送异步消息，这个消息的作用之一就是通知ViewRootImpl去执行测量，布局，绘制操作。</p>
</blockquote>
<p>看看Choreographer 的代码，Choreographer和Looper一样 是线程单例的。接着看看Choreographer构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        <span class="comment">//使用当前线程looper创建 mHandler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">        <span class="comment">//USE_VSYNC 4.1以上默认是true，表示 具备接受VSync的能力，这个接受能力就是FrameDisplayEventReceiver</span></span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">                : <span class="literal">null</span>;</span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算一帧的时间，Android手机屏幕是60Hz的刷新频率，就是16ms</span></span><br><span class="line">        mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表类型CallbackQueue的数组，大小为5，</span></span><br><span class="line">		<span class="comment">//也就是数组中有五个链表，每个链表存相同类型的任务：输入、动画、遍历绘制等任务（CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL）</span></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		创建了一个mHandler、VSync事件接收器mDisplayEventReceiver、任务链表数组mCallbackQueues。</p>
<p>​		postCallback最终调用到postCallbackDelayedInternal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postCallbackDelayedInternal</span><span class="params">(<span class="type">int</span> callbackType,</span></span><br><span class="line"><span class="params">        Object action, Object token, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    	<span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">// 加上延迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dueTime</span> <span class="operator">=</span> now + delayMillis;</span><br><span class="line">        <span class="comment">//取对应类型的CallbackQueue添加任务</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">        	<span class="comment">//立即执行</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//延迟运行，最终也会走到scheduleFrameLocked()</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		首先取对应类型的CallbackQueue添加任务，action就是mTraversalRunnable，token是null。<strong>CallbackQueue的addCallbackLocked()就是把 dueTime、action、token组装成CallbackRecord后 存入CallbackQueue的下一个节点</strong>。</p>
<p>​		没有延迟会执行scheduleFrameLocked()方法，有延迟就会使用 mHandler发送MSG_DO_SCHEDULE_CALLBACK消息，并且注意到 <strong>使用msg.setAsynchronous(true)把消息设置成异步</strong>，这是因为前面设置了同步屏障，只有异步消息才会执行。</p>
<p>看下mHandler的对这个消息的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FrameHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">                	<span class="comment">// 执行doFrame,即绘制过程</span></span><br><span class="line">                    doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                	<span class="comment">//申请VSYNC信号，例如当前需要绘制任务时</span></span><br><span class="line">                    doScheduleVsync();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                	<span class="comment">//需要延迟的任务，最终还是执行上述两个事件</span></span><br><span class="line">                    doScheduleCallback(msg.arg1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>直接使用doScheduleCallback方法，看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doScheduleCallback</span><span class="params">(<span class="type">int</span> callbackType)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                    scheduleFrameLocked(now);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现也是走到这里，即延迟运行最终也会走到scheduleFrameLocked()，跟进看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleFrameLocked</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            mFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//开启了VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当前执行的线程，是否是mLooper所在线程</span></span><br><span class="line">                <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                	<span class="comment">//申请 VSYNC 信号</span></span><br><span class="line">                    scheduleVsyncLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 若不在，就用mHandler发送消息到原线程，最后还是调用scheduleVsyncLocked方法</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                    msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">                    mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 如果未开启VSYNC则直接doFrame方法（4.1后默认开启）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nextFrameTime</span> <span class="operator">=</span> Math.max(</span><br><span class="line">                        mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">                msg.setAsynchronous(<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">                mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果系统未开启 VSYNC 机制，此时直接发送 MSG_DO_FRAME 消息到 FrameHandler。注意查看上面贴出的 FrameHandler 代码，此时直接执行 doFrame 方法。</li>
<li>Android 4.1 之后系统默认开启 VSYNC，在 Choreographer 的构造方法会创建一个 FrameDisplayEventReceiver，scheduleVsyncLocked 方法将会通过它申请 VSYNC 信号。</li>
<li>isRunningOnLooperThreadLocked 方法，其内部根据 Looper 判断是否在原线程，否则发送消息到 FrameHandler。最终还是会调用 scheduleVsyncLocked 方法申请 VSYNC 信号。</li>
</ol>
<p>​		到这里，<strong>FrameHandler的作用很明显里了：发送异步消息（因为前面设置了同步屏障）。有延迟的任务发延迟消息、不在原线程的发到原线程、没开启VSYNC的直接走 doFrame 方法取执行绘制。</strong></p>
<p>看 scheduleVsyncLocked 方法是如何申请 VSYNC 信号的。</p>
<p>有一个叫做FrameDisplayEventReceiver的类，它是专门用来接收vsync信号的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">DisplayEventReceiver</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     	* 接收到VSync脉冲时 回调</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> timestampNanos VSync脉冲的时间戳</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class="line"><span class="comment">     	* <span class="doctag">@param</span> frame 帧号码，自增</span></span><br><span class="line"><span class="comment">     	*/</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            mTimestampNanos = timestampNanos;</span><br><span class="line">            mFrame = frame;</span><br><span class="line">            <span class="comment">//将本身作为runnable传入msg， 发消息后 会走run()，即doFrame()，也是异步消息</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">            msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">            doFrame(mTimestampNanos, mFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		**onVsync()方法中只是使用mHandler发送消息到MessageQueue中，不一定是立刻执行，如何MessageQueue中前面有较为耗时的操作，那么就要等完成，才会执行本次的doFrame()**。这里的mHandler还是上面的FrameHandler。</p>
<p>​		接收到信号之后就走到了doFrame方法</p>
<p>doFrame()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> startNanos;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">			<span class="comment">// 预期执行时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">intendedFrameTimeNanos</span> <span class="operator">=</span> frameTimeNanos;</span><br><span class="line">            startNanos = System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时间是否超过一帧的时间（这是因为MessageQueue虽然添加了同步屏障，但是还是有正在执行的同步任务，导致doFrame延迟执行了）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> startNanos - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            	<span class="comment">// 计算掉帧数</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">skippedFrames</span> <span class="operator">=</span> jitterNanos / mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                	<span class="comment">// 掉帧超过30帧打印Log提示</span></span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames!  &quot;</span></span><br><span class="line">                            + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos;</span><br><span class="line">                ...</span><br><span class="line">                frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">            <span class="comment">// Frame标志位恢复</span></span><br><span class="line">            mFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 记录最后一帧时间</span></span><br><span class="line">            mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 按类型顺序 执行任务</span></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markInputHandlingStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markAnimationsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            AnimationUtils.unlockAnimationClock();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		上面都有注释了很好理解，接着看任务的具体执行doCallbacks 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">doCallbacks</span><span class="params">(<span class="type">int</span> callbackType, <span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">        CallbackRecord callbacks;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="comment">// 根据指定的类型Callback Queue中查找到达执行时间的CallbackRecord</span></span><br><span class="line">            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">            <span class="keyword">if</span> (callbacks == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mCallbacksRunning = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//提交任务类型</span></span><br><span class="line">            <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">jitterNanos</span> <span class="operator">=</span> now - frameTimeNanos;</span><br><span class="line">                <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">lastFrameOffset</span> <span class="operator">=</span> jitterNanos % mFrameIntervalNanos</span><br><span class="line">                            + mFrameIntervalNanos;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Commit callback delayed by &quot;</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                                + <span class="string">&quot; ms which is more than twice the frame interval of &quot;</span></span><br><span class="line">                                + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">&quot; ms!  &quot;</span></span><br><span class="line">                                + <span class="string">&quot;Setting frame time to &quot;</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                                + <span class="string">&quot; ms in the past.&quot;</span>);</span><br><span class="line">                        mDebugPrintNextFrameTimeDelta = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                    mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 迭代执行队列所有任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">CallbackRecord</span> <span class="variable">c</span> <span class="operator">=</span> callbacks; c != <span class="literal">null</span>; c = c.next) &#123;</span><br><span class="line">                <span class="comment">// 回调CallbackRecord的run，其内部回调Callback的run</span></span><br><span class="line">                c.run(frameTimeNanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                mCallbacksRunning = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">CallbackRecord</span> <span class="variable">next</span> <span class="operator">=</span> callbacks.next;</span><br><span class="line">                    <span class="comment">//回收CallbackRecord</span></span><br><span class="line">                    recycleCallbackLocked(callbacks);</span><br><span class="line">                    callbacks = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (callbacks != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		主要内容就是取对应任务类型的队列，遍历队列执行所有任务，执行任务是 CallbackRecord的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallbackRecord</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> dueTime;</span><br><span class="line">        <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">        <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            	<span class="comment">// 通过postFrameCallback 或 postFrameCallbackDelayed，会执行这里</span></span><br><span class="line">                ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//取出Runnable执行run()</span></span><br><span class="line">                ((Runnable)action).run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		前面看到mChoreographer.postCallback传的token是null，所以取出action，就是Runnable，执行run()，这里的action就是 ViewRootImpl 发起的绘制任务mTraversalRunnable了，那么<strong>这样整个逻辑就闭环了</strong>。</p>
<h3 id="performTraversals"><a href="#performTraversals" class="headerlink" title="performTraversals"></a>performTraversals</h3><p>看一下performTraversals的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewRootImpl </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DecorView 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">layoutRequested</span> <span class="operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">// 此处可能会调用 performMeasure 方法</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != <span class="literal">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="comment">// 如果 lp.horizontalWeight 或 lp.verticalWeight 大于 0 则重新调用 performMeasure 测量</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            layoutRequested = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">didLayout</span> <span class="operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performMeasure</span><span class="params">(<span class="type">int</span> childWidthMeasureSpec, <span class="type">int</span> childHeightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;measure&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="type">int</span> desiredWindowWidth,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> desiredWindowHeight)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">     	 <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="type">int</span> xoff, <span class="type">int</span> yoff,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DecorView是一个FrameLayout下面会直接进入FrameLayout的measure方法，参数就是上面生成的childWidthMeasureSpec和childHeightMeasureSpec。</p>
<p>​		<strong>DecorView 的测量规格由窗口的尺寸和其 LayoutParams 共同确定，而普通 View 的测量规格由父 View 的 MeasureSpec 和自身的 LayoutParams 决定，就是measureChildWithMargins方法，MeasureSpec 确定后，就可以在 onMeasure() 方法中确定 View 的测量宽高。</strong></p>
<p>​		<strong>对于 ViewGroup，除了要完成自己的测量，还要遍历调用子元素的 measure() 方法之后才能确定自己的值，而 View 只需要通过 measure() 方法就能确定测量规格。</strong></p>
<p>​		View 的测量过程由 View 的 measure() 方法完成，measure() 方法是一个 final 类型的方法，子类不能重写。</p>
<p>mView.measure -&gt; View::measure -&gt; FrameLayout.onMeasure</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">	<span class="comment">// 处理子view的measure</span></span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth = Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight = Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">                <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                            lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                        mMatchParentChildren.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置在测量完子View后结合子View的情况设置自身的measure值</span></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.cn/post/6904192359253147661#heading-5">https://juejin.cn/post/6904192359253147661#heading-5</a></p>
<h4 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h4><ul>
<li><p><strong>MeasureSpec 的理解</strong></p>
<p>MeasureSpec是一个32位的int值，用于描述View的大小和模式。它的高2位表示模式（mode），低30位表示大小（size）MeasureSpec有三种模式：</p>
<ol>
<li><p>精确模式（<strong>MeasureSpec.EXACTLY</strong>）：在这种模式下，View的大小已经确定，为SpecSize所指定的值。例如，当我们将控件的layout_width或layout_height指定为具体数值或者为<strong>MATCH_PARENT</strong>时，都是控件大小已经确定的情况，都是精确尺寸</p>
</li>
<li><p>最大模式（<strong>MeasureSpec.AT_MOST</strong>）：在这种模式下，父控件给出的是最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。例如，当控件的layout_width或layout_height指定为<strong>WRAP_CONTENT</strong>时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。</p>
</li>
<li><p>未指定模式（<strong>MeasureSpec.UNSPECIFIED</strong>）：在这种模式下，父控件不会干涉子View想要多大的尺寸，子View可以随意使用空间，不受限制。例如，在ScrollView或NestedScrollView中，子View的测量模式可能会被设置为MeasureSpec.UNSPECIFIED，这样子View就可以根据自己的内容来决定自己的大小。</p>
</li>
</ol>
</li>
</ul>
<p><strong>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求</strong></p>
<ul>
<li><p><strong>mode的值</strong></p>
<p>-<strong>2147483648</strong>   对应的二进制表示是 <code>0b10000000000000000000000000011000</code>。在这个二进制中，最低的两位 <code>00</code> 表示测量模式为 <code>AT_MOST</code>。 </p>
<p><strong>1073742099</strong> 对应的二进制表示是 <code>0b10000000000000000000000100100011</code>。在这个二进制中，最低的两位 <code>11</code> 表示测量模式为 <code>EXACTLY</code>。</p>
</li>
<li><p><strong>ViewGroup独有的measureChildWithMargins</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed, <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>以LinearLayout为例 解析Measure过程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先分析下Android View 的结构：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>我们写的布局最终会add到上面图片的FrameLayout中。</p>
<p>然后开始FrameLayout的measure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;  </span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>measureChildWithMargins的源码就是上面的ViewGroup的Measure的代码。</p>
<p>上面的performTraversals方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br></pre></td></tr></table></figure>

<p>再结合view视图层次DecorView的下一级是ViewRoot这是个LinearLayout。ViewRoot 是系统的View，它的LayoutParams默认都是match_parent。</p>
<p>根据上面的计算规则：</p>
<p>ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size。</p>
<p><strong>目前ViewRoot的measure方法的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。</strong></p>
<p>measure方法会调用onMeasure方法开启计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinearLayout：</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewRoot的子view有两个ViewStub和id.content.</p>
<p>调用ViewRoot.measure后会调用，LinearLayout 的onMeasure 方法开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用。</p>
<p>根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿<strong>ViewRoot 的MeasureSpec</strong> 和 <strong>android.R.id.content的LayoutParams</strong> 做计算了，计算过程就是调用getChildMeasureSpec的方法。</p>
<p>来看下计算过程，首先ViewRoot.measure的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。content的width和height都是matchparent。那么看下getChildMeasureSpec方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 只看这个分支</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// 根据条件走到这个分支</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 后传递给content的Measure方法</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>id&#x2F;content是个FrameLayout然后又开启了新的计算流程。</p>
<p>这个计算流程就开始计算我们自己写的布局了，再看下原布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先应该是先计算最外面的LinearLayout，根据规则LinearLayout的measure(int widthMeasureSpec, int heightMeasureSpec)的两个MeasureSpec的mode都应该是<strong>EXACTLY</strong></p>
<p>然后开启LinearLayout的onMeasure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后根据LinearLayout的measure结合TextView的LayoutParams计算得到传递给TextView的MeasureSpaec。</p>
<p>这里看看LinearLayout的measure的源码，因为orientation&#x3D;”vertical”所以会走measureVertical(widthMeasureSpec, heightMeasureSpec);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>; <span class="comment">// 总高度，子控件累加总高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大子控件的宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子view测量状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">alternativeMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 没有设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weightedMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allFillParent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 子控件全设置match_parent</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子控件累加总权重（子控件设置了layout_weight）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();<span class="comment">// 子控件总数量</span></span><br><span class="line"><span class="comment">// 这里获取了LinearLayout的Mode</span></span><br><span class="line">  	<span class="comment">// 根据上面分析widthMode都是EXACTLY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matchWidth</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 有子View宽度设置为match_parent</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skippedMeasure</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否跳过重新测量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">baselineChildIndex</span> <span class="operator">=</span> mBaselineAlignedChildIndex; <span class="comment">// 基线子view</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 跟setMeasureWithLargestChildEnabled()有关</span></span><br><span class="line">		<span class="comment">// 当设定为true，所有有设定了weight的子View的最小高度是：最大的View的高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useLargestChild</span> <span class="operator">=</span> mUseLargestChild;</span><br><span class="line"><span class="comment">// 最大子控件的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestChildHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">consumedExcessSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 需要测量的子View总数，不需要测量指的是设定了weight</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nonSkippedChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子view数量开启循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 测量view为null占据的高度，默认返回0</span></span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonSkippedChildCount++;</span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取当前子view的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 处理 weight</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 判断当前子view的height == 0 且 weight &gt; 0  </span></span><br><span class="line">      	<span class="comment">// 根据布局来看 useExcessSpace应该为false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useExcessSpace</span> <span class="operator">=</span> lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 子View的高度是具体的，可以这直接算出来，不需算子View的高度</span></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="literal">true</span>; <span class="comment">// 该子View直接忽略二次计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// useExcessSpace 为false  无法精确计算子View</span></span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">              <span class="comment">// 假设为true的话 让子view的height为WRAP_CONTENT</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">				<span class="comment">// 判断Weight的值，为0则usedHeight为mTotalLength  mTotalLength表示目前为止已经测量过的子视图的总高度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">usedHeight</span> <span class="operator">=</span> totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">          	<span class="comment">// 开始走getChildMeasureSpec流程。 这里是获取TextView的MeasureSpec 然后走它的onMeasure方法</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line">				<span class="comment">// 获取child的高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">          	<span class="comment">// 获取总共的长度 </span></span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                    + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                    + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="literal">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span> lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 底部是否有分割线，计算最高高度</span></span><br><span class="line">    <span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置了 measureWithLargestChild 且 总高度无法确定，需要重新计算 mToatalLength</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 添加padding</span></span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查最小高度</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据heightMeasureSpec计算最后结果，heightSizeAndState存储最终的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSizeAndState</span> <span class="operator">=</span> resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingExcess</span> <span class="operator">=</span> heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 简单来说就是 skippedMeasure为true说明之前的测量被跳过了需要重新测量</span></span><br><span class="line">  	<span class="comment">// 或者使用了Weight属性 要启动二次测量</span></span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">            || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">      	<span class="comment">// 计算总的weight，mWidgetSum是外部设定，totalWeight是首次计算出来的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">remainingWeightSum</span> <span class="operator">=</span> mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">childWeight</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 计算分配的值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> (<span class="type">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">              	<span class="comment">// 剩余分配高度</span></span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">              	<span class="comment">// 剩余比重总和</span></span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                  	<span class="comment">// 子View直接是largestChildHeight</span></span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// 子view是没有height，直接为分配高度</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子View有height，另外还要加上分配的高度</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">              	<span class="comment">// 重新测量子View</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span>  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">          	<span class="comment">// 计算子View的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span></span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">childExtra</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LinearLayout的onMeasure中的child.measure启动了TextView的onMeasure():</p>
<p>源码就不展示了，大概就是根据传入的获取MeasureSpec计算自己的宽度和高度，然后通过setMeasuredDimension方法将获取的值赋值给mMeasuredWidth和mMeasuredHeight。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个值就是layout进行定位的值。</p>
<h4 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h4><p>回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>

<p>measure执行完之后就该执行layout了，mView.getMeasuredWidth()和mView.getMeasuredHeight()就是上个阶段计算得到的值。</p>
<p>还是先看FrameLayout的layout干了啥</p>
<p>FrameLayout没有自己实现layout函数，得看ViewGroup里的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没啥东西，还是得看super.layout(l, t, r, b);的实现，也就是View中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      .....</span><br><span class="line">     <span class="comment">//设置View位于父视图的坐标轴  主要是初始化了四个值  mLeft  mTop  mRight mBottom</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> setFrame(l, t, r, b); </span><br><span class="line">      <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">              ViewDebug.trace(<span class="built_in">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line">          mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">      mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在View中onLayout是空实现，所以回到FrameLayout中看具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> childLeft;</span><br><span class="line">                <span class="type">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                        <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// layout(int l, int t, int r, int b)</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是根据规则获取了child的childLeft和childTop,然后启动child的layout函数。</p>
<p>这里看一下view的坐标系</p>
<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/cc5c57e82f5346e0ad194f914edd0e5d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png" style="zoom: 50%;" />

<p>left和top坐标确定了view左上角的位置，right和bottom坐标确定了右下角的位置。</p>
<p>right - left 为view的宽(width)  bottom - top 为view的高(height)。</p>
<p>Layout流程就这些没啥好说的。</p>
<h4 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h4><p>再回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br></pre></td></tr></table></figure>

<p>FrameLayout和ViewGroup都没有重写draw方法，所以我们看下View中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         *      7. If necessary, draw the default focus highlight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="type">int</span> saveCount;</span><br><span class="line">				<span class="comment">// 绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShowingLayoutBounds()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;re done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程用这张图片概括一下，循环的入口是draw方法。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/webp-20231215160503207" alt="img"></p>
<p><a href="https://juejin.cn/post/6952624592514973732">requestLayout竟然涉及到这么多知识点</a></p>
<p><a href="https://juejin.cn/post/6863756420380196877">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a></p>
<p><a href="https://juejin.cn/post/7017452765672636446#heading-8">Android invalidate&#x2F;postInvalidate&#x2F;requestLayout 彻底厘清</a></p>
<p><a href="https://juejin.cn/post/6904518722564653070?searchId=202403061612369260ECC8F072D9103CB2#heading-2">比较一下requestLayout和invalidate方法</a></p>
<h1 id="Android输入系统"><a href="#Android输入系统" class="headerlink" title="Android输入系统"></a>Android输入系统</h1><p><a href="https://www.cnblogs.com/fanglongxiang/p/14091511.html">Android10_原理机制系列_事件传递机制 </a></p>
<p><a href="https://juejin.cn/post/7203989318271221816">[Android输入系统] Socket连接的建立</a></p>
<p><a href="https://juejin.cn/post/7171130176158302245#heading-3">Android图形系统（五）番外篇：触摸事件详解</a></p>
<h2 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h2><p><code>InputManagerService</code> 是 Android 系统中负责管理输入事件（如触摸、按键、轨迹球等）的服务。作为系统服务的一部分，它是 Android 输入系统的核心组件之一，主要职责包括输入设备管理、事件处理和分发、焦点管理、手势识别和安全性等。<code>InputManagerService</code> 确保用户与设备的交互能够顺畅且安全地进行。system_server的逻辑属于system_server进程不属于应用进程。</p>
<p><code>InputManagerService</code> 的创建过程如下：</p>
<ol>
<li><strong>系统启动</strong>：Android 设备启动时，<code>Zygote</code> 进程先启动，并创建 <code>SystemServer</code> 进程。</li>
<li><strong>启动系统服务</strong>：<code>SystemServer</code> 进程启动后，按预定顺序启动各种系统服务，包括 <code>InputManagerService</code>。</li>
<li><strong>创建 InputManagerService</strong>：<code>SystemServer</code> 创建 <code>InputManagerService</code> 实例，并将其注册到系统服务管理器（<code>ServiceManager</code>）中，使其他组件可以访问。</li>
<li><strong>初始化输入设备</strong>：<code>InputManagerService</code> 启动后，初始化系统中的输入设备，并开始监听输入事件。</li>
<li><strong>准备就绪</strong>：完成初始化后，<code>InputManagerService</code> 为系统和应用程序提供输入管理服务。</li>
</ol>
<h2 id="InputManagerService创建"><a href="#InputManagerService创建" class="headerlink" title="InputManagerService创建"></a>InputManagerService创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SystemServer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WindowManagerService</span> <span class="variable">wm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputManagerService</span> <span class="variable">inputManager</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建IMS对象</span></span><br><span class="line">        inputManager = <span class="keyword">new</span> <span class="title class_">InputManagerService</span>(context);</span><br><span class="line">        wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">        <span class="comment">//注册服务：&quot;input&quot;</span></span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">                <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());</span><br><span class="line">        <span class="comment">// 启动</span></span><br><span class="line">        inputManager.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">InputManagerService</span> <span class="variable">inputManagerF</span> <span class="operator">=</span> inputManager;</span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputManagerF != <span class="literal">null</span>) &#123;</span><br><span class="line">                inputManagerF.systemRunning();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, BOOT_TIMINGS_TRACE_LOG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SystemServer中 关于IMS主要看3个内容：</p>
<ul>
<li>new InputManagerService()，最后进入native 最终创建了InputManager及一系列相关内容</li>
<li>inputManager.setWindowManagerCallbacks(），设置了回调，这里说明了 最终如何回调到PhoneWindowManager。</li>
<li>inputManager.start()，主要是IntputManager中两个线程运行起来。InputReaderThread读取和处理，InputDispatcherThread派发。</li>
</ul>
<p>下面是流程中几个重要的对象：</p>
<ul>
<li><p>EventHub：创建InputReader时 可以看到先创建了EventHub作为参数。</p>
<p>EventHub 通过Linux内核的INotify与Epoll机制 监听设备，可直接访问 设备节点。通过 getEvents() 方法 读取设备节点的原始输入事件 数据。</p>
<p>关于 EventHub的创建 这里不讨论了，这里只需简单了解它上面一点就可以了。它涉及内核和一些机制，暂时我也还不熟悉，哈哈。</p>
</li>
<li><p>InputReader：负责输入事件的获取。在独立线程（InputReaderThread）中 循环执行，有以下几个功能：</p>
<p>功能1-通过 EventHub 不断 <strong>获取设备节点的 原始输入数据</strong> 。</p>
<p>功能2-然后 <strong>进行加工处理后 交由 InputDispatcher分派</strong> 。</p>
<p>功能3-它还有 <strong>管理 输入设备列表和配置</strong> 。</p>
</li>
<li><p>InputDispatcher：负责输入事件的派发。在独立线程（InputDispatcherThread）中运行，其保存有WMS的所有窗口信息。</p>
<p>在接收到 InputReader 的输入事件后，会在窗口信息中找到合适的窗口并派发消息。同时还会监控ANR的产生。</p>
</li>
<li><p>InputReaderThread、InputDispatcherThread：因为InputReader 和 InputDispatcher都是耗时操作，因此创建 单独线程 来运行他们。这就是他们运行的线程。</p>
</li>
</ul>
<h2 id="输入事件中的模块"><a href="#输入事件中的模块" class="headerlink" title="输入事件中的模块"></a>输入事件中的模块</h2><p>Android输入系统，主要包含以下几个模块：</p>
<p>发送端：运行在system_server进程，主要运行在<code>InputReaderThread</code>和<code>InputDispatcherThread</code>。</p>
<ul>
<li><code>InputReader</code>：这个模块主要负责从硬件获取输入，转换成事件<code>Event</code>，传给<code>InputDispatcher</code>。</li>
<li><code>InputDispatcher</code>：将<code>InputReader</code>传递过来的事件分发给相应的窗口，并且监控ANR。</li>
</ul>
<p>接收端：运行在应用程序进程，运行在UI线程。</p>
<ul>
<li><code>InputEventReceiver</code>：在App端接收按键，并进行分发。</li>
<li><code>View</code>和<code>Activity</code>：接收按键并进行处理。</li>
</ul>
<p>基础服务：</p>
<ul>
<li><code>InputManagerService</code>：负责<code>InputReader</code>和<code>InputDispatcher</code>的创建。</li>
<li><code>WindowManagerService</code>：管理<code>InputManager</code>与<code>Window</code>及<code>AMS</code>之间的通信。</li>
</ul>
<p>通信机制：<code>socket</code>：发送端和接收端跨进程，采用的是socket的通信机制。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/wms_ims.png" alt="wms_ims"></p>
<p><strong>说明：</strong></p>
<ul>
<li>图中<strong>3个红色虚线框：</strong> 即下面输入事件传递 介绍的3部分内容。IMS中事件的读取和派发；WMS中Window获取事件和传递；View中事件的传递和处理。</li>
<li>图中<strong>2种颜色区域：</strong> 标识2个进程。system_server 和 应用进程。</li>
<li>图中<strong>红色实线箭头：</strong> 文章介绍的 事件传递的 主要过程。</li>
<li>图中<strong>2个红色虚线箭头：</strong> 列出了 两个比较常见的policy拦截的大致阶段 (当然不止这两个)，说明了最终如何回调到PhoneWindowManager的同名方法。</li>
</ul>
<h2 id="事件流程跟踪"><a href="#事件流程跟踪" class="headerlink" title="事件流程跟踪"></a>事件流程跟踪</h2><p>在 startOtherServices()中，创建IMS后，设置了回调，最后有 <code>inputManager.start();</code> ，这个就是 两个线程运行起来 并执行了 threadLoop() 的起点。threadLoop() 会循环执行，InputReaderThread的threadLoop()方法里面执行的就是InputReader，他的作用2就是对获取的事件进行加工处理后 交由 InputDispatcher分派。</p>
<p>具体的处理先不看，<strong>输入事件 由InputReader 获取处理后，传递到InputDispatcher，封装成EventEntry并加入mInboundQueue 队列。</strong>之后就到了InputDispatcherThread线程的逻辑。根据先进先出原则依次处理入队的事件。</p>
<p>取出事件后进行类型判断然后进行一系列的处理，<strong>最终是将事件等信息封装为InputMessage， 通过InputChannel将这个消息发送出去。</strong></p>
<p>上面只是大概总结了一下IMS段做的一些事情，最后消息通过InputChannel发送到目标窗口的进程了。</p>
<blockquote>
<p>在 Android 的输入系统中，<code>InputChannel</code> 是一个用于在不同进程或线程之间传递输入事件的通道。它是一个底层组件，用于在应用程序和系统服务（如 <code>InputManagerService</code>）之间进行输入事件的传输。</p>
</blockquote>
<p>下面到了WMS接收事件，此时WMS所在的进程就是当前的应用进程。</p>
<p>在ViewRootImpl的setView() 方法中会创建一个WindowInputEventReceiver对象， 创建的过程中重要做了这么几件事情：1.在native层创建NativeInputEventReceiver，创建的过程中会将inputChannel封装到mInputConsumer。2.执行initialize()方法，在里面会在主线程的<strong>Looper</strong>中注册输入事件的监听，<strong>当Looper监听到有输入事件时，会回调 NativeInputEventReceiver的handleEvent()方法。</strong>handleEvent()方法会从InputChannel读取信息，并处理保存事件到inputEvent然后回调java层的 InputEventReceiver.dispatchInputEvent。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> consumeBatches, <span class="type">nsecs_t</span> frameTime, <span class="type">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> skipCallbacks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">//从InputChannel读取信息，并处理保存事件到inputEvent，参考2.4.1</span></span><br><span class="line">        <span class="type">status_t</span> status = mInputConsumer.<span class="built_in">consume</span>(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//回调java层的 InputEventReceiver.dispatchInputEvent，参考2.4.2</span></span><br><span class="line">                env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><code>ViewRootImpl</code> 是 Android 中负责将视图（<code>View</code>）层次结构附加到窗口并进行布局、绘制等操作的内部类。</p>
<p><code>setView()</code> 方法是 <code>ViewRootImpl</code> 中的一个关键方法，它用于设置视图层次结构的根视图，并启动视图的布局和绘制过程。</p>
<p><code>WindowInputEventReceiver</code> 是 Android 系统中用于接收输入事件的类。</p>
<p><code>NativeInputEventReceiver</code> 是 Android 输入系统的一部分，用于在原生代码层接收来自输入设备的事件。</p>
</blockquote>
<p>WindowInputEventReceiver是继承自InputEventReceiver的也就是回调了WindowInputEventReceiver的dispatchInputEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">InputEventReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInputEvent</span><span class="params">(InputEvent event)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (processedEvents != <span class="literal">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//输入事件 加入队列，插到队列尾部</span></span><br><span class="line">            enqueueInputEvent(event, <span class="built_in">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队之后就是在ViewRootImpl::enqueueInputEvent函数中依次处理队列中的事件具体的代码就不贴了，也就是层层函数传递。最终传递到下面这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ViewRootImpl</span><br><span class="line"><span class="comment">// 这是按键触发的事件 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">KeyEvent</span> <span class="variable">event</span> <span class="operator">=</span> (KeyEvent)q.mEvent;</span><br><span class="line">        ...</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> FORWARD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触屏触发的事件</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">MotionEvent</span> <span class="variable">event</span> <span class="operator">=</span> (MotionEvent)q.mEvent;</span><br><span class="line">       <span class="comment">// 处理手写事件</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> mHandwritingInitiator.onTouchEvent(event);</span><br><span class="line">		   ...</span><br><span class="line">        handled = handled || mView.dispatchPointerEvent(event);</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的mView就是DecorView，然后看下DecorView的dispatchKeyEvent实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">keyCode</span> <span class="operator">=</span> event.getKeyCode();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isDown</span> <span class="operator">=</span> action == KeyEvent.ACTION_DOWN;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mWindow.isDestroyed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> cb != <span class="literal">null</span> &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchKeyEvent(event)</span><br><span class="line">                : <span class="built_in">super</span>.dispatchKeyEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isDown ? mWindow.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">            : mWindow.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是Activity的窗口，cb获取到的是Activity，mFeatureId是-1。这里的mWindow是PhoneWindow，即Activity在attach()时 创建的PhoneWindow，在setContentView()过程 通过mDecor.setWindow()传入到DecorView中的。</p>
<p>这个mWindow.getCallback()获取的是Activity本身，即Activity在attach()时setCallback() 传入的this本身。</p>
<p>DecorView没有自己实现dispatchPointerEvent方法，dispatchPointerEvent的具体实现在View类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    	<span class="comment">// 判断是否是触摸事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后这里会调用DecorView的dispatchTouchEvent(event)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">      <span class="keyword">return</span> cb != <span class="literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">              ? cb.dispatchTouchEvent(ev) : <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	这里的cb就是activity然后调用了它的dispatchTouchEvent方法。</p>
<p><strong>总结：</strong></p>
<p>内核将原始事件写入到设备文件中，InputReader 不断地通过 EventHub 将原始事件取出来，解析加工成 KeyEvent、MotionEvent 事件，然后交给 InputDispatcher</p>
<p>InputDispatcher 根据 WMS 提供的窗口信息将事件交给合适的窗口</p>
<p>接着，窗口的 ViewRootImpl 对象再沿着控件树将事件派发给感兴趣的控件，控件对其收到的事件作出响应，更新自己的画面、执行特定的动作</p>
<h1 id="Android-View事件分发"><a href="#Android-View事件分发" class="headerlink" title="Android View事件分发"></a>Android View事件分发</h1><p><a href="https://www.jianshu.com/p/38015afcdb58">https://www.jianshu.com/p/38015afcdb58</a></p>
<h2 id="分发的事件是什么"><a href="#分发的事件是什么" class="headerlink" title="分发的事件是什么"></a>分发的事件是什么</h2><p>我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的。根据不同动作，主要有以下三种事件类型：<br>1.ACTION_DOWN：<strong>手指刚接触屏幕，按下去的那一瞬间产生该事件</strong><br>2.ACTION_MOVE：<strong>手指在屏幕上移动时候产生该事件</strong><br>3.ACTION_UP：<strong>手指从屏幕上松开的瞬间产生该事件</strong></p>
<p><strong>从ACTION_DOWN开始到ACTION_UP结束我们称为一个事件序列</strong></p>
<p>正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在MotionEvent上来讲无外乎下面两种。<br><strong>1.点击后抬起，也就是单击操作：ACTION_DOWN -&gt; ACTION_UP<br>2.点击后再风骚的滑动一段距离，再抬起：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP</strong></p>
<h2 id="MotionEvent事件分发的三个方法"><a href="#MotionEvent事件分发的三个方法" class="headerlink" title="MotionEvent事件分发的三个方法"></a>MotionEvent事件分发的三个方法</h2><ul>
<li><p><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong><br>通过方法名我们不难猜测，它就是事件分发的重要方法。那么很明显，如果一个MotionEvent传递给了View，那么dispatchTouchEvent方法一定会被调用！<br>返回值：表示是否消费了当前事件。可能是View本身的onTouchEvent方法消费，也可能是子View的dispatchTouchEvent方法中消费。返回true表示事件被消费，本次的事件终止。返回false表示View以及子View均没有消费事件，将调用父View的onTouchEvent方法</p>
</li>
<li><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong><br>事件拦截，当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。特别注意，这是ViewGroup特有的方法，View并没有拦截方法<br>返回值：是否拦截事件传递，返回true表示拦截了事件，那么事件将不再向下分发而是调用View本身的onTouchEvent方法。返回false表示不做拦截，事件将向下分发到子View的dispatchTouchEvent方法。</p>
</li>
<li><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong><br>真正对MotionEvent进行处理或者说消费的方法。在dispatchTouchEvent进行调用。<br>返回值：返回true表示事件被消费，本次的事件终止。返回false表示事件没有被消费，将调用父View的onTouchEvent方法</p>
</li>
</ul>
<p>上面的三个方法可以用以下的伪代码来表示其之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//事件是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev))&#123;<span class="comment">//调用onInterceptTouchEvent判断是否拦截事件</span></span><br><span class="line">        consume = onTouchEvent(ev);<span class="comment">//如果拦截则调用自身的onTouchEvent方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);<span class="comment">//不拦截调用子View的dispatchTouchEvent方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;<span class="comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件分发的具体流程"><a href="#事件分发的具体流程" class="headerlink" title="事件分发的具体流程"></a>事件分发的具体流程</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。那么很明显我们先看Activity的dispatchTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Activity：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getWindow().superDispatchTouchEvent(ev)方法发现是Window类当中的一个抽象方法，Window的唯一实现类是PhoneWindow。那么去看PhoneWindow对应的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneWindow</span></span><br><span class="line">    <span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line">    <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个DecorView就是Window的顶级View，我们通过setContentView设置的View是它的子View，</strong>到这里事件已经被传递到我们的顶级View中，一般是ViewGroup。</p>
<p>看看ViewGroup的dispatchTouchEvent方法实现，代码比较多先看下判断是否拦截事件的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// 在开始新的触摸手势时，丢弃所有以前的状态。由于应用切换、ANR 或其他一些状态更改，框架可能已删除上一个手势的 up 或 cancel 事件。</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里会执行 mFirstTouchTarget = null;  mFirstTouchTarget是用来承载处理事件的子View对象，这个对象非常重要，它决定了ViewGroup是否拦截事件</span></span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否拦截事件的标志位</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">    	   <span class="comment">// 判断是否是ACTION_DOWN事件和mFirstTouchTarget是否为null，如果是ACTION_DOWN事件说明是一个新的事件或者mFirstTouchTarget不为null说明有处理事件的子View，会然后会判断子view是否调用了requestDisallowInterceptTouchEvent方法来禁止ViewGroup拦截，判断通过后会调用onInterceptTouchEvent方法来判断最终是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查触摸事件是否来自鼠标设备</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            <span class="comment">// 检查触摸事件的动作是否为按下（ACTION_DOWN）</span></span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            <span class="comment">// 检查是否按下了主要的鼠标按钮</span></span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            <span class="comment">// 调用isOnScrollbarThumb方法检查是否在滚动条拇指上</span></span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getXDispatchLocation(<span class="number">0</span>), ev.getYDispatchLocation(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">// 如果上述条件都为真，表示需要拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件有一个为假，表示不需要拦截该事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码，通过判断actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN和 mFirstTouchTarget !&#x3D; null判断是否拦截，这里有一点要注意的是，根据逻辑 <strong>如果ViewGroup没有拦截ACTION_DOWN事件的话说明这组事件会有子view处理，所以mFirstTouchTarget 不会为null。否则的话mFirstTouchTarget 为null且不是ACTION_DOWN事件说明之前拦截了ACTION_DOWN事件，则后面的事件直接拦截。</strong></p>
<p><strong>mFirstTouchTarget 是否有值决定了ViewGroup是否拦截ACTION_DOWN以外的事件</strong></p>
<p>假设这里不拦截的话，看后续的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="comment">//对子View进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断1，View可见并且没有播放动画。2，点击事件的坐标落在View的范围内</span></span><br><span class="line">            <span class="comment">//如果上述两个条件有一项不满足则continue继续循环下一个View</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 走到这里说明找到了满足的子View了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里会判断mFirstTouchTarget，因为目前还未将事件传递给子view所以还是null 返回的也会是null</span></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="comment">//如果有子View处理即newTouchTarget 不为null则跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">//dispatchTransformedTouchEvent第三个参数child这里不为null，实际调用的是child的dispatchTouchEvent方法，具体实现可以看下面。 重点方法</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX = ev.getX();</span><br><span class="line">                mLastTouchDownY = ev.getY();</span><br><span class="line">                <span class="comment">//当child处理了点击事件，那么会设置mFirstTouchTarget 在addTouchTarget被赋值，具体实现看下面</span></span><br><span class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//子View处理了事件，然后就跳出了for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     ......</span><br><span class="line">         <span class="comment">// 如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false） </span></span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true，子View为GroupView的话会重复上面的逻辑，不是的话会直接走View的dispatchTouchEvent方法。</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">     	<span class="comment">// 这里给mFirstTouchTarget赋值了，也就是上面说的是否处理了事件看mFirstTouchTarget是否为null</span></span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示ViewGroup进行事件传递的逻辑，在dispatchTransformedTouchEvent中会判断子View是否消费了事件，如果消费了会给mFirstTouchTarget赋值否则mFirstTouchTarget仍为null。</p>
<p>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）。会再次调用dispatchTransformedTouchEvent方法，且传入得child为null。</p>
<p>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">           handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">           handled = child.dispatchTouchEvent(event);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>目前为止ViewGroup的事件处理逻辑分析完了。</p>
<p><strong>结论</strong>：</p>
<blockquote>
<p><strong>ViewGroup会遍历所有子View去寻找能够处理点击事件的子View（可见，没有播放动画，点击事件坐标落在子View内部）最终调用子View的dispatchTouchEvent方法处理事件</strong></p>
</blockquote>
<blockquote>
<p><strong>当子View处理了事件则mFirstTouchTarget 被赋值，并终止子View的遍历。</strong></p>
</blockquote>
<blockquote>
<p><strong>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）那么ViewGroup会去处理这个事件（本质调用View的dispatchTouchEvent去处理）</strong></p>
</blockquote>
<p>如果ViewGrop处理这个事件的话会调用View的dispatchTouchEvent。如果不是ViewGroup处理事件，而是普通的View处理事件的话会直接调用View的dispatchTouchEvent方法。</p>
<p>所以最终都会走到View的dispatchTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">//如果窗口没有被遮盖</span></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            <span class="comment">//当前监听事件</span></span><br><span class="line">            <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">            <span class="comment">//需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件,如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//result为false调用自己的onTouchEvent方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		View会先判断是否设置了OnTouchListener，<strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong> <strong>且当前View的dispatchTouchEvent方法就会返回false。</strong>当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法</p>
<p>​		执行顺序：ViewGroup&#x2F;View的onTouch() -&gt; onTouchEvent() -&gt; performClick（） -&gt; onClick()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    ... </span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span></span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p><strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>加一个知识点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">            setLongClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>View的setOnClickListener会默认将View的clickable设置成true。<br>View的setOnLongClickListener同样会将View的longClickable设置成true。</strong></p>
<p><strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong>这里的View的dispatchTouchEvent就会返回false，也就是dispatchTransformedTouchEvent方法会返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的<strong>dispatchTouchEvent是View嵌套调用的</strong>，所以最终的结果会由View层回调到Window层中，看一下原来的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值又会返回到Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个事件循环结束了循环</p>
<p>面试回答的时候为了逻辑清晰，可以定义一个只有一个ViewGroup和View的传递链</p>
<p>Activity - GroupView - View</p>
<p>事件由Activity 开始传递，然后到了GroupView 再到View，事件传递主要的逻辑就是GroupView层和 View层，</p>
<p>​		首先事件会走到Activity 的dispatchTouchEvent方法，里面会调用Window的superDispatchTouchEvent方法去处理事件。Window就是一个ViewGroup。如果Window没有处理了事件会调用Activity的onTouchEvent方法去消费事件。</p>
<blockquote>
<p>Window类是抽象类，其唯一实现类PhoneWindow类，superDispatchTouchEvent方法中会调用DecorView的superDispatchTouchEvent方法，而superDispatchTouchEvent方法中会调用ViewGroup的dispatchTouchEvent()方法。</p>
</blockquote>
<p>​		回到原来的逻辑，目前事件传递到了ViewGroup层，Window的superDispatchTouchEvent方法中会调用DecorView的事件分发方法。DecorView就是个FrameLayout，所以事件到了Viewgroup层。</p>
<p>​		Viewgroup的dispatchTouchEvent方法的逻辑，首先逻辑开始会判断要不要拦截当前事件，判断是否拦截会有两个判断条件。一个是当前的action事件是否为down事件，还有一个就是子View是否处理了事件的标志位。如果是down事件或者标志位不等于null会进行第二次判断，判断子view是否禁止当前父view拦截事件。默认是false，然后会调用onInterceptTouchEvent方法判断是否拦截默认是不拦截的。</p>
<p>​		如果既不是ACTION_DOWN事件，mFirstTouchTarget&#x3D;&#x3D;null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定后面move和up事件都会被拦截，因为如果没拦截的话mFirstTouchTarget不会为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    			<span class="comment">// 判断子view是否禁止当前父view拦截事件</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>​		如果判断不拦截的话就会遍历所有的子view寻找目标的view，判断条件有两个：View可见并且没有播放动画、点击事件的坐标落在View的范围内。</p>
<p>​		如果寻找不到的话就会调用ViewGroup的父类，也就是View的dispatchTouchEvent方法。因此会执行ViewGroup的onTouch() -&gt; onTouchEvent() -&gt; performClick（） -&gt; onClick()，即自己处理该事件，事件不会往下传递。</p>
<p>​		如果找到了目标View的话调用子View的dispatchTouchEvent方法，实现了事件的传递，然后最终也是调用了View的dispatchTouchEvent方法。</p>
<p>​		这个方法首先会判断当前View是否设置了OnTouchListener监听，如果设置了监听且onTouch方法返回了true，那么onTouchEvent不会被调用，且当前的dispatchTouchEvent方法直接返回true。如果返回false的话会接着调用onTouchEvent方法。</p>
<p>​		这个方法会判断clickable和longClickable，只要有一个是true就会消费事件，然后会通过switch case判断事件的类型，再up case中会调用当前view设置的点击事件。</p>
<p>​		目前一整个事件传递从activity到view消费的这么一个逻辑，其实主要还是再Viewgroup和View传递的逻辑。之前说了View 消费的情况，我下面说一下View不消费的情况。</p>
<p>​		View不消费的话ViewGroup同样会走View类的dispatchTouchEvent方法的逻辑，然后调用onTouchEvent方法。如果onTouchEvent方法返回false的话事件会返回到Window层然后再返回到Activity层，也就是一开始说的逻辑，会调用activity的onTouchEvent方法。</p>
<p>​		只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p>​		<strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>View的setOnClickListener会默认将View的clickable设置成true。</p>
<p>View的setOnLongClickListener同样会将View的longClickable设置成true。</p>
<h2 id="事件分发native层"><a href="#事件分发native层" class="headerlink" title="事件分发native层"></a>事件分发native层</h2><p><strong><a href="https://www.cnblogs.com/fanglongxiang/p/14091511.html">https://www.cnblogs.com/fanglongxiang/p/14091511.html</a></strong></p>
<h2 id="事件分发处理嵌套Recyclerview的嵌套滑动冲突"><a href="#事件分发处理嵌套Recyclerview的嵌套滑动冲突" class="headerlink" title="事件分发处理嵌套Recyclerview的嵌套滑动冲突"></a>事件分发处理嵌套Recyclerview的嵌套滑动冲突</h2><p>冲突原因：</p>
<p>​		嵌套滑动机制，<code>ViewGroup</code>（如 <code>RecyclerView</code>、<code>NestedScrollView</code> 等）可以作为嵌套滑动的父视图或子视图。在嵌套滑动的上下文中，父视图可以在不直接拦截触摸事件的情况下参与子视图的滑动处理，通过嵌套滑动的回调方法如 <code>onStartNestedScroll</code>、<code>onNestedScroll</code> 等来实现。但是，如果父视图决定处理嵌套滑动，它可能会通过这些机制间接“拦截”子视图的事件。</p>
<p>解决方式：</p>
<p>​		默认让父视图不要拦截触摸事件，然后在子View滑动到底部之后再允许拦截事件。</p>
<p>思路：</p>
<p>​		当用户开始触摸时（即 <code>ACTION_DOWN</code> 事件发生），记录初始触摸点的 <code>Y</code> 坐标。此外，通过调用 <code>requestDisallowInterceptTouchEvent(true)</code> 通知父视图不要拦截后续的触摸事件，这样可以确保子 <code>RecyclerView</code> 能够接收到完整的滑动事件序列（例如，连续的 <code>ACTION_MOVE</code> 事件）。</p>
<p>​		而当子 <code>RecyclerView</code> 滚动到顶部或底部时，后续的滑动操作能够传递给父 <code>RecyclerView</code>，从而允许父 <code>RecyclerView</code> 进行滑动。</p>
<p>给子View设置OnTouchListener</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildScrollTouchListener</span>(<span class="keyword">private</span> <span class="keyword">val</span> childRecyclerView: RecyclerView) : View.OnTouchListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initialY = <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouch</span><span class="params">(v: <span class="type">View</span>, event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                initialY = event.y</span><br><span class="line">                <span class="comment">// 明确地请求父视图不要拦截触摸事件</span></span><br><span class="line">                v.parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">               <span class="comment">// 检查子 RecyclerView 是否能够向上滚动。如果返回 false，表示已经滚动到顶部</span></span><br><span class="line">			  <span class="keyword">val</span> canScrollUp = childRecyclerView.canScrollVertically(-<span class="number">1</span>)</span><br><span class="line">			  <span class="comment">// 检查子 RecyclerView 是否能够向下滚动。如果返回 false，表示已经滚动到底部</span></span><br><span class="line">               <span class="keyword">val</span> canScrollDown = childRecyclerView.canScrollVertically(<span class="number">1</span>)</span><br><span class="line">		      <span class="comment">// 比较当前触摸点的 Y 坐标和初始触摸点的 Y 坐标，如果当前的 Y 大于初始的 Y，说明是向上滚动的手势</span></span><br><span class="line">			 <span class="keyword">val</span> isScrollingUp = event.y &gt; initialY</span><br><span class="line">			 <span class="comment">// 同理，如果当前的 Y 小于初始的 Y，说明是向下滚动的手势</span></span><br><span class="line">   			 <span class="keyword">val</span> isScrollingDown = event.y &lt; initialY</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((isScrollingUp &amp;&amp; !canScrollUp) || (isScrollingDown &amp;&amp; !canScrollDown)) &#123;</span><br><span class="line">                    <span class="comment">// 如果子 RecyclerView 滑动到顶部并且继续向上滑，或者滑动到底部并继续向下滑</span></span><br><span class="line">                    <span class="comment">// 则允许父 RecyclerView 捕获滑动事件</span></span><br><span class="line">                    v.parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不消耗事件，让子 RecyclerView 正常处理滑动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置给子Recyclerview</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">holder.childRecyclerView.apply &#123; setOnTouchListener(ChildScrollTouchListener(<span class="keyword">this</span>)) &#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>在事件传递到ViewGroup之后会有这么个判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取子View是否禁止拦截</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">      <span class="comment">// onInterceptTouchEvent默认是不拦截的</span></span><br><span class="line">      intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">      ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 不拦截</span></span><br><span class="line">         intercepted = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h1><h2 id="自定义-View实现方式"><a href="#自定义-View实现方式" class="headerlink" title="自定义 View实现方式"></a>自定义 View实现方式</h2><p>总结下来有三种：</p>
<ul>
<li>继承某个控件，然后对它的一些功能进行修改，或者删除添加</li>
<li>将多个控件组合在一起形成一个新的View</li>
<li>继承 View &#x2F; ViewGroup 类，重写 <strong><code>onMeasure()</code><strong>、</strong><code>onLayout()</code><strong>、</strong><code>onDraw()</code></strong> 三大方法，从 0 到 1 创造一个新的控件。</li>
</ul>
<p>代码示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaterialEdit</span>(context: Context,attrs:AttributeSet) :</span><br><span class="line">    AppCompatEditText(context,attrs) &#123; <span class="comment">// 定义一个名为 MaterialEdit 的类，继承自 AppCompatEditText</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量和变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_SIZE = <span class="number">12.</span>dp  <span class="comment">// 文本大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_MARGIN = <span class="number">8.</span>dp <span class="comment">// 文本边距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> HORIZONTAL_OFFSET = <span class="number">5.</span>dp <span class="comment">// 水平偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> VERTICAL_OFFSET = <span class="number">23.</span>dp <span class="comment">// 垂直偏移量  浮动标签距离view顶部的向下偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> EXTRA_VERTICAL_OFFSET = <span class="number">16.</span>dp <span class="comment">// 便签动画时的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG) <span class="comment">// 创建一个 Paint 对象，用于绘制文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> floatingLabelShown = <span class="literal">false</span> <span class="comment">// 一个标志，表示浮动标签是否正在显示</span></span><br><span class="line">    <span class="keyword">var</span> useFloatingLabel = <span class="literal">false</span> <span class="comment">// 一个标志，表示是否使用浮动标签</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field != value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                <span class="keyword">if</span> (field) &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop + TEXT_SIZE + TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop - TEXT_SIZE - TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">            <span class="keyword">by</span> lazy &#123;</span><br><span class="line">                ObjectAnimator.ofFloat(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.textSize = TEXT_SIZE <span class="comment">// 设置 Paint 的文本大小</span></span><br><span class="line">        <span class="comment">// 获取自定义属性 useFloatingLabel 的值  会触发 set 方法</span></span><br><span class="line">        <span class="keyword">val</span> typeArray = context.obtainStyledAttributes(attrs,R.styleable.MaterialEdit)</span><br><span class="line">        useFloatingLabel = typeArray.getBoolean(R.styleable.MaterialEdit_useFloatingLabel,<span class="literal">true</span>)</span><br><span class="line">        typeArray.recycle() <span class="comment">// 回收 typeArray</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 EditText 中的文本改变时，执行这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        text: <span class="type">CharSequence</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        start: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthBefore: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthAfter: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮动标签正在显示，且文本变为空，那么隐藏浮动标签</span></span><br><span class="line">        <span class="keyword">if</span> (floatingLabelShown &amp;&amp; text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">false</span></span><br><span class="line">            animator.reverse() <span class="comment">// 执行动画的逆向操作，即隐藏浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果浮动标签没有显示，且文本不为空，那么显示浮动标签</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!floatingLabelShown &amp;&amp; !text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">true</span></span><br><span class="line">            animator.start() <span class="comment">// 开始执行动画，即显示浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个方法中绘制 EditText 的界面</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas) <span class="comment">// 调用父类的 onDraw 方法，绘制 EditText 的主体</span></span><br><span class="line">        paint.alpha = (floatingLabelFraction * <span class="number">0xff</span>).toInt() <span class="comment">// 根据动画的进度，设置 Paint 的透明度</span></span><br><span class="line">        <span class="comment">// 计算当前的垂直位置</span></span><br><span class="line">        <span class="keyword">val</span> currentVerticalValue =</span><br><span class="line">            VERTICAL_OFFSET + EXTRA_VERTICAL_OFFSET * (<span class="number">1</span> - floatingLabelFraction)</span><br><span class="line">        <span class="comment">// 在计算出的位置绘制提示文本</span></span><br><span class="line">        hint?.toString()?.let &#123;</span><br><span class="line">            canvas.drawText(</span><br><span class="line">                it,</span><br><span class="line">                HORIZONTAL_OFFSET,</span><br><span class="line">                currentVerticalValue,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义-View-Demo"><a href="#自定义-View-Demo" class="headerlink" title="自定义 View Demo"></a>自定义 View Demo</h1><h2 id="歌词自定义View"><a href="#歌词自定义View" class="headerlink" title="歌词自定义View"></a>歌词自定义View</h2><h1 id="Android-动画"><a href="#Android-动画" class="headerlink" title="Android 动画"></a>Android 动画</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p><strong>帧动画（Frame Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">val frameAnimation = imageView.background as AnimationDrawable</span><br><span class="line">frameAnimation.start()</span><br></pre></td></tr></table></figure>

<p><strong>补间动画（Tween Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">val rotateAnimation = AnimationUtils.loadAnimation(context, R.anim.rotate)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p><strong>属性动画（Property Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">2000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure>

<p><strong>过渡动画（Transition Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup = findViewById(R.id.scene_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> scene1: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene1, context)</span><br><span class="line"><span class="keyword">val</span> scene2: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene2, context)</span><br><span class="line"></span><br><span class="line">TransitionManager.go(scene2, TransitionInflater.from(context).inflateTransition(R.transition.example_transition))</span><br></pre></td></tr></table></figure>

<p><strong>触摸反馈动画（Touch Feedback Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义触摸反馈动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;?android:attr/colorControlHighlight&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/button_normal&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br><span class="line">button.background = ContextCompat.getDrawable(context, R.drawable.ripple)</span><br></pre></td></tr></table></figure>

<p><strong>物理动画（Physics-based Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> springAnimation = SpringAnimation(imageView, DynamicAnimation.ROTATION, <span class="number">0f</span>)</span><br><span class="line">springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW</span><br><span class="line">springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY</span><br><span class="line">springAnimation.start()</span><br></pre></td></tr></table></figure>

<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">   imageView.setBackgroundResource(R.drawable.animation)</span><br><span class="line">   <span class="keyword">val</span> animationDrawable = imageView.background <span class="keyword">as</span> AnimationDrawable</span><br><span class="line">   animationDrawable.start()</span><br></pre></td></tr></table></figure>

<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.ani)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p>补间动画的属性</p>
<p>补间动画（Tween Animation）在 Android 中主要包括四种类型：AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation，它们分别对应透明度、缩放、位移和旋转四种动画效果。</p>
<p>以下是这四种补间动画的主要属性：</p>
<ol>
<li><strong>AlphaAnimation（透明度动画）</strong>：<ul>
<li>fromAlpha：动画开始时视图的透明度（0.0 - 1.0）</li>
<li>toAlpha：动画结束时视图的透明度（0.0 - 1.0）</li>
</ul>
</li>
<li><strong>ScaleAnimation（缩放动画）</strong>：<ul>
<li>fromXScale：动画开始时视图的X轴缩放比例</li>
<li>toXScale：动画结束时视图的X轴缩放比例</li>
<li>fromYScale：动画开始时视图的Y轴缩放比例</li>
<li>toYScale：动画结束时视图的Y轴缩放比例</li>
<li>pivotX：X轴的缩放中心点</li>
<li>pivotY：Y轴的缩放中心点</li>
</ul>
</li>
<li><strong>TranslateAnimation（位移动画）</strong>：<ul>
<li>fromXDelta：动画开始时视图在X轴的位置</li>
<li>toXDelta：动画结束时视图在X轴的位置</li>
<li>fromYDelta：动画开始时视图在Y轴的位置</li>
<li>toYDelta：动画结束时视图在Y轴的位置</li>
</ul>
</li>
<li><strong>RotateAnimation（旋转动画）</strong>：<ul>
<li>fromDegrees：动画开始时视图的旋转角度</li>
<li>toDegrees：动画结束时视图的旋转角度</li>
<li>pivotX：旋转的中心点X坐标</li>
<li>pivotY：旋转的中心点Y坐标</li>
</ul>
</li>
</ol>
<p>以上每种动画类型的属性都可以在 XML 中定义，也可以在代码中动态设置。除了这些特定的属性外，所有的补间动画还有一些共同的属性，例如：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>fillAfter：动画结束后，视图是否保持动画结束时的状态</li>
<li>fillBefore：动画开始前，视图是否保持动画开始时的状态</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatMode：动画的重复模式（重新开始或反向执行）</li>
<li>interpolator：动画的插值器（用于控制动画的速度变化）</li>
</ul>
<p>区域问题</p>
<p>补间动画虽然能对控件做动画 ，但是并没有改变控件内 部 的属性值 。也就是说只是做了动画，它的位置属性啥的都没有变。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>​		补间动画和逐帧动画统称为视图动画 ，从字面意思中可以看 出，这两个动画只能对派生自 View 类的控件实例起作用； 而属性动画则不同，从名字 中可以看出它应该是作用于控件属性的 。<strong>正因为属性动画 能够只针对控件的某一个属性来做动画，所以造就了它能单独改变控件某一个属性的值 ，比如颜色 。</strong></p>
<p>属性动画分为ValueAnimator 和 ObjectAnimator 。</p>
<h3 id="ValueAnimator-："><a href="#ValueAnimator-：" class="headerlink" title="ValueAnimator ："></a><strong>ValueAnimator</strong> ：</h3><p>简单使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">   animator.setDuration(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 在这里监听</span></span><br><span class="line">   animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">       <span class="comment">// 可以在这里根据value值对View进行操作</span></span><br><span class="line">       <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">       loge(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   animator.start()</span><br></pre></td></tr></table></figure>

<p>比如用来移动View</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">		<span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(value, value, value + imageView.width, value + imageView.height)</span><br><span class="line">        &#125;</span><br><span class="line">	    animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationStart&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationEnd&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationRepeat&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        animator.start()</span><br><span class="line">	    <span class="comment">//无限次重复的动画必须得在合适的时机cancel</span></span><br><span class="line">        animator.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View就会沿着从左上角到右下角的对角线进行移动。1秒钟完成动画，然后无限次的重复动画。</p>
<h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">animator.interpolator = AccelerateDecelerateInterpolator()</span><br></pre></td></tr></table></figure>

<p>Android SDK 提供了多种内置的插值器：</p>
<ol>
<li><code>LinearInterpolator</code>: 时间和动画进度之间是线性关系，也就是匀速运动。</li>
<li><code>AccelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐加快。</li>
<li><code>DecelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐减慢。</li>
<li><code>AccelerateDecelerateInterpolator</code>: 动画开始时速度逐渐加快，然后在结束时速度逐渐减慢。</li>
<li><code>AnticipateInterpolator</code>: 开始时，先向相反方向改变一段距离，然后再沿正常方向开始动画。</li>
<li><code>OvershootInterpolator</code>: 动画结束时，会超出目标值一些，然后再弹回来。</li>
<li><code>AnticipateOvershootInterpolator</code>: 开始时向相反方向改变，结束时超出目标值，然后再弹回。</li>
<li><code>BounceInterpolator</code>: 动画结束时，会像弹球一样多次弹跳。</li>
<li><code>CycleInterpolator</code>: 动画会循环指定的次数，每次循环都包括一个正向和一个反向的动画。</li>
<li><code>FastOutSlowInInterpolator</code>: 开始时快速，然后慢慢减速。</li>
</ol>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">100</span>, <span class="number">400</span>)</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">        loge(currentValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里currentValue的计算公式为，比如都到了全程的百分二十</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentValue = 100 + (400 -100)x 0.2</span><br></pre></td></tr></table></figure>

<p>这个0.2也就是进度值时插值器里的getinterpolatio方法返回的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getInterpolation</span><span class="params">(<span class="type">float</span> input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>input 参数与任何我们设定的值没有关系，只与时间有关 ，随着时间的推移，动画的进度也自然地增加，input 参数就代表了当前动画的进度，而返回值则表示动画的当前数值进度。</p>
<p>Linearlnterpolator插值器中就直接返回了input</p>
<p>所以自定义插值器只需要实现TimeInterpolator 接口然后自定义getInterpolation方法的返回值就可以了。</p>
<h3 id="Evaluator估值器"><a href="#Evaluator估值器" class="headerlink" title="Evaluator估值器"></a>Evaluator估值器</h3><p>作用：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1705668341835.jpg" alt="1705668341835"></p>
<p>我们通过监昕器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值 。 那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator 。Evaluator 用 于将从插值器返回的数值进度转换成对应的数值。</p>
<p>oflnt（）和ofFloat（）都是系统直接提供的函数 ，所以会有默认的插值器和 Evaluator 可供使用 。</p>
<p>以IntEvaluator为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startInt</span> <span class="operator">=</span> startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>(int)(startInt + fraction * (endValue - startInt))</code>就等价于上面的<code>currentValue = 100 + (400 -100)×进度值</code></p>
<p>自定义Evaluator</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEvaluator</span> : <span class="type">android.animation.TypeEvaluator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Int</span>, endValue: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.setEvaluator(ReverseEvaluator())</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(imageView.left, currentValue, imageView.right, currentValue + imageView.height)</span><br><span class="line">            loge(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br></pre></td></tr></table></figure>

<p>最终实现了View从下到上也就是从终点到起点的运动。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p><strong>ValueAnimator 有一个缺点 ，就是只能对动画中的数值进行计算 。</strong> 如果想对那个个控件执行操作，就需要监听 ValueAnimator 的动画过程，相比于补间动画要烦琐得多 。所以在 ValueAnimator 的基础上派生了 一个类 ObjectAnimator 。ObjectAnimator 是直接针对属性进行改变。 </p>
<p><strong>简单使用</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">    <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView,<span class="string">&quot;alpha&quot;</span>,<span class="number">0f</span>,<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// 一次的动画时常为2000毫秒</span></span><br><span class="line">    animator.setDuration(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">    animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">    animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">    animator.start()</span><br></pre></td></tr></table></figure>

<p>代码设置了imageView的透明度的从0到1的变化动画，ObjectAnimator 做动画，并不是根据控件XML 中的属性来改变的，而是通过指定属性所对应的 set 函数来改变的。View类中定义了alpha的set函数。</p>
<h3 id="ObjectAnimator动画原理"><a href="#ObjectAnimator动画原理" class="headerlink" title="ObjectAnimator动画原理"></a>ObjectAnimator动画原理</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122162025356.png" alt="image-20240122162025356"></p>
<p>​		在 ObjectAnimator 的动画流程中，先通过插值器产生当前进度的百分比，然后再经过 Evaluator 生成对应百分比所对应的数字值 。 这两步与 ValueAnimator 的动画流程是完全一样的，唯一不同的是最后一步，在 ValueAnimator 中，需要通过添加监昕器来监昕当前的数值；而在 ObjectAnimator 中，则先根据属性值拼装成对应的 set 函数的名 字（ 比如这里的scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，得到 setScaleY ），然后通过反射找到对应控件的setScaleY (float scale Y）函数，井将当前的数值作为setScaleY (floatscaleY）函数的参数传入 。</p>
<p>​		第一，拼接 set 函数的方法。<strong>首先强制将属性的第一个字母大写 ，然后与 set 拼接</strong>，就得到对应的 set 函数的名字。注意，只是强制将属性的第一个字母大写 ，后面的部分是保持不变的 。反过来， 如果我们的函数名为 setScalePointX（），那么在写属性时可以写成 scalePointX 或者 ScalePointX，<strong>即第一个字母大小写随意，但是后面的部分必须与set 函数后面部分的大小写保持一致 。找函数这一步是通过反射来实现的。</strong></p>
<p>​		第二，如何确定函数的参数类型？我们知道了如何找到对应的函数名，那么对应方法中的参数类型如何确定呢？我们在介绍 ValueAnimator 的时候说过，动画过程中产生的数值与构造时传入的值类型是一样的。由于 ObjectAnimator 与 ValueAnimator 在插值器和 Evaluator 这两步是完全一样的，而当前的动画数值是在 Evaluator 这一步产生的，所以 ObjectAnimator 的动画中产生的数值类型与构造时传入的值类型也是一样的。</p>
<p>​		第三，调用set 函数以后怎么办 ？从ObjectAnimator 的动画流程中可以看到，ObjectAnimator 只负责把动画过程中的数值传到对应属性的 s et 函数中就结束了。注意，传给set 函数以后就结束了！set 函数就相当于我们在ValueAnimator 中添加的监听器，set 函数中对控件的操作还是需要由我们自己来写的。</p>
<h3 id="自定义-ObjectAnimator-属性"><a href="#自定义-ObjectAnimator-属性" class="headerlink" title="自定义 ObjectAnimator 属性"></a>自定义 ObjectAnimator 属性</h3><p>在自定义View的时候，可以来自定义一个属性来实现动画的载体。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">       <span class="keyword">set</span>(value) &#123;</span><br><span class="line">           field = value</span><br><span class="line">           invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">           <span class="keyword">by</span> lazy &#123;</span><br><span class="line">               ObjectAnimator.ofFloat(</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                   <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中floatingLabelFraction就是自定义的属性，然后再ofFloat方法中的target设置为this。</p>
<p>当且仅当动画只有一个过渡值时，系统才会调用对应属性的 get 函数来得到动画的初始值。如下面</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">&quot;floatingLabelFraction&quot;</span>, <span class="number">1f</span> )</span><br></pre></td></tr></table></figure>

<p>当不存在 get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h3 id="组合动画AnimatorSet"><a href="#组合动画AnimatorSet" class="headerlink" title="组合动画AnimatorSet"></a>组合动画AnimatorSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translation</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  <span class="comment">// 平移动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);  <span class="comment">// 旋转动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 透明度动画 // 创建组合动画的对象 </span></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();  <span class="comment">// 根据需求组合动画 </span></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  <span class="comment">//启动动画 </span></span><br><span class="line">animSet.start()</span><br></pre></td></tr></table></figure>

<p>常用的组合方法</p>
<ul>
<li>AnimatorSet.play(Animator anim)   ：播放当前动画</li>
<li>AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行</li>
<li>AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行</li>
<li>AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行</li>
<li>AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行</li>
</ul>
<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>PropertyValuesHolder 类的含义就是 ，它其 中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内 部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态 的 。在封装成Prope向NaluesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframeO</span> <span class="operator">=</span> Keyframe . ofFloat(Of , <span class="number">1</span>);</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframel</span> <span class="operator">=</span> Keyframe.ofFloat(O.lf , <span class="number">1.</span>lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframe9</span> <span class="operator">=</span> Keyframe .ofFloat(<span class="number">0</span> . <span class="number">9f</span> , l . lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframelO</span> <span class="operator">=</span> Keyframe . ofFloat(l , <span class="number">1</span>) ;</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">frameHolder2</span> <span class="operator">=</span> PropertyValuesHolder . ofKeyframe (” ScaleX”,</span><br><span class="line">scaleXframeO , scaleXframel, scaleXframe9 , scaleXframelO) ;</span><br><span class="line"> <span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(mimage,frameHolderl,frameHolder2,frameHolder3);</span><br><span class="line">        animator.setDuration(lOOO);</span><br><span class="line">        animator.start();</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator 中唯一一个能实现多动画同时播放的方法。</p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>为 View 的动画操作提供一种更加便捷的用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tvText.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> animator = tvText.animate()</span><br><span class="line">    animator.duration=<span class="number">1000</span></span><br><span class="line">    animator.translationX(<span class="number">100f</span>)<span class="comment">//点击一次会向右偏移，再点击没效果</span></span><br><span class="line">    animator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h4 id="为什么要减少布局的嵌套层次？"><a href="#为什么要减少布局的嵌套层次？" class="headerlink" title="为什么要减少布局的嵌套层次？"></a>为什么要减少布局的嵌套层次？</h4><p><a href="https://rengwuxian.com/compose-intrinsic-measurement/">https://rengwuxian.com/compose-intrinsic-measurement/</a></p>
<h4 id="Android中常用布局的性能对比"><a href="#Android中常用布局的性能对比" class="headerlink" title="Android中常用布局的性能对比"></a>Android中常用布局的性能对比</h4><p>同层级下RelativeLayout会对子View做两次measure，而LinearLayout则只需一次measure过程，但是如果LinearLayout中有weight属性，则也需要进行两次measure。在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。</p>
<p>ConstraintLayout存在的最大目的是减少布局层级和过度绘制，为了实现这个目的，它在绘制的时候会有很多的计算，对于简单布局来说，得不偿失。</p>
<h4 id="requestLayout-会触发draw吗"><a href="#requestLayout-会触发draw吗" class="headerlink" title="requestLayout 会触发draw吗"></a>requestLayout 会触发draw吗</h4><p>不一定</p>
<p>​		requestLayout最终会走到ViewRootImpl的performTraversals方法，然后会触发Measure、Layout 过程。由于没有设置重绘区域，因此Draw 过程将不会触发。</p>
<p>​		但是如果View的尺寸改变了，变大了，那么调用了requestLayout后因为走了Measure、Layout 过程，测量、摆放倒是重新设置了，但是不调用Draw出不来效果。</p>
<p>​		在layout方法里进行判读尺寸是否改变，改变了的话调用invalidate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#View.java</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setFrame</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="literal">true</span>;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldWidth</span> <span class="operator">=</span> mRight - mLeft;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldHeight</span> <span class="operator">=</span> mBottom - mTop;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newWidth</span> <span class="operator">=</span> right - left;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newHeight</span> <span class="operator">=</span> bottom - top;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sizeChanged</span> <span class="operator">=</span> (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line">            <span class="comment">//尺寸发生改变 调用invalidate 传入true，否则传入false</span></span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="invalidate会触发layout吗"><a href="#invalidate会触发layout吗" class="headerlink" title="invalidate会触发layout吗"></a>invalidate会触发layout吗</h4><p>​		invalidate最终会走到ViewRootImpl的performTraversals方法，在ViewRootImpl中mLayoutRequested 的默认值为false，且在invalidate的流程中未对其赋值，所以不会调用layout和measure。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DecorView 实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">layoutRequested</span> <span class="operator">=</span> mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">// 此处可能会调用 performMeasure 方法</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != <span class="literal">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="comment">// 如果 lp.horizontalWeight 或 lp.verticalWeight 大于 0 则重新调用 performMeasure 测量</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            layoutRequested = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">didLayout</span> <span class="operator">=</span> layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cancelDraw</span> <span class="operator">=</span> mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="invalidate和requestLayout的区别"><a href="#invalidate和requestLayout的区别" class="headerlink" title="invalidate和requestLayout的区别"></a>invalidate和requestLayout的区别</h4><ol>
<li>**invalidate()**：<ul>
<li>作用：用于请求重绘当前视图。当视图的内容（如颜色、文本、背景等）发生变化，需要更新显示时，可以调用此方法。</li>
<li>触发过程：<code>invalidate()</code> 会导致视图的 <code>draw()</code> 方法被调用，以便重新绘制视图的外观。</li>
<li>使用场景：当你需要更新视图的显示内容，但视图的大小和位置不变时，使用 <code>invalidate()</code>。</li>
</ul>
</li>
<li>**requestLayout()**：<ul>
<li>作用：用于请求重新测量和布局当前视图及其子视图。当视图的大小或位置需要改变时，可以调用此方法。</li>
<li>触发过程：<code>requestLayout()</code> 会导致视图的 <code>measure()</code> 方法和 <code>layout()</code> 方法被调用，以便重新确定视图及其子视图的大小和位置。</li>
<li>使用场景：当你动态地改变了视图的大小、边距、填充等属性，或者添加、移除子视图时，需要调用 <code>requestLayout()</code> 来通知系统重新布局。</li>
</ul>
</li>
</ol>
<p>​		其实<code>requestLayout</code>和<code>invalidate</code>均会发起<code>scheduleTraversals</code>之后的三大流程，但对于是否分发深入下去，其中的标记位起到了决定性作用。</p>
<p>​		<code>requestLayout</code>必然会进行measure、layout、draw（会根据size是否change在layout时发起invalidate，如果不确定是否change且需要重绘，可以再手动调用invalidate()）</p>
<p>​		<code>invalidate</code>仅会进行draw，当然如果在期间环节，<code>某个view.layoutParams发生变化</code>，导致measure时判断<code>needsLayout</code>为true，那也会进行measure、layout</p>
<h4 id="为什么view-post可以获取到控件高度"><a href="#为什么view-post可以获取到控件高度" class="headerlink" title="为什么view.post可以获取到控件高度"></a>为什么view.post可以获取到控件高度</h4><p>​		post即把action放在view的等待队列<code>mRunQueue</code>中，在<code>performTraversals&gt;&gt;view.dispatchAttachedToWindow</code>会取出所有的<code>handler action</code>推送到ViewRootHandler，由于performTraversals自身就是个<code>handler Runnable</code>，所以view.post内容一定会等到performTraversals完成后才会等到消息队列执行。</p>
<h4 id="怎么实现圆角的ImageView？"><a href="#怎么实现圆角的ImageView？" class="headerlink" title="怎么实现圆角的ImageView？"></a>怎么实现圆角的ImageView？</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义圆角 ImageView 类，继承自 AppCompatImageView</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundImageView</span>(context: Context, attrs: AttributeSet? = <span class="literal">null</span>) :</span><br><span class="line">    androidx.appcompat.widget.AppCompatImageView(context, attrs) &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Path 对象用于绘制圆角矩形路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path: Path = Path()</span><br><span class="line">    <span class="comment">// 定义一个变量用于存储圆角半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cornerRadius: <span class="built_in">Float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// 从布局属性中获取自定义属性</span></span><br><span class="line">        <span class="keyword">val</span> typedArray =</span><br><span class="line">            context.theme.obtainStyledAttributes(attrs, R.styleable.RoundedImageView, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取自定义属性的值，如果没有设置，则使用默认值 20f</span></span><br><span class="line">            cornerRadius = typedArray.getDimension(R.styleable.RoundedImageView_cornerRadius, <span class="number">20f</span>)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 回收 TypedArray 对象</span></span><br><span class="line">            typedArray.recycle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 onDraw 方法以实现自定义绘制逻辑</span></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;DrawAllocation&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个矩形，大小与 ImageView 相同</span></span><br><span class="line">        <span class="keyword">val</span> rect = RectF(<span class="number">0f</span>, <span class="number">0f</span>, width.toFloat(), height.toFloat())</span><br><span class="line">        <span class="comment">// 重置路径对象</span></span><br><span class="line">        path.reset()</span><br><span class="line">        <span class="comment">// 向路径中添加一个圆角矩形</span></span><br><span class="line">        path.addRoundRect(rect, cornerRadius, cornerRadius, Path.Direction.CCW)</span><br><span class="line">        <span class="comment">// 使用路径裁剪画布</span></span><br><span class="line">        canvas.clipPath(path)</span><br><span class="line">        <span class="comment">// 调用父类的 onDraw 方法绘制图像</span></span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他好几种方式：<a href="https://juejin.cn/post/7095200146761187336#heading-3">Android ImageView 圆角实现</a></p>
]]></content>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2024/03/26/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		<strong>重用</strong>存在的线程，<strong>减少</strong>对象创建、消亡的<strong>开销</strong>，提升性能。 可有效<strong>控制最大并发</strong>线程数，提高系统资源的使用率，同时避免过多资源竞争，<strong>避免堵塞</strong>。 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize, //池中允许的最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>int corePoolSize</code>: 核心线程数，即使线程是空闲的，也会一直存活在线程池中，除非设置了<code>allowCoreThreadTimeOut</code>。</p>
<blockquote>
<p><code>allowCoreThreadTimeOut(boolean)</code> 方法用于控制核心线程是否允许超时回收。</p>
</blockquote>
</li>
<li><p><code>int maximumPoolSize</code>: 线程池中允许的最大线程数。当工作队列满了，并且已创建的线程数小于最大线程数时，线程池会再创建新的线程执行任务。</p>
</li>
<li><p><code>long keepAliveTime</code>: 当线程数大于核心线程数时，这是多余空闲线程在终止前等待新任务的最长时间。</p>
</li>
<li><p><code>TimeUnit unit</code>: <code>keepAliveTime</code>参数的时间单位。</p>
</li>
<li><p><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 用于保存等待执行的任务的队列。这个队列仅用于保存由<code>execute</code>方法提交的<code>Runnable</code>任务。</p>
</li>
<li><p><code>RejectedExecutionHandler handler</code>: 当线程池已经达到最大容量并且工作队列也满了时，用于处理新提交的任务的拒绝策略。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> threadPool = Executors.newFixedThreadPool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交10个任务给线程池执行</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">        threadPool.execute &#123;</span><br><span class="line">            println(<span class="string">&quot;Task <span class="variable">$i</span> is running in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    threadPool.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用默认的调度器启动10个协程</span></span><br><span class="line">    repeat(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 将协程的执行切换到IO线程</span></span><br><span class="line">            withContext(Dispatchers.IO) &#123;</span><br><span class="line">                println(<span class="string">&quot;Task <span class="variable">$i</span> is running in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟任务执行耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程池提交任务submit和execute的区别？</p>
<ol>
<li><strong>返回值</strong>:<ul>
<li><code>execute(Runnable command)</code>: 没有返回值。它接受一个<code>Runnable</code>对象作为参数。</li>
<li><code>submit(Callable&lt;T&gt; task)</code>或<code>submit(Runnable task)</code>: 返回一个<code>Future&lt;T&gt;</code>对象。对于<code>submit(Runnable task)</code>，如果任务正常完成，<code>Future</code>的<code>get</code>方法将返回<code>null</code>。</li>
</ul>
</li>
<li><strong>异常处理</strong>:<ul>
<li><code>execute</code>: 如果在执行任务时抛出异常，那么异常将被传递给未捕获异常处理器（如果设置了的话），否则异常将被忽略。</li>
<li><code>submit</code>: 如果任务执行过程中抛出异常，异常将被封装在返回的<code>Future</code>对象中，可以通过调用<code>Future</code>的<code>get</code>方法来获取异常。</li>
</ul>
</li>
<li><strong>任务类型</strong>:<ul>
<li><code>execute</code>只能接受<code>Runnable</code>类型的任务。</li>
<li><code>submit</code>可以接受<code>Runnable</code>或<code>Callable</code>类型的任务。<code>Callable</code>任务允许有返回值，并且可以抛出经过检查的异常。</li>
</ul>
</li>
</ol>
<p>​		通常情况下，如果需要处理异步任务的结果或异常，使用<code>submit</code>比较方便，因为它返回一个<code>Future</code>对象，可以通过这个对象来获取任务的结果或者检查任务是否已经完成。如果不需要关心任务的结果，只是想简单地执行一个任务，那么使用<code>execute</code>就足够了。</p>
<h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p>将任务添加</p>
<ul>
<li><strong>当线程池中的线程数小于核心线程数时</strong>，新提交的任务将创建一个新的核心线程来执行该任务，即使此时线程池中存在空闲线程。</li>
<li><strong>当线程池中的线程数达到核心线程数时</strong>，新提交的任务将被放入任务队列中，等待线程池中的核心线程调度执行。</li>
<li><strong>当任务队列已满且线程池中的线程数量小于最大线程数时</strong>，新提交的任务会创建非核心线程执行任务。</li>
<li><strong>当提交任务数超过最大线程数时</strong>，新提交的任务将由拒绝策略处理。</li>
<li><strong>当线程池中的线程数超过核心线程数时</strong>（即非核心线程），如果这些线程的空闲时间达到了keepAliveTime，这些空闲线程将被关闭。</li>
<li><strong>当设置allowCoreThreadTimeOut(true)时</strong>，线程池中的核心线程在空闲时间达到keepAliveTime后也将被关闭。</li>
</ul>
<h2 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h2><p>Executors工具类中创建线程池一共有6种，每种有一个重载方法，所以能创建线程池方法一共12个。</p>
<ol>
<li><ul>
<li>创建一个固定大小的线程池，线程数和核心线程的值都是传入的值，所有提交的任务都会在这些线程中执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>newCachedThreadPool</strong></p>
<ul>
<li>创建一个可缓存的线程池，如果线程池的大小超过了处理需求，将回收空闲线程，否则添加新线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>newSingleThreadExecutor</strong></p>
<ul>
<li>创建一个单线程的Executor，以无界队列方式来运行该线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>newScheduledThreadPool</strong></p>
<ul>
<li>创建一个固定大小的线程池，支持定时及周期性任务执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>newSingleThreadScheduledExecutor</strong></p>
<ul>
<li>创建一个单线程的定时任务线程池，可以用于延迟执行任务或者定期执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>newWorkStealingPool</strong></p>
<ul>
<li>创建一个工作窃取算法的线程池，该线程池适用于大量短暂异步任务的场景。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h4 id="newFixedThreadPool："><a href="#newFixedThreadPool：" class="headerlink" title="newFixedThreadPool："></a><strong>newFixedThreadPool：</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		创建的线程池的线程数和核心线程的值都是传入的值，因为没有非核心线程所以存活时间设置没有意义。且任务队列为<code>LinkedBlockingQueue</code>默认是无限制的，所以可以一直往任务队列里加任务，永远无法创建非核心线程。进行任务的线程一直都是那么几个核心线程。</p>
<p>​		核心数与最大数设置为同一个值，以此来保证并发控制。但由于这种特殊无界的特性，需要关注到是否合理使用防止OOM的发生。</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>控制资源使用</p>
<p>固定数量的线程池有效控制了系统资源的使用。避免系统资源（如内存）被大量线程耗尽。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>灵活性差</p>
<p>不能动态调整，在某些瞬时高并发的场景下，有界线程池可能无法及时响应大量的任务，如果设置的线程数较小，并且任务提交速度较快，可能导致部分任务一直等待执行，产生线程饥饿的情况。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>​		有界线程池适用于<strong>相对稳定的工作负载，能够限制线程数量，防止资源耗尽。</strong>在选择线程池类型时，需要根据应用场景和性能需求来进行权衡。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>  核心线程数为0，线程池最大线程数为无限制，线程空闲时间为60秒，任务队列为SynchronousQueue一个不存储元素的队列。
</code></pre>
<p>​		这中线程池每个提交的任务都会创建一个非核心线程去执行，提交100个任务就会创建100个线程。但是线程的存活时间有要求。</p>
<p><strong>优点：</strong></p>
<p>​		无界线程池会根据需求动态地创建新线程，无上限地适应任务的数量。使得<strong>线程池能够灵活地适应工作负载的变化。</strong></p>
<p><strong>缺点：</strong></p>
<p>​		线程数量没有上限</p>
<p><strong>总结：</strong></p>
<p>​		无界线程池<strong>适用于任务短暂、处理速度快的场景</strong>，</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> <span class="comment">//这里用到了装饰器模式，这是与Fix的唯一区别</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		这种线程池适合执行那些有顺序要求的任务，且减少了线程的创建和销毁开销，如果任务抛出异常而导致线程终止，会创建一个新的线程来取代原来的线程。</p>
<p>与newFixedThreadPool的区别</p>
<blockquote>
<p><code>FinalizableDelegatedExecutorService</code>类里面多了一个<code>finalize()</code>方法，该方法实际上调用的是线程池的<code>shutdown()</code>方法把线程池状态变为SHUTDOWN（<strong>即把任务执行完而不接受新任务</strong>）。</p>
<p>而二者之间主要区别在于垃圾回收时<code>Single</code>线程池多了一步销毁方法，其次是<code>Fix</code>线程池后期可以更改线程池数量，<code>Single</code>不可以（因为本来就是单一）</p>
</blockquote>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> executor = ScheduledThreadPoolExecutor(<span class="number">5</span>)</span><br><span class="line">   <span class="comment">// 执行一个延迟任务</span></span><br><span class="line">   executor.schedule(&#123; println(<span class="string">&quot;Delayed task executed&quot;</span>) &#125;, <span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">   <span class="comment">// 执行一个固定周期的重复任务</span></span><br><span class="line">   executor.scheduleAtFixedRate(&#123; println(<span class="string">&quot;Periodic task executed&quot;</span>) &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>

<p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		这种线程池用于执行延迟任务或者定时任务。核心线程数为传入的值，最大线程数为无限制，线程空闲时间由<code>DEFAULT_KEEPALIVE_MILLIS</code>确定，任务队列为<code>DelayedWorkQueue</code>，这是一种<strong>按照超时时间排序</strong>的队列结构</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>定时执行和周期性执行</p>
<p><code>ScheduledThreadPoolExecutor</code>可以精确地控制任务的执行时间和频率，适用于需要定时或周期性执行任务的场景。</p>
</li>
<li><p>资源使用相对稳定</p>
<p>由于有核心线程数的限制，即使在任务数量较多的情况下，也能保持资源使用的稳定性。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>可能导致资源耗尽</p>
<p>虽然有核心线程数的限制，但最大线程数为无限制，如果提交的延迟任务数量过多，而且执行时间较长，可能会创建大量线程，导致资源耗尽。</p>
</li>
<li><p>延迟任务堆积</p>
<p>如果任务提交速度远大于处理速度，可能会导致延迟任务在队列中堆积，从而影响到任务的准时执行</p>
</li>
</ul>
<p><a href="https://juejin.cn/post/7343440691681181747#heading-9">两万字长文-最全的线程池详解</a></p>
<p><a href="https://arnofrost.github.io/2020/07/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E6%B5%85%E6%9E%90/">线程池应用浅析</a></p>
]]></content>
  </entry>
  <entry>
    <title>Glide</title>
    <url>/2024/03/26/Glide/</url>
    <content><![CDATA[<h1 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h1><p>Glide 默认内存缓存用的是弱引用+LruCache</p>
<p>取的顺序是：弱引用、LruCache、磁盘 </p>
<p>存的顺序是：磁盘、弱引用、LruCache</p>
<h2 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h2><p>Glide设计了一个弱引用缓存，当从内存里面加载时，会先从弱引用里面获取图片资源；</p>
<p>为什么要多设计一层弱引用的缓存呢？</p>
<p>这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！</p>
<p>那么设计了一个弱引用缓存的好处在于，没有触发GC的这段时间，可以重复的利用图片资源，减少从LruCache里的操作；</p>
<p>用弱引用保存正在使用的图片数据（正在使用的不能放在LRU内存缓存中，LRU有可能触发超过内存最大限制导致回收），当触发GC弱引用缓存被回收（说明此时不是正在使用的图片了）后又会被加到LRU缓存中。</p>
<p><strong>LruCache：</strong></p>
<p>LruCache 采用<strong>最近最少使用算法</strong>，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致OOM。</p>
<p><strong>LruCache底层实现：</strong></p>
<p>LruCache 构造方法里创建一个<strong>LinkedHashMap</strong>，accessOrder 参数传true，表示按照访问顺序排序，数据存储基于LinkedHashMap。</p>
<p>LinkedHashMap 的原理：LinkedHashMap 定义了一个全空的节点<strong>header</strong>拥有两个指针，after  和before。在添加新元素时在hashmap的的基础上再维护了一个双向链表。且最新添加的元素都在header的前面就是before的位置。从而<strong>链表头节点header的before是最新访问的数据，header的after则是最旧的数据。</strong></p>
<p><strong>LruCache 重写了LinkedHashMap 的trimToSize方法，判断内存如果超过一定大小，则移除最老的数据</strong></p>
<p><strong>小结：</strong>LinkHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（<strong>从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的</strong>）。</p>
<p>LruCache 内部用LinkHashMap存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面put数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。</p>
<h2 id="磁盘缓存-DiskLruCache"><a href="#磁盘缓存-DiskLruCache" class="headerlink" title="磁盘缓存 DiskLruCache"></a>磁盘缓存 DiskLruCache</h2><p>DiskLruCache 跟 LruCache 实现思路是差不多的，一样是设置一个总大小，每次往硬盘写文件，总大小超过阈值，就会将旧的文件删除。</p>
<h2 id="缓存总结"><a href="#缓存总结" class="headerlink" title="缓存总结"></a>缓存总结</h2><p>Glide缓存分为 弱引用+ LruCache+ DiskLruCache ，其中读取数据的顺序是：弱引用 &gt; LruCache &gt; DiskLruCache&gt;<br>网络；写入缓存的顺序是：网络 –&gt; DiskLruCache–&gt; LruCache–&gt;弱引用</p>
<h2 id="防止OOM"><a href="#防止OOM" class="headerlink" title="防止OOM"></a>防止OOM</h2><p>1.LruCache缓存大小设置</p>
<p>2.软引用：在发生OOM之前，垃圾回收器会回收SoftReference引用的对象。</p>
<p>3.onLowMemory：<strong>Activity、Fragment会调用<code>onLowMemory</code>方法，可以在这个方法里去清除缓存</strong></p>
<p>4.从Bitmap 像素存储位置考虑</p>
<p>Bitmap 之所以占内存大不是因为对象本身大，而是因为Bitmap的像素数据， <strong>Bitmap的像素数据大小 &#x3D; 宽 * 高 * 1像素占用的内存。</strong></p>
<h1 id="Glide-1"><a href="#Glide-1" class="headerlink" title="Glide"></a>Glide</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.github.bumptech.glide:glide:5.0.0-rc01&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.github.bumptech.glide:compiler:5.0.0-rc01&#x27;</span></span><br></pre></td></tr></table></figure>

<p>代码使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="built_in">this</span>).load(URL).into(ivGlide)</span><br></pre></td></tr></table></figure>

<h2 id="with方法"><a href="#with方法" class="headerlink" title="with方法"></a>with方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中getRetriever 是单例的形式来向外提供唯一对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Glide</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Glide glide;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title function_">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (glide == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">GeneratedAppGlideModule</span> <span class="variable">annotationGeneratedModule</span> <span class="operator">=</span></span><br><span class="line">          getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">      <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (glide == <span class="literal">null</span>) &#123;</span><br><span class="line">          checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> glide;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​		传入的context又被传入了checkAndInitializeGlide方法，同时传入的还有一个GeneratedAppGlideModule对象，这个对象是由 Glide 的注解处理器在编译时生成的，包含了 Glide 配置的信息。然后里面又调用到了initializeGlide方法，这个方法的大致逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeGlide</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> GlideBuilder builder,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> GeneratedAppGlideModule annotationGeneratedModule)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Context</span> <span class="variable">applicationContext</span> <span class="operator">=</span> context.getApplicationContext();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析清单文件中的 GlideModule</span></span><br><span class="line">  List&lt;GlideModule&gt; manifestModules = Collections.emptyList();</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule == <span class="literal">null</span> || annotationGeneratedModule.isManifestParsingEnabled()) &#123;</span><br><span class="line">    manifestModules = <span class="keyword">new</span> <span class="title class_">ManifestParser</span>(applicationContext).parse();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排除指定的 GlideModule</span></span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="literal">null</span></span><br><span class="line">      &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();</span><br><span class="line">    manifestModules.removeIf(<span class="keyword">module</span> -&gt; excludedModuleClasses.contains(<span class="keyword">module</span>.getClass()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用 GlideModule 的配置</span></span><br><span class="line">  <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : manifestModules) &#123;</span><br><span class="line">    <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (annotationGeneratedModule != <span class="literal">null</span>) &#123;</span><br><span class="line">    annotationGeneratedModule.applyOptions(applicationContext, builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建并注册 Glide 实例 这里也是用了构建者模式</span></span><br><span class="line">  <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> builder.build(applicationContext, manifestModules, annotationGeneratedModule);</span><br><span class="line">  applicationContext.registerComponentCallbacks(glide);</span><br><span class="line">  Glide.glide = glide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法负责初始化 Glide，包括解析配置、应用配置选项，并构建 <code>Glide</code> 实例。</p>
<p>这个讲一下自定义配置的方式</p>
<p>想配置 Glide 的内存缓存大小，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyAppGlideModule</span> <span class="keyword">extends</span> <span class="title class_">AppGlideModule</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyOptions</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> GlideBuilder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置内存缓存大小为 20MB</span></span><br><span class="line">        builder.setMemoryCache(<span class="keyword">new</span> <span class="title class_">LruResourceCache</span>(<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在这个例子中，<code>MyAppGlideModule</code> 就是自定义的 Glide 模块，Glide 的注解处理器会根据它生成 <code>GeneratedAppGlideModule</code>，并在运行时使用它来配置 Glide。也可以进行其他自定义配置的操作具体可以参考<a href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html#%E9%81%BF%E5%85%8D%E5%9C%A8%E7%A8%8B%E5%BA%8F%E5%BA%93%E4%B8%AD%E4%BD%BF%E7%94%A8-appglidemodule">官网</a></p>
<p>​		上面通过单例的形式获取了Glide对象后通过getRequestManagerRetriever方法获取了RequestManagerRetriever对象，而RequestManagerRetriever是用来管理RequestManager的。具体来说，<code>RequestManagerRetriever</code> 的作用包括：</p>
<ol>
<li>**检索 <code>RequestManager</code>**：<code>RequestManagerRetriever</code> 提供了方法来获取不同上下文（如 <code>Activity</code>、<code>Fragment</code>、<code>ApplicationContext</code> 等）对应的 <code>RequestManager</code> 实例。这些 <code>RequestManager</code> 实例会根据它们所在的上下文来自动处理图像加载请求的暂停和恢复。</li>
<li><strong>管理 <code>RequestManager</code> 实例</strong>：<code>RequestManagerRetriever</code> 负责创建新的 <code>RequestManager</code> 实例（如果还不存在）并将它们与对应的上下文关联起来。它还确保同一个上下文使用同一个 <code>RequestManager</code> 实例，以避免不必要的资源消耗。</li>
<li><strong>处理生命周期事件</strong>：<code>RequestManagerRetriever</code> 与上下文的生命周期事件（如 <code>Activity</code> 的 <code>onStart</code>、<code>onStop</code>、<code>onDestroy</code> 等）相结合，以确保图像加载请求在适当的时间被暂停或恢复。这有助于优化资源使用和提高应用性能。</li>
</ol>
<p>根据上面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRetriever(activity).get(activity);</span><br></pre></td></tr></table></figure>

<p>最后返回的是一个RequestManager对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">  <span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">          &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据上述规则可以得出以下几个结论：</p>
<ol>
<li>同一个 Activity 对应一个 FragmentManager，一个 FragmentManager 对应一个 RequestManagerFragment，一个 RequestManagerFragment 对应一个 RequestManager，所以<strong>一个 Activity 对应 一个 RequestManager</strong>；</li>
<li>同一个 Fragment 同样可得出上述结论；</li>
<li>但如果 Fragment 属于 Activity，或者 Fragment 属于 Fragment，在 Activity、Framgnent 中分别创建 Glide 请求是并不会只创建一个 RequestManager；</li>
<li><strong>子线程</strong>发起 Glide 请求或传入对象为 ApplicationContext，则使用全局单例的 RequestManager。</li>
</ol>
<p>上面代码中看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>看具体的重载逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># RequestManagerRetriever</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> FragmentActivity activity)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125;</span><br><span class="line">  assertNotDestroyed(activity);</span><br><span class="line">  frameWaiter.registerSelf(activity);</span><br><span class="line">  <span class="comment">// 判断Activity是否可见</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isActivityVisible</span> <span class="operator">=</span> isActivityVisible(activity);</span><br><span class="line">  <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(activity.getApplicationContext());</span><br><span class="line">  <span class="keyword">return</span> lifecycleRequestManagerRetriever.getOrCreate(</span><br><span class="line">      activity,</span><br><span class="line">      glide,</span><br><span class="line">      activity.getLifecycle(),</span><br><span class="line">      activity.getSupportFragmentManager(),</span><br><span class="line">      isActivityVisible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后调用了getOrCreate方法，看到传入的几个参数应该知道是咋回事了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># LifecycleRequestManagerRetriever</span><br><span class="line">RequestManager <span class="title function_">getOrCreate</span><span class="params">(Context context,Glide glide,<span class="keyword">final</span> Lifecycle lifecycle,FragmentManager childFragmentManager,<span class="type">boolean</span> isParentVisible)</span> &#123;</span><br><span class="line">  Util.assertMainThread(); <span class="comment">// 确保在主线程中执行</span></span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">result</span> <span class="operator">=</span> getOnly(lifecycle); <span class="comment">// 尝试获取已存在的RequestManager实例</span></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123; <span class="comment">// 如果不存在，则创建新的实例</span></span><br><span class="line">    <span class="type">LifecycleLifecycle</span> <span class="variable">glideLifecycle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleLifecycle</span>(lifecycle); <span class="comment">// 创建Glide的生命周期对象</span></span><br><span class="line">    result =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide,</span><br><span class="line">            glideLifecycle,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SupportRequestManagerTreeNode</span>(childFragmentManager),</span><br><span class="line">            context); <span class="comment">// 使用工厂方法创建RequestManager实例</span></span><br><span class="line">    lifecycleToRequestManager.put(lifecycle, result); <span class="comment">// 将新创建的实例与生命周期对象关联</span></span><br><span class="line">    glideLifecycle.addListener(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LifecycleListener</span>() &#123; <span class="comment">// 为Glide的生命周期对象添加监听器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;&#125; <span class="comment">// 生命周期开始时的回调（空实现）</span></span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;&#125; <span class="comment">// 生命周期停止时的回调（空实现）</span></span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123; <span class="comment">// 生命周期销毁时的回调</span></span><br><span class="line">            lifecycleToRequestManager.remove(lifecycle); <span class="comment">// 从映射中移除对应的RequestManager实例</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isParentVisible) &#123; <span class="comment">// 如果父组件可见</span></span><br><span class="line">      result.onStart(); <span class="comment">// 启动RequestManager，开始处理图片加载请求</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回RequestManager实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方法逻辑：</strong></p>
<ol>
<li>首先，调用<code>Util.assertMainThread()</code>确保方法在主线程中调用。</li>
<li>然后，尝试通过<code>getOnly(lifecycle)</code>从<code>lifecycleToRequestManager</code>映射中获取已存在的<code>RequestManager</code>实例。</li>
<li>如果不存在，就创建一个新的RequestManager实例：<ul>
<li>创建一个<code>LifecycleLifecycle</code>实例，它是一个自定义的生命周期对象，用于将Glide的生命周期与外部组件的生命周期同步。</li>
<li>使用<code>factory.build(...)</code>方法创建一个新的<code>RequestManager</code>实例，传入Glide实例、生命周期对象、一个用于支持请求管理的<code>SupportRequestManagerTreeNode</code>实例和上下文对象。</li>
<li>将新创建的<code>RequestManager</code>实例与对应的生命周期对象关联起来，存储在<code>lifecycleToRequestManager</code>映射中。</li>
<li>为<code>glideLifecycle</code>添加一个<code>LifecycleListener</code>监听器，当外部组件销毁时，从映射中移除对应的<code>RequestManager</code>实例。</li>
</ul>
</li>
<li>如果<code>isParentVisible</code>为<code>true</code>，表示父组件可见，那么调用<code>result.onStart()</code>使<code>RequestManager</code>开始处理图片加载请求。</li>
<li>最后，返回<code>RequestManager</code>实例。</li>
</ol>
<p>总的来说，这个方法的作用是确保每个生命周期对象关联一个唯一的<code>RequestManager</code>实例，用于管理该生命周期内的图片加载请求，并且确保在生命周期结束时正确地清理资源。</p>
<p>RequestManager 主要由两个作用：</p>
<ol>
<li>创建 RequestBuilder ；</li>
<li>通过生命周期管理请求的启动结束等。</li>
</ol>
<p>RequestBuilder的职责很明确，用于创建获取图片的请求，例如设置 RequestOption、缩略图、加载失败占位图等等；这个类使用了建造者模式来构建参数，这样有一个好处就是，可以很方便的添加各种各样复杂的参数</p>
<p>总结上面的逻辑：</p>
<p>​		首先获取单例glide对象，这个代码逻辑是在一个叫做initializeGlide的方法里面，这里面会解析应用GlideModule 的配置，然后通过构建者模式获取对象。然后通过获取的Glide对象获取了RequestManagerRetriever对象，这个对象是用来管理 <code>RequestManager</code> 实例的，然后根据传入的context类型返回对应的RequestManager。如果context是Fragment Activity的子类会注册进Fragment Activity的Lifecycle观察者队列里面，以此完成生命周期的控制。RequestManager会创建RequestBuilder。</p>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@CheckResult</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> String string)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>load方法最终的返回值是创建一个RequestBuilder<Drawable>，下面来看看创建的具体过程。</p>
<p>load方法传入的是一个字符串，最终会被传入SingleRequest这个类的构造中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># RequestBuilder</span><br><span class="line">RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">        <span class="comment">//只是简单地赋值</span></span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        isModelSet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>只是简单的赋值，将url传递给RequestBuilder的成员。</p>
<h2 id="into方法"><a href="#into方法" class="headerlink" title="into方法"></a>into方法</h2><p>into方法开启了真正的资源查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.with(this).load(URL).into(ivGlide)</span><br></pre></td></tr></table></figure>

<p>into有好几个重载方法，这里以ivGlide为ImageView为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># RequestBuilder</span><br><span class="line"><span class="keyword">public</span> ViewTarget&lt;ImageView, TranscodeType&gt; <span class="title function_">into</span><span class="params">(<span class="meta">@NonNull</span> ImageView view)</span> &#123;</span><br><span class="line">  Util.assertMainThread(); <span class="comment">// 确保在主线程中执行</span></span><br><span class="line">  Preconditions.checkNotNull(view); <span class="comment">// 检查view是否为null</span></span><br><span class="line"></span><br><span class="line">  BaseRequestOptions&lt;?&gt; requestOptions = <span class="built_in">this</span>; <span class="comment">// 获取当前的请求选项</span></span><br><span class="line">  <span class="comment">// 检查是否需要根据ImageView的ScaleType设置转换</span></span><br><span class="line">  <span class="keyword">if</span> (!requestOptions.isTransformationSet() <span class="comment">// 检查是否已设置转换</span></span><br><span class="line">      &amp;&amp; requestOptions.isTransformationAllowed() <span class="comment">// 检查是否允许转换</span></span><br><span class="line">      &amp;&amp; view.getScaleType() != <span class="literal">null</span>) &#123; <span class="comment">// 检查ImageView的ScaleType是否为null</span></span><br><span class="line">    <span class="comment">// 根据ImageView的ScaleType设置相应的转换</span></span><br><span class="line">    <span class="keyword">switch</span> (view.getScaleType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CENTER_CROP:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterCrop(); <span class="comment">// 设置居中裁剪</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER_INSIDE:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside(); <span class="comment">// 设置居中内部</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_CENTER:</span><br><span class="line">      <span class="keyword">case</span> FIT_START:</span><br><span class="line">      <span class="keyword">case</span> FIT_END:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalFitCenter(); <span class="comment">// 设置适应中心</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FIT_XY:</span><br><span class="line">        requestOptions = requestOptions.clone().optionalCenterInside(); <span class="comment">// 设置适应XY</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CENTER:</span><br><span class="line">      <span class="keyword">case</span> MATRIX:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 不做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建并返回ViewTarget对象，用于加载图片到ImageView</span></span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass), <span class="comment">// 创建ImageViewTarget，transcodeClass是泛型的类型</span></span><br><span class="line">      <span class="comment">/* targetListener= */</span> <span class="literal">null</span>, <span class="comment">// 不设置目标监听器</span></span><br><span class="line">      requestOptions, <span class="comment">// 使用设置好的请求选项</span></span><br><span class="line">      Executors.mainThreadExecutor()); <span class="comment">// 使用主线程执行器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面最终调用还是在下面这个方法，也就是多个重载方法的最终调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">    BaseRequestOptions&lt;?&gt; options,</span></span><br><span class="line"><span class="params">    Executor callbackExecutor)</span> &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 创建图片请求</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前图片控件是否已经有设置图片请求了，如果有且还没有加载完成，</span></span><br><span class="line">  <span class="comment">// 或者加载完成但是加载失败了，那么就将这个请求再重新调用begin，再一次进行请求；</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest(); <span class="comment">// 获取target上一个关联的请求</span></span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous) <span class="comment">// 检查新请求是否与旧请求等价</span></span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123; <span class="comment">// 检查是否需要跳过内存缓存</span></span><br><span class="line">    <span class="comment">// 如果请求已完成，重新开始将确保结果重新传递，触发RequestListeners和Targets。</span></span><br><span class="line">    <span class="comment">// 如果请求失败，重新开始将重新启动请求，给予另一次完成的机会。</span></span><br><span class="line">    <span class="comment">// 如果请求已经在运行，我们可以让它继续运行而不受干扰。</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123; <span class="comment">// 检查旧请求是否正在运行</span></span><br><span class="line">      <span class="comment">// 使用旧请求而不是新请求，以允许优化，如跳过设置占位符、跟踪和取消跟踪Targets、获取View尺寸等。</span></span><br><span class="line">      previous.begin(); <span class="comment">// 开始旧请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target; <span class="comment">// 返回target</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//清除当前图片控件的图片请求</span></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  <span class="comment">// 设置请求给控件</span></span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  <span class="comment">// 再将请求添加到requestManager中</span></span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		这段代码的主要作用是将构建好的图片加载请求与目标<code>Target</code>关联，并根据请求的状态决定是否重新开始请求或使用旧请求。</p>
<p><strong>将请求设置给了封装了图片控件的target，这样做有什么好处呢？</strong></p>
<p>​		我们的页面大多数都是列表页，那么基本上会使用RecycleView这种列表控件来加载数据，而这种列表在加载图片的时候，快速滑动时会出现加载错乱的问题，其原因是RecycleView的Item复用的问题；</p>
<p>而Glide就是在这里通过这样的操作来避免这样的问题；</p>
<p>在调用setRequest的时候，将当前的Request作为tag设置给了View，那么在获取Request进行加载的时候，就不会出现错乱的问题；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setTag</span><span class="params">(<span class="meta">@Nullable</span> Object tag)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  view.setTag(tagId, tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，无论是重新开始请求或使用旧请求，都是从<code>request.begin()</code>开始的。</p>
<p>下面这张图片总结一下上面的流程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281707881.png" alt="img"></p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Request 主要的实现类有三个：</p>
<ol>
<li>SingleRequest</li>
<li>ThumbnailRequestCoordinator</li>
<li>ErrorRequestCoordinator</li>
</ol>
<p><strong>SingleRequest</strong></p>
<p>​		这个类负责执行请求并将结果反映到 Target 上。<br>        当我们使用 Glide 加载图片时，会先根据 Target 类型创建不同的 Target，然后 RequestBuilder 将这个 target 当做参数创建 Request 对象，Request 与 Target 就是这样关联起来的。</p>
<p>​		这里就会先创建一个包含 Target 的 SingleRequest 对象。考虑到性能问题，可能会连续创建很多个 SingleRequest 对象，所以使用了对象池来做缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># SingleRequest</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123; <span class="comment">// 同步锁，保证请求的线程安全</span></span><br><span class="line">    assertNotCallingCallbacks(); <span class="comment">// 检查是否在回调方法中调用</span></span><br><span class="line">    stateVerifier.throwIfRecycled(); <span class="comment">// 检查请求是否已经被回收</span></span><br><span class="line">    startTime = LogTime.getLogTime(); <span class="comment">// 记录开始时间，用于日志记录</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="literal">null</span>) &#123; <span class="comment">// 这里就是load设置的那个url</span></span><br><span class="line">      <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; <span class="comment">// 检查是否有有效的尺寸覆盖</span></span><br><span class="line">        width = overrideWidth; <span class="comment">// 设置宽度</span></span><br><span class="line">        height = overrideHeight; <span class="comment">// 设置高度</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">logLevel</span> <span class="operator">=</span> getFallbackDrawable() == <span class="literal">null</span> ? Log.WARN : Log.DEBUG; <span class="comment">// 设置日志级别</span></span><br><span class="line">      onLoadFailed(<span class="keyword">new</span> <span class="title class_">GlideException</span>(<span class="string">&quot;Received null model&quot;</span>), logLevel); <span class="comment">// 加载失败，模型为空</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.RUNNING) &#123; <span class="comment">// 如果请求已经在运行</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot restart a running request&quot;</span>); <span class="comment">// 抛出异常，不能重启正在运行的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == Status.COMPLETE) &#123; <span class="comment">// 如果请求已经完成</span></span><br><span class="line">      onResourceReady(</span><br><span class="line">          resource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>); <span class="comment">// 直接使用上次的资源</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记请求开始</span></span><br><span class="line">    experimentalNotifyRequestStarted(model); <span class="comment">// 通知请求开始</span></span><br><span class="line"></span><br><span class="line">    cookie = GlideTrace.beginSectionAsync(TAG); <span class="comment">// 开始异步跟踪部分</span></span><br><span class="line">    status = Status.WAITING_FOR_SIZE; <span class="comment">// 设置状态为等待尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; <span class="comment">// 如果有有效的尺寸覆盖</span></span><br><span class="line">      onSizeReady(overrideWidth, overrideHeight); <span class="comment">// 如果已经有了明确的尺寸，开始加载</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target.getSize(<span class="built_in">this</span>); <span class="comment">// 没有的话先去获取尺寸，最终还是走onSizeReady</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) <span class="comment">// 如果状态为运行中或等待尺寸</span></span><br><span class="line">        &amp;&amp; canNotifyStatusChanged()) &#123; <span class="comment">// 并且可以通知状态改变</span></span><br><span class="line">      target.onLoadStarted(getPlaceholderDrawable()); <span class="comment">// 通知目标加载开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">      logV(<span class="string">&quot;finished run method in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录完成时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>begin()</code>方法是用于开始图片加载请求的。它首先检查模型是否为<code>null</code>，如果是，则直接失败并返回。接着，它会检查请求的状态，如果请求已经在运行中，则抛出异常。如果请求已经完成，则直接使用上一次的资源和尺寸。如果请求既不是完成状态也不是运行状态，则视为新请求，从头开始执行。最后，它会根据需要更新目标的加载状态，并记录日志。</p>
<p>​		最终都是会调用到onSizeReady方法，然后通过Engine的load方法来开启请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># SingleRequest</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSizeReady</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">  stateVerifier.throwIfRecycled(); <span class="comment">// 检查请求是否已经被回收</span></span><br><span class="line">  <span class="keyword">synchronized</span> (requestLock) &#123; <span class="comment">// 同步锁，保证请求的线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;Got onSizeReady in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录尺寸准备好的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123; <span class="comment">// 如果状态不是等待尺寸</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 返回，不继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.RUNNING; <span class="comment">// 设置状态为运行中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="variable">sizeMultiplier</span> <span class="operator">=</span> requestOptions.getSizeMultiplier(); <span class="comment">// 获取尺寸乘数</span></span><br><span class="line">    <span class="built_in">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier); <span class="comment">// 应用尺寸乘数到宽度</span></span><br><span class="line">    <span class="built_in">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier); <span class="comment">// 应用尺寸乘数到高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished setup for calling load in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录完成设置的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始加载图片</span></span><br><span class="line">    loadStatus =</span><br><span class="line">        engine.load(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            requestOptions.getSignature(),</span><br><span class="line">            <span class="built_in">this</span>.width,</span><br><span class="line">            <span class="built_in">this</span>.height,</span><br><span class="line">            requestOptions.getResourceClass(),</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            requestOptions.getDiskCacheStrategy(),</span><br><span class="line">            requestOptions.getTransformations(),</span><br><span class="line">            requestOptions.isTransformationRequired(),</span><br><span class="line">            requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">            requestOptions.getOptions(),</span><br><span class="line">            requestOptions.isMemoryCacheable(),</span><br><span class="line">            requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">            requestOptions.getUseAnimationPool(),</span><br><span class="line">            requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">            <span class="built_in">this</span>,</span><br><span class="line">            callbackExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果状态不是运行中，设置加载状态为null</span></span><br><span class="line">    <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">      loadStatus = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">      logV(<span class="string">&quot;finished onSizeReady in &quot;</span> + LogTime.getElapsedMillis(startTime)); <span class="comment">// 记录尺寸准备完成的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>onSizeReady()</code>方法是在目标尺寸准备好时被调用的。它会设置请求的状态为运行中，应用尺寸乘数到宽度和高度，然后开始加载图片。如果加载完成或状态改变，会进行相应的处理。</p>
<p>​		最终的请求还是来到了Engine类的load方法，下面看下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; LoadStatus <span class="title function_">load</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">/* 参数 */</span>)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>; <span class="comment">// 记录开始时间，用于日志记录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建用于缓存的键</span></span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span></span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource; <span class="comment">// 声明内存资源变量</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 同步锁，保证线程安全</span></span><br><span class="line">    <span class="comment">// 尝试从内存缓存中加载资源</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="literal">null</span>) &#123; <span class="comment">// 如果内存中没有资源</span></span><br><span class="line">      <span class="comment">// 等待现有的加载完成或开始新的加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果内存中有资源，回调资源准备好的方法</span></span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null，表示不需要等待新的加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的参数占地比较多我就先省略了，具体可以看<a href="https://github.com/bumptech/glide/blob/193cf61354cc01f38b15bf1605905b49a19e6b7a/library/src/main/java/com/bumptech/glide/load/engine/Engine.java#L155">源代码</a>。</p>
<p>​		<code>load()</code>方法负责一个图片加载的过程。它首先构建一个用于缓存的键，然后尝试从内存缓存中加载资源。如果内存缓存中没有资源，它将等待现有的加载完成或开始新的加载。如果找到了资源就通过cb回调回去，这个cb就是前面的SingleRequest，然后回调给了它的onResourceReady方法。最后通过层层回调传递数据，然后设置到View上。</p>
<h3 id="从缓存查找资源"><a href="#从缓存查找资源" class="headerlink" title="从缓存查找资源"></a>从缓存查找资源</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br></pre></td></tr></table></figure>

<p>看下这个方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rivate EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, <span class="type">boolean</span> isMemoryCacheable, <span class="type">long</span> startTime) &#123;</span><br><span class="line">  ...</span><br><span class="line">      <span class="comment">// 构建用于缓存的键</span></span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span></span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从弱引用里获取图片资源</span></span><br><span class="line">  EngineResource&lt;?&gt; active = loadFromActiveResources(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 从LRU缓存里面获取图片资源</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = loadFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从弱引用里获取图片资源"><a href="#从弱引用里获取图片资源" class="headerlink" title="从弱引用里获取图片资源"></a>从弱引用里获取图片资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从弱引用里获取图片资源    get的具体实现在下面</span></span><br><span class="line">  EngineResource&lt;?&gt; active = activeResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (active != <span class="literal">null</span>) &#123; <span class="comment">// 如果资源存在</span></span><br><span class="line">    active.acquire(); <span class="comment">// 增加资源的引用计数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> active; <span class="comment">// 返回资源，如果不存在则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ActiveResources</span><br><span class="line">   </span><br><span class="line"><span class="meta">@VisibleForTesting</span> <span class="keyword">final</span> Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">synchronized</span> EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从映射中获取对应的弱引用</span></span><br><span class="line">  <span class="type">ResourceWeakReference</span> <span class="variable">activeRef</span> <span class="operator">=</span> activeEngineResources.get(key);</span><br><span class="line">  <span class="keyword">if</span> (activeRef == <span class="literal">null</span>) &#123; <span class="comment">// 如果弱引用不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 直接返回null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从弱引用队列中获取EngineResource对象</span></span><br><span class="line">  EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">  <span class="keyword">if</span> (active == <span class="literal">null</span>) &#123; <span class="comment">// 如果EngineResource对象已被回收</span></span><br><span class="line">    cleanupActiveReference(activeRef); <span class="comment">// 清理弱引用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> active; <span class="comment">// 返回EngineResource对象，如果已被回收则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这里要说一下弱引用在内存里面的机制，弱引用对象在Java虚拟机触发GC时，会回收弱引用对象，不管此时内存是不是够用！</p>
<p>​		那么设计了一个弱引用缓存的好处在于，没有触发GC的这段时间，可以重复的利用图片资源，减少从LruCache里的操作；</p>
<p>​		用弱引用保存正在使用的图片数据（正在使用的不能放在LRU内存缓存中，LRU有可能触发超过内存最大限制导致回收），当触发GC弱引用缓存被回收（说明此时不是正在使用的图片了）后又会被加到LRU缓存中。</p>
<h4 id="从LRU缓存里面获取图片资源"><a href="#从LRU缓存里面获取图片资源" class="headerlink" title="从LRU缓存里面获取图片资源"></a>从LRU缓存里面获取图片资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中获取EngineResource对象</span></span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中存在资源</span></span><br><span class="line">    cached.acquire(); <span class="comment">// 增加资源的引用计数</span></span><br><span class="line">    activeResources.activate(key, cached); <span class="comment">// 将资源添加到弱引用队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cached; <span class="comment">// 返回缓存中的资源，如果不存在则为null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MemoryCache cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中移除并获取资源</span></span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中没有资源</span></span><br><span class="line">    result = <span class="literal">null</span>; <span class="comment">// 结果为null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123; <span class="comment">// 如果缓存的是EngineResource对象</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached; <span class="comment">// 直接转换为EngineResource对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果缓存的是其他类型的资源，创建一个新的EngineResource对象</span></span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EngineResource</span>&lt;&gt;(</span><br><span class="line">            cached,</span><br><span class="line">            <span class="comment">/* isMemoryCacheable= */</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">/* isRecyclable= */</span> <span class="literal">true</span>,</span><br><span class="line">            key,</span><br><span class="line">            <span class="comment">/* listener= */</span> <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回从缓存中获取的EngineResource对象，如果没有则为null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有个细节就是从LRU缓存里面获取图片资源后加入到了弱引用队列中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activeResources.activate(key, cached);</span><br></pre></td></tr></table></figure>

<p>极致的压榨性能</p>
<h3 id="从磁盘和网络查找资源"><a href="#从磁盘和网络查找资源" class="headerlink" title="从磁盘和网络查找资源"></a>从磁盘和网络查找资源</h3><p>从磁盘或者网络读取，必然是一个耗时的任务，那么肯定是要放在子线程里面执行，而Glide里也正是这样实现的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="title function_">if</span> <span class="params">(memoryResource == <span class="literal">null</span>)</span> &#123; <span class="comment">// 如果内存中没有资源</span></span><br><span class="line">      <span class="comment">// 等待现有的加载完成或开始新的加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看具体代码，还是省略参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; LoadStatus <span class="title function_">waitForExistingOrStartNewJob</span><span class="params">(。。。)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试获取当前正在执行的任务</span></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">  <span class="keyword">if</span> (current != <span class="literal">null</span>) &#123; <span class="comment">// 如果任务已存在</span></span><br><span class="line">    current.addCallback(cb, callbackExecutor); <span class="comment">// 为任务添加回调</span></span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">      logWithTimeAndKey(<span class="string">&quot;Added to existing load&quot;</span>, startTime, key); <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, current); <span class="comment">// 返回加载状态</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的EngineJob</span></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的DecodeJob</span></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      。。。);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将新的EngineJob添加到任务映射中</span></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//添加回调，这个cb就是SingleRequest自己，todo1</span></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123; <span class="comment">// 如果启用了详细日志</span></span><br><span class="line">    logWithTimeAndKey(<span class="string">&quot;Started new load&quot;</span>, startTime, key); <span class="comment">// 记录日志</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoadStatus</span>(cb, engineJob); <span class="comment">// 返回新的加载状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		run方法里面主要有一个runWrapped方法，这个方法才是最终执行的地方；</p>
<p>​		在这个com.bumptech.glide.load.engine.DecodeJob#getNextGenerator方法里面，会获取内存生产者Generator，这几个内容生产者分别对应着不同的缓存数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># DecodeJob</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runWrapped</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123; <span class="comment">// 根据运行原因执行不同的操作</span></span><br><span class="line">    <span class="keyword">case</span> INITIALIZE: <span class="comment">// 初始化</span></span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE); <span class="comment">// 获取下一个阶段</span></span><br><span class="line">      currentGenerator = getNextGenerator(); <span class="comment">// 获取下一个数据生成器</span></span><br><span class="line">      runGenerators(); <span class="comment">// 运行数据生成器</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE: <span class="comment">// 切换到源服务</span></span><br><span class="line">      runGenerators(); <span class="comment">// 运行数据生成器</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA: <span class="comment">// 解码数据</span></span><br><span class="line">      decodeFromRetrievedData(); <span class="comment">// 从检索到的数据中解码</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 未识别的运行原因</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unrecognized run reason: &quot;</span> + runReason); <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title function_">getNextGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123; <span class="comment">// 根据当前阶段获取相应的数据生成器</span></span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE: <span class="comment">// 资源缓存</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResourceCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建资源缓存生成器</span></span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE: <span class="comment">// 数据缓存</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataCacheGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建数据缓存生成器</span></span><br><span class="line">    <span class="keyword">case</span> SOURCE: <span class="comment">// 源数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SourceGenerator</span>(decodeHelper, <span class="built_in">this</span>); <span class="comment">// 创建源数据生成器</span></span><br><span class="line">    <span class="keyword">case</span> FINISHED: <span class="comment">// 完成</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回null，表示没有更多的生成器</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		<code>runWrapped()</code>方法根据不同的运行原因执行相应的操作，如初始化、切换到源服务、解码数据等。<code>getNextGenerator()</code>方法根据当前的阶段返回相应的数据生成器，用于获取数据。这些生成器负责从不同的数据源（如资源缓存、数据缓存、源数据）获取数据，并在数据准备好后进行解码处理。</p>
<p>ResourceCacheGenerator：对应转化后的图片资源生产者；</p>
<p>DataCacheGenerator：对应没有转化的原生图片资源生产者；</p>
<p>SourceGenerator：对应着网络资源内容生产者；</p>
<p>那么则对应着这个ResourceCacheGenerator和这个DataCacheGenerator的生产者；</p>
<p>这两个方法的实现差不多，都是通过获取一个File对象，然后再根据File对象来加载对应的图片数据；</p>
<p>在上面的runWrapped方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentGenerator = getNextGenerator(); <span class="comment">// 获取下一个数据生成器</span></span><br><span class="line">runGenerators(); <span class="comment">// 运行数据生成器</span></span><br></pre></td></tr></table></figure>

<p>runGenerators方法里面就执行了生成器的startNext方法。</p>
<p>从上面我们可以知道，Glide的磁盘缓存，是从DiskLruCache里面获取的；</p>
<h4 id="从磁盘缓存获取资源"><a href="#从磁盘缓存获取资源" class="headerlink" title="从磁盘缓存获取资源"></a><strong>从磁盘缓存获取资源</strong></h4><h5 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h5><p>下面我们来看一下这个DataCacheGenerator的startNext方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ResourceCacheGenerator</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">  GlideTrace.beginSection(<span class="string">&quot;ResourceCacheGenerator.startNext&quot;</span>); <span class="comment">// 开始追踪此方法的执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;Key&gt; sourceIds = helper.getCacheKeys(); <span class="comment">// 获取缓存的键列表</span></span><br><span class="line">    <span class="keyword">if</span> (sourceIds.isEmpty()) &#123; <span class="comment">// 如果键列表为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; resourceClasses = helper.getRegisteredResourceClasses(); <span class="comment">// 获取注册的资源类列表</span></span><br><span class="line">    <span class="keyword">if</span> (resourceClasses.isEmpty()) &#123; <span class="comment">// 如果资源类列表为空</span></span><br><span class="line">      <span class="keyword">if</span> (File.class.equals(helper.getTranscodeClass())) &#123; <span class="comment">// 如果转码类是File</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>( <span class="comment">// 抛出异常，表示找不到加载路径</span></span><br><span class="line">          <span class="string">&quot;Failed to find any load path from &quot;</span></span><br><span class="line">              + helper.getModelClass()</span><br><span class="line">              + <span class="string">&quot; to &quot;</span></span><br><span class="line">              + helper.getTranscodeClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (modelLoaders == <span class="literal">null</span> || !hasNextModelLoader()) &#123; <span class="comment">// 如果没有模型加载器或没有下一个模型加载器</span></span><br><span class="line">      resourceClassIndex++; <span class="comment">// 增加资源类索引</span></span><br><span class="line">      <span class="keyword">if</span> (resourceClassIndex &gt;= resourceClasses.size()) &#123; <span class="comment">// 如果资源类索引超出范围</span></span><br><span class="line">        sourceIdIndex++; <span class="comment">// 增加源ID索引</span></span><br><span class="line">        <span class="keyword">if</span> (sourceIdIndex &gt;= sourceIds.size()) &#123; <span class="comment">// 如果源ID索引超出范围</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示没有更多数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        resourceClassIndex = <span class="number">0</span>; <span class="comment">// 重置资源类索引</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Key</span> <span class="variable">sourceId</span> <span class="operator">=</span> sourceIds.get(sourceIdIndex); <span class="comment">// 获取当前源ID</span></span><br><span class="line">      Class&lt;?&gt; resourceClass = resourceClasses.get(resourceClassIndex); <span class="comment">// 获取当前资源类</span></span><br><span class="line">      Transformation&lt;?&gt; transformation = helper.getTransformation(resourceClass); <span class="comment">// 获取转换器</span></span><br><span class="line">      <span class="comment">// 创建资源缓存键</span></span><br><span class="line">      currentKey =</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ResourceCacheKey</span>(</span><br><span class="line">              helper.getArrayPool(),</span><br><span class="line">              sourceId,</span><br><span class="line">              helper.getSignature(),</span><br><span class="line">              helper.getWidth(),</span><br><span class="line">              helper.getHeight(),</span><br><span class="line">              transformation,</span><br><span class="line">              resourceClass,</span><br><span class="line">              helper.getOptions());</span><br><span class="line">      cacheFile = helper.getDiskCache().get(currentKey); <span class="comment">// 从磁盘缓存获取文件</span></span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="literal">null</span>) &#123; <span class="comment">// 如果文件存在</span></span><br><span class="line">        sourceKey = sourceId; <span class="comment">// 设置源键</span></span><br><span class="line">        modelLoaders = helper.getModelLoaders(cacheFile); <span class="comment">// 获取模型加载器列表</span></span><br><span class="line">        modelLoaderIndex = <span class="number">0</span>; <span class="comment">// 重置模型加载器索引</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadData = <span class="literal">null</span>; <span class="comment">// 重置加载数据</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标记是否开始加载</span></span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123; <span class="comment">// 如果尚未开始且有下一个模型加载器</span></span><br><span class="line">      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); <span class="comment">// 获取模型加载器</span></span><br><span class="line">      <span class="comment">// 构建加载数据</span></span><br><span class="line">      loadData =</span><br><span class="line">          modelLoader.buildLoadData(</span><br><span class="line">              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; <span class="comment">// 如果加载数据有效且有加载路径</span></span><br><span class="line">        started = <span class="literal">true</span>; <span class="comment">// 标记开始加载</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>); <span class="comment">// 加载数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> started; <span class="comment">// 返回是否开始加载</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    GlideTrace.endSection(); <span class="comment">// 结束追踪此方法的执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里主要分为两步：</p>
<p>第一步是通过生成的key从DiskLruCache里面获取File对象；</p>
<p>第二步是将File对象，通过LoadData将File对象转化为Bitmap对象；</p>
<p>Glide在加载DiskLruCache的时候，会将所有图片对应的路径信息加载到内存中，当调用DiskLruCache的get方法时，其实是从DiskLruCache里面维护的一个Lru内存缓存里直接获取的；</p>
<p>所以第一步的get方法，其实是从LruCache内存缓存里面获取File对象的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cacheFile = helper.getDiskCache().get(currentKey);</span><br></pre></td></tr></table></figure>

<p>从这行代码开始，跟踪helper.getDiskCache()这个方法，最终会创建一个DiskLruCacheWrapper对象，然后调用它的get方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># DiskLruCacheWrapper</span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">get</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">safeKey</span> <span class="operator">=</span> safeKeyGenerator.getSafeKey(key); <span class="comment">// 获取安全的键</span></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;Get: Obtained: &quot;</span> + safeKey + <span class="string">&quot; for for Key: &quot;</span> + key); <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">File</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 初始化结果为null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;								<span class="comment">// get的具体逻辑在下面</span></span><br><span class="line">        <span class="keyword">final</span> DiskLruCache.<span class="type">Value</span> <span class="variable">value</span> <span class="operator">=</span> getDiskCache().get(safeKey); <span class="comment">// 从磁盘缓存中获取值</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            result = value.getFile(<span class="number">0</span>); <span class="comment">// 获取文件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Unable to get from disk cache&quot;</span>, e); <span class="comment">// 记录警告日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"># DiskLruCache   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Value <span class="title function_">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    checkNotClosed(); <span class="comment">// 检查缓存是否未关闭</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> lruEntries.get(key); <span class="comment">// 从映射中获取条目</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果未找到条目，则返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果条目不可读，则返回 null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : entry.cleanFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果条目中的任何文件丢失，则返回 null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redundantOpCount++; <span class="comment">// 增加冗余操作计数</span></span><br><span class="line">    journalWriter.append(READ); <span class="comment">// 将 READ 操作追加到日志中</span></span><br><span class="line">    journalWriter.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    journalWriter.append(key); <span class="comment">// 将键追加到日志中</span></span><br><span class="line">    journalWriter.append(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable); <span class="comment">// 如果需要，提交清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Value</span>(key, entry.sequenceNumber, entry.cleanFiles, entry.lengths); <span class="comment">// 返回一个新的 Value 对象</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>​		如果是首次初始化DiskLruCache的时候，上面的代码中getDiskCache()方法最终走到了DiskLruCache类的readJournalLine方法，这里面会创建一个Entry对象，在Entry对象的构造方法里面创建了File对象；</p>
<p>​		DiskLruCache初始化之后下载的图片，文件在存入本地的时候也会将其加入到DiskLruCache的Lru内存里，其实现是在DiskLruCache的edit()方法；这里先把生成的Entry对象加入到内存中，然后通过IO操作Editor将图片文件写入到本地，</p>
<p>总结上面的逻辑</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281833248.webp" alt="image.png"></p>
<h5 id="将File对象转化为Bitmap对象"><a href="#将File对象转化为Bitmap对象" class="headerlink" title="将File对象转化为Bitmap对象"></a>将File对象转化为Bitmap对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123; <span class="comment">// 如果尚未开始且有下一个模型加载器</span></span><br><span class="line">      ModelLoader&lt;File, ?&gt; modelLoader = modelLoaders.get(modelLoaderIndex++); <span class="comment">// 获取模型加载器</span></span><br><span class="line">      <span class="comment">// 构建加载数据</span></span><br><span class="line">      loadData =</span><br><span class="line">          modelLoader.buildLoadData(</span><br><span class="line">              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());</span><br><span class="line">      <span class="keyword">if</span> (loadData != <span class="literal">null</span> &amp;&amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) &#123; <span class="comment">// 如果加载数据有效且有加载路径</span></span><br><span class="line">        started = <span class="literal">true</span>; <span class="comment">// 标记开始加载</span></span><br><span class="line">        loadData.fetcher.loadData(helper.getPriority(), <span class="built_in">this</span>); <span class="comment">// 加载数据</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281834833.webp" alt="image.png"></p>
<p>上面获取到的字节数据ByteBuffer，最终会回调到DecodeJob这个类，在这里面实现了解码的逻辑；</p>
<p>看一下DecodeJob的onDataFetcherReady方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataFetcherReady</span><span class="params">(</span></span><br><span class="line"><span class="params">    Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面调用了decodeFromRetrievedData方法来解码图片流数据；</p>
<p>这里通过LoadPath类来实现解码的功能</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281837384.webp" alt="image.png"></p>
<p>至此从磁盘获取数据就解析完了</p>
<h4 id="从网络获取资源"><a href="#从网络获取资源" class="headerlink" title="从网络获取资源"></a>从网络获取资源</h4><p>加载网络缓存的地方是在SourceGenerator类的startNext方法，我们来看一下大致的实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># SourceGenerator</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否有数据需要缓存</span></span><br><span class="line">    <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> dataToCache;</span><br><span class="line">        dataToCache = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试缓存数据</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isDataInCache</span> <span class="operator">=</span> cacheData(data);</span><br><span class="line">            <span class="comment">// 如果缓存失败，直接返回 true，表示本次加载任务结束</span></span><br><span class="line">            <span class="keyword">if</span> (!isDataInCache) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果缓存成功，继续执行后续逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 处理缓存过程中可能出现的 IOException</span></span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Failed to properly rewind or write data to cache&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从源缓存生成器加载数据</span></span><br><span class="line">    <span class="keyword">if</span> (sourceCacheGenerator != <span class="literal">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置源缓存生成器</span></span><br><span class="line">    sourceCacheGenerator = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化加载数据</span></span><br><span class="line">    loadData = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历模型加载器，尝试启动下一个加载任务</span></span><br><span class="line">    <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">        loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">        <span class="keyword">if</span> (loadData != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">                || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">            startNextLoad(loadData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否成功启动加载任务</span></span><br><span class="line">    <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> &#123;</span><br><span class="line">    loadData.fetcher.loadData(</span><br><span class="line">        helper.getPriority(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		这个方法做了两步，第一步是缓存数据，第二步就是从网络下载图片资源了；</p>
<p>​		下面这个实现看起来是不是很熟悉，和磁盘缓存的逻辑一样，也是通过ModelLoader来加载数据；</p>
<p>​		而这个ModelLoader也是通过Registry来获取的，创建的地方也是通过Registry在Glide的构造方法里进行创建，并缓存到缓存里；</p>
<p>​		而这里最终调用的ModelLoader是HttpGlideUrlLoader，加载网络数据的地方是在HttpUrlFetcher的loadData方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="literal">null</span>, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;Failed to load data for url&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">&quot;Finished http url fetcher fetch in &quot;</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>loadDataWithRedirects方法里面实就是Android原生的网络请求，通过创建HttpURLConnection来从网络获取图片数据；</p>
<p>回去成功后通过callback回调了回去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>​		onDataReadyInternal(toStart, data);方法里面只是对当前类SourceGenerator的成员dataToCache进行赋值。</p>
<p>​		然后回头看startNext方法，一开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否有数据需要缓存</span></span><br><span class="line">   <span class="keyword">if</span> (dataToCache != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 尝试缓存数据</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isDataInCache</span> <span class="operator">=</span> cacheData(data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>cacheData方法就是将数据写进了磁盘缓存中，具体的代码就不看了。</p>
<h2 id="内存缓存的具体实现"><a href="#内存缓存的具体实现" class="headerlink" title="内存缓存的具体实现"></a>内存缓存的具体实现</h2><p>回顾上面的代码 “从LRU缓存里面获取图片资源” 这一节，里面调用了getEngineResourceFromCache这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  <span class="comment">// 从缓存中移除并获取资源</span></span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EngineResource&lt;?&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (cached == <span class="literal">null</span>) &#123; <span class="comment">// 如果缓存中没有资源</span></span><br><span class="line">    result = <span class="literal">null</span>; <span class="comment">// 结果为null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cached <span class="keyword">instanceof</span> EngineResource) &#123; <span class="comment">// 如果缓存的是EngineResource对象</span></span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached; <span class="comment">// 直接转换为EngineResource对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果缓存的是其他类型的资源，创建一个新的EngineResource对象</span></span><br><span class="line">    result =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EngineResource</span>&lt;&gt;(</span><br><span class="line">            cached,</span><br><span class="line">            <span class="comment">/* isMemoryCacheable= */</span> <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">/* isRecyclable= */</span> <span class="literal">true</span>,</span><br><span class="line">            key,</span><br><span class="line">            <span class="comment">/* listener= */</span> <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回从缓存中获取的EngineResource对象，如果没有则为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的cache的具体实现类是LruResourceCache</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruResourceCache</span> <span class="keyword">extends</span> <span class="title class_">LruCache</span>&lt;Key, Resource&lt;?&gt;&gt; <span class="keyword">implements</span> <span class="title class_">MemoryCache</span></span><br></pre></td></tr></table></figure>

<p>这里的LruCache类就是实现的Lru算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruCache</span>&lt;T, Y&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, Entry&lt;Y&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">100</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> initialMaxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> maxSize;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> currentSize;</span><br><span class="line">    ......</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">    Map.Entry&lt;T, Entry&lt;Y&gt;&gt; last; <span class="comment">// 用于存储最后一个条目的变量</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;T, Entry&lt;Y&gt;&gt;&gt; cacheIterator; <span class="comment">// 缓存的迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直到缓存的当前大小小于或等于期望的大小</span></span><br><span class="line">    <span class="keyword">while</span> (currentSize &gt; size) &#123;</span><br><span class="line">        cacheIterator = cache.entrySet().iterator(); <span class="comment">// 获取缓存条目的迭代器</span></span><br><span class="line">        last = cacheIterator.next(); <span class="comment">// 获取第一个条目（由于访问顺序，这是最近最少使用的条目）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Entry&lt;Y&gt; toRemove = last.getValue(); <span class="comment">// 获取要移除的条目</span></span><br><span class="line">        currentSize -= toRemove.size; <span class="comment">// 从当前大小中减去被移除条目的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">T</span> <span class="variable">key</span> <span class="operator">=</span> last.getKey(); <span class="comment">// 获取被移除条目的键</span></span><br><span class="line">        cacheIterator.remove(); <span class="comment">// 从缓存中移除该条目</span></span><br><span class="line"></span><br><span class="line">        onItemEvicted(key, toRemove.value); <span class="comment">// 调用回调方法来处理条目的逐出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中LinkedHashMap的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final Map&lt;T, Entry&lt;Y&gt;&gt; cache = new LinkedHashMap&lt;&gt;(100, 0.75f, true);</span><br></pre></td></tr></table></figure>

<p>​		这个 <code>LinkedHashMap</code> 被初始化为一个具有 100 的初始容量，0.75 的加载因子，并且按照访问顺序来维护键值对，这使得它适合用作缓存的底层实现。</p>
<p>这个类中最重要的一个方法trimToSize，它实现了缓存的移除逻辑：</p>
<p>​		移除条目，直到缓存的总大小小于或等于期望的大小。对于每个被移除的条目，它会更新缓存的当前大小，并调用一个回调方法（<code>onItemEvicted</code>）来执行在缓存中逐出条目时所需的任何额外操作。</p>
<p><strong>这里还涉及到一个知识点就是在移除条目的时候如何判断条目有没有被引用</strong></p>
<p>继续看上面的trimToSize方法，它里面的onItemEvicted(key, toRemove.value);被实现在LruResourceCache中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># LruResourceCache</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onItemEvicted</span><span class="params">(<span class="meta">@NonNull</span> Key key, <span class="meta">@Nullable</span> Resource&lt;?&gt; item)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (listener != <span class="literal">null</span> &amp;&amp; item != <span class="literal">null</span>) &#123;</span><br><span class="line">     listener.onResourceRemoved(item);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个回调的最终实现是在EngineResource类的recycle方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># EngineResource</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">recycle</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (acquired &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot recycle a resource while it is still acquired&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRecycled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot recycle a resource that has already been recycled&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  isRecycled = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRecyclable) &#123;</span><br><span class="line">    resource.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里有个判读就是在acquired大于0时会抛异常，acquired是当前资源的引用计数。每当资源被引用的时候会加一，当资源不再被需要时（例如，当图片从屏幕上移除时），<code>acquired</code> 的值会减一。</p>
<p>获取图片时，会首先从软引用寻找，没有的话从Lru缓存里寻找，找到的话会返回资源，同时将资源添加到弱引用队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">private</span> EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">      cached.acquire();</span><br><span class="line">      <span class="comment">// 添加到弱引用队列中</span></span><br><span class="line">      activeResources.activate(key, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​		下次再要被引用时可以直接从弱引用队列中获得资源，当图片不再使用的时候，比如说暂停请求或者加载完毕或者清除资源时，就会将其从弱引用中转移到LruCache缓存池中。总结一下，就是正在使用中的图片使用弱引用来进行缓存，暂时不用的图片使用LruCache来进行缓存的功能;同一张图片只会出现在弱引用和LruCache中的一个。</p>
<h2 id="磁盘缓存的具体实现"><a href="#磁盘缓存的具体实现" class="headerlink" title="磁盘缓存的具体实现"></a>磁盘缓存的具体实现</h2><p>​		磁盘缓存是通过DiskLruCache来管理的,根据缓存策略，会有2种类型的图片，DATA(原始图片)和 RESOURCE（转换后的图片）。磁盘缓存依次通过ResourcesCacheGenerator、SourceGenerator、DataCacheGenerator来获取缓存数据。ResourcesCacheGenerator获取的是转换过的缓存数据；SourceGenerator获取的是未经转换的原始的缓存数据；DataCacheGenerator是通过网络获取图片数据再按照按照缓存策略的不同去缓存不同的图片到磁盘上。</p>
<p>​		根据缓存策略的不同会获取到不同类型的缓存图片。它的逻辑是：先从转换后的缓存中取；没有的话再从原始的（没有转换过的）缓存中拿数据；再没有的话就从网络加载图片数据，获取到数据之后，再依次缓存到磁盘和弱引用。</p>
<h2 id="缓存读取顺序"><a href="#缓存读取顺序" class="headerlink" title="缓存读取顺序"></a>缓存读取顺序</h2><p>弱引用缓存 -&gt; LruCache -&gt; DiskLruCache</p>
<p>Engine类的load方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; LoadStatus <span class="title function_">load</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="comment">/* 参数 */</span>)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>; </span><br><span class="line">  <span class="type">EngineKey</span> <span class="variable">key</span> <span class="operator">=</span> keyFactory.buildKey();</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource; </span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; </span><br><span class="line">    <span class="comment">// 尝试从内存缓存中加载资源</span></span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="literal">null</span>) &#123; </span><br><span class="line">      <span class="comment">// 从硬盘搜索或者网络加载</span></span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          <span class="comment">/* 参数 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调资源</span></span><br><span class="line">  cb.onResourceReady(</span><br><span class="line">      memoryResource, DataSource.MEMORY_CACHE, <span class="comment">/* isLoadedFromAlternateCacheKey= */</span> <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存得写入顺序"><a href="#缓存得写入顺序" class="headerlink" title="缓存得写入顺序"></a>缓存得写入顺序</h2><p>网络获取  -&gt; DiskLruCache 缓存原图  -&gt;  弱引用缓存  -&gt;  LruCache  -&gt;  DiskLruCache 缓存编码后的图片</p>
<p>加载网络数据的地方是在HttpUrlFetcher的loadData方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> DataCallback&lt;? <span class="built_in">super</span> InputStream&gt; callback)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> LogTime.getLogTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//进行网络请求</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">result</span> <span class="operator">=</span> loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="literal">null</span>, glideUrl.getHeaders()); </span><br><span class="line">      callback.onDataReady(result); <span class="comment">//调用 SourceGenerator的onDataReady()方法</span></span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后看回调的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startNextLoad</span><span class="params">(<span class="keyword">final</span> LoadData&lt;?&gt; toStart)</span> &#123;</span><br><span class="line">    loadData.fetcher.loadData(</span><br><span class="line">        helper.getPriority(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DataCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDataReady</span><span class="params">(<span class="meta">@Nullable</span> Object data)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onDataReadyInternal(toStart, data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLoadFailed</span><span class="params">(<span class="meta">@NonNull</span> Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentRequest(toStart)) &#123;</span><br><span class="line">              onLoadFailedInternal(toStart, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDataReadyInternal</span><span class="params">(LoadData&lt;?&gt; loadData, Object data)</span> &#123;</span><br><span class="line">    <span class="type">DiskCacheStrategy</span> <span class="variable">diskCacheStrategy</span> <span class="operator">=</span> helper.getDiskCacheStrategy();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">      dataToCache = data; <span class="comment">//关注点1</span></span><br><span class="line">      cb.reschedule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher, </span><br><span class="line">          loadData.fetcher.getDataSource(), originalKey); <span class="comment">//关注点2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从网络请求图片资源，请求完成后将请求结果传给了 SourceGenerator 的 onDataReday()：</p>
<p>​		看关注点1，如果请求返回的数据 data 不为空且需要缓存原始数据，就将 data 赋值给我们刚才提到的 dataToCache，接着调用 cb.reschedule() 会再一次进入到 SourceGenerator 的 startNext() 方法，这个时候 dataToCache 已经不为空就可以写入磁盘缓存了，然后进入cacheData方法进行写内存的操作。注意这里是缓存的原始未经过任何修改的图片，如果不需要缓存原始数据，直接调用 DecodeJob.onDataFetcherReady()。</p>
<p>​	</p>
<p>​		关注点2，最终会回调到EngineJob的onResourceReady方法，接着再封装后回调到Engine的onEngineJobComplete方法，里面调用了ActiveResources的activate方法将资源存入弱引用队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># EngineJob</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResourceReady</span><span class="params">(</span></span><br><span class="line"><span class="params">      Resource&lt;R&gt; resource, DataSource dataSource, <span class="type">boolean</span> isLoadedFromAlternateCacheKey)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.resource = resource;</span><br><span class="line">      <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">      <span class="built_in">this</span>.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyCallbacksOfResult();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># Engine</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">onEngineJobComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">      EngineJob&lt;?&gt; engineJob, Key key, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; resource.isMemoryCacheable()) &#123;</span><br><span class="line">      activeResources.activate(key, resource);</span><br><span class="line">    &#125;</span><br><span class="line">    jobs.removeIfCurrent(key, engineJob);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># ActiveResources</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">activate</span><span class="params">(Key key, EngineResource&lt;?&gt; resource)</span> &#123;</span><br><span class="line">    <span class="type">ResourceWeakReference</span> <span class="variable">toPut</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourceWeakReference</span>(</span><br><span class="line">            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">    <span class="type">ResourceWeakReference</span> <span class="variable">removed</span> <span class="operator">=</span> activeEngineResources.put(key, toPut);</span><br><span class="line">    <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">      removed.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>​	进入弱引用队列后就可以开始它和LRU缓存的逻辑了。</p>
<p><a href="https://www.jianshu.com/p/171793326b94">https://www.jianshu.com/p/171793326b94</a></p>
<p><a href="">Glide的缓存源码分析</a></p>
<p><a href="https://juejin.cn/post/6970683481127043085?searchId=202403012037006E1E0D02801CA59E3EF8#heading-4">【带着问题学】Glide做了哪些优化?</a></p>
<p><a href="https://juejin.cn/post/6891307560557608967?searchId=202403012037006E1E0D02801CA59E3EF8#heading-7">#</a></p>
<p><a href="https://juejin.cn/post/6951585628890857480?searchId=202403012037006E1E0D02801CA59E3EF8">BitmapPool 了解吗？Glide 是如何实现 Bitmap 复用的？</a></p>
<p><a href="https://juejin.cn/post/7014041490439536654?searchId=202403111637516D0024166BE83DC9A93A#heading-13">Glide源码解析</a></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="Glide从Lru内存里移除得图片-是咋处理的？"><a href="#Glide从Lru内存里移除得图片-是咋处理的？" class="headerlink" title="Glide从Lru内存里移除得图片 是咋处理的？"></a>Glide从Lru内存里移除得图片 是咋处理的？</h4><p>Glide 处理从 LRU（Least Recently Used，最近最少使用）内存缓存中移除图片的流程大致如下：</p>
<ol>
<li><strong>缓存策略</strong>:<ul>
<li>Glide 使用 LRU 算法作为其内存缓存的管理策略。这意味着当内存缓存达到预设的最大容量时，最近最少使用的图片会被移除以腾出空间给新的图片。</li>
</ul>
</li>
<li><strong>触发条件</strong>:<ul>
<li>当新的图片需要被加载并缓存时，如果内存缓存已满，Glide 会根据 LRU 算法选择要移除的图片。</li>
</ul>
</li>
<li><strong>移除流程</strong>:<ul>
<li>Glide 会从内存缓存中移除选定的图片，并确保相关的资源被适当地回收。这通常涉及到减少图片引用计数，并在没有其他引用时释放图片占用的内存。</li>
</ul>
</li>
<li><strong>资源回收</strong>:<ul>
<li>如果移除的图片没有其他地方在使用，Glide 会负责回收这些图片占用的资源，比如 Bitmap 对象。这是通过调用 Bitmap 的 <code>recycle()</code> 方法来实现的，该方法会释放 Bitmap 占用的内存。</li>
</ul>
</li>
<li><strong>监听和回调</strong>:<ul>
<li>Glide 提供了监听器和回调机制，允许开发者在图片被缓存、移除或加载时执行自定义操作。这可以用于监控缓存的使用情况或处理特定的缓存事件。</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Android 虚拟机</title>
    <url>/2024/02/02/Android%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="Android-虚拟机"><a href="#Android-虚拟机" class="headerlink" title="Android 虚拟机"></a>Android 虚拟机</h1><p>在Android系统中，Java虚拟机是借由大名鼎鼎的Zygote进程来创建的。Zygote是Java世界的创造者——即Android中所有Java进程都由Zygote进程fork而来，而Zygote进程自己又是Linux系统上的init进程通过解析配置脚本来启动的。</p>
<h2 id="Dalvik-DVM"><a href="#Dalvik-DVM" class="headerlink" title="Dalvik DVM"></a>Dalvik DVM</h2><h3 id="与JVM对比"><a href="#与JVM对比" class="headerlink" title="与JVM对比"></a>与JVM对比</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-93cda252f04eaa29f9e0a3cd27ba2470_1440w.webp" alt="img"></p>
<p><strong>基于栈的虚拟机（如 Java 虚拟机 - JVM）：</strong></p>
<p>基于栈的虚拟机每一个运行的线程，都有一个独立的栈，栈中记录了方法调用的历史，每一个方法的调用，都对应一个栈帧，并且将栈帧压入栈中，最顶部的栈帧为当前栈帧，既 当前执行的方法，基于栈帧与操作数栈进行所有操作。</p>
<p>执行流程：</p>
<ul>
<li><strong>将栈顶某类型值存入局部变量某处</strong>：这是说，我们从栈（一种数据结构，可以想象成一摞盘子）的顶部取出一个值（就像取走最上面的盘子），然后把这个值放到我们的”局部变量”中。你可以把”局部变量”想象成一种存储区域，我们可以在那里放东西，以便稍后使用。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要暂时保存一些数据以便稍后使用时发生。例如，你可能正在计算一个复杂的表达式，需要将中间结果暂时保存下来，以便在稍后的计算中使用。这时，你就可以将这个中间结果（即栈顶的值）保存到局部变量中。</p>
</blockquote>
<ul>
<li><strong>将局部变量中某处某类型常量压入操作数栈</strong>：这是说，我们从”局部变量”中取出一个值（就像从抽屉里取出一件衣服），然后把这个值放到栈的顶部（就像把一个新盘子放到盘子堆的顶部）。</li>
</ul>
<blockquote>
<p>这个操作通常在你需要使用之前保存的数据时发生。例如，你可能需要使用之前保存的中间结果来完成表达式的计算。这时，你就可以将这个中间结果（即局部变量中的值）压入栈中，以便进行接下来的计算。</p>
</blockquote>
<ul>
<li><strong>执行相关指令</strong>：这是说，我们要执行一些操作，这些操作可能会使用栈顶的值，也可能会改变栈顶的值，或者做其他的事情。这些操作是由虚拟机的指令集定义的，每一种指令都有特定的功能，例如加法、减法、乘法等。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-404079569b9204d0783c7a324e201fcb_1440w.webp" alt="img"></p>
<p><strong>基于寄存器的虚拟机（如 Dalvik 虚拟机 - DVM）</strong>：</p>
<p>基于寄存器的虚拟机中没有操作数栈，不过有很多虚拟寄存器，类似操作数栈，这些寄存器也存放在运行时栈中，本质上就是一个数组，与JVM相似，在Dalvik 虚拟机中每个线程都有自己的程序计数器 和 调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p>
<blockquote>
<p>寄存器 CPU的组成部分，寄存器是有限存储容量的高速存储容器（计算机中各级存储速度 寄存器-&gt; 一级缓存-&gt;二级缓存 -&gt; 内存 -&gt; 硬盘），可以用来管理指令、数据的地址。</p>
</blockquote>
<p>执行流程：</p>
<p>直接依据指令，将某类型值存入虚拟寄存器中，相关的操作也依据指令在虚拟寄存器中通过CPU处理，将处理结果返回虚拟寄存器（省掉了基于栈的流程中局部变量与操作数栈中数据的流动）</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-f7c8576e5446b47136b6836b83c8caac_1440w.webp" alt="img"></p>
<p><a href="https://www.zhihu.com/question/20207106">借鉴文章</a></p>
<h3 id="DVM本身的优化"><a href="#DVM本身的优化" class="headerlink" title="DVM本身的优化"></a>DVM本身的优化</h3><ol>
<li>将多个类文件收集到同一个dex文件中，以便节省空间；</li>
<li>使用只读的内存映射方式加载dex文件，以便可以多进程共享dex文件，节省程序加载时间；</li>
<li>提前调整好字节序（byte order）和字对齐（word alignment）方式，使得它们更适合于本地机器，以便提高指令执行速度；</li>
<li>尽量提前进行字节码验证（bytecode verification），提高程序的加载速度；</li>
<li>需要重写字节码的优化要提前进行。</li>
</ol>
<h3 id="DVM内存管理"><a href="#DVM内存管理" class="headerlink" title="DVM内存管理"></a>DVM内存管理</h3><p>Dalvik虚拟机的内存大体上可以分为Java Object Heap、Bitmap Memory和Native Heap三种。</p>
<p><strong>Java Object Heap：</strong>用来分配Java对象的，也就是我们在代码new出来的对象都是位于Java Object Heap上的。</p>
<p><strong>Bitmap Memory：</strong>在Android 3.0之前，Bitmap Memory是在Native Heap中分配的，但是这部分内存同样计入Java Object Heap中，也就是说，Bitmap占用的内存和Java Object占用的内存加起来不能超过Java Object Heap的最大值。在Android 3.0以及更高的版本中，<strong>Bitmap Memory就直接是在Java Object Heap中分配了，这样就可以直接接受GC的管理。</strong>Native Heap就是在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<p><strong>Native Heap：</strong>在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制</p>
<h3 id="简述GC"><a href="#简述GC" class="headerlink" title="简述GC"></a>简述GC</h3><p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h3 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译(JIT)"></a>即时编译(JIT)</h3><p>JIT是相对AOT而言的，即JIT是在程序运行的过程中进行编译的，而AOT是在程序运行前进行编译的</p>
<h3 id="DVM进程和线程管理特点"><a href="#DVM进程和线程管理特点" class="headerlink" title="DVM进程和线程管理特点"></a>DVM进程和线程管理特点</h3><ol>
<li>每一个Android应用程序进程都有一个Dalvik虚拟机实例。这样做的好处是Android应用程序进程之间不会相互影响，也就是说，一个Android应用程序进程的意外中止，不会影响到其它的Android应用程序进程的正常运行。</li>
<li>每一个Android应用程序进程都是由一种称为Zygote的进程fork出来的。Zygote进程是由init进程启动起来的，也就是在系统启动的时候启动的。Zygote进程在启动的时候，会创建一个虚拟机实例，并且在这个虚拟机实例将所有的Java核心库都加载起来。每当Zygote进程需要创建一个Android应用程序进程的时候，它就通过复制自身来实现，也就是通过fork系统调用来实现。这些被fork出来的Android应用程序进程，一方面是复制了Zygote进程中的虚拟机实例，另一方面是与Zygote进程共享了同一套Java核心库。这样不仅Android应用程序进程的创建过程很快，而且由于所有的Android应用程序进程都共享同一套Java核心库而节省了内存空间。</li>
</ol>
<h3 id="DVM启动分析"><a href="#DVM启动分析" class="headerlink" title="DVM启动分析"></a>DVM启动分析</h3><p>启动过程主要就是完成了以下四个事情：</p>
<ol>
<li>创建了一个Dalvik虚拟机实例；</li>
<li>加载了Java核心类及其JNI方法；</li>
<li>为主线程的设置了一个JNI环境；</li>
<li>注册了Android核心类的JNI方法。</li>
</ol>
<p>​		Zygote进程为Android系统准备好了一个Dalvik虚拟机实例，以后Zygote进程在创建Android应用程序进程的时候，就可以将它自身的Dalvik虚拟机实例复制到新创建Android应用程序进程中去，从而加快了Android应用程序进程的启动过程。此外，Java核心类和Android核心类（位于dex文件中），以及它们的JNI方法（位于so文件中），都是以内存映射的方式来读取的，因此，<strong>在Android系统中，应用程序进程都是由Zygote进程孵化出来的，而Zygote进程是由Init进程启动的。Zygote进程在启动时会创建一个Dalvik虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的Dalvik虚拟机实例。</strong></p>
<h3 id="DVM下的GC"><a href="#DVM下的GC" class="headerlink" title="DVM下的GC"></a>DVM下的GC</h3><p><a href="https://jasonzhong.github.io/2017/09/28/Android-%E6%B5%85%E6%9E%90-GC-%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">Android-浅析-GC-基础原理</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/41822747">Dalvik虚拟机垃圾收集（GC）过程分析</a></p>
<p>Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做Active Heap，另一部分叫做Zygote Heap。<strong>Zygote堆用来管理Zygote进程在启动过程中预加载和创建的各种对象</strong>，而Active堆是在Zygote进程fork第一个子进程之前创建的。之后无论是Zygote进程还是其子进程，都在Active堆上进行对象分配和释放。这样做的目的是使得Zygote进程和其子进程最大限度地共享Zygote堆所占用的内存。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240127151630567.png" alt="image-20240127151630567"></p>
<p>Dalvik虚拟机需要一些辅助数据结构，包括一个Card Table、两个Heap Bitmap和一个Mark Stack。</p>
<p>Card Table：记录在垃圾收集过程中对象的引用情况的，以便可以实现Concurrent G。</p>
<p>Live Heap Bitmap：用来记录上次GC之后，还存活的对象</p>
<p>Mark Heap Bitmap：用来记录当前GC中还存活的对象。</p>
<p>上次GC后存活的但是当前GC不存活的对象，就是需要释放的对象。<strong>Davlk虚拟机使用标记-清除（Mark-Sweep）算法进行GC。</strong>在标记阶段，通过一个<strong>Mark Stack来实现递归检查被引用的对象</strong>，即在当前GC中存活的对象。有了这个Mark Stack，就可以通过循环来模拟函数递归调用。Mark阶段从根集（Root Set）开始，递归地<strong>标记出当前所有被引用的对象</strong>，而Sweep阶段负责回收那些没有被引用的对象。</p>
<p>在分析Dalvik虚拟机使用的Mark-Sweep算法之前，我们先来了解一下什么情况下会触发GC。Dalvik虚拟机在三种情况下会触发四种类型的GC。</p>
<p>jvm将GC抽象成了一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GcSpec</span> &#123;    </span><br><span class="line">  <span class="type">bool</span> isPartial;  <span class="comment">// 为true时，表示仅仅回收Active堆的垃圾；为false时，表示同时回收Active堆和Zygote堆的垃圾。</span></span><br><span class="line">  <span class="type">bool</span> isConcurrent; <span class="comment">// 为true时，表示执行并行GC；为false时，表示执行非并行GC。</span></span><br><span class="line">  <span class="type">bool</span> doPreserve;  <span class="comment">// 为true时，表示在执行GC的过程中，不回收软引用引用的对象；为false时，表示在执行GC的过程中，回收软引用引用的对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *reason;  <span class="comment">// 描述</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>然后产生了四种GC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_FOR_MALLOC;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_CONCURRENT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_EXPLICIT;  </span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> GcSpec *GC_BEFORE_OOM;  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>GC_FOR_MALLOC</strong>: 表示是在堆上分配对象时内存不足触发的GC。</li>
<li><strong>GC_CONCURRENT</strong>: 表示是在已分配内存达到一定量之后触发的GC。</li>
<li><strong>GC_EXPLICIT</strong>: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。</li>
<li><strong>GC_BEFORE_OOM</strong>: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</li>
</ul>
<p>GC_FOR_MALLOC、GC_CONCURRENT和GC_BEFORE_OOM三种类型的GC都是在分配对象的过程触发的</p>
<p>Dalvik虚拟机支持非并行和并行两种GC,它们的总体流程是相似的，主要差别在于前者在执行的过程中一直是挂起非GC线程的，而后者是有条件地挂起非GC线程。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20Dalvik%20GC.png" alt="Android Dalvik GC"></p>
<p>以上就是并行和非并行GC的执行总体流程，它们的主要区别在于，<strong>前者在GC过程中，有条件地挂起和唤醒非GC线程，而后者在执行GC的过程中，一直都是挂起非GC线程的。</strong>并行GC通过有条件地挂起和唤醒非GC线程，就可以使得应用程序获得更好的响应性。但是我们也应该看到，并行GC需要多执行一次标记根集对象以及递归标记那些在GC过程被访问了的对象的操作。也就是说，并行GC在使用得应用程序获得更好的响应性的同时，也需要花费更多的CPU资源。</p>
<p>在Android 2.3之前，Dalvik虚拟使用的垃圾收集机制有以下特点：</p>
<ol>
<li>Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；</li>
<li>Full heap collection，也就是一次收集完全部的垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都大于100ms。</li>
</ol>
<p>在Android 2.3以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：</p>
<ol>
<li>Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；</li>
<li>Partial collection，也就是一次可能只收集一部分垃圾；</li>
<li>一次垃圾收集造成的程序中止时间通常都小于5ms。</li>
</ol>
<h2 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h2><p>下面都是基于Android4.4</p>
<h3 id="ART替换DVM"><a href="#ART替换DVM" class="headerlink" title="ART替换DVM"></a>ART替换DVM</h3><p>ART虚拟机，它和Dalvik虚拟机、Java虚拟机的关系如图1所示：<br><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/d3c3b501eff5f127d1227631137b4c81_653x445.png" alt="d3c3b501eff5f127d1227631137b4c81_653x445">Dalvik虚拟机和ART虚拟机都实现了三个用来抽象Java虚拟机的接口：</p>
<ol>
<li>JNI_GetDefaultJavaVMInitArgs – 获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM – 在进程中创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs – 获取进程中创建的虚拟机实例</li>
</ol>
<p>在Android系统中，Davik虚拟机实现在libdvm.so中，ART虚拟机实现在libart.so中。也就是说，libdvm.so和libart.so导出了JNI_GetDefaultJavaVMInitArgs、JNI_CreateJavaVM和JNI_GetCreatedJavaVMs这三个接口，供外界调用。</p>
<p>此外，Android系统还提供了一个系统属性persist.sys.dalvik.vm.lib，它的值要么等于libdvm.so，要么等于libart.so。当等于libdvm.so时，就表示当前用的是Dalvik虚拟机，而当等于libart.so时，就表示当前用的是ART虚拟机。</p>
<p>以上描述的Dalvik虚拟机和ART虚拟机的共同之处，当然它们之间最显著还是不同之处。不同的地方就在于，<strong>Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码。</strong>这意味着Dalvik虚拟机包含有一个解释器，用来执行dex字节码，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8852432">Dalvik虚拟机简要介绍和学习计划</a>这个系列的文章。当然，Android从2.2开始，也包含有JIT（Just-In-Time），用来在运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后再执行。通过JIT，就可以有效地提高Dalvik虚拟机的执行效率。但是，<strong>将dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作的。</strong>因此，即使用采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。</p>
<p>DVM在应用在安装的过程，其实也会执行一次“翻译”的过程。只不过这个“翻译”的过程是将dex字节码进行优化，也就是由dex文件生成odex文件。而ART将这个过程换成了直接翻译成机器码，从流程的角度来说没什么改变。</p>
<p>应用程序的安装发生在两个时机，<strong>第一个时机是系统启动的时候，第二个时机系统启动完成后用户自行安装的时候。</strong>在第一个时机中，系统除了会对&#x2F;system&#x2F;app和&#x2F;data&#x2F;app目录下的所有APK进行dex字节码到本地机器码的翻译之外，还会对&#x2F;system&#x2F;framework目录下的APK或者JAR文件，以及这些APK所引用的外部JAR，进行dex字节码到本地机器码的翻译。这样就可以保证除了应用之外，系统中使用Java来开发的系统服务，也会统一地从dex字节码翻译成本地机器码。也就是说，将Android系统中的Dalvik虚拟机替换成ART运行时之后，系统中的代码都是由ART运行时来执行的了，这时候就不会对Dalvik虚拟机产生任何的依赖。</p>
<h3 id="ART简要介绍"><a href="#ART简要介绍" class="headerlink" title="ART简要介绍"></a>ART简要介绍</h3><p>在APK运行之前，就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了。这种技术不但使得我们可以不对原有的APK作任何修改，还可以使得这些APK只需要在安装时翻译一次，就可以无数次以本地机器指令的形式运行。在ART中，打包在APK里面的Dex字节码是通过LLVM翻译成本地机器指令的。LLVM是一个用来快速开发自己的编译器的框架系统</p>
<p>在ART运行时中，APK在安装的时候，安装服务PackageManagerService会通过守护进程installd调用另外一个工具dex2oat对打包在APK里面包含有Dex字节码进翻译。这个翻译器实际上就是基于LLVM架构实现的一个编译器，它的前端是一个Dex语法分析器。</p>
<p>ART的运行原理：</p>
<ul>
<li>在Android系统启动过程中创建的Zygote进程利用ART运行时导出的Java虚拟机接口创建ART虚拟机。</li>
<li>APK在安装的时候，打包在里面的classes.dex文件会被工具dex2oat翻译成本地机器指令，最终得到一个ELF格式的oat文件。</li>
<li>APK运行时，上述生成的oat文件会被加载到内存中，并且ART虚拟机可以通过里面的oatdata和oatexec段找到任意一个类的方法对应的本地机器指令来执行。</li>
</ul>
<h3 id="ART加载OAT文件"><a href="#ART加载OAT文件" class="headerlink" title="ART加载OAT文件"></a>ART加载OAT文件</h3><p>Android运行时ART，它的核心是OAT文件。OAT文件是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p>APK在安装的过程中，会通过dex2oat工具生成一个OAT文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">run_dex2oat</span><span class="params">(<span class="type">int</span> zip_fd, <span class="type">int</span> oat_fd, <span class="type">const</span> <span class="type">char</span>* input_file_name,    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span>* output_file_name, <span class="type">const</span> <span class="type">char</span>* dexopt_flags)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* DEX2OAT_BIN = <span class="string">&quot;/system/bin/dex2oat&quot;</span>;    </span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_INT_LEN = <span class="number">12</span>;      <span class="comment">// &#x27;-&#x27;+10dig+&#x27;\0&#x27; -OR- 0x+8dig    </span></span><br><span class="line">    <span class="type">char</span> zip_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> zip_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--zip-location=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    <span class="type">char</span> oat_fd_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-fd=&quot;</span>) + MAX_INT_LEN];    </span><br><span class="line">    <span class="type">char</span> oat_location_arg[<span class="built_in">strlen</span>(<span class="string">&quot;--oat-name=&quot;</span>) + PKG_PATH_MAX];    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_fd_arg, <span class="string">&quot;--zip-fd=%d&quot;</span>, zip_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(zip_location_arg, <span class="string">&quot;--zip-location=%s&quot;</span>, input_file_name);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_fd_arg, <span class="string">&quot;--oat-fd=%d&quot;</span>, oat_fd);    </span><br><span class="line">    <span class="built_in">sprintf</span>(oat_location_arg, <span class="string">&quot;--oat-location=%s&quot;</span>, output_file_name);    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Running %s in=%s out=%s\n&quot;</span>, DEX2OAT_BIN, input_file_name, output_file_name);    </span><br><span class="line">    <span class="built_in">execl</span>(DEX2OAT_BIN, DEX2OAT_BIN,    </span><br><span class="line">          zip_fd_arg, zip_location_arg,    </span><br><span class="line">          oat_fd_arg, oat_location_arg,    </span><br><span class="line">          (<span class="type">char</span>*) <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;execl(%s) failed: %s\n&quot;</span>, DEX2OAT_BIN, <span class="built_in">strerror</span>(errno));    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="ART堆组成"><a href="#ART堆组成" class="headerlink" title="ART堆组成"></a>ART堆组成</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141224005343406" alt="img"></p>
<p>​		ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space。其中，Image Space、Zygote Space、Allocation Space是在地址上连续的空间，称为Continuous Space，而Large Object Space是一些离散地址的集合，用来分配一些大对象，称为Discontinuous Space。</p>
<p>​		在Image Space和Zygote Space之间，隔着一段用来映射system@<a href="mailto:&#x66;&#114;&#97;&#109;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#x6f;&#x74;&#46;&#97;&#x72;&#x74;">&#x66;&#114;&#97;&#109;&#x65;&#119;&#111;&#114;&#x6b;&#x40;&#x62;&#111;&#x6f;&#x74;&#46;&#97;&#x72;&#x74;</a>@classes.oat文件的内存。system@<a href="mailto:&#x66;&#114;&#97;&#x6d;&#101;&#x77;&#x6f;&#114;&#x6b;&#64;&#x62;&#111;&#x6f;&#x74;&#x2e;&#97;&#x72;&#x74;">&#x66;&#114;&#97;&#x6d;&#101;&#x77;&#x6f;&#114;&#x6b;&#64;&#x62;&#111;&#x6f;&#x74;&#x2e;&#97;&#x72;&#x74;</a>@classes.oat是一个OAT文件，它是由在系统启动类路径中的所有DEX文件翻译得到的，而<strong>Image Space空间就包含了那些需要预加载的系统类对象。</strong>这意味着需要预加载的类对象是在生成system@<a href="mailto:&#102;&#x72;&#97;&#109;&#x65;&#x77;&#111;&#114;&#x6b;&#64;&#x62;&#x6f;&#x6f;&#x74;&#x2e;&#x61;&#114;&#116;">&#102;&#x72;&#97;&#109;&#x65;&#x77;&#111;&#114;&#x6b;&#64;&#x62;&#x6f;&#x6f;&#x74;&#x2e;&#x61;&#114;&#116;</a>@classes.oat这个OAT文件的时候创建并且保存在文件system@<a href="mailto:&#102;&#x72;&#x61;&#109;&#x65;&#x77;&#111;&#x72;&#107;&#x40;&#98;&#111;&#x6f;&#x74;&#46;&#x61;&#x72;&#x74;">&#102;&#x72;&#x61;&#109;&#x65;&#x77;&#111;&#x72;&#107;&#x40;&#98;&#111;&#x6f;&#x74;&#46;&#x61;&#x72;&#x74;</a>@classes.dex中，以后只要系统启动类路径中的DEX文件不发生变化（即不发生更新升级），那么以后每次系统启动只需要将文件system@<a href="mailto:&#102;&#x72;&#x61;&#x6d;&#101;&#119;&#111;&#x72;&#x6b;&#x40;&#98;&#111;&#x6f;&#116;&#x2e;&#97;&#114;&#x74;">&#102;&#x72;&#x61;&#x6d;&#101;&#119;&#111;&#x72;&#x6b;&#x40;&#98;&#111;&#x6f;&#116;&#x2e;&#97;&#114;&#x74;</a>@classes.dex直接映射到内存即可，省去了创建各个类对象的时间。之前使用Dalvik虚拟机作为应用程序运行时时，每次系统启动时，都需要为那些预加载的类创建类对象。因此，虽然ART运行时第一次启动时会比较慢，但是以后启动实际上会更快。</p>
<pre><code>     Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的。Zygote Space在Zygote进程和应用程序进程之间共享的，而Allocation Space则是每个进程独占的。同样的，Zygote进程一开始只有一个Image Space和一个Zygote Space。**在Zygote进程fork第一个子进程之前，就会把Zygote Space一分为二，原来的已经被使用的那部分堆还叫Zygote Space，而未使用的那部分堆就叫Allocation Space。以后的对象都在Allocation Space上分配。**
</code></pre>
<p>​		Image Space和Zygote Space在Zygote进程和应用程序进程之间进行共享，而Allocation Space就每个进程都独立地拥有一份。注意，虽然Image Space和Zygote Space都是在Zygote进程和应用程序进程之间进行共享，但是前者的对象只创建一次，而后者的对象需要在系统每次启动时根据运行情况都重新创建一遍。</p>
<p>与Dalivk虚拟机类似，ART运行时也使用一个Heap对象来描述堆：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20141229201435625" alt="img"></p>
<p>Heap类包含了以下重要成员变量描述ART运行时的堆，它们的作用如下所述：</p>
<pre><code>   1. mark_sweep_collectors_: 一个std::vector&lt;collector::MarkSweep*&gt;向量，保存了六种Mark-Sweep垃圾收集器。

   2. continuous_spaces_: 一个std::vector&lt;space::ContinuousSpace*&gt;向量，保存了图1所示的三个在地址空间上连续的Image Space、Zygote Space和Allocation Space。

   3. concurrent_gc_: 一个bool变量，描述是否支持并行GC，可以通过ART运行时启动选项-Xgc来指定。

   4. parallel_gc_threads_: 一个size_t变量，指定在GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ParallelGCThreads指定。如果没有指定，它的值就等于CPU核心数减1。这里之所以要减1是因为parallel_gc_threads_描述的实际上是除了当前GC线程之外的其它也用于GC任务的线程的个数。

   5. conc_gc_threads_: 一个size_t变量，指定非GC暂停阶段用来同时执行GC任务的线程数，可以通过ART运行时启动选项-XX:ConcGCThreads来指定。

   6. discontinuous_spaces_: 一个std::vector&lt;space::DiscontinuousSpace*&gt;向量，保存了图1所示的在地址空间上不连续的Large Object Space。

   7. alloc_space_: 一个space::DlMallocSpace指针，指向一个space::DlMallocSpace对象，该对象描述的是图1所示的Allocation Space。

   8. large_object_space_: 一个space::LargeObjectSpace指针，指向一个space::LargeObjectSpace对象，该对象描述的是图1所示的Large Object Space。

   9. card_table_: 一个UniquePtr&lt;accounting::CardTable&gt;指针，指向一个accounting::CardTable对象，该对象描述的是图1所示的Card Table。

   10. image_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于上方的Mod Union Table对象，用来记录在GC并行阶段在Image Space上分配的对象对在Zygote Space和Allocation Space上分配的对象的引用。

   11. zygote_mod_union_table_: 一个UniquePtr&lt;accounting::ModUnionTable&gt;指针，指向一个accounting::ModUnionTable对象，该对象描述的是图1所示的位于下方的Mod Union Table，用来记录在GC并行阶段在Zygote Space上分配的对象对在Allocation Space上分配的对象的引用。

   12. mark_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Mark Stack，用来在GC过程中实现递归对象标记。

   13. allocation_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Allocation Stack，用来记录上一次GC后分配的对象，用来实现类型为Sticky的Mark Sweep Collector。

   14. live_stack_: 一个UniquePtr&lt;accounting::ObjectStack&gt;指针，指向一个accounting::ObjectStack对象，该对象描述的是图1所示的Live Stack，配合allocation_stack_一起使用，用来实现类型为Sticky的Mark Sweep Collector。

   15. mark_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Mark Bitmap，与Dalvik虚拟机的Mark Bitmap作用是一样的，用来标记当前GC之后还存活的对象。

   16. live_bitmap_: 一个UniquePtr&lt;accounting::HeapBitmap&gt;指针，指向一个accounting::HeapBitmap对象，该对象描述的是图1所示的Live Bitmap，与Dalvik虚拟机的Live Bitmap作用是一样的，用来标记上一次GC之后还存活的对象。

    除了上述的16个成员变量，Heap类还定义了以下三个垃圾收集接口：

    1. CollectGarbage: 用来执行显式GC，例如用实现System.gc接口。

    2. ConcurrentGC: 用来执行并行GC，只能被ART运行时内部的GC守护线程调用。

    3. CollectGarbageInternal: ART运行时内部调用的GC接口，可以执行各种类型的GC。
</code></pre>
<p>​		上面我们提到，Heap类的成员变量mark_sweep_collectors_保存了ART运行时内部使用的六种垃圾收集器，这六种垃圾收集器分为两组。其中一组是支持并行GC的，另一组是不支持并行GC的。每一组都由MarkSweep、PartialMarkSweep和StickyMarkSweep三种类型的垃圾收集器组成</p>
<p>​		StickyMarkSweep继承于PartialMarkSweep，PartialMarkSweep又继承于MarkSweep、而MarkSweep又继承于GarbageCollector。因此，我们可以推断出，GarbageCollector定义了垃圾收集器接口，而MarkSweep、PartialMarkSweep和StickyMarkSweep通过重定某些接口来实现不同类型的垃圾收集器。</p>
<p>​		 在GarbageCollector中，有一个成员变量heap_，指向的是ART运行时堆，同时定义了两个public成员函数IsConcurrent和GetGcType。前者用来获得一个垃圾收集器是否支持并行GC，后者用来获得垃圾收集器类型 。</p>
<p> 垃圾收集器类型通过枚举类型GcType：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  kGcTypeNone, <span class="comment">// 一个占位符</span></span><br><span class="line">  kGcTypeSticky, <span class="comment">// 指的就是StickyMarkSweep类型的垃圾收集器，用来收集上次GC以来分配的对象。</span></span><br><span class="line">  kGcTypePartial,<span class="comment">// 指的就是PartialMarkSweep类型的垃圾收集器，用来收集在Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeFull, <span class="comment">//指的就是MarkSweep类型的垃圾收集器，用来收集在Zygote Space和Allocation Space上分配的对象。</span></span><br><span class="line">  kGcTypeMax, <span class="comment">// 垃圾收集器类型个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GarbageCollector通过定义以下五个虚函数描述GC的各个阶段：</p>
<pre><code>   1. InitializePhase: 用来实现GC的初始化阶段，用来初始化垃圾收集器内部的状态。

   2. MarkingPhase: 用来实现GC的标记阶段，该阶段有可能是并行的，也有可能不是并行。

   3. HandleDirtyObjectsPhase: 用来实现并行GC的Dirty Object标记，也就是递归标记那些在并行标记对象阶段中被修改的对象。

   4. ReclaimPhase: 用来实现GC的回收阶段。

   5. FinishPhase: 用来实现GC的结束阶段。
</code></pre>
<p>MarkSweep类通过重写上述五个虚函数实现自己的垃圾收集过程，同时，它又通过定义以下三个虚函数来让子类PartialMarkSweep和StickyMarkSweep实现特定的垃圾收集器：</p>
<ol>
<li><p>MarkReachableObjects: 用来递归标记从根集对象引用的其它对象。</p>
</li>
<li><p>BindBitmap: 用来指定垃圾收集范围。</p>
</li>
<li><p>Sweep: 用来回收垃圾对象。</p>
</li>
</ol>
<p>   其中，MarkSweep类通过自己实现的成员函数BindBitmap将垃圾收集范围指定为Zygote和Allocation空间，而PartialMarkSweep和StickyMarkSweep类通过重写成员函数BindBitmap将垃圾收集范围指定为Allocation空间和上次GC后所分配的对象。此外，StickyMarkSweep类还通过重定成员函数MarkReachableObjects和Sweep将对象标记和回收限制为上次GC后所分配的对象</p>
<h3 id="ART-GC"><a href="#ART-GC" class="headerlink" title="ART GC"></a>ART GC</h3><p>ART模式英文全称为：Android runtime，谷歌Android 4.4系统新增的一种应用运行模式。<br>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<p>ART GC 与 Dalvik 的一个主要区别在于 <strong>ART GC 引入了移动垃圾回收器。</strong>使用移动 GC 的目的在于通过堆压缩来减少后台应用使用的内存。目前，触发堆压缩的事件是 ActivityManager 进程状态的改变。当应用转到后台运行时，它会通知 ART 已进入不再“感知”卡顿的进程状态。此时 ART 会进行一些操作（例如，压缩和监视器压缩），从而导致应用线程长时间暂停。目前正在使用的两个移动 GC 是同构空间压缩和半空间压缩。</p>
<ol>
<li>半空间压缩将对象在两个紧密排列的碰撞指针空间之间进行移动。这种移动 GC 适用于小内存设备，因为它可以比同构空间压缩稍微多节省一点内存。额外节省出的空间主要来自紧密排列的对象，这样可以避免 RosAlloc&#x2F;DlMalloc 分配器占用开销。由于 CMS 仍在前台使用，且不能从碰撞指针空间中进行收集，因此当应用在前台使用时，半空间还要再进行一次转换。这种情况并不理想，因为它可能引起较长时间的暂停。</li>
<li>同构空间压缩通过将对象从一个 RosAlloc 空间复制到另一个 RosAlloc 空间来实现。这有助于通过减少堆碎片来减少内存使用量。这是目前非低内存设备的默认压缩模式。相比半空间压缩，同构空间压缩的主要优势在于应用从后台切换到前台时无需进行堆转换。</li>
</ol>
<p><strong>OAT文件</strong></p>
<p>OAT文件是Android运行时ART的核心，它是一种Android私有ELF文件格式，它不仅包含有从DEX文件翻译而来的本地机器指令，还包含有原来的DEX文件内容。这使得我们无需重新编译原有的APK就可以让它正常地在ART里面运行，也就是我们不需要改变原来的APK编程接口。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Android%20ART%20GC.png" alt="Android ART GC"></p>
<p>非并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC标记阶段。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>恢复第2步挂起的ART运行时线程。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>并行流程：</p>
<ul>
<li>调用子类实现的成员函数InitializePhase执行GC初始化阶段。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数MarkingPhase执行GC并行标记阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>挂起所有的ART运行时线程。</li>
<li>调用子类实现的成员函数HandleDirtyObjectsPhase处理在GC并行标记阶段被修改的对象。。</li>
<li>恢复第4步挂起的ART运行时线程。</li>
<li>重复第5到第7步，直到所有在GC并行阶段被修改的对象都处理完成。</li>
<li>获取用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数ReclaimPhase执行GC回收阶段。</li>
<li>释放用于访问Java堆的锁。</li>
<li>调用子类实现的成员函数FinishPhase执行GC结束阶段。</li>
</ul>
<p>从上面的分析就可以看出，并行GC和非并行GC的区别在于：</p>
<ol>
<li>非并行GC的标记阶段和回收阶段是在挂住所有的ART运行时线程的前提下进行的，因此，只需要执行一次标记即可。</li>
<li>并行GC的标记阶段只锁住了Java堆，因此它不能阻止那些不是正在分配对象的ART运行时线程同时运行，而这些同进运行的ART运行时线程可能会引用了一些在之前的标记阶段没有被标记的对象。如果不对这些对象进行重新标记的话，那么就会导致它们被GC回收，造成错误。因此，与非并行GC相比，并行GC多了一个处理脏对象的阶段。所谓的脏对象就是我们前面说的在GC标记阶段同时运行的ART运行时线程访问或者修改过的对象。</li>
<li>并行GC并不是自始至终都是并行的，例如，处理脏对象的阶段就是需要挂起除GC线程以外的其它ART运行时线程，这样才可以保证标记阶段可以结束。</li>
</ol>
<p>ART 的优点主要有三点：</p>
<ol>
<li>标记自身：ART在对象分配时会将新分配的对象压入到Heap类的成员变量allocation<em>stack</em>描述的Allocation Stack中去，从而可以一定程度上缩减对象遍历范围。</li>
<li>预读取：对于标记Allocation Stack的内存时，会预读取接下来要遍历的对象，同时在取出来该对象后又会将该对象引用的其他对象压入栈中，直至遍历完毕。</li>
<li>减少挂起时间：在Mark阶段是不会Block其他线程的，这个阶段会有Dirty数据，比如Mark发现不会使用的但是这个时候又被其他线程使用的数据，在Mark阶段也会处理一些Dirty数据而不是留在最后Block的时候再去处理，这样也会减少后面Block阶段对于脏数据的处理的时间。</li>
</ol>
<h3 id="Android-5-0-7-0-ART-GC"><a href="#Android-5-0-7-0-ART-GC" class="headerlink" title="Android 5.0 ~ 7.0 ART GC"></a>Android 5.0 ~ 7.0 ART GC</h3><p><strong>引入分代管理</strong></p>
<p>将堆分为新生代 (Young Generation) 和老年代 (Old Generation)，对应的GC也分为两种：</p>
<ul>
<li>Minor GC: 针对新生代的垃圾回收</li>
<li>Major GC (Full GC) : 针对整个堆的垃圾回收</li>
</ul>
<p><a href="http://lihaizhou.top/2021/10/27/%E5%AF%B9Android-S-ART-GC%E7%9A%84%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86/">对Android-S-ART-GC的源码梳理</a></p>
<p><a href="https://juejin.cn/post/6875678394332217357">ART虚拟机 | GC的触发时机和条件</a></p>
<p><a href="https://hello2mao.github.io/2015/12/11/ART_GC_VS_Dalvik_GC/">Android 5.0 ART GC 对比 Android 4.x Dalvik GC</a></p>
<p><a href="https://juejin.cn/post/6966205309782065159">android-gc-简史</a></p>
<p><a href="https://medium.com/@banerjee.s.sayans/android-garbage-collection-in-a-nutshell-e5c8acfa1538">Android Garbage Collection in a Nutshell</a></p>
<p><a href="https://paul.pub/android-art-vm/">Android上的ART虚拟机</a></p>
<p><a href="https://source.android.com/docs/core/runtime/gc-debug?hl=zh-cn">谷歌文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24835977">Android GC原理探究</a></p>
<p><a href="https://www.zhihu.com/question/297654028">Android Devlik和ART采用的是哪种垃圾收集器？</a></p>
<h3 id="ART-GC-回收策略的类型"><a href="#ART-GC-回收策略的类型" class="headerlink" title="ART GC 回收策略的类型"></a>ART GC 回收策略的类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># art/runtime/gc/collector/gc_type.h</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GcType</span> &#123;</span><br><span class="line">  <span class="comment">// Placeholder for when no GC has been performed.</span></span><br><span class="line">  kGcTypeNone,</span><br><span class="line">  <span class="comment">// Sticky mark bits GC that attempts to only free objects allocated since the last GC.</span></span><br><span class="line">  kGcTypeSticky,</span><br><span class="line">  <span class="comment">// Partial GC that marks the application heap but not the Zygote.</span></span><br><span class="line">  kGcTypePartial,</span><br><span class="line">  <span class="comment">// Full GC that marks and frees in both the application and Zygote heap.</span></span><br><span class="line">  kGcTypeFull,</span><br><span class="line">  <span class="comment">// Number of different GC types.</span></span><br><span class="line">  kGcTypeMax,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>kGcTypeNone:</strong><ul>
<li>描述：表示没有进行垃圾回收。</li>
<li>用途：作为占位符，表示在此时没有执行垃圾回收操作。</li>
</ul>
</li>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
<li><strong>kGcTypeFull:</strong><ul>
<li>描述：表示完全垃圾回收，同时标记并释放应用和Zygote堆中的对象。</li>
<li>用途：执行整个堆的垃圾回收，涉及应用堆和Zygote堆的所有对象。</li>
</ul>
</li>
<li><strong>kGcTypeMax:</strong><ul>
<li>描述：表示不同垃圾回收类型的总数。</li>
<li>用途：作为一个计数器，表示所有可能的垃圾回收类型的数量。</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201211109922.png" alt="image-20240201211109922"></p>
<h3 id="ART-Heap的创建"><a href="#ART-Heap的创建" class="headerlink" title="ART Heap的创建"></a>ART Heap的创建</h3><p>看一下Heap创建时的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kMemMapSpaceName[<span class="number">2</span>] = &#123;<span class="string">&quot;main space&quot;</span>, <span class="string">&quot;main space 1&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* kRegionSpaceName = <span class="string">&quot;main space (region space)&quot;</span></span><br><span class="line"></span><br><span class="line">Heap::<span class="built_in">Heap</span>(……)&#123;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;space::ImageSpace&gt;&gt; boot_image_spaces;</span><br><span class="line">  <span class="comment">// 创建ImageSpace,用来加载boot.oat</span></span><br><span class="line">  <span class="keyword">if</span> (space::ImageSpace::<span class="built_in">LoadBootImage</span>(……,&amp;boot_image_spaces,……)) &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemMap main_mem_map_1;</span><br><span class="line">  MemMap main_mem_map_2;</span><br><span class="line"></span><br><span class="line">  std::string error_str;</span><br><span class="line">  MemMap non_moving_space_mem_map;</span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="comment">// 创建ZygoteSpace虚拟内存，大小为64M</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* space_name = is_zygote ? kZygoteSpaceName : kNonMovingSpaceName;</span><br><span class="line">    <span class="keyword">if</span> (heap_reservation.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      non_moving_space_mem_map = heap_reservation.<span class="built_in">RemapAtEnd</span>(</span><br><span class="line">          heap_reservation.<span class="built_in">Begin</span>(), space_name, PROT_READ | PROT_WRITE, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      non_moving_space_mem_map = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          space_name, request_begin, non_moving_space_capacity, &amp;error_str);</span><br><span class="line">    &#125;</span><br><span class="line">    request_begin = kPreferredAllocSpaceBegin + non_moving_space_capacity;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 前台gc不是并发复制回收时，会创建两个space，5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ != kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (separate_non_moving_space || !is_zygote) &#123;</span><br><span class="line">    <span class="comment">//3. 创建name为“main space”的space的虚拟内存</span></span><br><span class="line">      main_mem_map_1 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">          kMemMapSpaceName[<span class="number">0</span>], request_begin, capacity_, &amp;error_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     ……</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//同样是5.x~7.x的系统采用这种gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (support_homogeneous_space_compaction ||</span><br><span class="line">      background_collector_type_ == kCollectorTypeSS ||</span><br><span class="line">      foreground_collector_type_ == kCollectorTypeSS) &#123;</span><br><span class="line">    <span class="comment">//4. 创建name为“main space 1”的space的虚拟内存</span></span><br><span class="line">    main_mem_map_2 = <span class="built_in">MapAnonymousPreferredAddress</span>(</span><br><span class="line">        kMemMapSpaceName[<span class="number">1</span>], main_mem_map_1.<span class="built_in">End</span>(), capacity_, &amp;error_str);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (separate_non_moving_space) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = non_moving_space_mem_map.<span class="built_in">Size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* non_moving_space_mem_map_begin = non_moving_space_mem_map.<span class="built_in">Begin</span>();</span><br><span class="line">    <span class="comment">//通过DlMallocSpace来管理ZygoteSpze</span></span><br><span class="line">    non_moving_space_ = space::DlMallocSpace::<span class="built_in">CreateFromMemMap</span>(std::<span class="built_in">move</span>(non_moving_space_mem_map),</span><br><span class="line">                                                               <span class="string">&quot;zygote / non moving space&quot;</span>,</span><br><span class="line">                                                               kDefaultStartingSize,</span><br><span class="line">                                                               initial_size,</span><br><span class="line">                                                               size,</span><br><span class="line">     ……</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前台gc为并发复制回收，8.0及以上系统采用的gc算法</span></span><br><span class="line">  <span class="keyword">if</span> (foreground_collector_type_ == kCollectorTypeCC) &#123;</span><br><span class="line">    <span class="comment">//创建一个容量为capacity_ * 2，即1g的space，虽然这里创建了1g，但是可用的只有512，另外一半是GC时，用于对象移动的</span></span><br><span class="line">    MemMap region_space_mem_map =</span><br><span class="line">        space::RegionSpace::<span class="built_in">CreateMemMap</span>(kRegionSpaceName, capacity_ * <span class="number">2</span>, request_begin);</span><br><span class="line">   </span><br><span class="line">    ……</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsMovingGc</span>(foreground_collector_type_)) &#123;</span><br><span class="line">    <span class="comment">// 通过BumpPointerSpace管理前面创建的main space和main space</span></span><br><span class="line">    bump_pointer_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 1&quot;</span>,</span><br><span class="line">                                                                    std::<span class="built_in">move</span>(main_mem_map_1));</span><br><span class="line">   </span><br><span class="line">    temp_space_ = space::BumpPointerSpace::<span class="built_in">CreateFromMemMap</span>(<span class="string">&quot;Bump pointer space 2&quot;</span>,</span><br><span class="line">                                                            std::<span class="built_in">move</span>(main_mem_map_2));</span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//通过MainMallocSpace来管理前面创建的main space和main space</span></span><br><span class="line">    <span class="built_in">CreateMainMallocSpace</span>(std::<span class="built_in">move</span>(main_mem_map_1), initial_size, growth_limit_, capacity_);</span><br><span class="line">    <span class="keyword">if</span> (main_mem_map_2.<span class="built_in">IsValid</span>()) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* name = kUseRosAlloc ? kRosAllocSpaceName[<span class="number">1</span>] : kDlMallocSpaceName[<span class="number">1</span>];</span><br><span class="line">      main_space_backup_.<span class="built_in">reset</span>(<span class="built_in">CreateMallocSpaceFromMemMap</span>(std::<span class="built_in">move</span>(main_mem_map_2),</span><br><span class="line">                                                           initial_size,</span><br><span class="line">                                                           growth_limit_,</span><br><span class="line">                                                           capacity_,</span><br><span class="line">                                                           name,</span><br><span class="line">                                                           <span class="comment">/* can_move_objects= */</span> <span class="literal">true</span>));</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请并创建LargeObjectSpace</span></span><br><span class="line">  <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kFreeList) &#123;</span><br><span class="line">    large_object_space_ = space::FreeListSpace::<span class="built_in">Create</span>(<span class="string">&quot;free list large object space&quot;</span>, capacity_);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (large_object_space_type == space::LargeObjectSpaceType::kMap) &#123;</span><br><span class="line">    large_object_space_ = space::LargeObjectMapSpace::<span class="built_in">Create</span>(<span class="string">&quot;mem map large object space&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>所有的 Space 创建，都是先通过 mmap 申请一块匿名内存，然后将这块内存放入对应的 Space 空间中进行管理</strong>。比如 ZygoteSpace 的创建，会先通过 CreateFromMemMap 函数创建一个名字为 zygote，大小为 64M 的匿名内存，然后将这一块内存放入 DlMallocSpace 管理。下面简单介绍一下用来管理申请内存的 Space：</p>
<ol>
<li><strong>DlMallocSpace</strong>：通过 dlmalloc 内存分配器来申请和释放内存，这是一个很出名的内存分配器，网上有大量的资料介绍，这里就不详细介绍了。</li>
<li><strong>MainMallocSpace</strong>：通过谷歌开发的 rosalloc 内存分配管理器来申请和释放内存。rosalloc 的用法比 dlmalloc 要复杂得多，而且还需要 ART 虚拟机中其他模块进行配合。但是分配的效果要比 dlmalloc 更好，并且多线程下表现更好。</li>
<li><strong>BumpPointerSpace</strong>：很简单的内存分配算法，按照顺序分配，类似于链表，容易出现内存碎片，所以只用在线程本地存储或者存活周期很长的对象空间上。</li>
<li><strong>RegionSpace</strong>：RegionSpace 的内存分配算法比 BumpPointerSpace 稍微高级一点。它先将内存资源划分成一个个固定大小（由 kRegionSize 指定，默认为 1MB）的内存块，每一个内存块由一个 Region 对象表示，进行内存分配时，先找到满足要求的 Region，然后从这个 Region 中分配资源。</li>
<li><strong>FreeListSpace&#x2F;LargeObjectMapSpace</strong>：通过 list 或者 map 来分配和释放内存，比 BumpPointerSpace 更简单。</li>
</ol>
<p>MainSpace 会根据 GC 回收器类型这个条件判断，有不同的创建方式，并且选择是放入 RegionSpace、BumpPointerSpace 还是 MainMallocSpace 中，这里判断规则如下：</p>
<ol>
<li>Android5.x~7.x：会创建名字为 “main space” 和 “main space 1”，大小都为 512M 的空间，并且 main space 和 main space 1 会通过 MainMallocSpace 来维护和管理，实际只会使用其中的一个空间，只有当执行 GC 的时候，另一个空间才派上用场。此时，GC 回收器会将前面所使用的空间中的存活对象全部移动到另一个空间来。</li>
<li>Android8.0 及以上：创建 main space (region space)，并且通过 <strong>RegionSpace</strong> 来维护和管理。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9865353d11a44837aec2fd55a1e4aff3%7Etplv-k3u1fbpfcp-jj-mark%3A2079%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace(</strong><code>region space</code>**)**：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p><strong>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。</strong></p>
<h3 id="ART堆对象分配"><a href="#ART堆对象分配" class="headerlink" title="ART堆对象分配"></a>ART堆对象分配</h3><p>在 Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存，我们直接看这个接口申请内存的代码逻辑（完整的代码可以看：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">heap-inl.h</a>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只保留了主逻辑，通过注释可以看到，虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<p>什么是大对象呢？通过 ShouldAllocLargeObject 判断接口可以看到，申请的内存大小大于 3页，且是基本类型数组或者字符串便认为是大对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::ShouldAllocLargeObject</span><span class="params">(ObjPtr&lt;mirror::Class&gt; c, <span class="type">size_t</span> byte_count)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> byte_count &gt;= large_object_threshold_ &amp;&amp; (c-&gt;<span class="built_in">IsPrimitiveArray</span>() || c-&gt;<span class="built_in">IsStringClass</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ART堆对象的释放"><a href="#ART堆对象的释放" class="headerlink" title="ART堆对象的释放"></a>ART堆对象的释放</h3><p> Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC，在上面申请流程中我们可以看到申请内存失败后，会调用 AllocateInternalWithGc 接口去重新申请，这个接口会调用 CollectGarbageInternal 接口进行 GC。(源码连接：<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c++复制代码<span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//1. 选择对应的垃圾回收器</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) </span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// Try to read each page of the memory map in case mprotect didn&#x27;t work properly b/19894268.</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">      current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 执行GC</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口的逻辑比较简单：</p>
<ol>
<li>选择合适的 GarbageCollector（垃圾回收器），并设置好这个 collector 的环境，如 kCollectorTypeSS（半空间回收）就会设置好 FromSpace 和 ToSpace。</li>
<li>接着调用执行 collector-&gt;Run 接口，collector 会执行对象的回收策略。</li>
</ol>
<p>不同的 GarbageCollector 对应了不同的 GC 算法，这一块的知识比较庞大，超出了该篇章的内容，不做详细的介绍了，只简单介绍一下 GarbageCollector 是如何判断一个对象是否可回收的。</p>
<h2 id="ART-GC-1"><a href="#ART-GC-1" class="headerlink" title="ART  GC"></a>ART  GC</h2><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>root set的定义在虚拟机的<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/">art</a>&#x2F;<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/">runtime</a>&#x2F;<a href="https://cs.android.com/android/platform/superproject/+/android13-release:art/runtime/gc_root.h">gc_root.h</a>文件下，</p>
<p>在 Android 内存管理中，”根对象” 是指那些能够直接或间接引用其他对象的对象。垃圾收集器通过识别和遍历这些根对象，能够确定哪些对象是可达的，哪些对象是不可达的，从而进行垃圾回收。</p>
<p><strong>虚拟机能直接找到的Object对象都属于root set。</strong>所谓的”root set”指的是包含了一些Java对象（在ART虚拟机中具体是mirror Object对象）的集合。这些对象不是通过其他对象的引用型成员变量来找到的，而是由虚拟机根据其实现特点来确定的。一般而言，”root set”包含多种类型的root信息。</p>
<p>这些根对象的类型用于表示对象的引用来源和作用域,这些内容以枚举类型的形式存放在gc_root.h下。</p>
<p>以下是其中一些根对象类型的简要解释：</p>
<ul>
<li><code>kRootJNIGlobal</code>: <strong>JNI 全局引用</strong>，即由 JNI（Java Native Interface）创建的全局引用。</li>
<li><code>kRootJNILocal</code>: <strong>JNI 局部引用</strong>，即由 JNI 创建的局部引用。</li>
<li><code>kRootJavaFrame</code>: <strong>表示 Java 方法调用的栈帧</strong>，即 Java 方法中的局部变量和操作数栈。</li>
<li><code>kRootNativeStack</code>: <strong>表示 Native 方法的调用栈</strong>，即 Native 方法中的局部变量和操作数栈。</li>
<li><code>kRootStickyClass</code>: Sticky 类，通常指的是被标记为 “sticky” 的类对象。在垃圾回收的实现中，可能会有一些对象在回收过程中被标记为 “sticky”，这表示它们在接下来的阶段中，例如移动对象的阶段，将不会被移动或发生其他变化。这样的标记有助于提高垃圾回收的效率，因为不需要频繁地处理这些对象。</li>
<li><code>kRootThreadBlock</code>: <strong>线程块</strong>，表示线程的信息块。</li>
<li><code>kRootMonitorUsed</code>: 正在使用的监视器，即被线程锁，锁住的对象。</li>
<li><code>kRootThreadObject</code>: <strong>线程对象，表示 Java 中的线程对象。</strong></li>
<li><code>kRootInternedString</code>: Interned 字符串，表示在字符串常量池中的字符串。</li>
<li><code>kRootFinalizing</code>: 正在进行 finalization（终结操作）的对象。</li>
<li><code>kRootDebugger</code>: 被调试器引用的对象。</li>
<li><code>kRootReferenceCleanup</code>: 引用清理，通常与引用队列相关。</li>
<li><code>kRootVMInternal</code>: <strong>虚拟机内部使用的对象。</strong></li>
<li><code>kRootJNIMonitor</code>: JNI 监视器对象，即由 JNI 创建的监视器。</li>
</ul>
<p>这些根对象类型的识别和分析对于 Android 内存分析和垃圾回收是至关重要的，它们帮助系统找出哪些对象是存活的，哪些对象可以被回收。</p>
<h3 id="ART-GC-方案"><a href="#ART-GC-方案" class="headerlink" title="ART  GC 方案"></a>ART  GC 方案</h3><p>ART 默认的GC方案Android 14 为CMC，Android 13-8为CMS。</p>
<p>​	下面这段代码时JNI层设置AndroidRuntime，大概是读取配置文件来解析对应的GC处理器选项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># /frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"><span class="comment">// 解析运行时选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.gctype&quot;</span>, gctypeOptsBuf, <span class="string">&quot;-Xgc:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取是否启用分代收集的配置</span></span><br><span class="line">std::string enable_generational_cc =</span><br><span class="line">    server_configurable_flags::<span class="built_in">GetServerConfigurableFlag</span>(RUNTIME_NATIVE_BOOT_NAMESPACE,</span><br><span class="line">                                                         ENABLE_GENERATIONAL_CC,</span><br><span class="line">                                                         <span class="comment">/*default_value=*/</span> <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 根据配置值决定是否启用分代收集，并添加相应选项</span></span><br><span class="line"><span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;true&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kGenerationalCCRuntimeOption);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (enable_generational_cc == <span class="string">&quot;false&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">addOption</span>(kNoGenerationalCCRuntimeOption);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析后台GC处理器的配置选项</span></span><br><span class="line"><span class="built_in">parseRuntimeOption</span>(<span class="string">&quot;dalvik.vm.backgroundgctype&quot;</span>, backgroundgcOptsBuf, <span class="string">&quot;-XX:BackgroundGC=&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的<code>backgroundgcOptsBuf</code>和<code>gctypeOptsBuf</code>分别读取配置然后解析设置了前台GC和后台GC，下面看下GC具体的解析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># art/cmdline/cmdline_types.h</span></span><br><span class="line"><span class="comment">// 解析垃圾收集器类型的方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> gc::CollectorType <span class="title">ParseCollectorType</span><span class="params">(<span class="type">const</span> std::string&amp; option)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (option == <span class="string">&quot;MS&quot;</span> || option == <span class="string">&quot;nonconcurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CMS&quot;</span> || option == <span class="string">&quot;concurrent&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCMS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;SS&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeSS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (option == <span class="string">&quot;CC&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeCC;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gc::kCollectorTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上面就是前后台通用的GC处理器项有：</p>
<ul>
<li><code>kCollectorTypeMS</code>: 代表标记-清除（Mark-Sweep）垃圾回收器。在这种回收器中，首先标记不再使用的内存，然后清除或回收这些标记的内存。</li>
<li><code>kCollectorTypeCMS</code>: 代表并发标记-清除（Concurrent Mark-Sweep）垃圾回收器。这是一种改进的标记-清除算法，它允许在标记过程中应用程序线程和垃圾回收线程并发运行。</li>
<li><code>kCollectorTypeSS</code>: 代表单步垃圾回收器（Sticky-Start）。这可能是一种实验性的或者特殊用途的垃圾回收策略，具体实现和特性可能因系统和环境而异。</li>
<li>kCollectorTypeGSS：GSS 垃圾回收器是在 SS 的基础上引入了分代的概念。</li>
<li><code>kCollectorTypeCC</code>: 代表并发复制回收器（Compact Collection）垃圾回收器。这种回收器的目标是在回收内存的同时压缩内存，以减少内存碎片化。</li>
</ul>
<p>后台会多一个</p>
<ul>
<li>kCollectorTypeHomogeneousSpaceCompact：代表同质空间压缩垃圾回收器，将存活对象压缩到内存区域的一端，从而在另一端创建一个连续的空闲空间。这有助于减少内存碎片，提高内存的可用性。</li>
</ul>
<h3 id="ART-GC-分配器实现"><a href="#ART-GC-分配器实现" class="headerlink" title="ART GC 分配器实现"></a>ART GC 分配器实现</h3><p>分配器的类型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">AllocatorType</span> : <span class="type">char</span> &#123;</span><br><span class="line">  kAllocatorTypeBumpPointer,      <span class="comment">// 使用全局 CAS（Compare and Swap）实现的 BumpPointer 分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeTLAB,             <span class="comment">// 在 BumpPointer 空间内使用 TLAB（Thread-Local Allocation Buffer）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeRosAlloc,         <span class="comment">// 使用 RosAlloc（分离大小、自由列表）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeDlMalloc,         <span class="comment">// 使用 dlmalloc（著名的 C malloc）分配器。 (*)</span></span><br><span class="line">  kAllocatorTypeNonMoving,        <span class="comment">// 用于非移动对象的特殊分配器。</span></span><br><span class="line">  kAllocatorTypeLOS,              <span class="comment">// 大对象空间。</span></span><br><span class="line">  <span class="comment">// 以下与 BumpPointer 分配器的主要区别在于从多个区域而不是单个连续空间分配内存。</span></span><br><span class="line">  kAllocatorTypeRegion,           <span class="comment">// 在区域内使用 CAS 实现的连续 BumpPointer 分配。 (*)</span></span><br><span class="line">  kAllocatorTypeRegionTLAB,       <span class="comment">// 使用区域片段作为 TLAB。对大多数小对象的默认设置。 (*)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>不同的分配器，对应着不同的内存空间，而不同的内存空间，又都有着自身的内存分配方式 。</strong>ART GC中所涉及的内存空间是用 一 个枚举类型 SpaceType 来表示的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpaceType</span> &#123;</span><br><span class="line">  kSpaceTypeImageSpace,           <span class="comment">// 用于存储应用程序的可执行代码和资源的空间</span></span><br><span class="line">  kSpaceTypeMallocSpace,          <span class="comment">// 用于分配堆对象的普通堆空间</span></span><br><span class="line">  kSpaceTypeZygoteSpace,          <span class="comment">// 用于存储 Zygote 进程中的共享对象的空间</span></span><br><span class="line">  kSpaceTypeBumpPointerSpace,     <span class="comment">// 用于快速分配对象的堆空间</span></span><br><span class="line">  kSpaceTypeLargeObjectSpace,     <span class="comment">// 用于存储大对象的空间，通常采用不同的分配和回收策略</span></span><br><span class="line">  kSpaceTypeRegionSpace,          <span class="comment">// 用于分配堆对象的区域化空间，实现一种分代垃圾回收策略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过switch- case 结构，根据分配器类型 allocator_ type 的不同取值，去选择对应的<strong>空间类</strong>，并调用其分配空间函数，以此去实现内存分配 。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201230533603.png" alt="image-20240201230533603"></p>
<p>空间类的继承关系：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1163119-20170514004423957-2085494711.jpg" alt="img"></p>
<h3 id="ATR-GC-回收器的实现"><a href="#ATR-GC-回收器的实现" class="headerlink" title="ATR GC 回收器的实现"></a>ATR GC 回收器的实现</h3><p>​		在ART中，回收器的实现代码位于<code>art/Runtime/gc/collector</code>目录之下。回收器本身有一个实现类<code>GarbageCollector</code>，不同回收方案所对应的回收器是作为<code>GarbageCollector</code>的子类进行实现的。</p>
<p>​		<code>GarbageCollector</code>类的声明和实现分别位于<code>art/Runtime/gc/collector</code>目录下的<code>garbage_collector.h</code>和<code>garbage_collector.cc</code>中。<code>GarbageCollector</code>类继承自<code>RootVisitor</code>、<code>IsMarkedVisitor</code>和<code>MarkObjectVisitor</code>。</p>
<p>​		<code>GarbageCollector</code>类中包含一个<code>ScopedPause</code>类，<code>ScopedPause</code>类有一个重要的成员变量<code>collector_</code>，它是指向回收器的指针。在<code>GarbageCollector</code>类中，比较重要的成员函数包括<code>Run()</code>函数和<code>RunPhases()</code>函数。<code>Run()</code>函数用于运行回收器，而<code>RunPhases()</code>函数用于运行GC的所有阶段。</p>
<p>​		<code>GarbageCollector::Run()</code>函数在实现垃圾回收功能时，通过调用<code>RunPhases()</code>函数来运行所有的GC阶段，从而最终实现垃圾回收的目标。</p>
<p>​		<code>RunPhases()</code>函数在<code>GarbageCollector</code>类中并没有具体实现，而是要在其子类中根据需要去实现。因此，<code>GarbageCollector</code>类的子类的<code>RunPhases()</code>函数是对应回收器的核心实现。这种设计允许每个具体的垃圾回收方案有自己的实现方式，以满足特定的需求。</p>
<p>下面是GC中主要类的关系</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240202192845076.png" alt="image-20240202192845076"></p>
<h3 id="分配器与回收器"><a href="#分配器与回收器" class="headerlink" title="分配器与回收器"></a>分配器与回收器</h3><p>​	选择回收器</p>
<p>​	<a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc">heap.cc</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heap::ChangeCollector</span><span class="params">(CollectorType collector_type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 只有在挂起所有 Mutator 线程以避免竞态条件时才执行此操作。</span></span><br><span class="line">  <span class="keyword">if</span> (collector_type != collector_type_) &#123;</span><br><span class="line">    <span class="comment">// 更新收集器类型</span></span><br><span class="line">    collector_type_ = collector_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除当前 GC 计划</span></span><br><span class="line">    gc_plan_.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据新的收集器类型生成新的 GC 计划</span></span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC: &#123;</span><br><span class="line">        <span class="comment">// 如果使用分代 CC（Generational CC），添加 Sticky GC 类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB（Thread-Local Allocation Buffer） 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegionTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeRegion);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 TLAB 设置分配器类型</span></span><br><span class="line">        <span class="keyword">if</span> (use_tlab_) &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeTLAB);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">ChangeAllocator</span>(kAllocatorTypeBumpPointer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMS: &#123;</span><br><span class="line">        <span class="comment">// 添加 Sticky、Partial 和 Full GC 类型</span></span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeSticky);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypePartial);</span><br><span class="line">        gc_plan_.<span class="built_in">push_back</span>(collector::kGcTypeFull);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据使用 RosAlloc 设置分配器类型</span></span><br><span class="line">        <span class="built_in">ChangeAllocator</span>(kUseRosAlloc ? kAllocatorTypeRosAlloc : kAllocatorTypeDlMalloc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">UNIMPLEMENTED</span>(FATAL);</span><br><span class="line">        <span class="built_in">UNREACHABLE</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置默认的并发启动字节数</span></span><br><span class="line">    <span class="built_in">SetDefaultConcurrentStartBytesLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配器和回收器对应表</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240201231055275.png" alt="image-20240201231055275"></p>
<h3 id="堆内存GC流程"><a href="#堆内存GC流程" class="headerlink" title="堆内存GC流程"></a>堆内存GC流程</h3><h4 id="对象内存申请"><a href="#对象内存申请" class="headerlink" title="对象内存申请"></a>对象内存申请</h4><p>分配器要为新建立的对象分配空间，这个操作主要靠 Heap 类的 AllocObjectWithAllocator( ）函数实现， AllocObjectWithAll ocator( ）函数的实现位于 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap-inl.h">art &#x2F; Runtime&#x2F;gc&#x2F; heap- inl. h</a> 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GC触发"><a href="#GC触发" class="headerlink" title="GC触发"></a>GC触发</h4><p>GC 回收器主要在进行垃圾回收的时候使用，而垃圾回收的执行需要触发事件进行触发 。垃圾回收的触发，在实现上专门由 一 个枚举类型 GcCause 表示，这个枚举类型的定义位于 art &#x2F; Runtime &#x2F; gc &#x2F; gc_cause. h 中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">GcCause</span> &#123;</span><br><span class="line">  <span class="comment">// 无效的 GC 原因，用作占位符。</span></span><br><span class="line">  kGcCauseNone,</span><br><span class="line">  <span class="comment">// 由于分配失败而触发的 GC。执行分配的线程在重试分配之前被阻塞，等待 GC 完成。</span></span><br><span class="line">  kGcCauseForAlloc,</span><br><span class="line">  <span class="comment">// 用于确保在分配之前有足够的空闲内存的后台 GC。</span></span><br><span class="line">  kGcCauseBackground,</span><br><span class="line">  <span class="comment">// 显式的 System.gc() 调用。</span></span><br><span class="line">  kGcCauseExplicit,</span><br><span class="line">  <span class="comment">// 在超过 NativeAllocationGcWatermark 时触发的为本地分配而进行的 GC。</span></span><br><span class="line">  <span class="comment">// （根据是否运行非并发收集器，这可能是一个阻塞的 GC）。</span></span><br><span class="line">  kGcCauseForNativeAlloc,</span><br><span class="line">  <span class="comment">// 为了进行收集器转换而触发的 GC。</span></span><br><span class="line">  kGcCauseCollectorTransition,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于禁用移动 GC（目前用于 GetPrimitiveArrayCritical）。</span></span><br><span class="line">  kGcCauseDisableMovingGc,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于修整堆。</span></span><br><span class="line">  kGcCauseTrim,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和插装之间的排除。</span></span><br><span class="line">  kGcCauseInstrumentation,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除应用程序图像空间。</span></span><br><span class="line">  kGcCauseAddRemoveAppImageSpace,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现 GC 和调试器之间的排除。</span></span><br><span class="line">  kGcCauseDebugger,</span><br><span class="line">  <span class="comment">// 在前台和后台收集器都是 CMS 时触发的用于背景转换的 GC。</span></span><br><span class="line">  kGcCauseHomogeneousSpaceCompact,</span><br><span class="line">  <span class="comment">// 类链接器原因，用于保护填充 art 方法的特殊值。</span></span><br><span class="line">  kGcCauseClassLinker,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于实现代码缓存元数据和 GC 之间的排除。</span></span><br><span class="line">  kGcCauseJitCodeCache,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于添加或删除系统弱引用持有者。</span></span><br><span class="line">  kGcCauseAddRemoveSystemWeakHolder,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 hprof 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseHprof,</span><br><span class="line">  <span class="comment">// 非真实的 GC 原因，用于防止 GetObjectsAllocated 在 GC 过程中运行。</span></span><br><span class="line">  kGcCauseGetObjectsAllocated,</span><br><span class="line">  <span class="comment">// 用于 Profile Saver 的 GC 原因。</span></span><br><span class="line">  kGcCauseProfileSaver,</span><br><span class="line">  <span class="comment">// 在启动时删除 dex 缓存数组的 GC 原因。</span></span><br><span class="line">  kGcCauseDeletingDexCacheArrays,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于开发者而言，常见的是其中三种：</p>
<ul>
<li>GcCauseForAlloc：通过new分配新对象时，堆中剩余空间(普通应用默认上限为256M，声明largeHeap的应用为512M)不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>GcCauseExplicit：当应用调用系统API System.gc()时，会产生一次GC动作。</li>
<li>GcCauseBackground：后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。相比于前两种GC，后台GC出现的更多也更加隐秘。这个触发动作是在分配内存成功之后进行的触发 。为了确保每次分配空 间都 有空 间可用。</li>
</ul>
<p>最终的GC 触发最终都会通过调用CollectGarbagelnternal ( ）函数进行 GC 。实现位于<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc;l=2709">art&#x2F;Runtime&#x2F;gc &#x2F; heap.cc</a> 中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">collector::GcType <span class="title">Heap::CollectGarbageInternal</span><span class="params">(collector::GcType gc_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               GcCause gc_cause,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">bool</span> clear_soft_references,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> requested_gc_num)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前线程和运行时对象</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果堆无法运行GC，则静默失败并返回未运行任何GC。</span></span><br><span class="line">  <span class="keyword">switch</span> (gc_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> collector::kGcTypePartial: &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">HasZygoteSpace</span>()) &#123;</span><br><span class="line">        <span class="comment">// 如果没有Zygote空间，不增加gcs_completed_计数，应该使用kGcTypeFull重试。</span></span><br><span class="line">        <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// 其他GC类型没有特殊情况，这使它们不可运行。主要的情况是全GC。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换线程状态，确保没有持有Mutator锁</span></span><br><span class="line">  <span class="function">ScopedThreadStateChange <span class="title">tsc</span><span class="params">(self, ThreadState::kWaitingPerformingGc)</span></span>;</span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程正在处理堆栈溢出，则不足够的剩余堆栈空间运行GC。</span></span><br><span class="line">  <span class="keyword">if</span> (self-&gt;<span class="built_in">IsHandlingStackOverflow</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果我们正在抛出堆栈溢出错误，我们可能没有足够的剩余堆栈空间来运行GC。</span></span><br><span class="line">    <span class="comment">// 计数此GC，以防有人在等待它完成。</span></span><br><span class="line">    gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">    <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> compacting_gc;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取GC完成锁并切换线程状态，等待GC完成</span></span><br><span class="line">    gc_complete_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">    <span class="function">ScopedThreadStateChange <span class="title">tsc2</span><span class="params">(self, ThreadState::kWaitingForGcToComplete)</span></span>;</span><br><span class="line">    <span class="function">MutexLock <span class="title">mu</span><span class="params">(self, *gc_complete_lock_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保一次只有一个GC</span></span><br><span class="line">    <span class="built_in">WaitForGcToCompleteLocked</span>(gc_cause, self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经在其他地方触发了适当的GC，则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (requested_gc_num != GC_NUM_ANY &amp;&amp; !<span class="built_in">GCNumberLt</span>(<span class="built_in">GetCurrentGcNum</span>(), requested_gc_num)) &#123;</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compacting_gc = <span class="built_in">IsMovingGc</span>(collector_type_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是压缩式GC，检查是否禁用了移动GC。</span></span><br><span class="line">    <span class="keyword">if</span> (compacting_gc &amp;&amp; disable_moving_gc_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Skipping GC due to disable moving GC count &quot;</span> &lt;&lt; disable_moving_gc_count_;</span><br><span class="line">      <span class="comment">// 再次计数此GC。</span></span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在关机过程中禁用了GC，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (gc_disabled_for_shutdown_) &#123;</span><br><span class="line">      gcs_completed_.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">      <span class="keyword">return</span> collector::kGcTypeNone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置正在运行的收集器类型和最后的GC原因。</span></span><br><span class="line">    collector_type_running_ = collector_type_;</span><br><span class="line">    last_gc_cause_ = gc_cause;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是由于分配而触发的GC，增加统计信息计数。</span></span><br><span class="line">  <span class="keyword">if</span> (gc_cause == kGcCauseForAlloc &amp;&amp; runtime-&gt;<span class="built_in">HasStatsEnabled</span>()) &#123;</span><br><span class="line">    ++runtime-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">    ++self-&gt;<span class="built_in">GetStats</span>()-&gt;gc_for_alloc_count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取在堆上执行GC的垃圾收集器对象。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes_allocated_before_gc = <span class="built_in">GetBytesAllocated</span>();</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(gc_type, collector::kGcTypeMax);</span><br><span class="line">  <span class="built_in">DCHECK_NE</span>(gc_type, collector::kGcTypeNone);</span><br><span class="line">  collector::GarbageCollector* collector = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据GC类型和分配器类型选择垃圾收集器。</span></span><br><span class="line">  <span class="keyword">if</span> (compacting_gc) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(current_allocator_ == kAllocatorTypeBumpPointer ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeTLAB ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegion ||</span><br><span class="line">           current_allocator_ == kAllocatorTypeRegionTLAB);</span><br><span class="line">    <span class="keyword">switch</span> (collector_type_) &#123;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeSS:</span><br><span class="line">        <span class="comment">// 选择SemiSpace收集器并设置SemiSpace的源和目标空间。</span></span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetFromSpace</span>(bump_pointer_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetToSpace</span>(temp_space_);</span><br><span class="line">        semi_space_collector_-&gt;<span class="built_in">SetSwapSemiSpaces</span>(<span class="literal">true</span>);</span><br><span class="line">        collector = semi_space_collector_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCMC:</span><br><span class="line">        <span class="comment">// 选择MarkCompact收集器。</span></span><br><span class="line">        collector = mark_compact_;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> kCollectorTypeCC:</span><br><span class="line">        <span class="comment">// 选择ConcurrentCopying收集器。</span></span><br><span class="line">        collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">        <span class="keyword">if</span> (use_generational_cc_) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> 其他线程必须在开始检查active_concurrent_copying_collector_之前进行翻转检查。</span></span><br><span class="line">          active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">                  young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">          active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                     std::memory_order_relaxed);</span><br><span class="line">          <span class="built_in">DCHECK</span>(active_cc_collector-&gt;<span class="built_in">RegionSpace</span>() == region_space_);</span><br><span class="line">          collector = active_cc_collector;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid collector type &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于kCollectorTypeCMC，temp_space_将为null。</span></span><br><span class="line">    <span class="keyword">if</span> (temp_space_ != <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; collector != active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">      temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">Protect</span>(PROT_READ | PROT_WRITE);</span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">        <span class="comment">// 尝试读取内存映射的每一页，以防mprotect没有正确工作 b/19894268。</span></span><br><span class="line">        temp_space_-&gt;<span class="built_in">GetMemMap</span>()-&gt;<span class="built_in">TryReadable</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">CHECK</span>(temp_space_-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_allocator_ == kAllocatorTypeRosAlloc ||</span><br><span class="line">             current_allocator_ == kAllocatorTypeDlMalloc) &#123;</span><br><span class="line">    <span class="comment">// 根据分配器类型选择垃圾收集器。</span></span><br><span class="line">    collector = <span class="built_in">FindCollectorByGcType</span>(gc_type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Invalid current allocator &quot;</span> &lt;&lt; current_allocator_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查垃圾收集器是否可用。</span></span><br><span class="line">  <span class="built_in">CHECK</span>(collector != <span class="literal">nullptr</span>)</span><br><span class="line">      &lt;&lt; <span class="string">&quot;Could not find garbage collector with collector_type=&quot;</span></span><br><span class="line">      &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(collector_type_) &lt;&lt; <span class="string">&quot; and gc_type=&quot;</span> &lt;&lt; gc_type;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行垃圾收集器。</span></span><br><span class="line">  collector-&gt;<span class="built_in">Run</span>(gc_cause, clear_soft_references || runtime-&gt;<span class="built_in">IsZygote</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加已释放内存的计数。</span></span><br><span class="line">  <span class="built_in">IncrementFreedEver</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求堆修剪。</span></span><br><span class="line">  <span class="built_in">RequestTrim</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展堆，以便知道何时执行下一次GC。</span></span><br><span class="line">  <span class="built_in">GrowForUtilization</span>(collector, bytes_allocated_before_gc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录旧的本地分配的字节数。</span></span><br><span class="line">  old_native_bytes_allocated_.<span class="built_in">store</span>(<span class="built_in">GetNativeBytes</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录GC日志。</span></span><br><span class="line">  <span class="built_in">LogGC</span>(gc_cause, collector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成GC过程。</span></span><br><span class="line">  <span class="built_in">FinishGC</span>(self, gc_type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际上将所有清除的引用入队。在GC正式完成后执行此操作，否则可能会发生死锁。</span></span><br><span class="line">  SelfDeletingTask* clear = reference_processor_-&gt;<span class="built_in">CollectClearedReferences</span>(self);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行清理引用任务。</span></span><br><span class="line">  clear-&gt;<span class="built_in">Run</span>(self);</span><br><span class="line">  clear-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知DDMS GC已完成。</span></span><br><span class="line">  Dbg::<span class="built_in">GcDidFinish</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类卸载时卸载本地库。我们在调用FinishGC之后执行此操作，以防JNI_OnUnload函数进行分配。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line">    soa.<span class="built_in">Vm</span>()-&gt;<span class="built_in">UnloadNativeLibraries</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回GC的类型。</span></span><br><span class="line">  <span class="keyword">return</span> gc_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="GC流程补充"><a href="#GC流程补充" class="headerlink" title="GC流程补充"></a>GC流程补充</h3><p>Android 版本 8 到 13 期间，系统一直使用的是 Concurrent Copy 垃圾回收算法（CC）。该算法通过使用 FromSpace 和 ToSpace 两个内存空间，实现了一种巧妙的复制机制。这种机制通过在垃圾回收过程中，同时利用这两个空间，来达到空间换时间的效果，或者说通过复杂度来提高垃圾回收的效率。在具体操作中，对象被从一个空间（FromSpace）复制到另一个空间（ToSpace），从而清理掉 FromSpace 中不再被引用的对象。</p>
<p>这种复制机制会在垃圾回收过程中使用两倍的内存，因为需要同时维护两个空间。在极端情况下，这可能导致内存占用量翻倍，因为系统需要为每个对象在 FromSpace 和 ToSpace 中都分配空间。尽管这可能带来一些额外的内存消耗，但由于复制算法的高效性，通常能够更迅速地回收垃圾，从而提高整体性能。这种垃圾回收方式在某些场景下可能更适用，特别是对于实时性能要求较高的系统。</p>
<p>ART虚拟机创建时先确定内存回收器的类型，进而绑定对应的内存分配器，因回收器已设置为CC(ConcurrentCopying)即并发复制回收器，则Heap内存的主要分配区域定为RegionSpace，RegionSpace由一个个256KB的Region组成。对应的RegionSpace内存分配器定为kAllocatorTypeRegion。</p>
<p>从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。</p>
<p>并发复制 GC 的一些主要特性包括：</p>
<ul>
<li>CC 支持使用名为“RegionTLAB”的触碰指针分配器。此分配器可以向每个应用线程分配一个线程本地分配缓冲区 (TLAB)，这样，应用线程只需触碰“栈顶”指针，而无需任何同步操作，即可从其 TLAB 中将对象分配出去。</li>
<li>CC 通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理。这是在读取屏障的帮助下实现的，<strong>读取屏障会拦截来自堆的引用读取</strong>，无需应用开发者进行任何干预。</li>
<li>GC 只有一次很短的暂停，对于堆大小而言，该次暂停在时间上是一个常量。</li>
<li>在 Android 10 及更高版本中，CC 会扩展为分代 GC。它支持轻松回收存留期较短的对象，这类对象通常很快便会无法访问。这有助于提高 GC 吞吐量，并显著延迟执行全堆 GC 的需要。</li>
</ul>
<p>ART代码中的heap则是一个类，其作用更像是堆内存的管理器。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Android 4.4</th>
<th>Android 5~6</th>
<th>Android 7</th>
<th>Android 8~9</th>
<th>Android 10</th>
</tr>
</thead>
<tbody><tr>
<td>回收算法</td>
<td>CMS</td>
<td>CMS</td>
<td>CMS</td>
<td>CC</td>
<td>CC</td>
</tr>
<tr>
<td>内存分配机制</td>
<td>Single-Thread</td>
<td>Per-Thread</td>
<td>Per-thread</td>
<td>Bump Pointer</td>
<td>Bump Pointer</td>
</tr>
<tr>
<td>内存分配性能</td>
<td>1x</td>
<td>4-5x</td>
<td>10x</td>
<td>18x</td>
<td>18x</td>
</tr>
<tr>
<td>临时变量开销</td>
<td>高</td>
<td>低(分代)</td>
<td>低(分代)</td>
<td>中</td>
<td>低(分代)</td>
</tr>
<tr>
<td>内存整理(防止碎片化)</td>
<td>后台</td>
<td>后台&#x2F;事件</td>
<td>后台&#x2F;事件</td>
<td>前台并发</td>
<td>前台并发</td>
</tr>
</tbody></table>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是 Concurrent Mark Sweep 的简称，中文翻译为并发标记清除方案，可以简单地理解为并发的标记清除方案 。为了提高垃圾回收的效率，学者们提出了并发垃圾回收 。 并发垃圾回收允许赋值器线程和回收器线程同时执行以提高回收效率 。 在这里需要注意区分并发垃圾回收和并行垃圾回收 。 与并发垃圾回收不同的是，并行垃圾回收通常使用多个回收器线程进行垃圾回收 。CMS 方案允许赋值器和回收器线程同时执行，并且其回收器分为标记和清除两个阶段 。</p>
<h3 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h3><p>它是 “Semi-Space”（半空间）和 “Mark-Sweep”（标记-清除）两种垃圾回收算法的混合方案。</p>
<ol>
<li><strong>Semi-Space (半空间)</strong>: Semi-Space 是一种年轻代垃圾回收算法，通常用于处理新生代对象的回收。它将堆空间分为两个大小相等的半空间，一个是源空间，一个是目标空间。在垃圾回收过程中，存活的对象从源空间复制到目标空间，然后清理源空间中的所有对象。这有助于提高内存分配的效率，减少内存碎片。</li>
<li><strong>Mark-Sweep (标记-清除)</strong>: Mark-Sweep 是一种用于整个堆的垃圾回收算法。它分为两个主要阶段。首先，标记阶段会遍历并标记所有可达的对象。然后，在清除阶段，未标记的对象会被释放，堆空间得到整理。</li>
</ol>
<p>“SS” 方案将这两种算法结合在一起。在堆的年轻代使用 Semi-Space 进行垃圾回收，而在整个堆使用 Mark-Sweep 进行垃圾回收。这样，可以结合两种算法的优点，达到更好的性能和空间利用率。</p>
<h3 id="GSS"><a href="#GSS" class="headerlink" title="GSS"></a>GSS</h3><p>GSS 是 SS 回收方案的分代回收版本 。分代回收在对象中引入了“年龄＂的概念， 将对象分为新生代对象和老年代对象 。其中， 新生代对象指的是刚生成的对象，老年代对象指的是到达 一 定“年龄＂的对象 。因为新生代对象大部分会变成垃圾，所以分代回收将新生代对象和老年代对象分别进行 GC ，对新生代对象进行的 GC 称为新生代 GC ，对老年代对象进行的 GC 称为老年代 GC ， 一 般情况下会提高新生代 GC 的频率，降低老年代 GC 的频率，这样可以提高效率 。分代回收并不能单独作为 一 种方案而直接使用，它通常会和标记 －清除、复制等基本 GC方案结合起来进行使用 。在这里，分代回收会和 SS 回收方案结合起来，形成 一 个新的方案，即 GSS 。</p>
<h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>CC 是 Concurrent Copying 的简称，中文翻译为并发复制回收，它可以看作复制回收的并发版本 。CC 可以在读取屏障的帮助下，通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理，比非并发版本更加高效 </p>
<h3 id="CMC"><a href="#CMC" class="headerlink" title="CMC"></a>CMC</h3><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GCRoots Set</p>
<p>ART Java Heap</p>
<p>​		从Android 8 (Oreo) 开始默认方案是并发复制 (CC)，cc涉及到的堆空间的区域为RegionSpace。</p>
<p>​		在GC触发章节讲到在GC Case 枚举中对于开发者而言，常见的是其中三种：申请内存时触发的GcCauseForAlloc、调用系统API System.gc()时GcCauseExplicit、并发GCGcCauseBackground。具体的执行过程可以看章节的详解，但最终的GC 触发最终都会通过调用CollectGarbagelnternal。</p>
<p>​		CollectGarbageInternal里会通过switch casel来通过回收器类型来选择合适的 GarbageCollector（垃圾回收器），这里的类型就是<code>kCollectorTypeCC</code>。看下具体代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据垃圾回收器的类型选择相应的回收器</span></span><br><span class="line"><span class="keyword">switch</span> (collector_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> kCollectorTypeCC: <span class="comment">// 如果是并发拷贝垃圾回收器类型</span></span><br><span class="line">    collector::ConcurrentCopying* active_cc_collector;</span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_) &#123; <span class="comment">// 如果使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 根据回收类型选择相应的活跃拷贝垃圾回收器</span></span><br><span class="line">      active_cc_collector = (gc_type == collector::kGcTypeSticky) ?</span><br><span class="line">              young_concurrent_copying_collector_ : concurrent_copying_collector_;</span><br><span class="line">      <span class="comment">// 将选择的拷贝垃圾回收器存储为活跃拷贝垃圾回收器</span></span><br><span class="line">      active_concurrent_copying_collector_.<span class="built_in">store</span>(active_cc_collector,</span><br><span class="line">                                                 std::memory_order_relaxed);</span><br><span class="line">      <span class="comment">// 设置当前回收器为选择的拷贝垃圾回收器</span></span><br><span class="line">      collector = active_cc_collector;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不使用分代并发拷贝垃圾回收器</span></span><br><span class="line">      <span class="comment">// 获取存储的活跃拷贝垃圾回收器</span></span><br><span class="line">      collector = active_concurrent_copying_collector_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 处理其他类型的垃圾回收器</span></span><br><span class="line">    <span class="comment">// 添加适当的处理逻辑或错误处理代码</span></span><br><span class="line">    <span class="comment">// 可以根据实际情况进行补充</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在获取对应的GarbageCollector后这里获取的应该是<a href="http://aospxref.com/android-13.0.0_r3/xref/art/runtime/gc/collector/concurrent_copying.h">concurrent_copying.h</a>，接着调用执行 collector-&gt;Run 接口，然后会执行RunPhases()函数。</p>
<p>这里简单看一下具体的代码实现，应该看不懂但是知道有这个流程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentCopying::RunPhases</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查是否使用Baker读屏障或TableLookup读屏障</span></span><br><span class="line">  <span class="built_in">CHECK</span>(kUseBakerReadBarrier || kUseTableLookupReadBarrier);</span><br><span class="line">  <span class="comment">// 检查垃圾回收是否处于非活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(!is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收标记为活动状态</span></span><br><span class="line">  is_active_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  Thread* self = Thread::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">// 记录当前运行垃圾回收的线程</span></span><br><span class="line">  thread_running_gc_ = self;</span><br><span class="line">  <span class="comment">// 断言Mutator锁未被当前线程持有</span></span><br><span class="line">  Locks::mutator_lock_-&gt;<span class="built_in">AssertNotHeld</span>(self);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化阶段</span></span><br><span class="line">    <span class="built_in">InitializePhase</span>();</span><br><span class="line">    <span class="comment">// 如果是分代垃圾回收，不是年轻代，且不强制撤离所有对象，则执行标记阶段</span></span><br><span class="line">    <span class="keyword">if</span> (use_generational_cc_ &amp;&amp; !young_gen_ &amp;&amp; !force_evacuate_all_) &#123;</span><br><span class="line">      <span class="built_in">MarkingPhase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用Baker读屏障且存在灰色的Dirty Immune对象</span></span><br><span class="line">  <span class="keyword">if</span> (kUseBakerReadBarrier &amp;&amp; kGrayDirtyImmuneObjects) &#123;</span><br><span class="line">    <span class="comment">// 切换到读屏障标记入口点，确保在灰色对象标记之前切换</span></span><br><span class="line">    <span class="built_in">ActivateReadBarrierEntrypoints</span>();</span><br><span class="line">    <span class="comment">// 并发标记灰色的Dirty Immune对象，以减少垃圾回收暂停时间</span></span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="built_in">GrayAllDirtyImmuneObjects</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 翻转线程根</span></span><br><span class="line">  <span class="built_in">FlipThreadRoots</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行拷贝阶段</span></span><br><span class="line">    <span class="built_in">CopyingPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果启用NoFromSpaceRefsVerification</span></span><br><span class="line">  <span class="keyword">if</span> (kEnableNoFromSpaceRefsVerification) &#123;</span><br><span class="line">    <span class="comment">// 计时器，用于记录暂停时长</span></span><br><span class="line">    <span class="function">TimingLogger::ScopedTiming <span class="title">split</span><span class="params">(<span class="string">&quot;(Paused)VerifyNoFromSpaceReferences&quot;</span>, GetTimings())</span></span>;</span><br><span class="line">    <span class="comment">// 暂停，执行验证</span></span><br><span class="line">    <span class="function">ScopedPause <span class="title">pause</span><span class="params">(<span class="keyword">this</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;正在验证不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行验证不存在From-Space引用</span></span><br><span class="line">    <span class="built_in">VerifyNoFromSpaceReferences</span>();</span><br><span class="line">    <span class="keyword">if</span> (kVerboseMode) &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;验证完成，确保不存在From-Space引用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再次检查标记栈是否为空</span></span><br><span class="line">    <span class="built_in">CheckEmptyMarkStack</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 进入临界区，使用ReaderMutexLock自动加锁和解锁</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ReaderMutexLock <span class="title">mu</span><span class="params">(self, *Locks::mutator_lock_)</span></span>;</span><br><span class="line">    <span class="comment">// 执行回收阶段</span></span><br><span class="line">    <span class="built_in">ReclaimPhase</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完成垃圾回收阶段</span></span><br><span class="line">  <span class="built_in">FinishPhase</span>();</span><br><span class="line">  <span class="comment">// 断言垃圾回收仍处于活动状态</span></span><br><span class="line">  <span class="built_in">CHECK</span>(is_active_);</span><br><span class="line">  <span class="comment">// 将垃圾回收状态标记为非活动</span></span><br><span class="line">  is_active_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 清空运行垃圾回收的线程信息</span></span><br><span class="line">  thread_running_gc_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		我们知道cc是基于标记-复制算法的，在Android 10 CC垃圾回收器引入了分代。但是ConcurrentCopying并非将空间划分为两个半空间，而是以RegionSpace中的Region为单位进行处理，同时还能根据存活对象所占内存的比例来灵活设置Region被划归为From Space的条件。这个分代思想有点类似于JavaJVM中的G1收集器的算法。<strong>从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现。</strong></p>
<p>​		上面的ART GC回收策略章节知道，kCollectorTypeCC对应的回收策略有kGcTypeSticky, kGcTypePartial。再看一遍这两个的定义</p>
<ol>
<li><strong>kGcTypeSticky:</strong><ul>
<li>描述：表示一种”Sticky”标记位垃圾回收，试图仅释放自上次GC以来分配的对象。</li>
<li>用途：这可能是一种优化，只回收最近分配的对象，而不涉及整个堆。</li>
</ul>
</li>
<li><strong>kGcTypePartial:</strong><ul>
<li>描述：表示部分垃圾回收，标记应用堆但不标记Zygote堆。</li>
<li>用途：在垃圾回收过程中，只处理应用堆的部分，而不涉及Zygote堆。Zygote是Android中一个特殊的进程，用于孵化其他应用进程。</li>
</ul>
</li>
</ol>
<p>GC的大体流程为：</p>
<ul>
<li><p>InitializePhase，初始化统计量，设置标记等。</p>
</li>
<li><p>MarkingPhase，遍历所有Root根集，将根集对象直接引用对象压入mark_stack，并发标记存活对象记录在mark_bitmap中（此阶段只用于确定回收区域，StickyGC和ExplicitGC不需要）。</p>
</li>
<li><p>FlipThreadRoots，依据上一阶段的标记信息，确定回收区域（倾向于回收垃圾对象多的region），回收区域设置为from_space。</p>
</li>
<li><p>CopyingPhase，处理跨代、跨区引用的dirty_card,将from_space中的存活对象拷贝至to_space，更新引用等。</p>
</li>
<li><p>ReclaimPhase，释放from_space的空间，重置为to_space。</p>
</li>
</ul>
<p>Sticky GC，基于“标记-复制”算法实现</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/01fa2365dfacd63e02e5d201654d7124.png" alt="01fa2365dfacd63e02e5d201654d7124.png"></p>
<p>Partial GC 基于标记-整理算法</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/90d0ecea1c99af4058c88b8af80c864e.png" alt="90d0ecea1c99af4058c88b8af80c864e.png"></p>
<p>其中还涉及的一些东西：</p>
<ol>
<li><p>内存分配算法：整个堆划分为多个同样大小的Region（256KB），Region内分配内存使用最高效的BumpPointer指针碰撞算法，缺点是无法单独释放某个对象的内存(漂浮垃圾无法避免)，只能整个释放Region占用的空间。</p>
</li>
<li><p>回收算法：全局层面为标记-整理算法，两个Region间为标记-复制算法。有效地减少内存碎片。</p>
</li>
<li><p>跨区引用：写屏障支持，用CardTable实现RememberSet，记录跨代&#x2F;特殊Space与RegionSpace间的引用。</p>
<ul>
<li><strong>跨区引用</strong>：在垃圾回收的上下文中，”跨区引用” 指的是对象之间的引用关系，其中被引用的对象位于不同的内存区域。在这种情况下，需要考虑如何有效地跟踪和处理这些跨区引用。写屏障是一种支持跨区引用的机制，通过它可以在修改对象引用时执行额外的代码。在这个特定的实现中，使用 CardTable 来实现 RememberSet。RememberSet 是一种数据结构，用于记录指向其他内存区域的引用。CardTable 会被标记为 “Dirty”，以指示某个区域内的引用发生了变化，需要在后续的回收阶段中进行处理。</li>
</ul>
</li>
<li><p>并发：由CardTable，转发指针，起始快照，目标空间不变(只访问to_space对象)等特性支持。</p>
<ul>
<li><p><strong>CardTable（卡表）</strong>：CardTable 是一种数据结构，通常是一个字节数组，用于跟踪堆内存中每个小块（通常是一小块连续的内存，称为 Card）的状态。在并发垃圾回收中，卡表被用来记录对象引用的变化，特别是在写入引用时，标记与之相关的卡为”Dirty”（脏）。这有助于回收器识别哪些部分的内存发生了变化，需要在后续的回收阶段中处理。</p>
</li>
<li><p><strong>转发指针</strong>：在并发垃圾回收期间，当一个对象被复制到新的内存空间时，原始的引用需要被修正，指向新的内存地址。这个修正过程中可能会用到转发指针，即在原始地址上放置一个指针，指向新的内存地址。</p>
</li>
<li><p><strong>起始快照</strong>：在并发垃圾回收开始时，需要对内存状态进行一次快照，即记录当前所有对象的状态和位置。这个快照通常称为起始快照，它是垃圾回收器追踪对象移动和变化的基准。</p>
</li>
<li><p><strong>目标空间不变</strong>：指的是在并发垃圾回收期间，被回收的对象会被复制到新的内存空间（通常称为 to_space），而这个 to_space 在整个回收过程中是保持不变的。这确保了应用线程在访问 to_space 中的对象时，可以避免对正在进行的垃圾回收操作产生干扰。</p>
</li>
</ul>
</li>
<li><p><strong>写屏障（Write Barrier）</strong>：</p>
</li>
</ol>
<ul>
<li><p><strong>写前屏障</strong>：<strong>在修改对象的引用型成员变量之前执行一段特殊代码。这段代码负责标记与该对象相关的内存卡（Card）为Dirty。</strong>在并发复制垃圾收集中，Card通常是内存空间的一个固定大小的块。Dirty表示该块中的对象引用发生了变化。</p>
</li>
<li><p><strong>写后屏障</strong>：在修改对象的引用型成员变量之后执行一段特殊代码。这段代码也负责标记与该对象相关的内存卡为Dirty（脏）。</p>
</li>
<li><p>作用：通过这两种写屏障，垃圾收集器能够跟踪在上一次垃圾回收之后和并发期间发生的引用变化。<strong>Dirty（脏）的标记会被用于确定哪些对象需要在垃圾回收期间进行复制。</strong></p>
</li>
</ul>
<ol start="6">
<li><strong>读屏障（Read Barrier）</strong>：</li>
</ol>
<ul>
<li><p>读取对象的引用型成员变量时，会在访问目标对象之前执行一段特殊代码。<strong>这段代码负责检查目标对象是否已经被拷贝到新的内存位置。</strong></p>
</li>
<li><p>在并发复制垃圾收集中，如果目标对象尚未被拷贝，Mutator（应用程序线程）会执行拷贝操作，将对象复制到新的内存位置，并更新原对象的LockWord，使其指向新的目标对象。然后，引用会被修正为新的目标对象。</p>
</li>
<li><p>作用：读屏障确保在读取对象引用时，始终能够获得有效的引用<strong>。如果目标对象已经被拷贝到新的位置，读屏障负责确保引用被修正为新的目标对象，而不是指向旧的内存位置。</strong></p>
</li>
</ul>
<ol start="7">
<li><p>转发指针：被拷贝后的from_space原对象LockWord配置转发指针，之后所有访问原对象都会自动指向to_space新对象。</p>
<ul>
<li><p>“转发指针” 是一种在垃圾回收中用于处理对象拷贝的机制。在并发复制（Concurrent Copying）的垃圾回收算法中，当一个对象被移动到新的内存空间（例如从 from_space 到 to_space）时，为了确保之前对原对象的引用仍然有效，会在原对象的位置留下一个特殊的标记，即 “转发指针”。</p>
<p>具体来说，转发指针是一个指向新的拷贝对象的指针。当程序试图访问原对象时，会经过这个转发指针，从而自动指向新的对象。这样一来，即使对象在垃圾回收过程中被移动，引用该对象的代码仍然能够正确地访问到新的位置。</p>
<p>这种机制的好处是，无需修改引用原对象的代码，就能够实现对象的动态迁移。这对于需要在垃圾回收过程中保持应用程序线程的活动性（不需要停顿应用线程）的并发垃圾回收算法是非常有用的。</p>
</li>
</ul>
</li>
<li><p>优势：</p>
</li>
</ol>
<p>指针碰撞分配，贡献最高的内存分配速度。</p>
<p>前后台内存整理，更少的内存碎片，可控的漂浮垃圾数量。</p>
<p>更灵活的内存管理单位，提升内存利用率，相比CMS降低平均32%的堆占用（google官方数据）。</p>
<p>更精准的分代垃圾回收策略，提升吞吐量（回收效率），减少PauseTime。</p>
<ol start="9">
<li>不足：</li>
</ol>
<p>预留两倍堆空间的内存地址（32位应用影响明显，增加虚拟内存地址不足OOM概率）。</p>
<p>并发复制过程耗时随堆大小、对象数递增，耗时较长。</p>
<p>Mutator线程参与对象拷贝和Tracing，存在对象移动风暴。</p>
<p>读写互斥锁与锁堆特殊场景阻塞应用线程。</p>
<p>无法单独释放某个对象的内存，并发过程中新增对象默认为存活，存在一定的漂浮垃圾。</p>
<p>有关回收器的知识可以看上面的章节“ART GC 的分配器实现”的讲解。</p>
<p>有关Space的东西看上面的ART Heap创建。</p>
<p>有关GC Case的情况看上面的回收器使用章节。</p>
<p>有关对象创建的东西看上面的ART堆对象分配章节。</p>
<p>有关对象释放的东西看上面的ART堆对象释放章节。</p>
<p>有关回收器的东西看上面的ART GC 回收器的实现</p>
<p>CC垃圾处理器涉及到的分配器是<strong>kAllocatorTypeReg1onTLAB</strong>，涉及到的空间类是<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/space/region_space.h">region_space</a>。</p>
]]></content>
  </entry>
  <entry>
    <title>Java JVM</title>
    <url>/2024/01/25/JavaJVM/</url>
    <content><![CDATA[<h1 id="Java-JVM"><a href="#Java-JVM" class="headerlink" title="Java JVM"></a>Java JVM</h1><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122212026094.png" alt="image-20240122212026094"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​		程序计数器可以看作是当前<strong>线程所执行的字节码的行号指示器。</strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>​		在java多线程中一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​		Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口等信息。</strong>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>​		局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>​		<strong>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示</strong>，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。<strong>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</strong></p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​		本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>​		Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java<br>世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>​		<strong>逃逸分析</strong>：</p>
<p>​		这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>​		逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 StringBuffer，那么StringBuffer将不会逃逸出方法。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<p>一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>二、<strong>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</strong></p>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<p>​	问：是不是所有的对象和数组都会在堆内存分配空间？</p>
<p>​	答：不一定，随着JIT编译器的发展，在编译期间，如果JIT(即时编译）经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。在开启逃逸分析之后，也并不是所有对象都没有在堆上分配。<a href="https://juejin.cn/post/6844903639308304397#heading-2">#</a></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​		方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p>
<p>​		方法区只是一个规范，Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的。 永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。永久代（PermGen区）用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代（PermGen区）中。</p>
<p>​		但在Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了本地内存（Native memory）；字符串常量池(interned strings)转移到了Java 堆（heap）中；<strong>类的静态变量(class statics)转移到了Java Heap。</strong></p>
<p>​		在Java8中取消了永久代，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。</p>
<p>本地内存：</p>
<p>堆内存是Java程序运行的主要内存区，由JVM自动管理，主要用于存储Java对象。本地内存则是由操作系统管理，需要程序员手动管理，主要用于执行本地方法和存储直接缓冲区。</p>
<p>java8下的内存模型</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/16f04cdf3a0ba3ea%7Etplv-t2oaga2asx-jj-mark%3A3024%3A0%3A0%3A0%3Aq75.png" alt="img"></p>
<p>方法区版本变迁：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101535441.png" alt="在这里插入图片描述"></p>
<p>常量池和静态变量的存储位置：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101554905.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101603471.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/20200803101611971.png" alt="在这里插入图片描述"></p>
<p>总结一下：</p>
<p>在1.6及以前方法区由永久代实现在堆物理内存中，静态变量和运行时常量池在永久代，字符串常量池也在运行时常量池中。</p>
<p>在1.7运行时常量池在永久代，将静态变量和字符串常量池移到了堆中</p>
<p>在1.8 方法区由元空间实现在本地内存中，静态变量和字符串常量池仍然在堆空间中</p>
<p><a href="https://blog.csdn.net/wanderlustLee/article/details/80762851">引用博客</a></p>
<p><a href="https://blog.csdn.net/alex6586/article/details/107757796">引用博客2</a></p>
<p>Java中基本数据类型存储在JVM中的存储位置？</p>
<p>简单来说：这取决于变量的声明位置，而不是它的类型。</p>
<p>局部变量存储在栈中，<a href="https://so.csdn.net/so/search?q=%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">实例变量</a>和静态变量存储在堆中。</p>
<p>也就是说，基本数据类型如果声明在方法内，那么它就存储在栈中，如果声明在类的成员或声明为 <code>static</code> 那么就存储在堆中</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​		运行时常量池（Runtime Constant Pool）是方法区的一部分。<strong>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>​		除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p>
<p>​		<strong>运行时常量池一个重要特征是具备动态性运行期间也可以将新的常量放入池中</strong>，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>​		既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<p>​		这里会存储类静态属性的引用，但是所引用的对象存放在堆中。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>​		在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，<strong>引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong></p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>new Person()</code>创建了一个新的<code>Person</code>对象存放在堆中，<code>person</code>是一个引用声明为局部变量存放在栈中，声明为成员变量就存储在堆中，它指向这个新创建的<code>Person</code>对象。</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402280938002.png" alt="图片"></p>
<ul>
<li><strong>检查加载：</strong></li>
</ul>
<p>		</p>
<p>​		当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<ul>
<li><strong>分配内存：</strong></li>
</ul>
<p>​		对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p>
<ul>
<li><strong>内存空间初始化：</strong></li>
</ul>
<p>​		内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<ul>
<li><strong>设置：</strong></li>
</ul>
<p>​		对象头通常包含了关于对象的元数据，如哈希码、GC状态信息、类元数据的引用等。这部分内容在创建对象时由JVM处理，不会被初始化为零。 实例字段（也就是我们通常说的对象的属性或成员变量）在对象创建时，如果我们没有明确给它们赋值，那么它们就会被初始化为对应类型的零值。具体的零值取决于字段的数据类型：</p>
<ul>
<li>对于数值类型（如int, long, double等），零值就是0。</li>
<li>对于布尔类型（boolean），零值是false。</li>
<li>对于字符类型（char），零值是null字符（’\u0000’）。</li>
<li>对于引用类型（如类、接口、数组等），零值是null。</li>
</ul>
<p>这样做的好处是，可以确保在任何情况下，只要对象被创建，它的实例字段就可以被安全地访问，不会出现未定义的状态。</p>
<ul>
<li><strong>对象初始化：</strong></li>
</ul>
<p>​		在以上工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 JVM 中，Java对象保存在堆中时，由以下三部分组成：</p>
<ul>
<li><strong>对象头（object header）</strong>：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。</li>
<li><strong>实例数据（Instance Data）</strong>：主要是存放类的数据信息，父类的信息，对象字段属性信息。</li>
<li><strong>对齐填充（Padding）</strong>：为了字节对齐，填充的数据，不是必须的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200917170455322-1670500196.png" alt="img"></p>
<p><strong>对象头：</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200917170544775-1625770619.png" alt="img"></p>
<p>Mark Word在32位JVM中是这么存的</p>
<p><a href="https://img2020.cnblogs.com/blog/1162587/202009/1162587-20200918154115022-312986152.png"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200918154115022-312986152.png" alt="img"></a></p>
<p>在64位JVM中是这么存的</p>
<p><a href="https://img2020.cnblogs.com/blog/1162587/202009/1162587-20200918154125385-1537793659.png"><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1162587-20200918154125385-1537793659.png" alt="img"></a></p>
<p>虽然它们在不同位数的JVM中长度不一样，但是基本组成内容是一致的。</p>
<ul>
<li><strong>锁标志位（lock）</strong>：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</li>
<li><strong>biased_lock</strong>：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</li>
<li><strong>分代年龄（age）</strong>：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li>
<li><strong>对象的hashcode（hash）</strong>：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。</li>
<li><strong>偏向锁的线程ID（JavaThread）</strong>：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li>
<li><strong>epoch</strong>：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li>
<li><strong>ptr_to_lock_record</strong>：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li>
<li><strong>ptr_to_heavyweight_monitor</strong>：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li>
</ul>
<p>​		<strong>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</strong></p>
<p><strong>实例数据：</strong></p>
<p>如果对象有属性字段，则这里会有数据信息。如果对象无属性字段，则这里就不会有数据。根据字段类型的不同占不同的字节，例如boolean类型占1个字节，int类型占4个字节等等；</p>
<p><strong>对齐数据</strong><a href="https://www.cnblogs.com/jajian/p/13681781.html#%E5%AF%B9%E9%BD%90%E6%95%B0%E6%8D%AE">#</a></p>
<p>对象可以有对齐数据也可以没有。默认情况下，Java虚拟机堆中对象的起始地址需要对齐至8的倍数。如果一个对象用不到8N个字节则需要对其填充，以此来补齐对象头和实例数据占用内存之后剩余的空间大小。如果对象头和实例数据已经占满了JVM所分配的内存空间，那么就不用再进行对齐填充了。</p>
<p>所有的对象分配的字节总SIZE需要是8的倍数，如果前面的对象头和实例数据占用的总SIZE不满足要求，则通过对齐数据来填满。</p>
<p><strong>其实对其填充的最终目的是为了计算机高效寻址。</strong></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>也就是栈中的指针访问到堆中对象的方式，主流的访问方式主要有使用句柄和直接指针两种：</p>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240123202431236.png" alt="image-20240123202431236"></p>
<ul>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240123202532036.png" alt="image-20240123202532036"></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240220153328613.png" alt="image-20240220153328613"></p>
<p>第一个阶段“加载”的进行时机不确定，但是《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<ul>
<li><p>使用new关键字实例化对象的时候。</p>
</li>
<li><p>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</p>
</li>
<li><p>调用一个类型的静态方法的时候。</p>
</li>
</ul>
<p>2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5)当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p><strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</strong></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<p>1）通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3）在堆内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法）</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<ol>
<li>文件格式验证</li>
</ol>
<p>验证字节流是否符合Class文件格式的规范</p>
<ol start="2">
<li>元数据验证</li>
</ol>
<p>对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相<br>悖的元数据信息。例如这个类的父类是否继承了不允许被继承的类（被final修饰的类）、如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</p>
<ol start="3">
<li>字节码验证</li>
</ol>
<p>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p>
<ol start="4">
<li>符号引用验证</li>
</ol>
<p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类<strong>是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</strong></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在<strong>JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中</strong>，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<p>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</p>
<ul>
<li><p>符号引用（Symbolic References）：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</strong>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
<li><p>直接引用（Direct References）：<strong>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</strong>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</li>
</ul>
<ol>
<li>类或接口的解析</li>
</ol>
<p>把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<p>1）<strong>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</strong>在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
<p>2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava&#x2F;lang&#x2F;Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</p>
<p>3）如果上面两步没有出现任何异常，<strong>那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。</strong>如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<ol start="2">
<li>字段解析</li>
</ol>
<p>这段话描述了对未解析字段符号引用的解析过程，首先对字段所属的类或接口的符号引用进行解析，然后按照特定的顺序逐级搜索字段所属的类或接口、实现的接口以及父类，直到找到与目标字段匹配的字段引用或者抛出异常。</p>
<ol start="3">
<li>方法解析</li>
</ol>
<p>首先解析方法所属的类或接口的符号引用，然后按照特定的顺序逐级搜索方法所属的类或接口、父类以及实现的接口，直到找到与目标方法匹配的方法引用或者抛出异常。</p>
<ol start="4">
<li>接口方法解析</li>
</ol>
<p>首先解析接口方法所属的类或接口的符号引用，然后按照特定的顺序逐级搜索接口方法所属的接口以及其父接口，直到找到与目标方法匹配的方法引用或者抛出异常。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p>
<p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：<u>初始化阶段就是执行类构造器<clinit>()方法的过程。</u></p>
<p><clinit>()方法的产生：</p>
<ul>
<li><strong><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。</strong>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">		System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，<strong>Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。</strong>因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
</li>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p>
<p>绝大多数Java程序都会使用到以下3个系统提供的类加载器来进行加载：</p>
<ul>
<li>启动类加载器（Bootstrap Class Loader）这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的。它主要负责加载Java运行时环境的核心类库，即Java平台核心API（如java.lang包、java.util包等），以及其他一些被系统引导的重要类。这些类库通常位于JDK的安装目录中，由Java虚拟机的实现提供。</li>
<li>扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li>
<li>应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240220173823422.png" alt="image-20240220173823422"></p>
<p>上图中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents Delegation Model）”。<strong>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</strong>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实的，而是通常使用 组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：<u>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</u></p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​		这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<ul>
<li><p>在<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVariables</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">localObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// localObject是GC Root，当方法执行时</span></span><br><span class="line">        <span class="comment">// 当localVariables方法执行完毕后，localObject不再作为GC Root</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">staticObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// staticObject是GC Root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSTANT_STRING</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// GC Root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</strong></p>
</li>
<li><p>所有被同步锁（synchronized关键字）持有的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// &#x27;lock&#x27;对象作为同步块的锁，是GC Root</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反射引用的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// GC Root</span></span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>仍处于存活状态中的线程中的对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">threadLocalObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 当前线程栈中的对象，作为GC Root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量/属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STATIC_CONST</span> <span class="operator">=</span> <span class="string">&quot;Static Constant&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例变量（普通变量）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONST</span> <span class="operator">=</span> <span class="string">&quot;Constant&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法中的局部变量和常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
</li>
</ul>
<h2 id="对象的生存与死亡"><a href="#对象的生存与死亡" class="headerlink" title="对象的生存与死亡"></a>对象的生存与死亡</h2><p>​		要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>​		如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<p>​		finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，<strong>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；</strong>如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<p><strong>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行</strong></p>
<h2 id="垃圾回收算法以及分代收集理论"><a href="#垃圾回收算法以及分代收集理论" class="headerlink" title="垃圾回收算法以及分代收集理论"></a>垃圾回收算法以及分代收集理论</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
<p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
<p>基于这两个假说出现了垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p>
<p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。</p>
<p>基于新生代和老年代相互引用的情况，出现了第三条假说：</p>
<p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<p>存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<p>基于这个假说就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在<strong>新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</strong>此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。</p>
<p><strong>回收类型概念</strong>：</p>
<ol>
<li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</li>
</ol>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​		就如它的字面意思一样，GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象<br>回收的阶段。</p>
<blockquote>
<p>在Mark阶段中，算法从根集（Root Set）开始，这是程序中一些已知的引用对象，比如全局变量、栈中的变量等。然后，算法递归地遍历所有通过<strong>这些根集直接或间接引用的对象，并将它们标记为“活跃”或“被引用”的对象。</strong>这样，标记阶段就识别出了在程序中仍然是可达的对象。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<p>​		第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p>
<p>​		第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>​		它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>​		如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>
<p>​		缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​		针对老年代对象的存亡特征，提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器#"></a>垃圾收集器<a href="https://huminxi.netlify.app/2022/07/06/java%208%20vs%20java%2017%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">#</a></h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/gc-preview.png" alt="img"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>​		Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机<strong>新生代收集器</strong>的唯一选择。当它使用<strong>标记-复制算法</strong>进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p>​		这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p>​		优点：简单、高效、它是所有收集器里额外内存消耗最小的；在资源匮乏的环境下的不二之选。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的<strong>老年代</strong>版本，它同样是一个单线程收集器，使用<strong>标记-整理</strong>算法。</p>
<p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<blockquote>
<p>它是客户端模式下的老年代收集器。在服务端模式下有两种用途：一种是在 JDK 5 及之前的版本中与 Parallel Scavenge 收集器配合使用；另一种就是在 CMS 收集器发生 <a href="https://www.zhihu.com/question/50398881">Concurrent Mode Failure</a> 时使用（处理浮动垃圾和内存碎片）。</p>
</blockquote>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew <strong>实质上是 Serial 收集器的多线程并行版本</strong>。除了同时使用多条线程进行垃圾收集之外，其余行为都与 Serial 收集器完全一致。</p>
<blockquote>
<p>ParNew 与 Serial 相比并没有太多创新之处，但它却是许多运行在服务端模式下的 HotSpot 虚拟机（尤其是 JDK 7 之前）首选的新生代收集器。其中一个很重要的原因是：除了 Serial 收集器之外，只有它能与 CMS 收集器配合工作。</p>
</blockquote>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>它是基于<strong>标记-复制</strong>算法实现的<strong>新生代</strong>收集器，也是能够并行收集的多线程收集器。与另一个并行收集器 ParNew 相比，Parallel Scavenge 关注的是吞吐量（Throughput）。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240125214740599.png" alt="image-20240125214740599"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持多线程并发收集（不会停止工作线程），基于<strong>标记-整理</strong>算法实现。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是基于<strong>标记-清除</strong>算法实现的老年代垃圾收集器，CMS的工作方式包括：</p>
<ol>
<li><strong>初始标记（Initial Mark）：</strong> 在初始标记阶段，<strong>CMS会暂停应用程序线程</strong>，标记所有的GC Roots，以及直接与GC Roots有关联的对象。</li>
<li><strong>并发标记（Concurrent Mark）：</strong> CMS通过并发标记阶段来标记所有可达的对象，尽量减少暂停时间。</li>
<li><strong>重新标记（Remark）：</strong> 在并发标记之后，<strong>CMS需要进行一次短暂的暂停</strong>来处理在并发标记期间产生的新的引用关系。</li>
<li><strong>并发清除（Concurrent Sweep）：</strong> 在重新标记后，CMS会并发地清理未标记的对象，释放空间</li>
</ol>
<p>由于CMS在标记和清理过程中尽量减少了停顿时间，因此它适合用于那些对停顿时间敏感的应用。然而，CMS也有一些缺点，例如可能产生碎片，以及在某些情况下可能需要进行Full GC。在Java 9及以后版本，G1（Garbage-First）收集器逐渐取代了CMS作为更先进的垃圾收集器。</p>
<ol>
<li>初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；</li>
<li>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li>
<li>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</li>
<li>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ol>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器#"></a>Garbage First收集器<a href="https://juejin.cn/post/6844903894196158471">#</a></h3><p>它开创了收集器<strong>面向局部收集</strong>的设计思路和<strong>基于Region（独立区域）</strong>的内存布局形式。G1收集器的名称源于其“Garbage-First”（G1）算法，<strong>该算法的目标是优先回收包含垃圾最多的Region。</strong>这有助于最大程度地减少堆中的垃圾。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</p>
<blockquote>
<p>G1 不再坚持固定大小以及固定数量的分代区域划分，而是<strong>把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。</strong>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。</p>
</blockquote>
<p>在 G1 收集器出现之前的所有收集器（包括 CMS 在内），垃圾收集的目标范围要么是整个新生代（Minor GC），要么是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set），衡量标准不再是它属于哪个分代，<strong>而是哪块内存中存放的垃圾数量最多，回收收益最大，优先处理回收收益最大的那些 Region，这也就是 Garbage First 名字的由来</strong>。</p>
<ul>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<p>相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。<strong>与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，</strong>无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<h2 id="Java8下的垃圾回收"><a href="#Java8下的垃圾回收" class="headerlink" title="Java8下的垃圾回收"></a>Java8下的垃圾回收</h2><p>java8使用的收集器是Parallel Scavenge加Parallel Old组合，Parallel Scavenge是基于<strong>标记-复制</strong>算法实现的<strong>新生代</strong>收集器，Parallel Old是基于<strong>标记-整理</strong>算法实现老年代收集器。</p>
<p>分代下的内存回收策略：</p>
<ul>
<li><strong>对象优先在Eden区分配</strong></li>
<li><strong>大对象直接进入老年代</strong></li>
<li><strong>长期存活的对象进入老年代</strong></li>
<li><strong>对象年龄的动态判断</strong></li>
<li><strong>空间分配担保</strong></li>
</ul>
<p>Java堆内存被划分为物理上隔开的2个大区域：</p>
<ul>
<li><strong>青年代Young Generation</strong></li>
<li><strong>老年代Old Generation</strong></li>
</ul>
<p>其中青年代(新生代)又分为了3个独立的区域：</p>
<ul>
<li><strong>Eden</strong></li>
<li><strong>Survivor</strong></li>
<li><strong>Survivor</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-450e07949f232db9fc7909c3e553ab2f_720w.webp" alt="img"></p>
<p><strong>Eden</strong>：大多数新建的Java对象被分配到这里(少数很大的对象会直接划分在老年代)，MinorGC（新生代的垃圾收集）后，此区域内的对象大多数被GC清理干净，释放内存，只有少数躲过了GC，从而提升至Survivor区域。</p>
<p><strong>Survivor</strong>：青年代中含有两个Survivor区域，为什么？因为青年代采用的是复制算法，复制算法会将左边已经使用过的对象复制到右边Survivor未使用区域，然后对左边Survivor区域做一次GC垃圾回收。存放在Survivor区域的对象，都是经历过至少1此MinorGC的，如果在此区域的对象能够顺利躲过多次MinorGC，则会提升至老年代。</p>
<p><strong>对象优先在Eden区分配</strong></p>
<p><strong>大多数情况下，新生的对象会直接在Eden区域分配内存，当内存不够时，虚拟机将会发动一次MinorGC。</strong></p>
<blockquote>
<p>MinorGC：在年轻代内存区域上的垃圾收集过程，因为大多数在年轻代上的对象“朝生夕灭”，所以MinorGC非常频繁，一般收集的速度也很快。<br>MajorGC&#x2F;Full GC：指发生在老年代的GC，此区域一般对象存活率高，GC一次的速度同城比MinorGC慢10倍以上。</p>
</blockquote>
<p><strong>大对象直接进入老年代</strong></p>
<p>所谓的大对象是指需要大量连续内存空间的Java对象，长字符串及大容量的数组。安放这些大对象，虚拟机会直接将其放在老年代，因为大对象一般涉及到的引用多，不容易「死」掉。而且大对象占内存，所以直接在老年代为其开辟一块连续的内存就比较合适。如果内存不够分配，虚拟机会触发垃圾收集过程。</p>
<p><strong>长期存活的对象进入老年代</strong></p>
<p>既然虚拟机采用分代收集的策略来管理内存，那么内存回收时就应该相应的判别哪些对象该放在青年代，哪些放在老年代。为此，JVM给每个对象定义了一个<strong>「年龄」</strong>计数器。如果对象在Eden出生，并且经过一次MinorGC后仍然存在，则「年龄」增加1岁。当年龄增加到一定数目(如：默认为15岁)，就会被<strong>「提升」</strong>至老年代。部分虚拟机提供了参数可以设置此<strong>年龄「阈值」</strong>。</p>
<p>青年代和老年代在Java堆内存上被划分为两块不同的物理区域，其中青年代中又单独划分成了三块——Eden+Survivor+Survivor。在这些不同区域上任何一个内存“满”了以后，都会触发一次垃圾收集过程。Java中绝大部分的新创建的对象都被分配到了青年代中的Eden区，当青年代满了，就会触发一次在青年代上的垃圾收集过程。</p>
<blockquote>
<p><strong>注意</strong>：对于老年代可能存在这么一种情况，老年代中的对象有时候会引用到新生代对象。这时如果要执行新生代 GC，则可能需要查询整个老年代上可能存在引用新生代的情况，这显然是低效的。所以，老年代中维护了一个 512 byte 的 <code>card table</code>，所有老年代对象引用新生代对象的信息都记录在这里。每当新生代发生 GC 时，只需要检查这个 <code>card table</code> 即可，大大提高了性能。</p>
</blockquote>
<p><strong>动态对象年龄判定</strong></p>
<p>为了更好地适应不同程序的内存状况，虚拟机并不是永远要求对象年龄必须达到「阈值」才能提升至老年代。在有的垃圾收集器实现中，如果Survivor空间中相同年龄的对象占用空间&gt;Survivor总空间的一半，则此年龄的所有对象就可以提前进入老年代，而不是必须达到阈值。</p>
<p><strong>空间分配担保</strong></p>
<p>在MinorGC之前，JVM会首先检查老年代最大可用的连续内存空间是否 &gt; 青年代所有对象总空间，并以其作为MajorGC执行的「担保」。如果大于则MinorGC可以正常执行。否则JVM会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，则继续执行MinorGC，否则则执行MajorGC用来回收足够的内存空间</p>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><h4 id="new一个对象的流程"><a href="#new一个对象的流程" class="headerlink" title="new一个对象的流程"></a>new一个对象的流程</h4><p>JVM创建对象的过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402280938002.png" alt="图片"></p>
<p>虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。类加载就是把class加载到JVM的运行时数据区的过程。</p>
<p><strong>检查加载</strong></p>
<p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查类是否已经被加载、解析和初始化过。</p>
<blockquote>
<p>符号引用：以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，JAVA在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址(实际地址)，就用符号引用来代替，而在类的解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。</p>
<p>假设People类被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用（org.simple.Tool）来代替。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址。</p>
</blockquote>
<p><strong>分配内存</strong></p>
<p>完成类的加载检查后，虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<p><strong>指针碰撞</strong></p>
<p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为—指针碰撞。</p>
<p><strong>空闲列表</strong></p>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为—空闲列表。</p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<ul>
<li>如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。</li>
<li>如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</li>
</ul>
<p><strong>并发安全</strong></p>
<p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>解决这个问题有两种方案：</p>
<p><strong>CAS</strong></p>
<p>对分配内存空间的动作进行同步处理—实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202402281002674.png" alt="图片"></p>
<p><strong>分配缓冲</strong></p>
<p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。</p>
<p>JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</p>
<p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。</p>
<p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p>
<p>默认情况下启用允许在年轻代空间中使用线程本地分配块（TLAB）。要禁用TLAB，需要指定<code>-XX:-UseTLAB</code>。</p>
<p><strong>内存空间初始化</strong></p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。(如int值为0，boolean值为false等等)。</p>
<p><strong>设置</strong></p>
<p>完成空间初始化后，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p>
<p><strong>对象初始化</strong></p>
<p>在以上工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。</p>
]]></content>
  </entry>
  <entry>
    <title>java 面试题</title>
    <url>/2024/03/08/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="SparseArrary和HashMap比较"><a href="#SparseArrary和HashMap比较" class="headerlink" title="SparseArrary和HashMap比较"></a>SparseArrary和HashMap比较</h4><p><code>SparseArray</code> 使用两个数组来存储数据，避免了 <code>HashMap</code> 中的Integer自动装箱（autoboxing）过程，减少了内存占用。在处理小型数据集时，这种差异尤为明显。但这也就是仅仅的优点了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SparseArray</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> keys:   <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">8</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">values</span>: <span class="operator">|</span> A <span class="operator">|</span> B <span class="operator">|</span> C <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>

<p>SparseArray的局限性：</p>
<ol>
<li><strong>只适用于整数键</strong>：<code>SparseArray</code> 只能使用整数作为键，而 <code>HashMap</code> 可以使用任何类型的对象作为键。</li>
<li><strong>可能不适合大型数据集</strong>：对于非常大的数据集，<code>SparseArray</code> 的二分查找可能不如 <code>HashMap</code> 的哈希查找高效。</li>
</ol>
<h4 id="ConcurrentHashMap基本原理"><a href="#ConcurrentHashMap基本原理" class="headerlink" title="ConcurrentHashMap基本原理"></a>ConcurrentHashMap基本原理</h4><p>ConcurrentHashMap的get方法是没有使用同步锁的，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点</p>
<h4 id="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥"><a href="#HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥" class="headerlink" title="HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?"></a>HashMap原理，存取过程，为什么用红黑树，红黑树与完全二叉树对比，HashTab、concurrentHashMap，concurrent包里有啥?</h4><p>存取过程：看下图是存的过程，取得过程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9LUlJ4dnFHY2ljWkdMVGljYUxZa3BiTldUZTBkVlRMRncxVEh1RWdFR2lhVkV3N0JoazBvVWRDVnNnN2dObG5yYUtuemljUEo2M3JiNDlvNFhRTTJWak5pY2ljdy8" alt="img"></p>
<p>其中对key得hash操作具体得内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>原始哈希值 <code>h</code> 的高16位右移16位（<code>h &gt;&gt;&gt; 16</code>），然后与原始哈希值进行异或运算（<code>^</code>）得到hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>一切以算的位置为基础寻找对应的数组节点，然后再遍历红黑树或者链表查找对应的元素。</p>
<p><strong>红黑树与完全二叉树对比：</strong></p>
<p>红黑树查找、插入和删除操作的最坏情况时间复杂度为 O(log n)。而完全二叉树是O(n)。</p>
<p><strong>Hashtable结构：</strong></p>
<p>它对几乎大部分方法都上了synchronized锁，底层结构为数组+链表，因为已经被废弃所以研究没有意义。</p>
<h4 id="Java的concurrent包里有啥："><a href="#Java的concurrent包里有啥：" class="headerlink" title="Java的concurrent包里有啥："></a><strong>Java的concurrent包里有啥：</strong></h4><p><strong>线程池和执行器框架</strong></p>
<ul>
<li><code>Executor</code>：执行已提交的 <code>Runnable</code> 任务的对象的接口。</li>
<li><code>ExecutorService</code>：扩展了 <code>Executor</code> 的接口，提供了更完整的异步任务执行框架。</li>
<li><code>ScheduledExecutorService</code>：扩展了 <code>ExecutorService</code>，支持定时以及周期性任务执行。</li>
<li><code>ThreadPoolExecutor</code>：<code>ExecutorService</code> 的实现类，用于管理和执行线程池中的任务。</li>
<li><code>ScheduledThreadPoolExecutor</code>：<code>ScheduledExecutorService</code> 的实现类，用于执行定时或周期性任务。</li>
</ul>
<p><strong>同步器</strong></p>
<ul>
<li><code>CountDownLatch</code>：允许一个或多个线程等待其他线程完成操作的同步辅助工具。</li>
<li><code>CyclicBarrier</code>：使一组线程在达到某个屏障时互相等待的同步辅助工具。</li>
<li><code>Semaphore</code>：基于计数的信号量，用于控制对资源的访问。</li>
<li><code>Exchanger</code>：用于在两个线程之间交换数据的同步点。</li>
<li><code>Phaser</code>：提供了一种更灵活的线程同步机制，类似于 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 的结合。</li>
</ul>
<p><strong>并发集合</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的 <code>HashMap</code> 实现。</li>
<li><code>ConcurrentLinkedQueue</code>：基于链接节点的、线程安全的无界队列。</li>
<li><code>ConcurrentSkipListMap</code>：线程安全的、可排序的 <code>Map</code> 实现。</li>
<li><code>ConcurrentSkipListSet</code>：基于 <code>ConcurrentSkipListMap</code> 的 <code>Set</code> 实现。</li>
<li><code>CopyOnWriteArrayList</code>：在写操作时复制底层数组的线程安全 <code>List</code> 实现。</li>
<li><code>CopyOnWriteArraySet</code>：基于 <code>CopyOnWriteArrayList</code> 的 <code>Set</code> 实现。</li>
</ul>
<p><strong>原子变量</strong></p>
<ul>
<li><code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code> 等：提供原子操作的变量类。</li>
<li><code>AtomicReference</code>：提供对对象引用的原子操作。</li>
<li><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code>：提供对数组元素的原子操作。</li>
</ul>
<p><strong>锁</strong></p>
<ul>
<li><code>Lock</code>：锁的基本接口。</li>
<li><code>ReentrantLock</code>：可重入的互斥锁实现。</li>
<li><code>ReadWriteLock</code>：读写锁的接口。</li>
<li><code>ReentrantReadWriteLock</code>：可重入的读写锁实现。</li>
<li><code>StampedLock</code>：提供了一种乐观读锁的实现。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><code>Future</code>：表示异步计算的结果。</li>
<li><code>Callable</code>：类似于 <code>Runnable</code>，但可以返回结果并抛出异常。</li>
<li><code>FutureTask</code>：<code>Future</code> 的实现类，用于表示异步计算。</li>
<li><code>CompletionService</code>：用于提交一组可调用任务，并以异步方式获取它们的结果。</li>
</ul>
<h4 id="ArrayList-如何保证线程安全？"><a href="#ArrayList-如何保证线程安全？" class="headerlink" title="ArrayList 如何保证线程安全？"></a>ArrayList 如何保证线程安全？</h4><ul>
<li>继承Arraylist，然后重写或按需求编写自己的方法，这些方法要写成synchronized，在这些<br>synchronized的方法中调用ArrayList的方法。</li>
<li>可以使用Collections.synchronizedList()这个函数进行包装</li>
</ul>
<h4 id="请说一说ArrayList、HashMap、LinkedHashMap-？"><a href="#请说一说ArrayList、HashMap、LinkedHashMap-？" class="headerlink" title="请说一说ArrayList、HashMap、LinkedHashMap ？"></a>请说一说ArrayList、HashMap、LinkedHashMap ？</h4><p><strong>ArrayList：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>ArrayList</code> 的底层是一个动态数组，而不是双向链表。初始长度默认为 10。当数组容量不足时，通常扩展为原来的 1.5 倍。</li>
<li><strong>时间复杂度</strong>：获取元素的时间复杂度是 O(1)，因为可以直接通过数组索引来访问。但是插入和删除操作的时间复杂度可能是 O(n)，因为可能需要移动元素来维护数组的连续性。</li>
</ul>
<p><strong>HashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>HashMap</code> 的底层是一个数组，数组中的每个位置（或称为“桶”）包含了一个链表或红黑树（当链表中的元素数量超过某个阈值时，链表会转换为红黑树）来处理哈希冲突。</li>
<li><strong>哈希冲突处理</strong>：当多个键的哈希值相同，或者不同的哈希值经过处理后落在同一个桶中时，这些键值对会以链表的形式存储。在 Java 8 及以后的版本中，链表过长时会转换为红黑树来提高查找效率。</li>
</ul>
<p><strong>LinkedHashMap：</strong></p>
<ul>
<li><strong>底层结构</strong>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，因此也是基于哈希表，但它还维护了一个双向链表来记录插入顺序或访问顺序。</li>
<li><strong>顺序性</strong>：遍历 <code>LinkedHashMap</code> 时，元素将按照插入顺序（默认）或访问顺序（如果在构造函数中设置）返回。</li>
<li><strong>访问顺序</strong>：在访问顺序模式下，每次 get 或 put 操作都会将被访问的元素移至双向链表的末尾。这种行为使得 <code>LinkedHashMap</code> 可以用来实现像最近最少使用（LRU）缓存策略这样的数据结构。</li>
</ul>
<p><a href="https://www.jianshu.com/p/8f4f58b4b8ab">图解LinkedHashMap原理</a></p>
<h4 id="Java中提供了抽象类还有接口，开发中如何去选择呢？"><a href="#Java中提供了抽象类还有接口，开发中如何去选择呢？" class="headerlink" title="Java中提供了抽象类还有接口，开发中如何去选择呢？"></a>Java中提供了抽象类还有接口，开发中如何去选择呢？</h4><p><strong>抽象类的设计目的，是代码复用；接口的设计目的，是对类的行为进行约束。抽象类强调从属关系，接口强调功能。</strong></p>
<p>总结一下异同：</p>
<ol>
<li>关键字不同</li>
<li>一个类可以继承多个接口，只能继承一个抽象类</li>
<li>抽象类有构造方法，接口没有</li>
<li>继承所用的关键字不同</li>
<li><strong>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default且可以使用其他的权限修饰符，可在子类中被重新定义，也可被重新赋值。</strong></li>
<li>抽象类可以继承接口，抽象类可以继承实体类。接口也可以继承接口</li>
</ol>
<p>同：</p>
<p>都可以包含抽象方法</p>
<p>都可以有默认实现的方法</p>
<p>都不能被实例化。</p>
<h4 id="静态内部类是什么？和非静态内部类的区别是什么"><a href="#静态内部类是什么？和非静态内部类的区别是什么" class="headerlink" title="静态内部类是什么？和非静态内部类的区别是什么"></a>静态内部类是什么？和非静态内部类的区别是什么</h4><p>当内部类被static声明，那么在内部类中就无法直接使用外部类的属性。<strong>普通内部类构造方法中实际上会隐式的传递外部类实例对象给内部类。在内部类中使用外部类的属性实际上是通过外部类的实例对象获取的。</strong></p>
<p>因此静态内部类与非静态内部类的区别有：</p>
<ol>
<li>非静态内部类能够访问外部类的静态和非静态成员，静态类只能访问外部类的静态成员。</li>
<li>非静态内部类不能脱离外部类被创建，静态内部类可以。</li>
</ol>
<h4 id="Java中在传参数时是将值进行传递，还是传递引用？"><a href="#Java中在传参数时是将值进行传递，还是传递引用？" class="headerlink" title="Java中在传参数时是将值进行传递，还是传递引用？"></a>Java中在传参数时是将值进行传递，还是传递引用？</h4><p>Java 总是<strong>采用值传递</strong>的方式来处理变量。这意味着当你将一个变量传递给一个方法时，实际上传递的是变量的一个副本，不是变量本身。</p>
<p>对于基本类型（如 <code>int</code>, <code>double</code>, <code>char</code> 等），这意味着方法得到的是基本值的副本。</p>
<p>对于对象，传递的是对象引用的副本，而不是对象本身。</p>
<h4 id="equals和-进行比较的区别"><a href="#equals和-进行比较的区别" class="headerlink" title="equals和&#x3D;&#x3D;进行比较的区别"></a>equals和&#x3D;&#x3D;进行比较的区别</h4><p>equals和&#x3D;&#x3D;的区别，需要分情况讨论：</p>
<ol>
<li>没有重写 equals ，则 equals 和 &#x3D;&#x3D; 是一样的。</li>
<li>如果重写了 equals，则需看 equals 的方法实现。以 String 类为例：</li>
<li>equals 是比较字符串的内容是否一样；</li>
<li>&#x3D;&#x3D; 是比较字符串的堆内存地址是否一样，或者说引用的值是否相等。</li>
</ol>
<h4 id="String-s-new-String-“xxx”-创建了几个String对象"><a href="#String-s-new-String-“xxx”-创建了几个String对象" class="headerlink" title="String s &#x3D; new String(“xxx”);创建了几个String对象?"></a>String s &#x3D; new String(“xxx”);创建了几个String对象?</h4><ol>
<li>由于字符串字面量 <code>&quot;xxx&quot;</code> 出现在代码中，它会被放入 Java 字符串常量池中（如果常量池中还没有一个相同的字符串的话）。</li>
<li><code>new String(&quot;xxx&quot;)</code> 表达式将使用 <code>&quot;xxx&quot;</code> 字符串字面量作为参数创建一个新的 <code>String</code> 对象，并且这个新对象不在常量池中，而是在堆上分配。</li>
</ol>
<p>所以，如果常量池中之前没有 <code>&quot;xxx&quot;</code> 字符串，那么这条语句总共会创建两个字符串对象：一个在常量池中，一个在堆上。如果常量池中已经包含了 <code>&quot;xxx&quot;</code> 字符串，那么这条语句只会在堆上创建一个新的 <code>String</code> 对象。</p>
<p><code>String s = &quot;xxx&quot;;</code>只会创建一个 <code>String</code> 对象，或者一个都不创建。</p>
<h4 id="finally中的代码一定会执行吗？try里有return，finally还执行么"><a href="#finally中的代码一定会执行吗？try里有return，finally还执行么" class="headerlink" title="finally中的代码一定会执行吗？try里有return，finally还执行么"></a>finally中的代码一定会执行吗？try里有return，finally还执行么</h4><p><code>finally</code> 块中的代码几乎总是会被执行，即便 <code>try</code> 块中有 <code>return</code> 语句。<code>finally</code> 块的设计目的就是为了确保重要的清理工作总是会发生，比如关闭文件流或者数据库连接等。</p>
<p>当 <code>try</code> 块中的代码执行了 <code>return</code> 语句后，方法返回之前，<code>finally</code> 块中的代码会先被执行。之后，方法才真正返回。</p>
<p>只有在以下特殊情况下，<code>finally</code> 块不会被执行：</p>
<ul>
<li>在 <code>try</code> 或 <code>catch</code> 块中调用了 <code>System.exit()</code> 方法。</li>
<li>程序或线程崩溃，或者 <code>JVM</code> 由于某些原因挂掉了。</li>
<li>线程在 <code>finally</code> 块执行之前被中断或杀死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          System.exit(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java异常机制中，异常Exception与错误Error区别"><a href="#Java异常机制中，异常Exception与错误Error区别" class="headerlink" title="Java异常机制中，异常Exception与错误Error区别"></a>Java异常机制中，异常Exception与错误Error区别</h4><p><code>Exception</code> 和 <code>Error</code> 都是 <code>Throwable</code> 的子类，它们都可以被 <code>throw</code> 和 <code>catch</code>。但它们通常代表着不同类型的问题，并且处理方式也不同。</p>
<p><strong>Exception</strong></p>
<p><code>Exception</code> 类代表了程序可以处理的异常情况。它们通常是由于程序错误或外部环境问题导致的。<code>Exception</code> 可以分为两类：</p>
<ul>
<li><strong>检查型异常（Checked Exceptions）</strong>：这类异常必须在编译时被捕获处理（<code>catch</code>）或者通过方法签名抛出（<code>throws</code>）。这类异常表示可恢复的条件，如 <code>IOException</code> 或 <code>SQLException</code>。</li>
<li><strong>非检查型异常（Unchecked Exceptions）</strong>：也称为运行时异常（<code>RuntimeException</code>），它们不需要显式的捕获处理。这些异常通常是程序逻辑错误，比如 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。</li>
</ul>
<p><strong>Error</strong></p>
<p><code>Error</code> 类代表了严重的错误事件，这种情况下，JVM 无法继续运行。它们通常是描述系统级错误，如硬件故障、JVM 错误等。例如，<code>OutOfMemoryError</code> 表示 JVM 没有足够的内存继续执行，<code>StackOverflowError</code> 表示栈空间溢出。</p>
<ul>
<li><strong>不需要显式捕获</strong>：通常情况下，应用程序不应该捕获这类错误。它们是如此基础严重，以至于应用通常无法处理。</li>
<li><strong>预防而非恢复</strong>：对于错误，我们通常要通过编码和测试来预防它们，而不是在运行时尝试恢复。</li>
</ul>
<p>总结：</p>
<ul>
<li><code>Exception</code> 是程序可以预期并尝试恢复的条件。</li>
<li><code>Error</code> 是指在正常情况下，程序不应该尝试捕获的系统级错误。</li>
</ul>
<h4 id="序列Parcelable-Serializable的区别？"><a href="#序列Parcelable-Serializable的区别？" class="headerlink" title="序列Parcelable,Serializable的区别？"></a>序列Parcelable,Serializable的区别？</h4><p><strong>Serializable</strong></p>
<p><code>Serializable</code> 是Java原生序列化接口，其实现简单：</p>
<ul>
<li>只需实现 <code>java.io.Serializable</code> 接口，不需要实现任何方法，即可使类可序列化。</li>
<li>是一个标记接口，它告诉JVM该对象可以被序列化。</li>
<li>使用反射来序列化对象，这个过程相对较慢，并且会随着序列化对象的大小而增加更多的内存开销。</li>
<li>序列化过程会自动进行，不需要手动编写序列化过程。</li>
<li>适用于网络传输或者本地存储。</li>
</ul>
<p><strong>Parcelable</strong></p>
<p><code>Parcelable</code> 是Android特有的序列化机制，其设计目的是为了更高效的序列化，以便在Bundle中传递数据：</p>
<ul>
<li>需要实现 <code>android.os.Parcelable</code> 接口，并手动实现序列化过程。</li>
<li>性能高于 <code>Serializable</code>，因为它使用的是手动添加的序列化方法，不依赖于Java的反射机制。</li>
<li>虽然性能更好，但代码更复杂，因为开发者需要实现 <code>Parcelable</code> 接口的 <code>writeToParcel</code> 和 <code>createFromParcel</code> 方法。</li>
<li>主要用于Intent中在Activity或服务之间传递数据，不推荐用于网络传输或本地存储。</li>
</ul>
<p><strong>区别总结</strong></p>
<ul>
<li><strong>性能</strong>：<code>Parcelable</code> 通常比 <code>Serializable</code> 更快，因为它是为Android优化的。</li>
<li><strong>实现方式</strong>：<code>Serializable</code> 实现起来更简单，<code>Parcelable</code> 更复杂但提供了更好的性能。</li>
<li><strong>用途</strong>：<code>Parcelable</code> 通常用于Android中的IPC传输，<code>Serializable</code> 可用于IPC以及将对象持久化到文件或数据库。</li>
</ul>
<p>因此，在Android中，<strong>当需要在Activity和Fragment之间传递数据时，推荐使用<code>Parcelable</code>，因为它更加高效。如果需要通过网络发送对象或者将对象写入文件，<code>Serializable</code> 可能是一个更好的选择，因为它实现起来更简单，并且是Java平台的标准序列化方式。</strong></p>
<p>对于<code>Parcelable</code>，需要实现<code>Parcelable</code>接口并定义序列化和反序列化的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">User</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        name = in.readString();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Parcelable</code>传递数据的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, AnotherActivity.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane Doe&quot;</span>, <span class="number">25</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;user_key&quot;</span>, user);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>在接收Activity中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getIntent().getParcelableExtra(<span class="string">&quot;user_key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>记住，<code>Parcelable</code>是Android推荐的方式，尤其是在需要频繁地序列化和反序列化，并且在应用内部传递复杂数据结构时。</p>
<h4 id="为什么Intent传递对象为什么需要序列化？"><a href="#为什么Intent传递对象为什么需要序列化？" class="headerlink" title="为什么Intent传递对象为什么需要序列化？"></a>为什么Intent传递对象为什么需要序列化？</h4><p>在Android中使用Intent传输数据除了基本数据类型之外，对于其他类型对象需要此类型实现了Serializable或者Parcelable序列化接口才能进行传输。</p>
<p>Intent传输数据本质上是使用Binder来完成的。Intent启动组件需要借助AMS完成，因此startActivity 会离开当前应用进程，进入AMS所在的system_server进程进行跨进程通信。<strong>这就意味着传输的对象需要在不同进程之间进行传输。为了保护不同进程互不干扰，进程隔离让system_server进程无法直接获取应用进程内存中的对象。</strong>因此必须通过类似于复制的手段，将应用进程的对象传递给system_server进程，再由system_server进程传递给应用中的 OtherActivity 。</p>
<h4 id="kotlin中进行序列化的方式"><a href="#kotlin中进行序列化的方式" class="headerlink" title="kotlin中进行序列化的方式"></a>kotlin中进行序列化的方式</h4><p>在 Kotlin 中，序列化也可以通过两种主要方式实现：使用标准 Java 的 <code>Serializable</code> 接口，或者使用 Kotlin 特有的 <code>Parcelize</code> 插件来实现 <code>Parcelable</code> 接口。</p>
<p><strong>使用 Serializable</strong></p>
<p>与 Java 相同，你可以简单地通过让类实现 <code>Serializable</code> 接口来使类可序列化。Kotlin 代码更加简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kotlinCopy codeimport java.io.Serializable</span><br><span class="line"></span><br><span class="line">data class User(val name: String, val age: Int) : Serializable</span><br></pre></td></tr></table></figure>

<p>在 Kotlin 中，通常推荐使用数据类（<code>data class</code>）来存储序列化数据，因为它们自动为你的字段生成 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。</p>
<p><strong>使用 Parcelable</strong></p>
<p>Kotlin 为 <code>Parcelable</code> 实现提供了一个名为 <code>@Parcelize</code> 的注解，这可以极大简化实现过程。首先，你需要在你的 <code>build.gradle</code> 文件中启用 <code>kotlin-android-extensions</code> 插件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;kotlin-android-extensions&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以如下定义一个实现 <code>Parcelable</code> 的数据类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcelable</span><br><span class="line"><span class="keyword">import</span> kotlinx.parcelize.Parcelize</span><br><span class="line"></span><br><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) : Parcelable</span><br></pre></td></tr></table></figure>

<p>这样，编译器会自动为你生成所有必要的 <code>Parcelable</code> 实现细节。</p>
<p><strong>注意事项</strong></p>
<p>如果你打算在多个平台上使用序列化，比如在 JVM 和 Android 上，你可能会考虑使用 Kotlin 的 <code>kotlinx.serialization</code> 库，它提供了一个跨平台的序列化框架。</p>
<p>下面是一个使用 <code>kotlinx.serialization</code> 库的例子：</p>
<p>首先，在 <code>build.gradle</code> 文件中添加序列化库的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.2.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以像这样使用 <code>@Serializable</code> 注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.serialization.Serializable</span><br><span class="line"></span><br><span class="line"><span class="meta">@Serializable</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>这个库提供了丰富的序列化和反序列化选项，包括 JSON、Protobuf 和 CBOR 等格式。这可以是一个在 Kotlin 中进行复杂序列化任务的强大工具。</p>
<h4 id="Java中变量的存储"><a href="#Java中变量的存储" class="headerlink" title="Java中变量的存储"></a>Java中变量的存储</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在 <code>Main</code> 类中，<code>a</code>、<code>s</code> 和 <code>str</code> 被称为实例变量（Instance Variables）或成员变量（Member Variables）。这些变量属于类的每个实例，因此每个 <code>Main</code> 类的对象都会有自己的一份 <code>a</code>、<code>s</code> 和 <code>str</code> 变量的副本。它们的值可以在对象之间独立变化。</p>
<p>​		创建 <code>Main</code> 类的一个实例时，像 <code>a</code> 这样的基本类型实例变量会在堆内存的对象分配区域中为该特定对象分配空间，并存储其值。每个 <code>Main</code> 对象都会有自己的 <code>a</code> 变量副本，它们是相互独立的。</p>
<p>​		</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 基本数据类型的局部变量</span></span><br><span class="line">    <span class="type">Main</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>(); <span class="comment">// 在方法中创建一个对象实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>localVar</code> 是一个基本数据类型的局部变量，它存储在栈内存中。当 <code>myMethod</code> 方法被调用时，<code>localVar</code> 被创建并存储在方法的栈帧中。当 <code>myMethod</code> 方法执行完成后，<code>localVar</code> 会随着栈帧的销毁而销毁。</p>
<p><strong>基本数据类型的局部变量通常存储在栈内存中，而基本数据类型的实例变量（作为对象的一部分）存储在堆内存中。</strong></p>
<p>​		obj是new Main()所创建的对象的引用，对象的引用（通常是一个局部变量）会存储在栈内存中，这个对象及其实例变量会存储在堆内存中。</p>
<h4 id="怎么理解Java中的多态"><a href="#怎么理解Java中的多态" class="headerlink" title="怎么理解Java中的多态"></a>怎么理解Java中的多态</h4><p>​		用白话来说，就是多个对象调用同一个方法，得到不同的结果。</p>
<p><strong>方法重写（Override）：</strong> 子类可以覆盖（重写）父类的方法，实现自己特定的行为。父类引用可以指向子类对象，并且在运行时将调用子类的方法，这称为动态方法调度。这种多态性可以实现基于继承的多态。</p>
<p><strong>接口多态性：</strong> Java中，多个类可以实现同一个接口，然后使用接口类型的引用来引用这些不同的对象，从而实现接口多态性。这允许不同的类以统一的方式执行相同的接口定义的操作。</p>
<h4 id="什么是Java对象，不生成实例就不是对象吗"><a href="#什么是Java对象，不生成实例就不是对象吗" class="headerlink" title="什么是Java对象，不生成实例就不是对象吗"></a>什么是Java对象，不生成实例就不是对象吗</h4><p>​		如果没有生成实例，那么就没有对象。在 Java 中，对象是根据类创建的一个实例。类是一个蓝图，定义了对象的属性和行为。当使用 <code>new</code> 关键字和构造器来创建类的实例时，就创建了一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>person</code> 是一个指向 <code>Person</code> 对象的引用，这个对象有 <code>name</code> 和 <code>age</code> 这两个属性。</p>
<p>​		对象是类的具体实例，它们在内存中占用空间，并拥有实际的状态（属性值）和行为（方法）。在没有创建实例的情况下，只有类的定义，而没有实际的对象。</p>
<h4 id="java中的foreash和普通for循环对比"><a href="#java中的foreash和普通for循环对比" class="headerlink" title="java中的foreash和普通for循环对比"></a>java中的foreash和普通for循环对比</h4><p><strong>普通<code>for</code>循环</strong></p>
<p>普通<code>for</code>循环使用索引来访问元素，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javafor (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    // 访问元素 array[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遍历数组或<code>ArrayList</code>时，普通<code>for</code>循环通常会有更好的性能，因为它直接通过索引访问元素，这在内存中是连续的，因此访问速度快。但是，当遍历<code>LinkedList</code>时，普通<code>for</code>循环的性能会显著下降，因为每次通过索引访问元素都需要从链表头开始遍历，导致时间复杂度为O*(*n方)</p>
<p><strong><code>foreach</code>循环</strong></p>
<p><code>foreach</code>循环是基于迭代器的遍历方式，其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javafor (ElementType element : collection) &#123;</span><br><span class="line">    // 访问元素 element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foreach</code>循环在遍历<code>ArrayList</code>时与普通<code>for</code>循环性能相近，但在遍历<code>LinkedList</code>时性能要优于普通<code>for</code>循环，因为它使用迭代器按顺序访问元素，每次调用<code>next()</code>方法的时间复杂度为O*(1)，因此总的时间复杂度为O*(<em>n</em>)</p>
<p>性能比较</p>
<ul>
<li>对于数组或<code>ArrayList</code>，普通<code>for</code>循环通常比<code>foreach</code>循环快，尤其是在数据量较大时</li>
<li>对于<code>LinkedList</code>，<code>foreach</code>循环比普通<code>for</code>循环快得多，因为普通<code>for</code>循环需要从链表头开始遍历以访问每个元素，而<code>foreach</code>循环则不需要</li>
</ul>
<p>结论</p>
<ul>
<li>基于数组实现的集合，使用普通for循环遍历数据</li>
<li>基于链表实现的集合，使用增强型for循环遍历数据</li>
</ul>
<h4 id="Classloader-类加载机制"><a href="#Classloader-类加载机制" class="headerlink" title="Classloader 类加载机制"></a>Classloader 类加载机制</h4><h3 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h3><h4 id="泛型是什么，泛型擦除呢？"><a href="#泛型是什么，泛型擦除呢？" class="headerlink" title="泛型是什么，泛型擦除呢？"></a>泛型是什么，泛型擦除呢？</h4><p>在 Java 中，泛型用于在编译时提供类型检查并消除类型转换的需要。泛型让你可以编写更通用、更安全的代码，因为它们让你在类、接口和方法上定义类型参数。</p>
<p>例如，一个泛型类 <code>Box&lt;T&gt;</code> 可以存储任何类型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个类型参数，它可以在创建 <code>Box</code> 对象时被替换为任何类型，例如 <code>Integer</code>、<code>String</code> 等。</p>
<p><strong>泛型擦除</strong> (Type Erasure)</p>
<p>泛型擦除是 Java 泛型的一种实现机制。在编译时，泛型类型参数会被擦除，替换为它们的边界（如果有的话）或者 <code>Object</code>。这意味着在运行时，泛型信息是不可用的，所有泛型类型都被视为原始类型（raw types）。</p>
<p>例如，考虑以下泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>在编译时，泛型类型参数 <code>String</code> 会被擦除，因此在运行时，<code>list</code> 的类型实际上就是 <code>List</code>，而不是 <code>List&lt;String&gt;</code>。</p>
<p>泛型擦除的主要目的是为了确保 Java 泛型的向后兼容性。这意味着使用泛型的 Java 代码可以与不支持泛型的旧版 Java 代码互操作。</p>
<h4 id="List能否转为List"><a href="#List能否转为List" class="headerlink" title="List能否转为List"></a>List<String>能否转为List<Object></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br></pre></td></tr></table></figure>

<p>因此List<String>其实能够强转为List<Object>。但是存在隐患：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strs = (List)<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Object&gt; objects = (List)strs;</span><br><span class="line">objects.add(<span class="number">123</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码使用objects（List<Object> ）向集合中增加整型数据：123。然后通过 strs获取数据时，因为其类型为List<String>，但是真实数据类型为整型。此时就会发生运行时异常</p>
<h4 id="Java的泛型中super-和-extends-有什么区别？"><a href="#Java的泛型中super-和-extends-有什么区别？" class="headerlink" title="Java的泛型中super 和 extends 有什么区别？"></a>Java的泛型中super 和 extends 有什么区别？</h4><p>? extends T 为上界通配符，也就是说限制类型只能是T 或者 T 的派生类</p>
<p>? super T 为通配符下界，也就是说限制类型只能是T 或者T的超类。</p>
<p>生产使用extends，消费使用super。结合上下界的特点可知：<br>经常读取数据，使用Extends；<br>经常加入数据，使用Super；</p>
<h4 id="注解是什么？有哪些使用场景？"><a href="#注解是什么？有哪些使用场景？" class="headerlink" title="注解是什么？有哪些使用场景？"></a>注解是什么？有哪些使用场景？</h4><p>注解（Annotations）是 Java 提供的一种元数据形式，它允许在代码中添加信息，这些信息可以在编译时、类加载时或运行时被读取和处理。注解本身不会直接影响程序的操作，但它们可以被编译器或运行时环境用来生成额外的代码、执行额外的检查或者在运行时改变行为。</p>
<h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><h4 id="假如只有一个cpu，单核，多线程还有用吗-？"><a href="#假如只有一个cpu，单核，多线程还有用吗-？" class="headerlink" title="假如只有一个cpu，单核，多线程还有用吗 ？"></a>假如只有一个cpu，单核，多线程还有用吗 ？</h4><p>CPU的执行速度要远大于IO的过程，因此在大多数情况下增加一些复杂的CPU计算都比增加一次IO要快。单核CPU可以通过给每个线程分配CPU时间片（时间单元）来实现多线程机制。由于CPU频率很高，故时间单元非常短。所以单核也可以实现多线程机制。</p>
<h4 id="sychronied修饰普通方法和静态方法的区别？什么是可见性"><a href="#sychronied修饰普通方法和静态方法的区别？什么是可见性" class="headerlink" title="sychronied修饰普通方法和静态方法的区别？什么是可见性?"></a>sychronied修饰普通方法和静态方法的区别？什么是可见性?</h4><p>sychronied是Java中并发编程的重要关键字之一。在并发编程中synchronized一直是解决线程安全问<br>题，它可以保证原子性，可见性，以及有序性。</p>
<ul>
<li>原子性：原子是构成物质的基本单位，所以原子的意思代表着—“不可分”。由不可分可知，具有原<br>子性的操作也就是拒绝线程调度器中断。</li>
<li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到，称为可见性。</li>
<li>有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时会改变程序中语句的顺序，但是不会影响最终的结果。有序性经典的例子就是利用DCL双重检查创建单例对象。</li>
</ul>
<p>synchronized可以修饰方法，也能够使用 synchronized(obj){} 定义同步代码块。修饰方法：</p>
<ol>
<li>实例方法也就是普通方法，作用于当前实例加锁，进入方法前需要获取当前实例的锁;</li>
<li>静态方法，作用于当前类对象加锁，进入方法前需要获取当前类对象的锁;修饰代码块，指定加锁对象，对给定对象加锁，进入代码块前要获得给定对象的锁。</li>
</ol>
<h4 id="Synchronized在JDK1-6之后做了哪些优化"><a href="#Synchronized在JDK1-6之后做了哪些优化" class="headerlink" title="Synchronized在JDK1.6之后做了哪些优化"></a>Synchronized在JDK1.6之后做了哪些优化</h4><p>jdk1.6以后为了减少获得锁和释放锁带来的性能消耗，对synchronized锁进行了优化，引入了偏向锁、轻量级锁、重量级锁;</p>
<p><strong>Java对象头</strong></p>
<p>对象在虚拟机内存中的布局分为三块区域：对象头、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里。对象头由：存储对象自身的运行时数据的Mark Word 32位系统中4 + 指向类的指针 kClass pointer ,如果是数组对象还会有数组长度 Array Length。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<ul>
<li><p><strong>「偏向锁」</strong>：</p>
<p>当一个线程第一个访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。<strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
</li>
<li><p><strong>「轻量级锁」：</strong></p>
</li>
</ul>
<p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<ul>
<li><strong>「重量级锁」：</strong>这时候的主要操作就在monitor了</li>
</ul>
<p>膨胀过程：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将Contention List中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h4 id="CAS无锁编程的原理"><a href="#CAS无锁编程的原理" class="headerlink" title="CAS无锁编程的原理"></a>CAS无锁编程的原理</h4><p>无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<ol>
<li><p>在内存地址V当中，存储着值为10的变量</p>
</li>
<li><p>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11。</p>
</li>
<li><p>在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
</li>
<li><p>线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交<br>失败。因为线程2已经将内存地址V的变量值修改为了11</p>
</li>
<li><p>线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A&#x3D;11，B&#x3D;12。<br>这个重新尝试的过程被称为自旋。</p>
</li>
<li><p>这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相<br>等的。</p>
</li>
<li><p>线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
</li>
</ol>
<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>ABA问题：CAS 设计机制就是获取某两个时刻(初始预期值和当前内存值)变量值，并进行比较更新，所以说如果<strong>在获取初始预期值和当前内存值这段时间间隔内，变量值由 A 变为 B 再变为 A，那么对于 CAS 来说是不可感知的</strong>，但实际上变量已经发生了变化；解决办法是在每次获取时加版本号，并且每次更新对版本号 +1，这样当发生 ABA 问题时通过版本号可以得知变量被改动过。</p>
<h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><p>是一个用于构建锁和同步器的框架。它能降低构建锁和同步器的工作量，还可以避免处理多个位置上发生的竞争问题。在基于AQS构建的同步器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS支持独占锁（exclusive）和共享锁(share)两种模式。</p>
<ol>
<li>独占锁：只能被一个线程获取到(Reentrantlock)。</li>
<li>共享锁：可以被多个线程同时获取(CountDownLatch,ReadWriteLock)。</li>
</ol>
<blockquote>
<p>​	无论是独占锁还是共享锁，本质上都是对AQS内部的一个变量state的获取。state是一个原子的int变量，用来表示锁状态、资源数等</p>
</blockquote>
<p><strong>公平锁的实现</strong></p>
<p>在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，<strong>如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</strong>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大</p>
<p><strong>非公平锁的实现</strong></p>
<p><strong>直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</strong>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h4 id="Synchronized的原理以及与ReentrantLock的区别。"><a href="#Synchronized的原理以及与ReentrantLock的区别。" class="headerlink" title="Synchronized的原理以及与ReentrantLock的区别。"></a>Synchronized的原理以及与ReentrantLock的区别。</h4><p>Synchronized <strong>的原理</strong></p>
<p><code>synchronized</code> 是 Java 中的一个关键字，用于实现线程同步，保证多线线程访问共享资源时的线程安全。<code>synchronized</code> 可以用来修饰方法或代码块。</p>
<ul>
<li><strong>修饰方法</strong>：当一个线程访问某个对象的 synchronized 方法时，该线程会自动获取该对象的锁，其他线程如果也想访问这个对象的 synchronized 方法，就必须等待当前线程释放锁后才能继续执行。</li>
<li><strong>修饰代码块</strong>：可以指定加锁的对象，只有获取到指定对象的锁的线程才能执行这个代码块。</li>
</ul>
<p><code>synchronized</code> 的底层实现主要依赖于 JVM 中的 Monitor（监视器锁）。当一个线程进入 synchronized 修饰的方法或代码块时，它会自动获取 Monitor 的所有权，退出时自动释放 Monitor 的所有权。如果其他线程也想获取这个 Monitor 的所有权，就必须等待当前线程释放。</p>
<p><strong>ReentrantLock</strong></p>
<p><code>ReentrantLock</code> 是 Java 并发包 <code>java.util.concurrent.locks</code> 中的一个类，提供了比 <code>synchronized</code> 更加灵活的锁定机制。<code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，并提供了丰富的功能，如可中断的锁获取、公平锁、锁绑定多个条件等。</p>
<p><strong>Synchronized 与 ReentrantLock 的区别</strong></p>
<ol>
<li><strong>锁的实现方式</strong>：<code>synchronized</code> 是基于 JVM 实现的内置锁机制，而 <code>ReentrantLock</code> 是基于 Java 代码实现的。</li>
<li><strong>锁的获取和释放</strong>：<code>synchronized</code> 自动管理锁的获取和释放，而 <code>ReentrantLock</code> 需要手动获取和释放锁，通常使用 <code>try-finally</code> 语句块确保锁的释放。</li>
<li><strong>等待可中断</strong>：<code>ReentrantLock</code> 提供了一个可以响应中断的锁获取方法（<code>lockInterruptibly()</code>），而 <code>synchronized</code> 不具备这一特性。</li>
<li><strong>公平性</strong>：<code>ReentrantLock</code> 可以设置为公平锁，即按照线程请求锁的顺序来获取锁，而 <code>synchronized</code> 则不保证公平性。</li>
<li><strong>条件变量支持</strong>：<code>ReentrantLock</code> 提供了 <code>Condition</code> 类，支持更加灵活的线程间协调，相当于 Object 类的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法的高级版本。</li>
</ol>
<h4 id="volatile关键字干了什么？（什么叫指令重排）"><a href="#volatile关键字干了什么？（什么叫指令重排）" class="headerlink" title="volatile关键字干了什么？（什么叫指令重排）"></a>volatile关键字干了什么？（什么叫指令重排）</h4><p>volatile是java提供的可以声明在成员属性前的一个关键字。在声明中包含此关键字的作用有：<br><strong>保证内存可见性</strong><br>可见性是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量都从主内存中读，跳过CPU cache这一步。当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。</p>
<p><strong>禁止指令重排</strong></p>
<p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。</p>
<p>volatile变量禁止指令重排序。针对volatile修饰的变量，在读写操作指令前后会插入内存屏障，<strong>指令重排序时不能把后面的指令重排序到内存屏障之前，也不能把前面的指令重排序到内存屏障之后。</strong>这样确保了在一个线程修改了 <code>volatile</code> 变量的值后，其他线程能够看到这个修改。</p>
<p><strong>禁止指令重排的原理</strong><br>volatile关键字提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。<br>JVM内存屏障插入策略：<br>在每个volatile写操作的前面插入一个StoreStore屏障；<br>在每个volatile写操作的后面插入一个StoreLoad屏障；<br>在每个volatile读操作的后面插入一个LoadLoad屏障；<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<p>代码使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instance&#x3D; new Singleton()并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br><span class="line">instance =memory; <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面操作2依赖于操作1，但是操作3并不依赖于操作2。所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory =allocate(); <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">instance =memory; <span class="comment">//3：instance指向刚分配的内存地址，此时对象还未初始化</span></span><br><span class="line">ctorInstance(memory); <span class="comment">//2：初始化对象</span></span><br></pre></td></tr></table></figure>

<p>指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</p>
<p>优化后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton3</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();<span class="comment">// 非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile-能否保证线程安全？在DCL上的作用是什么？"><a href="#volatile-能否保证线程安全？在DCL上的作用是什么？" class="headerlink" title="volatile 能否保证线程安全？在DCL上的作用是什么？"></a>volatile 能否保证线程安全？在DCL上的作用是什么？</h4><p>volatile无法保证线程安全，只能保证变量的可见性，并不能保证变量操作的原子性。原子性指的是一个或者多个操作在 CPU 执行的过程中不被中断的特性。</p>
<p>因为volatile不能保证变量操作的原子性，所以试图通过volatile来保证线程安全性是不靠谱的。<br>volatile在DCL上的作用是防止对象发生指令重排而引起的异常问题。</p>
<h4 id="volatile和synchronize有什么区别？"><a href="#volatile和synchronize有什么区别？" class="headerlink" title="volatile和synchronize有什么区别？"></a>volatile和synchronize有什么区别？</h4><ul>
<li>volatile 只能作用于变量，synchronized 可以作用于变量、方法、对象。</li>
<li>volatile 只保证了可见性和有序性，无法保证原子性，synchronized 可以保证线程间的有序性（个人猜测是无法保证线程内的有序性，即线程内的代码可能被 CPU 指令重排序）、原子性和可见性。</li>
<li>volatile 线程不阻塞，synchronized 线程阻塞。</li>
<li>volatile 本质是告诉 jvm 当前变量在寄存器中的值是不安全的需要从内存中读取；sychronized 则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞。</li>
<li>volatile标记的变量不会被编译器优化， synchronized标记的变量可以被编译器优化</li>
</ul>
<h4 id="死锁的场景和解决方案"><a href="#死锁的场景和解决方案" class="headerlink" title="死锁的场景和解决方案"></a>死锁的场景和解决方案</h4><p><strong>死锁的定义</strong><br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<p>死锁的发生必须具备以下四个必要条件。</p>
<ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<h4 id="锁分哪几类？"><a href="#锁分哪几类？" class="headerlink" title="锁分哪几类？"></a>锁分哪几类？</h4><ul>
<li>乐观锁&#x2F;悲观锁</li>
</ul>
<blockquote>
<p>乐观锁：获取数据时认为不会被其他线程修改，所以不会上锁，但是在更新的时候会判断其他线程是否修改此数据，如果被其他线程修改，则会发生自旋。<br>悲观锁：总是假设最坏的情况，获取数据时都认为其他线程会修改，因此在获取数据时都会上锁，<br>这样保证其他线程需要等待获取锁的线程处理完成并且释放锁</p>
</blockquote>
<ul>
<li>独享锁&#x2F;共享锁</li>
</ul>
<blockquote>
<p>独享锁是指该锁一次只能被一个线程所持有。</p>
<p>共享锁是指该锁可被多个线程所持有。</p>
</blockquote>
<ul>
<li>互斥锁&#x2F;读写锁</li>
</ul>
<blockquote>
<p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</p>
<p>互斥锁在Java中的具体实现就是ReentrantLock。<br>读写锁在Java中的具体实现就是ReadWriteLock。</p>
</blockquote>
<ul>
<li>可重入锁</li>
</ul>
<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。synchronized与ReetrantLock都是可重入锁。可重入锁的一个好处就是可以在一定程度避免死锁。</p>
<p>就是同一个线程内一个加锁方法内部调用另一个加锁方法，内层方法会自动获取锁。</p>
<ul>
<li>公平锁&#x2F;非公平锁</li>
</ul>
<blockquote>
<p>公平锁是指多个线程按照申请锁的顺序获取锁，非公平锁则是指多个线程获取锁的顺序并不是按照申请<br>锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</p>
</blockquote>
<ul>
<li>分段锁</li>
</ul>
<blockquote>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁。</p>
</blockquote>
<ul>
<li>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</li>
</ul>
<blockquote>
<p>这三种锁是指锁的状态，偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。<br>降低获取锁的代价。<br>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通<br>过自旋的形式尝试获取锁，不会阻塞，提高性能。<br>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定<br>次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入<br>阻塞，性能降低。</p>
</blockquote>
<ul>
<li>自旋锁</li>
</ul>
<blockquote>
<p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好<br>处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
</blockquote>
<h4 id="Java多线程对同一个对象进行操作"><a href="#Java多线程对同一个对象进行操作" class="headerlink" title="Java多线程对同一个对象进行操作"></a>Java多线程对同一个对象进行操作</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> int tickets = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sellTicket()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟卖票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> synchronized boolean sellTicket() &#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tickets--;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出一张票，剩余票数：&quot;</span> + tickets);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 票已售罄！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSelling</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        TicketSeller ticketSeller = new TicketSeller();</span><br><span class="line">        Thread w1 = new Thread(ticketSeller, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread w2 = new Thread(ticketSeller, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread w3 = new Thread(ticketSeller, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        w1.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？"><a href="#线程生命周期，线程可以多次调用start吗？-会出现什么问题？-为什么不能多次调用start？" class="headerlink" title="线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？"></a>线程生命周期，线程可以多次调用start吗？ 会出现什么问题？ 为什么不能多次调用start？</h4><p>不能 会抛异常 start后由创建进入就绪状态，不可逆</p>
<h4 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h4><p>守护线程，也叫Daemon线程，它是一种支持型、服务型线程，主要被用作程序中后台调度以及支持性工作，跟上层业务逻辑基本不挂钩。Java中垃圾回收线程就是一个典型的Daemon线程。</p>
<p><strong>使用标志位退出线程</strong><br>正常情况下线程的run方法执行完之后就会正常退出，如果想要中断执行的话可以在线程执行run方法过程中，通过一个自定义变量来决定是否还需要退出线程，若满足条件，则退出线程，反之继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 定义标志位，使用volatile，保证内存可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopFlag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">				<span class="comment">// 循环打印运行日志</span></span><br><span class="line">                <span class="keyword">while</span> (!stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; isrunning&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 退出后，打印退出日志</span></span><br><span class="line">                <span class="keyword">if</span> (stopFlag) &#123;</span><br><span class="line">                    System.out.println(currentThread().getName() + <span class="string">&quot; is stop&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">		<span class="comment">// 让子线程执行100ms后，将stopFlag置为true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        stopFlag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？"><a href="#sleep-、wait、yield与join的区别，wait-的线程如何唤醒它？" class="headerlink" title="sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？"></a>sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？</h4><p>sleep、yield与join是线程方法，而wait则是Object方法：</p>
<ul>
<li>sleep ，释放cpu资源，不释放锁资源，如果线程进入sleep的话，释放cpu资源，如果外层包有Synchronize，那么此锁并没有释放掉。</li>
<li>wait，释放cpu资源，也释放锁资源，一般用于锁机制中 肯定是要释放掉锁的，因为notify并不会立即调起此线程，因此cpu是不会为其分配时间片的，也就是说wait 线程进入等待池，cpu不分时间片给它，锁释放掉。</li>
<li>yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li>
<li>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另<br>一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</li>
</ul>
<h4 id="sleep是可中断的么"><a href="#sleep是可中断的么" class="headerlink" title="sleep是可中断的么"></a>sleep是可中断的么</h4><p>sleep是可中断的</p>
<h4 id="怎么保证线程按顺序执行？如何实现线程排队"><a href="#怎么保证线程按顺序执行？如何实现线程排队" class="headerlink" title="怎么保证线程按顺序执行？如何实现线程排队 ?"></a>怎么保证线程按顺序执行？如何实现线程排队 ?</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>, <span class="keyword">private</span> <span class="keyword">val</span> nextLetter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (currentLetter != letter) &#123;</span><br><span class="line">                    (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).wait()</span><br><span class="line">                &#125;</span><br><span class="line">                print(letter)</span><br><span class="line">                currentLetter = nextLetter</span><br><span class="line">                (<span class="keyword">this</span> <span class="keyword">as</span> java.lang.Object).notifyAll()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = PrintABC(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> b = PrintABC(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    <span class="keyword">val</span> c = PrintABC(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> threadA = Thread(a)</span><br><span class="line">    <span class="keyword">val</span> threadB = Thread(b)</span><br><span class="line">    <span class="keyword">val</span> threadC = Thread(c)</span><br><span class="line"></span><br><span class="line">    threadA.start()</span><br><span class="line">    threadB.start()</span><br><span class="line">    threadC.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kotlin协程实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.Mutex</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.sync.withLock</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">printLetter</span><span class="params">(lock: <span class="type">Mutex</span>, condition: <span class="type">Condition</span>, letter: <span class="type">Char</span>)</span></span> &#123;</span><br><span class="line">    lock.withLock &#123;</span><br><span class="line">        <span class="keyword">while</span> (PrintABC.currentLetter != letter) &#123;</span><br><span class="line">            condition.await()</span><br><span class="line">        &#125;</span><br><span class="line">        print(letter)</span><br><span class="line">        PrintABC.currentLetter = <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">            <span class="string">&#x27;A&#x27;</span> -&gt; <span class="string">&#x27;B&#x27;</span></span><br><span class="line">            <span class="string">&#x27;B&#x27;</span> -&gt; <span class="string">&#x27;C&#x27;</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="string">&#x27;A&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        condition.signal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintABC</span>(<span class="keyword">private</span> <span class="keyword">val</span> lock: Mutex, <span class="keyword">private</span> <span class="keyword">val</span> conditionA: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionB: Condition, <span class="keyword">private</span> <span class="keyword">val</span> conditionC: Condition, <span class="keyword">private</span> <span class="keyword">val</span> letter: <span class="built_in">Char</span>) : Runnable &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">var</span> currentLetter = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        repeat(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (letter) &#123;</span><br><span class="line">                <span class="string">&#x27;A&#x27;</span> -&gt; printLetter(lock, conditionA, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;B&#x27;</span> -&gt; printLetter(lock, conditionB, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                <span class="string">&#x27;C&#x27;</span> -&gt; printLetter(lock, conditionC, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> lock = Mutex()</span><br><span class="line">    <span class="keyword">val</span> conditionA = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionB = Condition(lock)</span><br><span class="line">    <span class="keyword">val</span> conditionC = Condition(lock)</span><br><span class="line"></span><br><span class="line">    launch &#123; PrintABC(lock, conditionA, conditionB, conditionC, <span class="string">&#x27;A&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionB, conditionA, conditionC, <span class="string">&#x27;B&#x27;</span>).run() &#125;</span><br><span class="line">    launch &#123; PrintABC(lock, conditionC, conditionA, conditionB, <span class="string">&#x27;C&#x27;</span>).run() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="非阻塞式生产者消费者如何实现"><a href="#非阻塞式生产者消费者如何实现" class="headerlink" title="非阻塞式生产者消费者如何实现"></a>非阻塞式生产者消费者如何实现</h4><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>七大参数</p>
<ol>
<li>corePoolSize<br>线程池中的常驻核心线程数</li>
<li>maximumPoolSize<br>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</li>
<li>keepAliveTime<br>空闲线程的存活时间。</li>
<li>unit<br>keepAliveTime的单位</li>
<li>workQueue<br>任务队列，被提交但尚未被执行的任务</li>
<li>threadFactory<br>表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可</li>
<li>handler：<br>拒绝策略，表示当队列满了并且工作线程大于等于线程池最大线程数（maximumPoolSize）时如<br>何处理</li>
</ol>
<p>使用JDK中自带的线程池可以通过创建ThreadPoolExecutor线程池对象，也能够通过Executors中定义的静态方法。其中Executors静态方法创建的线程池主要有以下类型：</p>
<p>1.newSingleThreadExecutor<br>        创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)<br>适用：一个任务一个任务执行的场景<br>2.newCachedThreadPool<br>        当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。<br>适用:执行很多短期异步的场景</p>
<p>3.newFixedThreadPool<br>        创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)，但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。<br>适用:长期执行的场景</p>
<p>4.NewScheduledThreadPool</p>
<p>​		创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构<br>适用:周期性执行的场景</p>
<h4 id="如何开启一个线程，开启大量线程会有什么问题，如何优化？"><a href="#如何开启一个线程，开启大量线程会有什么问题，如何优化？" class="headerlink" title="如何开启一个线程，开启大量线程会有什么问题，如何优化？"></a>如何开启一个线程，开启大量线程会有什么问题，如何优化？</h4><p>开启线程的方式：</p>
<p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyThread run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口，并实现内部run方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test MyRunnable run&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程内存<br>在Java中每个线程需要分配线程内存，用来存储自身的线程变量。在JDK 1.4中每个线程是256K的内存，<br>在JDK 1.5之后每个线程是1M的内存。</p>
<h4 id="HandlerThread是什么？"><a href="#HandlerThread是什么？" class="headerlink" title="HandlerThread是什么？"></a>HandlerThread是什么？</h4><p><strong>HandlerThread 是一个特殊的线程类，它内部拥有一个 Looper 对象，使得它可以拥有自己的消息循环。这使得 HandlerThread 能够像主线程一样处理消息和任务，非常适合用于需要执行多个任务或频繁操作数据库、文件和网络的场景。</strong></p>
<p><strong>使用场景：</strong> 与普通的 Thread 相比，HandlerThread 的优势在于它可以重复使用来执行多个任务，而不需要每次都创建新的线程。这不仅减少了资源消耗，还可以简化代码，因为你可以通过向 HandlerThread 的 Handler 发送消息来排队执行任务，而不需要手动管理线程的生命周期。这使得 HandlerThread 成为在后台线程中执行串行任务的理想选择。</p>
<h4 id="AsyncTask的原理"><a href="#AsyncTask的原理" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><p><code>AsyncTask</code> 是 Android 中用于简化异步操作的一个抽象类。它允许你在后台线程中执行长时间运行的操作，然后在主线程中更新 UI。</p>
<p><code>AsyncTask</code> 是 Android 中用于简化异步操作的一个抽象类。它允许你在后台线程中执行长时间运行的操作，然后在主线程中更新 UI。<code>AsyncTask</code> 的工作原理大致如下：</p>
<ol>
<li><strong>执行任务</strong>：当你创建一个 <code>AsyncTask</code> 的子类并调用 <code>execute()</code> 方法时，**<code>AsyncTask</code> 会在内部使用线程池（<code>Executor</code>）来启动一个新的线程。**</li>
<li><strong>后台处理</strong>：在新线程中，<code>doInBackground(Params...)</code> 方法会被调用。这是你执行长时间运行操作的地方，例如网络请求、数据库操作等。这个方法运行在后台线程中，所以它不会阻塞主线程。</li>
<li><strong>进度更新</strong>：如果你需要在任务执行过程中更新 UI（例如显示进度条），你可以在 <code>doInBackground()</code> 方法中调用 <code>publishProgress(Progress...)</code> 方法。这将触发 <code>onProgressUpdate(Progress...)</code> 方法的调用，该方法运行在主线程中，可以安全地更新 UI。</li>
<li><strong>任务完成</strong>：当 <code>doInBackground()</code> 方法完成后，返回的结果会被传递给 <code>onPostExecute(Result)</code> 方法。这个方法也运行在主线程中，你可以在这里更新 UI 或进行其他操作，以响应任务的完成。</li>
</ol>
<p><code>AsyncTask</code> 的一个重要特点是它提供了一种机制，使得在不同线程中执行的代码能够安全地与 UI 交互。</p>
<p>AsyncTask中的任务在4.0以上是串行执行的，在 AsyncTask 中提交的任务默认都会通过：</p>
<h4 id="Android中操作多线程的方式有哪些？"><a href="#Android中操作多线程的方式有哪些？" class="headerlink" title="Android中操作多线程的方式有哪些？"></a>Android中操作多线程的方式有哪些？</h4><p>常见的实现多线程的手段有五种：<br>第一种：Thread，Runnable<br>第二种：HandlerThread<br>第三种：AsyncTask<br>第四种：Executor<br>第五种：IntentService</p>
<h4 id="Android开发中怎样判断当前线程是否是主线程"><a href="#Android开发中怎样判断当前线程是否是主线程" class="headerlink" title="Android开发中怎样判断当前线程是否是主线程"></a>Android开发中怎样判断当前线程是否是主线程</h4><p>Android开发中, 有时需要判断当前线程到底是主线程, 还是子线程, 例如: 我们在自定义View时, 想要让View重绘, 需要先判断当前线程到底是不是主线程, 然后根据判断结果来决定到底是调用 invalidate()还是 postInvalidate() 方法。<br>在工作中获取当前的主线程，主要是借助Android中的Looper：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">Looper.getMainLooper().getThread() == Thread.currentThread();</span><br><span class="line">Looper.getMainLooper().getThread().getId() == Thread.currentThread().getId();</span><br></pre></td></tr></table></figure>

<h4 id="线程间如何通信？"><a href="#线程间如何通信？" class="headerlink" title="线程间如何通信？"></a>线程间如何通信？</h4><p>Handler</p>
<h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><h4 id="LinkedHashMap的数据结构"><a href="#LinkedHashMap的数据结构" class="headerlink" title="LinkedHashMap的数据结构"></a>LinkedHashMap的数据结构</h4><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403042110717.png" alt="LinkedHashMap 逻辑结构"></p>
<p>​		其中的head节点和tail节点就像两个对链表操作的指针，不断的按照顺序移动。head节点和tail节点是额外的专门用来标志头尾的节点。</p>
<p><a href="https://javaguide.cn/java/collection/linkedhashmap-source-code.html">LinkedHashMap 源码分析</a></p>
<h4 id="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"><a href="#Set底层存放怎么数据，是有序的还是无序的，可以重复吗" class="headerlink" title="Set底层存放怎么数据，是有序的还是无序的，可以重复吗"></a>Set底层存放怎么数据，是有序的还是无序的，可以重复吗</h4><p>Set只是一个接口，其实现类有HashSet无序，TreeSet有序，不过都不允许有重复元素</p>
<p>Set集合不允许存储重复元素的实现原理主要依赖于其底层数据结构的特性。在Java中，Set接口的常用实现类如HashSet和TreeSet，分别使用哈希表和红黑树作为底层数据结构。</p>
<p>HashSet</p>
<p>HashSet是基于HashMap实现的。当向HashSet中添加元素时，HashSet会首先计算元素的hashCode值，然后根据这个hashCode值来找到在哈希表中的存储位置。如果该位置没有元素，则直接存储；如果该位置已经有元素存在，则通过equals方法来检查两个元素是否相等。如果equals方法返回true，表明两个元素相同，新元素就不会被添加到集合中。如果equals方法返回false，表明两个元素不同，新元素会被添加到集合中，这可能会导致哈希冲突，并通过链表或红黑树解决冲突</p>
<p>TreeSet</p>
<p>TreeSet是基于TreeMap实现的，TreeMap是一种红黑树结构。在TreeSet中，元素在插入时会进行排序，排序依据是元素的compareTo方法（如果元素实现了Comparable接口）或者Comparator比较器（如果在TreeSet的构造器中提供了Comparator）。如果两个元素通过compareTo或Comparator比较结果为0，表明两个元素相同，新元素就不会被添加到集合中</p>
<p>总结</p>
<p>无论是HashSet还是TreeSet，它们都不允许存储重复元素。这是通过元素的hashCode和equals方法（对于HashSet）或者compareTo方法（对于TreeSet）来实现的。当添加一个新元素时，这些方法被用来检查新元素是否与集合中已存在的元素相同。如果相同，则新元素不会被添加，从而保证了集合中元素的唯一性</p>
<h4 id="ConcurrentHashMap如何保证线程安全"><a href="#ConcurrentHashMap如何保证线程安全" class="headerlink" title="ConcurrentHashMap如何保证线程安全"></a>ConcurrentHashMap如何保证线程安全</h4><p>​		ConcurrentHashMap 使用 Node 数组加链表加红黑树的数据结构。在并发操作时使用synchronized锁住了链表的头节点或红黑树的根节点</p>
<h4 id="ConcurrentHashMap去get元素的时候有加锁吗？"><a href="#ConcurrentHashMap去get元素的时候有加锁吗？" class="headerlink" title="ConcurrentHashMap去get元素的时候有加锁吗？"></a>ConcurrentHashMap去get元素的时候有加锁吗？</h4><p>​		get元素没加锁，增删改查四个种类操作之后查一类的操作没有加锁</p>
<h4 id="Object-finalize了解吗，只要有GC就会调用吗？"><a href="#Object-finalize了解吗，只要有GC就会调用吗？" class="headerlink" title="Object finalize了解吗，只要有GC就会调用吗？"></a>Object finalize了解吗，只要有GC就会调用吗？</h4><p>​		<code>finalize()</code>方法的主要目的是在对象从内存中删除之前释放对象使用的资源。</p>
<p>​		<code>finalize()</code>方法在特定对象的垃圾回收之前被调用，<strong>当垃圾回收器确定不存在对该对象的更多引用时</strong>，对象的垃圾回收器就会调用这个方法。</p>
<p><a href="https://zhuanlan.zhihu.com/p/551713593">https://zhuanlan.zhihu.com/p/551713593</a></p>
<h4 id="Object-notify了解吗，自己平时写代码有用过吗？"><a href="#Object-notify了解吗，自己平时写代码有用过吗？" class="headerlink" title="Object notify了解吗，自己平时写代码有用过吗？"></a>Object notify了解吗，自己平时写代码有用过吗？</h4><p>Java Object 中的 wait() 和 <a href="https://so.csdn.net/so/search?q=notify&spm=1001.2101.3001.7020">notify</a>() 方法和synchronized 实现多线程的同步等待。</p>
<p><a href="https://blog.csdn.net/qq_22076345/article/details/107881591">https://blog.csdn.net/qq_22076345/article/details/107881591</a></p>
<h4 id="反射性能耗在哪里？"><a href="#反射性能耗在哪里？" class="headerlink" title="反射性能耗在哪里？"></a>反射性能耗在哪里？</h4><p><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html">https://pdai.tech/md/java/basic/java-basic-x-reflection.html</a></p>
<h4 id="new-String-内存优化"><a href="#new-String-内存优化" class="headerlink" title="new String()内存优化"></a>new String()内存优化</h4><ol>
<li><strong>直接使用字符串字面量</strong>：在Java中，字符串字面量（如<code>String s = &quot;example&quot;;</code>）会自动被存储在字符串池中。如果你试图创建一个已经在字符串池中存在的字符串，Java会直接返回对现有字符串的引用，而不会创建新的对象。这样可以节省内存。</li>
<li><strong>使用<code>String.intern()</code>方法</strong>：<code>String.intern()</code>方法会返回字符串对象在字符串池中的引用。如果字符串池中已经存在相同的字符串，<code>intern()</code>方法会返回现有字符串的引用；如果字符串池中不存在该字符串，<code>intern()</code>方法会将该字符串添加到字符串池中，然后返回新添加的字符串的引用。</li>
<li><strong>避免使用<code>+</code>操作符进行字符串拼接</strong>：在Java中，使用<code>+</code>操作符进行字符串拼接会在每次拼接时创建新的字符串对象。这可能会导致大量的内存浪费。为了避免这个问题，你可以使用<code>StringBuilder</code>或<code>StringBuffer</code>进行字符串拼接。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Retrofit</title>
    <url>/2024/03/26/Retrofit/</url>
    <content><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="retroft-是如何简化链路的"><a href="#retroft-是如何简化链路的" class="headerlink" title="retroft 是如何简化链路的"></a>retroft 是如何简化链路的</h4><h4 id="retroft-的注解是什么时期解析"><a href="#retroft-的注解是什么时期解析" class="headerlink" title="retroft 的注解是什么时期解析"></a>retroft 的注解是什么时期解析</h4><p>​		Retrofit 的注解是在<strong>运行时</strong>解析的。当创建一个 Retrofit 实例并通过它创建 API 接口的动态代理对象时，Retrofit 会解析接口中定义的所有注解。这包括请求方法的注解（如 <code>@GET</code>、<code>@POST</code> 等），参数的注解（如 <code>@Path</code>、<code>@Query</code> 等），以及其他用于配置请求和响应处理的注解。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> apiService = retrofit.create(MyApiService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>



<h4 id="retroft用到的设计模式"><a href="#retroft用到的设计模式" class="headerlink" title="retroft用到的设计模式"></a>retroft用到的设计模式</h4><p><a href="https://juejin.cn/post/6879326343667023879">Retrofit中的设计模式</a></p>
<h4 id="Retrofit-动态代理具体做了什么"><a href="#Retrofit-动态代理具体做了什么" class="headerlink" title="Retrofit 动态代理具体做了什么"></a>Retrofit 动态代理具体做了什么</h4><p><a href="https://juejin.cn/post/6844903744954433544#heading-6">Java 动态代理详解</a></p>
<ol>
<li>解析接口方法的注解</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;users/&#123;user&#125;/repos&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">listRepos</span><span class="params">(<span class="meta">@Path(<span class="string">&quot;user&quot;</span>)</span> user: <span class="type">String</span>)</span></span>: Call&lt;List&lt;Repo&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		在这个例子中，<code>MyApiService</code> 接口定义了一个方法 <code>listRepos</code>，使用 <code>@GET</code> 注解指定了请求的类型和路径，使用 <code>@Path</code> 注解指定了路径参数。</p>
<ol start="2">
<li>创建动态代理对象</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> apiService = retrofit.create(MyApiService::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p>​		使用 <code>Retrofit.Builder</code> 来构建一个 <code>Retrofit</code> 实例，并通过 <code>create</code> 方法创建 <code>MyApiService</code> 接口的动态代理对象。</p>
<ol start="3">
<li>拦截接口方法调用</li>
</ol>
<p>​		当你调用 <code>apiService.listRepos(&quot;octocat&quot;)</code> 时，实际上是在调用动态代理对象的 <code>listRepos</code> 方法。这个方法调用会被拦截，Retrofit 会根据注解和传入的参数构造一个 HTTP GET 请求到 <code>https://api.github.com/users/octocat/repos</code>。</p>
<ol start="4">
<li>发送请求并处理响应</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">apiService.listRepos(<span class="string">&quot;octocat&quot;</span>).enqueue(<span class="keyword">object</span> : Callback&lt;List&lt;Repo&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">Repo</span>&gt;&gt;, response: <span class="type">Response</span>&lt;<span class="type">List</span>&lt;<span class="type">Repo</span>&gt;&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">            <span class="keyword">val</span> repos = response.body()</span><br><span class="line">            <span class="comment">// 处理响应数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理错误响应</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">List</span>&lt;<span class="type">Repo</span>&gt;&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 处理网络错误等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​		在这个例子中，<code>enqueue</code> 方法用于异步发送请求，并使用 <code>Callback</code> 接口来处理响应或错误。</p>
<ol start="5">
<li>错误处理</li>
</ol>
<p>​		错误处理已经在上一步的 <code>onResponse</code> 和 <code>onFailure</code> 方法中展示。如果响应不成功（<code>response.isSuccessful</code> 为 <code>false</code>），可以在 <code>onResponse</code> 方法中处理错误响应。如果发生网络错误等，可以在 <code>onFailure</code> 方法中处理。</p>
<h4 id="Retrofit-动态代理解析"><a href="#Retrofit-动态代理解析" class="headerlink" title="Retrofit 动态代理解析"></a>Retrofit 动态代理解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">    <span class="comment">// 验证提供的接口是否符合要求（比如是否为接口，是否包含正确的注解等）</span></span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Java 动态代理创建接口的实现</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            service.getClassLoader(), <span class="comment">// 使用接口的类加载器</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;service&#125;, <span class="comment">// 创建代理对象要实现的接口列表</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123; <span class="comment">// 处理接口方法调用的处理器</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get(); <span class="comment">// 获取当前平台（用于兼容性处理）</span></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]; <span class="comment">// 用于没有参数的方法调用</span></span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="meta">@Nullable</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">                    <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="comment">// 如果调用的是 Object 类的方法，则直接调用（比如 hashCode、equals、toString）</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理参数，确保不为 null</span></span><br><span class="line">                    args = args != <span class="literal">null</span> ? args : emptyArgs;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果是接口默认方法，则使用平台特定的方式调用</span></span><br><span class="line">                    <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                        ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                        : loadServiceMethod(method).invoke(args); <span class="comment">// 调用 Retrofit 的服务方法（处理网络请求等）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		理论上动态代理是为了通过自动生成代理对象在运行时控制要代理的对象的访问，JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// proxy: 代理对象，即动态生成的代理类的实例</span></span><br><span class="line">    	<span class="comment">// method: 正在被调用的方法</span></span><br><span class="line">    	<span class="comment">// args: 调用方法时传递的参数</span></span><br><span class="line"></span><br><span class="line">    	before();  <span class="comment">// 调用目标方法前的处理，例如日志记录、权限检查等</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 调用目标对象（target）的方法（method），并传递参数（args）</span></span><br><span class="line">    	<span class="comment">// target 是实际对象，代理对象是通过它来间接访问目标对象的方法</span></span><br><span class="line">    	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">    	after();  <span class="comment">// 调用目标方法后的处理，例如日志记录、资源释放等</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code> 是两个核心类，它们的作用如下：</p>
<ol>
<li><code>java.lang.reflect.Proxy</code></li>
</ol>
<p><code>Proxy</code> 类是动态代理类的超类，它提供了用于创建动态代理类和实例的静态方法。主要方法包括：</p>
<ul>
<li><code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>: 这是创建动态代理实例最常用的方法。它需要三个参数：类加载器（用于加载代理类）、接口数组（代理类需要实现的接口列表）、调用处理器（用于处理方法调用的对象）。这个方法返回一个实现了指定接口的代理实例。</li>
</ul>
<ol start="2">
<li><code>java.lang.reflect.InvocationHandler</code></li>
</ol>
<p><code>InvocationHandler</code> 是一个接口，它定义了一个方法 <code>invoke(Object proxy, Method method, Object[] args)</code>。在使用动态代理时，你需要实现这个接口，并提供 <code>invoke</code> 方法的实现，这个方法会在代理实例上的方法被调用时执行。</p>
<ul>
<li><code>invoke(Object proxy, Method method, Object[] args)</code>: 这个方法有三个参数：<code>proxy</code> 是动态代理实例本身，<code>method</code> 是被调用的方法，<code>args</code> 是调用方法时传递的参数。在这个方法的实现中，你可以定义在方法调用前后要执行的逻辑，比如日志记录、权限检查等。你还可以使用 <code>method.invoke(target, args)</code> 来调用目标对象的实际方法。</li>
</ul>
<p>总的来说，<code>Proxy</code> 类用于创建动态代理实例，而 <code>InvocationHandler</code> 接口用于定义代理实例上方法调用的处理逻辑。通过这两个类的配合使用，可以在运行时动态地创建代理对象并处理其方法调用，而无需手动编写代理类的代码。</p>
<p>​		但是在Retrofit中使用动态代理获取到api接口中的方法和方法的参数，然后解析注解拼装成一个HttpServiceMethod对象，然后调用这个对象的invoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> ReturnT <span class="title function_">invoke</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​		loadServiceMethod(method)方法解析注解拼装成一个HttpServiceMethod对象，等于替代了原生OkHttp拼装url，参数以及返回值解析等大量的重复代码工作</p>
<p>​		外部一旦调用了接口方法，例如request.getData();，就会触发InvocationHandler的invoke，从而根据注解生成Retrofit的ServiceMethod和OkHttpCall对象，这些都是发起网络请求的必备信息，然后最终发起请求。</p>
<h4 id="Retrofit大致流程"><a href="#Retrofit大致流程" class="headerlink" title="Retrofit大致流程"></a>Retrofit大致流程</h4><p>Retrofit中一次完整的流程包括以下几个步骤：</p>
<ol>
<li>Retrofit的创建，可以配置OkhttpClient、CallAdapter适配器、Converter转换器等。</li>
<li>调用create方法动态生成代理类发起网络请求，内部会调用到<code>loadServiceMethod</code>方法获取一个<code>ServiceMethod</code>对象。</li>
<li>经过<code>ServiceMethod</code>的<code>parseAnnotations</code>来解析请求方法的注解、参数注解、返回类型等数据传递给<code>HttpServiceMethod</code>.</li>
<li><code>HttpServiceMethod</code>中会根据method、返回类型、注解等获取<code>CallAdapter</code>和<code>Conveter</code>实现类，并返回一个<code>CallAdapted</code>对象。</li>
<li>回调<code>CallAdapted</code>的<code>invoke</code>方法，获取网络请求的封装类<code>OkHttpCall</code>对象。</li>
<li><code>OkHttpCall</code>对象会传递给<code>CallAdapter</code>对象来发起网络请求，并在<code>OkHttpCall</code>中调用<code>Conveter</code>解析响应。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403202342581.png" alt="img"></p>
<p><a href="https://juejin.cn/post/6930871831180083207">Retrofit流程解析</a></p>
<p><a href="http://www.notex.cc/2023-03-23/retrofit/">Retrofit 实现原理解析</a></p>
<h4 id="CallAdapter和Conveter的作用"><a href="#CallAdapter和Conveter的作用" class="headerlink" title="CallAdapter和Conveter的作用"></a><code>CallAdapter</code>和<code>Conveter</code>的作用</h4><p>​		在 Retrofit 中，<code>CallAdapter</code> 和 <code>Converter</code> 是两个用于定制网络请求和响应处理行为的重要组件。它们的实现类分别用于适配不同的调用方式和转换不同的数据格式。</p>
<p>CallAdapter</p>
<p>​		<code>CallAdapter</code> 负责将 <code>Call</code> 类型的响应适配成其他类型，比如 <code>Observable</code>、<code>Future</code> 或自定义类型。这允许你使用不同的异步机制来处理网络请求。</p>
<ul>
<li><strong>作用</strong>：<code>CallAdapter</code> 的作用是将 Retrofit 的 <code>Call</code> 对象转换成其他类型，从而支持不同的异步处理模式。</li>
<li><strong>示例</strong>：例如，如果你想在 Retrofit 中使用 RxJava 来处理异步请求，你可以使用 <code>RxJavaCallAdapterFactory</code> 作为 <code>CallAdapter</code> 的实现类。这样，API 接口方法就可以返回 <code>Observable</code>、<code>Single</code> 或其他 RxJava 类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>Converter</p>
<p>​		<code>Converter</code> 负责请求和响应的数据转换。它将 HTTP 请求体转换为特定格式的数据（比如 JSON、XML），并将响应体转换为 Java 对象。</p>
<ul>
<li><strong>作用</strong>：<code>Converter</code> 的作用是将 Java 对象与请求体或响应体之间进行转换，支持不同的数据格式和序列化库。</li>
<li><strong>示例</strong>：例如，如果你的 API 交互使用 JSON 格式，你可以使用 <code>GsonConverterFactory</code> 作为 <code>Converter</code> 的实现类。这样，Retrofit 就会使用 Gson 库来序列化请求参数为 JSON，并将响应 JSON 反序列化为 Java 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>​		总之，<code>CallAdapter</code> 和 <code>Converter</code> 的实现类在 Retrofit 中起着至关重要的作用，它们使得 Retrofit 能够灵活地适配不同的调用方式和数据格式，满足不同场景下的网络请求需求。</p>
]]></content>
  </entry>
  <entry>
    <title>kotlin面试题</title>
    <url>/2024/03/08/Kotlin%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="介绍一下kotlin的标准函数"><a href="#介绍一下kotlin的标准函数" class="headerlink" title="介绍一下kotlin的标准函数"></a>介绍一下kotlin的标准函数</h4><ul>
<li><p>下面是常用的四个标准函数，还有takeIf，takeUnless等等。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image.png" alt="image"></p>
</li>
</ul>
<p>作用：</p>
<ol>
<li><strong>可读性</strong>：标准库函数提供的功能可以用更简洁和具有描述性的方式来表达，这也使得代码更加易于理解和阅读。</li>
<li><strong>更少的样板代码</strong>：由于标准库函数将常见的操作封装在函数内部，因此，开发人员可以通过单行代码完成许多任务，这减少了样板代码的数量，并统一了代码的格式</li>
</ol>
<h4 id="分别应用于哪些场景？"><a href="#分别应用于哪些场景？" class="headerlink" title="分别应用于哪些场景？"></a><strong>分别应用于哪些场景？</strong></h4><ul>
<li><code>let</code> 和 <code>run</code> 通常用于需要对对象执行某些操作并返回结果的场景。</li>
<li><code>with</code> 适用于希望在一个特定对象上执行多个操作的场景。</li>
<li><code>also</code> 通常用于需要对对象进行链式操作并返回对象本身的场景。</li>
<li><code>apply</code> 适用于需要在对象上执行多个操作并返回对象本身的场景</li>
</ul>
<h4 id="kotlin的高级特性有哪些"><a href="#kotlin的高级特性有哪些" class="headerlink" title="kotlin的高级特性有哪些"></a>kotlin的高级特性有哪些</h4><ol>
<li><strong>Null安全</strong>：Kotlin通过内建的null安全支持来消除代码中的NullPointException。</li>
<li><strong>扩展函数</strong>：在Kotlin中，你可以为一个已存在的类添加新的函数，而不需要修改这个类的源代码。这就是扩展函数。</li>
<li><strong>默认参数和命名参数</strong>：Kotlin函数可以有默认参数值，这使得函数更加灵活。</li>
<li><strong>数据类</strong>：只需一个简单的<code>data</code>关键字，Kotlin就会为你生成equals() &#x2F; hashCode() &#x2F; toString()等通用的方法。</li>
<li><strong>Lambda表达式及高阶函数</strong>：Kotlin全面支持函数式编程，包括匿名函数，lambda表达式以及闭包。高阶函数是接受函数作为参数或返回函数的函数。</li>
<li><strong>协程</strong>：本质上，协程是轻量级的线程。它们在某些类似并发的情况下，可以替代线程，可以在一般情况下，可以以更少的开销和更少的复杂性来提供并发性。</li>
<li><strong>类型推断</strong>：Kotlin具有强大的类型推断能力，且语法简洁。这让我们能够写出简洁且类型安全的代码。</li>
<li><strong>集合操作符</strong>：对集合进行操作是日常任务的一部分，Kotlin提供了丰富的集合操作符（包括过滤、映射、归约等）。</li>
<li><strong>操作符重载</strong>：Kotlin允许你为自己的类型提供自定义的操作符。</li>
</ol>
<h4 id="suspend关键字怎么理解"><a href="#suspend关键字怎么理解" class="headerlink" title="suspend关键字怎么理解"></a>suspend关键字怎么理解</h4><p>​		标记一个函数为挂起函数。这种函数可以暂停执行当前的协程，并保存所有局部变量。</p>
<h4 id="使用协程的场景有哪些"><a href="#使用协程的场景有哪些" class="headerlink" title="使用协程的场景有哪些"></a>使用协程的场景有哪些</h4><ol>
<li><p><strong>异步任务</strong>：当任务需要在后台运行，而主线程需要保持空闲以维护UI响应时，这是使用协程的一个主要场景。比如，在Android开发中，网络请求、数据库查询等I&#x2F;O操作是最常使用协程进行异步操作的例子。</p>
</li>
<li><p><strong>并发执行多个任务</strong>：如果你需要同时执行多个任务，并且在所有任务完成后收集结果，那么协程的并发执行功能将非常有用。</p>
<p>在 Android 平台上协程主要就用来解决两个问题：</p>
<ol>
<li>处理耗时任务 (Long running tasks)，这种任务常常会阻塞主线程</li>
<li>保证主线程安全 (Main-safety)，即确保安全地从主线程调用任何 suspend 函数</li>
</ol>
</li>
</ol>
<h4 id="如何取消一个协程"><a href="#如何取消一个协程" class="headerlink" title="如何取消一个协程"></a>如何取消一个协程</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会返回一个Job对象，然后调用它的cancel方法可以取消作用域及其所有子协程。</p>
<h4 id="协程嵌套，子协程出现异常，协程会被取消吗"><a href="#协程嵌套，子协程出现异常，协程会被取消吗" class="headerlink" title="协程嵌套，子协程出现异常，协程会被取消吗"></a>协程嵌套，子协程出现异常，协程会被取消吗</h4><p>​		在Kotlin协程中，异常会自动向上传播，如果一个子协程抛出了异常，那么这个异常会被传递给它的父协程，如果父协程没有处理这个异常，那么这个异常会继续向上传递，直到被一个协程处理，或者传递到了顶层协程，导致整个协程作用域被取消。</p>
<p>解决方案：</p>
<p>使用SupervisorJob</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> supervisorJob = SupervisorJob()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main + supervisorJob)</span><br><span class="line"></span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用supervisorScope</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用async和await</p>
<p>​		子协程使用了<code>async</code>构建器，那么它会捕获所有的异常，并将这些异常封装在<code>Deferred</code>对象中，只有在调用<code>await</code>方法时，这些异常才会被抛出。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchMultipleData</span><span class="params">()</span></span>: List&lt;String&gt; = coroutineScope &#123;</span><br><span class="line">    <span class="keyword">val</span> deferredOne = async &#123; fetchData1() &#125;</span><br><span class="line">    <span class="keyword">val</span> deferredTwo = async &#123; fetchData2() &#125;</span><br><span class="line">    listOf(deferredOne.await(), deferredTwo.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正常取消子协程，父协程会被取消吗"><a href="#正常取消子协程，父协程会被取消吗" class="headerlink" title="正常取消子协程，父协程会被取消吗"></a>正常取消子协程，父协程会被取消吗</h4><p>​		取消子协程不会自动取消父协程，只有在子协程失败（抛出异常）并且这个失败没有被处理的情况下，父协程才会被取消。</p>
<h4 id="子协程正在异步运行，父协程取消，异步子协程会被取消吗"><a href="#子协程正在异步运行，父协程取消，异步子协程会被取消吗" class="headerlink" title="子协程正在异步运行，父协程取消，异步子协程会被取消吗"></a>子协程正在异步运行，父协程取消，异步子协程会被取消吗</h4><p>​		这是Kotlin协程结构化并发的一个重要特性结构化并发，确保了当父协程结束时，所有子协程也同时结束，避免了可能的资源泄露。</p>
<h4 id="页面中，比如在activity中，你会使用哪种协程"><a href="#页面中，比如在activity中，你会使用哪种协程" class="headerlink" title="页面中，比如在activity中，你会使用哪种协程"></a>页面中，比如在activity中，你会使用哪种协程</h4><ul>
<li>使用MainScope来创建协程作用域之行协程方法，并在Activity的<code>onDestroy</code>方法中调用<code>myScope.cancel()</code>取消所有未完成的协程，以避免内存泄漏。</li>
<li>Activity<code>的</code>lifecycleScope</li>
</ul>
<h4 id="协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗"><a href="#协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗" class="headerlink" title="协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗"></a>协程有一个异步任务，这个时候页面销毁了，会出现内存泄露吗</h4><p>​		在使用Kotlin协程处理异步任务时，如果不正确管理协程的生命周期，特别是在页面（如Android中的Activity或Fragment）销毁时还有协程在运行，理论上可能会导致内存泄露。但是，Kotlin协程提供了工具和技术来避免这种情况，关键在于正确使用协程作用域（<code>CoroutineScope</code>）来控制协程的生命周期。</p>
<p>为什么会出现内存泄露？</p>
<ul>
<li><strong>持有上下文引用</strong>：如果协程在执行时持有了页面的上下文（Context）或直接引用了页面的实例，并且在页面销毁后仍然继续执行，就可能会阻止页面的实例被垃圾回收，从而导致内存泄露。</li>
<li><strong>长时间运行的任务</strong>：如果页面启动了一个长时间运行的协程任务，并在任务完成之前页面就被销毁了，但协程仍然持有页面实例的引用，这同样会导致内存泄露。</li>
</ul>
<p>如何避免内存泄露？</p>
<ul>
<li><p><strong>使用生命周期感知的作用域</strong>：在Android开发中，通过使用与Activity或Fragment生命周期绑定的协程作用域（如<code>lifecycleScope</code>或<code>viewModelScope</code>），确保协程在页面销毁时自动取消，从而避免内存泄露。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Activity或Fragment中</span></span><br><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    <span class="comment">// 在这里启动协程任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动控制协程的取消</strong>：如果你自定义了<code>CoroutineScope</code>，需要确保在页面销毁时取消这个作用域内的所有协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    myCustomScope.cancel() <span class="comment">// 取消自定义作用域内的所有协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免持有页面上下文</strong>：如果协程需要访问上下文，尽量使用<code>applicationContext</code>或者在协程执行任务时不直接持有页面的引用。</p>
</li>
</ul>
<p>结论</p>
<p>​		虽然协程本身并不直接导致内存泄露，但如果不正确管理它们的生命周期，特别是在页面销毁时仍有协程任务运行且持有页面实例的引用，就可能出现内存泄露。正确使用生命周期感知的协程作用域，以及确保页面销毁时取消所有相关的协程任务，是避免内存泄露的关键。</p>
<p>​		</p>
<h4 id="如果协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗"><a href="#如果协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗" class="headerlink" title="如果协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗"></a>如果协程内部持有一个外部静态类，页面销毁，会出现内存泄露吗</h4><p>​		静态类的引用会阻止页面被垃圾回收器回收，这样页面的资源就不会被释放，从而导致内存泄漏。</p>
<h4 id="kotlin委托是什么"><a href="#kotlin委托是什么" class="headerlink" title="kotlin委托是什么"></a>kotlin委托是什么</h4><p>​		委托是一种设计模式，基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理</p>
<p>kotlin中为了减少模版代码，也支持委托功能，分为 <code>类委托</code> 和 <code>属性委托</code> 。</p>
<p><strong>类委托</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> kuKe = KuKe()</span><br><span class="line">    <span class="keyword">val</span> leiJun = LeiJun(kuKe)</span><br><span class="line">    leiJun.homeWork</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HomeWork</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KuKe</span>() : HomeWork &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;写作业写作业...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeiJun</span>(<span class="keyword">val</span> homeWork: HomeWork) : HomeWork <span class="keyword">by</span> homeWork</span><br></pre></td></tr></table></figure>

<p>雷军让他同学替他写作业</p>
<p><strong>属性委托</strong></p>
<p><strong>属性委托的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。</strong>原理是将这个属性的<code>get</code>&#x2F;<code>set</code>方法委托给另一个类去实现。</p>
<p>kotlin标准库提供了两个接口用来给属性实现委托</p>
<p><code>thisRef</code> —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；</p>
<p><code>property</code> —— 必须是类型 <code>KProperty&lt;*&gt;</code>或其超类型。</p>
<p><code>value</code> —— 必须与属性同类型或者是它的子类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于val属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadOnlyProperty</span>&lt;<span class="type">in R, out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于var属性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in R, T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">R</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后可以自定义委托属性的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a : <span class="built_in">Int</span> <span class="keyword">by</span> Delegate2()</span><br><span class="line">    println(a)</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate2</span>: <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any?, Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1123</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1123</span></span><br><span class="line">setValue <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>延迟属性</strong> </p>
<p>​		参数默认是SYNCHRONIZED</p>
<p>​		第一次调用 <code>get()</code> 会执行已传递给 <code>lazy()</code> 的 lambda 表达式并记录结果， 后续调用 <code>get()</code> 只是返回记录的结果。它委托了属性的初始化逻辑给 <code>Lazy</code> 类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> student <span class="keyword">by</span> lazy &#123; Student() &#125;</span><br></pre></td></tr></table></figure>

<p><strong>可观察委托</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observableProp: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;初始值：xxx&quot;</span>)&#123;</span><br><span class="line">    property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;property: <span class="variable">$property</span>: <span class="variable">$oldValue</span> -&gt; <span class="variable">$newValue</span> &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    observableProp = <span class="string">&quot;第一次修改值&quot;</span></span><br><span class="line">    observableProp = <span class="string">&quot;第二次修改值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property: <span class="keyword">var</span> observableProp: kotlin.String: 初始值：xxx -&gt; 第一次修改值 </span><br><span class="line">property: <span class="keyword">var</span> observableProp: kotlin.String: 第一次修改值 -&gt; 第二次修改值 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>可观察拦截的委托</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vetoableProp: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.vetoable(<span class="number">0</span>)&#123;</span><br><span class="line">    _, oldValue, newValue -&gt;</span><br><span class="line">    <span class="comment">// 如果新的值大于旧值，则生效</span></span><br><span class="line">    newValue &gt; oldValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>委托给另一个属性</strong></p>
<p>委托对象可以是</p>
<ul>
<li>顶层属性</li>
<li>同一个类的成员或扩展属性</li>
<li>另一个类的成员或扩展属性</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层属性</span></span><br><span class="line"><span class="keyword">var</span> topLevelInt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassWithDelegate</span>(<span class="keyword">val</span> anotherClassInt: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>(<span class="keyword">var</span> memberInt: <span class="built_in">Int</span>, <span class="keyword">val</span> classWithDelegate: ClassWithDelegate) &#123;</span><br><span class="line">    <span class="keyword">var</span> delegatedInt: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt <span class="comment">// 委托给顶层属性</span></span><br><span class="line">    <span class="keyword">val</span> delegatedClassInt: <span class="built_in">Int</span> <span class="keyword">by</span> classWithDelegate::anotherClassInt <span class="comment">// 委托给其他类的属性</span></span><br><span class="line">    <span class="keyword">val</span> delegatedMemberInt: <span class="built_in">Int</span> <span class="keyword">by</span> ::memberInt <span class="comment">// 委托给类的成员属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展属性 (注意，扩展属性不能有初始化器:原因就是扩展属性本质上不会在类中添加新的字段保存其值，所以没有地方存放初始值。 扩展属性并不能带有初始化器。)</span></span><br><span class="line"><span class="keyword">var</span> AA.extDelegated: <span class="built_in">Int</span> <span class="keyword">by</span> ::topLevelInt</span><br></pre></td></tr></table></figure>

<p>​		当想要以一种向后兼容的方式重命名一个属性的时候：引入一个新的属性、 使用 <code>@Deprecated</code> 注解来注解旧的属性、并委托其实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> newName: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">   <span class="meta">@Deprecated(<span class="string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="string">&quot;newName&quot;</span>))</span></span><br><span class="line">   <span class="keyword">var</span> oldName: <span class="built_in">Int</span> <span class="keyword">by</span> <span class="keyword">this</span>::newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么场景下使用委托"><a href="#什么场景下使用委托" class="headerlink" title="什么场景下使用委托"></a>什么场景下使用委托</h4><p>上面那些延迟初始化啥的</p>
<h4 id="Room与常规写Sql语句有什么区别"><a href="#Room与常规写Sql语句有什么区别" class="headerlink" title="Room与常规写Sql语句有什么区别"></a>Room与常规写Sql语句有什么区别</h4><p>减少模版代码，提供了封装可以与jetpack其他组件结合使用</p>
<h4 id="Kotlin里面init和构造函数那个先执行"><a href="#Kotlin里面init和构造函数那个先执行" class="headerlink" title="Kotlin里面init和构造函数那个先执行"></a>Kotlin里面init和构造函数那个先执行</h4><p>先回答这个问题</p>
<p>init块的代码会被合并到主函数中，如果非要分顺序的话，init块的代码和属性初始化的代码会按着顺序添加到主函数中</p>
<p>主构造函数—&gt; init —&gt; 次构造函数</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/v2-6b5c5f3b80f605afe84080d25cc8be1e_720w.png" alt="img"></p>
<p>其中init代码块和对象类型的属性的初始化会被合并到主构造函数中执行。</p>
<blockquote>
<p>初始化块中的代码实际上会成为主构造函数的一部分。对主构造函数的委托发生在访问次构造函数的第一条语句时，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。</p>
<p>即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块</p>
</blockquote>
<p><strong>Kotlin中的init代码块就相当于Java中的普通代码块，在创建对象的时候代码块会先执行。注意是每次创建都会执行一遍</strong></p>
<p><strong>Kotlin中的伴生对象相当于Java中的Static关键字。<br>伴生对象里的init代码块就相当于Java中的静态代码块。在类加载的时候会优先执行且只会执行一次。</strong></p>
<p>其中java的构造顺序为</p>
<ol>
<li>执行父类的静态代码块，并初始化父类静态成员变量</li>
<li>执行子类的静态代码块，并初始化子类静态成员变量</li>
<li>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量</li>
<li>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</li>
</ol>
<h4 id="kotlin的单例只有object关键字来修饰，是线程安全的吗"><a href="#kotlin的单例只有object关键字来修饰，是线程安全的吗" class="headerlink" title="kotlin的单例只有object关键字来修饰，是线程安全的吗?"></a><strong>kotlin的单例只有object关键字来修饰，是线程安全的吗?</strong></h4><p>​		Kotlin 中使用 <code>object</code> 关键字声明的单例对象是线程安全的。这是因为 Kotlin 在内部使用了懒加载和线程安全的初始化，确保只有一个实例被创建，并且在多线程环境下也能正确工作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		反编译后的Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 Java 代码中可以看出来，显然这是一个单例模式。</p>
<ul>
<li><strong>私有构造函数</strong></li>
<li><strong>通过静态字段对外提供实例</strong></li>
<li><strong>静态代码块中直接初始化，线程安全</strong> 。</li>
</ul>
<blockquote>
<p>这里插播一个问题，<strong>static 代码块在何时执行？</strong></p>
</blockquote>
<p>​		首先类加载阶段可以分为<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>、<strong>使用</strong>、<strong>卸载</strong> 七个步骤 。static 代码块就是在 <strong>初始化</strong> 阶段执行的。那么，哪些场景会触发类的初始化呢？有如下几种场景：</p>
<ul>
<li>通过 <code>new</code> 实例化对象</li>
<li>读写一个类的静态字段</li>
<li>调用一个类的静态方法</li>
<li>对类进行反射调用</li>
</ul>
<p>​		按照上面反编译出来的 Java 代码，获得单例对象的方法是 <code>Singleton.INSTANCE</code> ，即调用 <code>Singleon</code> 类的静态字段 <code>INSTANCE</code>，就会触发类的初始化阶段，也就触发了 static 代码块的执行，从而完成了单例对象的实例化。同时，由于类加载过程天生线程安全，所以 <strong>Kotlin 的 object 单例活脱脱的就是一个线程安全的懒汉式单例(访问时初始化)。</strong></p>
<p>​		线程安全的实现原理</p>
<p>Kotlin的单例模式背后使用的是Java的类加载机制和初始化机制来保证线程安全，具体来说：</p>
<ol>
<li><strong>类加载</strong>：在Java和Kotlin中，类的加载和初始化是由类加载器完成的。<strong>类加载器在加载类的过程中会进行加锁</strong>，确保每个类只被加载一次。</li>
<li><strong>初始化</strong>：当类被首次访问时，其静态初始化块和静态字段会被执行和初始化。这个过程是同步的，因此在多线程环境下，多个线程尝试初始化同一个类（例如，Kotlin中的单例对象）时，Kotlin运行时会保证只有一个线程能初始化这个单例，其它线程将等待初始化完成。从而保证了线程安全。</li>
</ol>
<h4 id="扩展函数原理是什么？"><a href="#扩展函数原理是什么？" class="headerlink" title="扩展函数原理是什么？"></a><strong>扩展函数原理是什么？</strong></h4><p>扩展函数会被编译成一个java静态函数，函数的第一个参数就是所被扩展对象调用这个函数时自己本身，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">exty</span><span class="params">(i:<span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$this</span> exty <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的编译后如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">exty</span><span class="params">(<span class="meta">@NotNull</span> String $<span class="built_in">this</span>$exty, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter($<span class="built_in">this</span>$exty, <span class="string">&quot;$this$exty&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> $<span class="built_in">this</span>$exty + <span class="string">&quot; exty &quot;</span> + i;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>java中的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        exty(s,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="介绍一下委托"><a href="#介绍一下委托" class="headerlink" title="介绍一下委托"></a><strong>介绍一下委托</strong></h4><p>​		在 Kotlin 中，委托是一种设计模式，允许一个类（委托类）将其一些职责委托给另一个类（委托对象），以实现代码的复用和组合。委托可以通过关键字 <code>by</code> 实现。</p>
<h4 id="看你熟悉协程，suspend关键字有啥作用？"><a href="#看你熟悉协程，suspend关键字有啥作用？" class="headerlink" title="看你熟悉协程，suspend关键字有啥作用？"></a><strong>看你熟悉协程，suspend关键字有啥作用？</strong></h4><p>​		<code>suspend</code> 关键字用于标记可以挂起执行的函数。挂起函数可以在不阻塞线程的情况下执行长时间运行的操作，如网络请求或文件读写，以提高程序的性能和响应性。</p>
<h4 id="协程方面除了网络方面，还有什么场景应用？"><a href="#协程方面除了网络方面，还有什么场景应用？" class="headerlink" title="协程方面除了网络方面，还有什么场景应用？"></a><strong>协程方面除了网络方面，还有什么场景应用？</strong></h4><p>除了网络请求，协程还可用于以下场景：</p>
<ol>
<li>文件操作</li>
</ol>
<p>使用协程读取文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">readFile</span><span class="params">(filePath: <span class="type">String</span>)</span></span>: String = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    File(filePath).readText()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数据库访问</li>
</ol>
<p>使用协程执行数据库查询：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserFromDatabase</span><span class="params">(userId: <span class="type">Int</span>)</span></span>: User = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 假设有一个数据库函数 getUserById 来获取用户信息</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@withContext</span> database.getUserById(userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定时任务</li>
</ol>
<p>使用协程定时执行任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startTimer</span><span class="params">()</span></span> = GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isActive) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>) <span class="comment">// 延迟一秒</span></span><br><span class="line">        println(<span class="string">&quot;Timer tick&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>UI 操作</li>
</ol>
<p>在协程中更新 UI（确保在主线程上）：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateUI</span><span class="params">()</span></span> = withContext(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="comment">// 更新 UI 组件</span></span><br><span class="line">    textView.text = <span class="string">&quot;Updated Text&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>后台任务</li>
</ol>
<p>使用协程执行耗时的后台任务：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.Dispatchers</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.withContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">performBackgroundTask</span><span class="params">()</span></span> = withContext(Dispatchers.Default) &#123;</span><br><span class="line">    <span class="comment">// 执行耗时操作</span></span><br><span class="line">    <span class="keyword">val</span> result = heavyComputation()</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LiveData除了post发送数据，还有什么？"><a href="#LiveData除了post发送数据，还有什么？" class="headerlink" title="LiveData除了post发送数据，还有什么？"></a><strong>LiveData除了post发送数据，还有什么？</strong></h4><p>​		LiveData 除了 <code>postValue</code> 发送数据，还可以使用 <code>setValue</code> 发送数据。</p>
<p>​		区别在于 <code>postValue</code> 可以在非主线程中调用，而 <code>setValue</code> 必须在主线程中使用。</p>
<h4 id="日常工作中，什么情况用post，什么情况用setValue？"><a href="#日常工作中，什么情况用post，什么情况用setValue？" class="headerlink" title="日常工作中，什么情况用post，什么情况用setValue？"></a><strong>日常工作中，什么情况用post，什么情况用setValue？</strong></h4><p>​		通常情况下，应该使用 <code>postValue</code> 来发送 LiveData 的数据，因为它允许在非主线程中进行数据更改。只有在确定当前线程是主线程时才使用 <code>setValue</code>。</p>
<h4 id="怎么取消一个协程？"><a href="#怎么取消一个协程？" class="headerlink" title="怎么取消一个协程？"></a><strong>怎么取消一个协程？</strong></h4><p>​		可以使用协程的 <code>cancel</code> 方法来取消一个协程，或者通过协程的 <code>Job</code> 对象来取消它。</p>
<h4 id="网速很慢，会不会出现内存泄漏，页面已经销毁情况下？"><a href="#网速很慢，会不会出现内存泄漏，页面已经销毁情况下？" class="headerlink" title="网速很慢，会不会出现内存泄漏，页面已经销毁情况下？"></a><strong>网速很慢，会不会出现内存泄漏，页面已经销毁情况下？</strong></h4><p>​		在页面已经销毁的情况下，网速慢通常不会导致内存泄漏。内存泄漏通常涉及对象引用无法释放，与网速慢无直接关系。</p>
<h4 id="有生命周期监听为什么还会出现内存泄漏？"><a href="#有生命周期监听为什么还会出现内存泄漏？" class="headerlink" title="有生命周期监听为什么还会出现内存泄漏？"></a><strong>有生命周期监听为什么还会出现内存泄漏？</strong></h4><p>​		内存泄漏通常发生在对象仍然被引用，但不再需要的情况下。即使有生命周期监听，如果对对象的引用未能适时解除，仍然可能导致内存泄漏。因此，需要确保在不需要时适时解除对象引用。</p>
<h4 id="kotlin扩展函数的原理"><a href="#kotlin扩展函数的原理" class="headerlink" title="kotlin扩展函数的原理"></a>kotlin扩展函数的原理</h4><p>先看代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 String 类添加一个扩展函数 reverse</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">reverse</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reversed()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> original = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">val</span> reversed = original.reverse() <span class="comment">// 使用扩展函数</span></span><br><span class="line">    println(reversed) <span class="comment">// 输出 &quot;olleH&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在底层，Kotlin 编译器会将这个扩展函数转换为一个静态函数，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaCopy code<span class="comment">// Java 伪代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String $receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>($receiver).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		需要注意的是，扩展函数并不修改原始类的定义，也不会在原始类中添加任何新的成员。它们只是一种语法糖，让你能够以一种看起来像是在调用类的成员函数的方式来调用静态函数。因此，扩展函数的解析是静态的，它们不支持多态，也就是说，它们的调用不是基于接收者对象的运行时类型，而是基于接收者对象在代码中声明的类型。下面举个例子理解这段话。</p>
<p>我们定义一个基类 <code>Animal</code> 和一个派生类 <code>Dog</code>，以及它们各自的成员函数 <code>makeSound</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> = <span class="string">&quot;generic animal sound&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="type">Animal</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeSound</span><span class="params">()</span></span> = <span class="string">&quot;bark&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们为 <code>Animal</code> 类和 <code>Dog</code> 类分别定义扩展函数 <code>makeNoise</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">makeNoise</span><span class="params">()</span></span> = <span class="string">&quot;generic animal noise&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Dog.<span class="title">makeNoise</span><span class="params">()</span></span> = <span class="string">&quot;woof&quot;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们创建一个 <code>Animal</code> 类型的变量，但是实际上它引用的是一个 <code>Dog</code> 对象，并尝试调用成员函数和扩展函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> myAnimal: Animal = Dog()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    println(myAnimal.makeSound()) <span class="comment">// 输出 &quot;bark&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用扩展函数</span></span><br><span class="line">    println(myAnimal.makeNoise()) <span class="comment">// 输出 &quot;generic animal noise&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>当我们调用成员函数 <code>makeSound</code> 时，输出是 <code>&quot;bark&quot;</code>。这是因为多态的作用，<code>makeSound</code> 的调用是基于 <code>myAnimal</code> 的实际运行时类型（<code>Dog</code>），而不是它的声明类型（<code>Animal</code>）。</li>
<li>然而，当我们调用扩展函数 <code>makeNoise</code> 时，输出是 <code>&quot;generic animal noise&quot;</code>。这是因为扩展函数的调用是基于 <code>myAnimal</code> 的声明类型（<code>Animal</code>），而不是它的实际运行时类型（<code>Dog</code>）。这说明扩展函数不支持多态，它们的调用是静态解析的。</li>
</ul>
<h4 id="什么叫多态？"><a href="#什么叫多态？" class="headerlink" title="什么叫多态？"></a>什么叫多态？</h4><p>​	多态（Polymorphism）是面向对象编程（OOP）的一个核心概念，它指的是同一个方法或属性在不同的对象中可以有不同的实现。多态允许我们以统一的方式处理不同类型的对象，而具体的行为则取决于对象的实际类型。</p>
<p>多态主要有两种形式：</p>
<ol>
<li><strong>编译时多态（静态多态）</strong>：这种多态是在编译时就确定的，主要通过方法重载（Method Overloading）实现。方法重载指的是在同一个类中存在多个同名方法，但它们的参数列表不同。</li>
<li><strong>运行时多态（动态多态）</strong>：这种多态是在运行时才确定的，主要通过方法重写（Method Overriding）和接口实现实现。运行时多态的典型例子是父类引用指向子类对象，通过这个引用调用的方法是子类的方法，而不是父类的方法。这种行为是基于对象的实际运行时类型决定的。</li>
</ol>
<p>具体的例子可以看上面的那个代码示例调用makeSound方法输出的是Dog的实现。</p>
<h4 id="kotlin幕后字段"><a href="#kotlin幕后字段" class="headerlink" title="kotlin幕后字段"></a>kotlin幕后字段</h4><p>属性 or 字段</p>
<p>首先需要理解下属性和字段的区别：</p>
<blockquote>
<p>字段是一个拥有值的类成员变量，可以是只读的或可变的，并可以用任何访问修饰符（例如public或private）进行标记。</p>
<p><strong>属性包含一个私有字段和访问器（getter 和 setter），它也可以是只读或可变的。</strong></p>
</blockquote>
<p>​	 属性是 Kotlin 中的一个高级概念，它封装了字段的访问。一个属性通常由一个字段（幕后字段）、一个 getter 方法和一个可选的 setter 方法组成。在 Kotlin 中，当你定义一个属性时，编译器会自动生成相应的 getter 和 setter 方法（对于 <code>var</code> 属性）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field.capitalize()</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value.trim()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>name</code> 是一个属性，它有一个自定义的 getter 和 setter。<code>field</code> 关键字在这里引用的是属性的幕后字段。</p>
<p>​		字段是类的一个成员，用于存储数据。<strong>在 Kotlin 中，字段通常作为属性的一部分存在，称为幕后字段</strong>（backing field）。你不能直接定义一个字段，<strong>它是由编译器在需要时为属性自动生成的。字段只在属性的访问器（getter 和 setter）中可见，并通过 <code>field</code> 关键字访问。</strong></p>
<p>​		总的来说，属性是 Kotlin 中的一个高级概念，它包含字段、getter 方法和 setter 方法。字段是类的一个低级概念，用于存储数据，通常作为属性的一部分存在。在 Kotlin 中，你通常会直接与属性打交道，而不是直接操作字段。</p>
<p><strong>幕后字段：</strong>指代一个属性背后用于存储数据的字段。在 Kotlin 中，属性通常由一个字段（用于存储数据）、一个 getter 方法（用于访问数据）和一个 setter 方法（用于修改数据）组成。这个用于存储数据的字段就被称为幕后字段。</p>
<p>​		幕后字段只在属性的 getter 和 setter 方法中可用，并且只能通过 <code>field</code> 关键字来访问。不管有没有自定义 getter 和 setter 方法都会生成<code>field</code> 来存储数据。但是如果属性的 getter 和 setter 方法都没有引用 <code>field</code>，那么该属性不会有幕后字段，这句话怎么理解呢？</p>
<p>​		就是这个属性的getter 和 setter 所使用的值都是外部值，看下面代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName: String = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">     <span class="keyword">get</span>() = field.toUpperCase()  <span class="comment">// 引用了 field</span></span><br><span class="line">     <span class="keyword">set</span>(value) &#123;</span><br><span class="line">      field = value.trim()  <span class="comment">// 引用了 field</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastName: String</span><br><span class="line">     <span class="keyword">get</span>() = fullName.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]  <span class="comment">// 没有引用 field</span></span><br><span class="line">     <span class="keyword">set</span>(value) &#123;</span><br><span class="line">     fullName = <span class="string">&quot;<span class="subst">$&#123;fullName.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]&#125;</span> <span class="variable">$value</span>&quot;</span>  <span class="comment">// 没有引用 field</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​	上面的lastName的get和set返回的都是外部值，所以它没有幕后字段，这个<strong>lastName也被称为幕后属性。</strong></p>
<h4 id="kotlin扩展属性"><a href="#kotlin扩展属性" class="headerlink" title="kotlin扩展属性"></a>kotlin扩展属性</h4><p>​	Kotlin 中的扩展属性允许你为现有的类添加新的属性，类似于扩展函数。然而，<strong>由于扩展属性并不会真正地向目标类添加新的字段，因此它们不能有幕后字段。这意味着扩展属性不能直接存储数据，而必须通过自定义的 getter  或 setter 方法来实现。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 String 类添加一个扩展属性 reversed</span></span><br><span class="line"><span class="keyword">val</span> String.reversed: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.reversed()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> original = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    println(original.reversed) <span class="comment">// 使用扩展属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们为 <code>String</code> 类添加了一个只读的扩展属性 <code>reversed</code>，它通过自定义的 getter 方法来返回字符串的反转版本。在底层，Kotlin 编译器会将这个扩展属性转换为一个静态的扩展 getter 函数，大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getReversed</span><span class="params">(String $receiver)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>($receiver).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用扩展属性时，原始的字符串实例 <code>original</code> 会被传递给这个静态扩展 getter 函数作为 <code>$receiver</code> 参数。</p>
<p>​		总的来说，扩展属性的原理是通过在编译时将属性访问转换为对相应扩展访问器函数的调用，这些访问器函数是静态的，并接受扩展类型的实例作为参数。</p>
<p>​		由于扩展属性不能有幕后字段，它们必须通过自定义的 getter 和 setter 方法来实现数据承载。也就是说如果想要让扩展属性承载数据必须自定义实现getter 和 setter 方法。举个例子看下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> tagMap = mutableMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Any.tag: String</span><br><span class="line">    <span class="keyword">get</span>() = tagMap[<span class="keyword">this</span>.toString()] ?: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        tagMap[<span class="keyword">this</span>.toString()] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="kotlin扩展属性可以赋值初始值吗？"><a href="#kotlin扩展属性可以赋值初始值吗？" class="headerlink" title="kotlin扩展属性可以赋值初始值吗？"></a>kotlin扩展属性可以赋值初始值吗？</h4><p>​	    Kotlin 中的扩展属性不能像普通属性那样直接赋予初始值。这是因为扩展属性本身不存储数据，它们没有幕后字段。如果想要扩展属性表现得像有初始值一样，可以在自定义的 getter 方法中提供一个默认值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> String.defaultedValue: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="string">&quot;Default Value&quot;</span> <span class="keyword">else</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><p>在 Kotlin 中，线程的创建主要有以下几种方式：</p>
<ol>
<li>使用 Thread 类直接创建</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;Thread is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 Runnable 接口</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;Runnable is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> thread = Thread(runnable)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用匿名类</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">        println(<span class="string">&quot;Anonymous class is running.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用线程池（ExecutorService）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> executor = Executors.newFixedThreadPool(<span class="number">2</span>) <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line"></span><br><span class="line">executor.execute &#123;</span><br><span class="line">    <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">    println(<span class="string">&quot;ExecutorService is running.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">executor.shutdown() <span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用协程（Coroutine）</li>
</ol>
<p>虽然协程不是传统意义上的线程创建方式，但在 Kotlin 中，它是一种非常流行的并发编程模式，可以用来替代传统的线程操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 在这里执行你的代码</span></span><br><span class="line">        println(<span class="string">&quot;Coroutine is running.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是 Kotlin 中常见的线程创建方式。在实际应用中，选择合适的方式取决于具体的需求和场景。协程提供了更加灵活和高效的并发处理能力，是 Kotlin 中推荐的并发编程模式。</p>
<h4 id="by关键字"><a href="#by关键字" class="headerlink" title="by关键字"></a>by关键字</h4><p>在 Kotlin 中，<code>by</code> 关键字主要用于两种场景：委托模式和属性委托。</p>
<p>委托模式:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseImpl</span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性委托:</p>
<p>自定义属性委托：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="comment">// 这两个方法是实现属性委托类的必须方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取属性的值。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thisRef 这个参数是指持有属性的对象的引用。如果属性是被一个类的实例所持有，那么 thisRef 就是这个类			的实例。如果属性是被一个对象所持有（比如一个单例对象），那么 thisRef 就是这个对象。如果属性是顶级属性，		thisRef 可能是 null。</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@param</span> property  这个参数是 KProperty&lt;*&gt; 类型的，它包含了关于属性本身的信息，比如属性的名称。这可以用于在		   委托的实现中区分不同的属性。</span></span><br><span class="line"><span class="comment"> 	 * <span class="doctag">@return</span> 属性的值。</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$thisRef</span>, thank you for delegating &#x27;<span class="subst">$&#123;property.name&#125;</span>&#x27; to me!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$value</span> has been assigned to &#x27;<span class="subst">$&#123;property.name&#125;</span>&#x27; in <span class="variable">$thisRef</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">    println(e.p) <span class="comment">// 调用 Delegate 的 getValue 方法</span></span><br><span class="line"></span><br><span class="line">    e.p = <span class="string">&quot;NEW&quot;</span> <span class="comment">// 调用 Delegate 的 setValue 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>懒加载:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    println(<span class="string">&quot;Computing the value...&quot;</span>)</span><br><span class="line">    <span class="string">&quot;Hello, Lazy World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性观察：<strong>每次属性值发生变化时都会触发一个回调函数的属性。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> observableValue: String <span class="keyword">by</span> Delegates.observable(<span class="string">&quot;Initial Value&quot;</span>) &#123; property, oldValue, newValue -&gt;</span><br><span class="line">    println(<span class="string">&quot;Property &#x27;<span class="subst">$&#123;property.name&#125;</span>&#x27; changed from &#x27;<span class="variable">$oldValue</span>&#x27; to &#x27;<span class="variable">$newValue</span>&#x27;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    observableValue = <span class="string">&quot;New Value&quot;</span> <span class="comment">// 触发回调函数</span></span><br><span class="line">    observableValue = <span class="string">&quot;Another Value&quot;</span> <span class="comment">// 再次触发回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="by-lazy的原理"><a href="#by-lazy的原理" class="headerlink" title="by lazy的原理"></a>by lazy的原理</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: <span class="built_in">Int</span> <span class="keyword">by</span> lazy &#123; <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>by lazy底层实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"><span class="comment">// Lazy是一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lazy</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		lazy是一个接口它的实现类有四个，其中InitializedLazyImpl只是负责序列化。看下具体的重载方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lazy</span><span class="params">(mode: <span class="type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; =</span><br><span class="line">    <span class="keyword">when</span> (mode) &#123;</span><br><span class="line">        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​		根据传入的mode不同会选择不同的实现模式，会选择不同实现类。其中SynchronizedLazyImpl和SafePublicationLazyImpl都是线程安全的不同点在于SafePublicationLazyImpl使用CAS自旋锁进行初始化操作，而SynchronizedLazyImpl是要同步锁的方式进行初始化操作，其他实现一样。UnsafeLazyImpl就是线程不安全的初始化操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个可以被序列化的私有类，实现了 Lazy 接口，用于线程安全的惰性初始化。</span></span><br><span class="line"><span class="comment">// T 是一个协变的类型参数，表示可以接受 T 或其子类型的对象。</span></span><br><span class="line"><span class="comment">// initializer 是一个无参数、返回类型为 T 的函数，用于惰性初始化。</span></span><br><span class="line"><span class="comment">// lock 是一个可选的锁对象，如果不提供，则使用 this 作为锁。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SynchronizedLazyImpl</span>&lt;<span class="type">out T</span>&gt;(initializer: () -&gt; T, lock: Any? = <span class="literal">null</span>) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存初始化函数的变量，使用可空类型，初始化后将其设为 null 以释放引用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> initializer: (() -&gt; T)? = initializer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储初始化后的值或表示未初始化的特殊值 UNINITIALIZED_VALUE。</span></span><br><span class="line">    <span class="comment">// 使用 @Volatile 注解保证在多线程环境中的可见性。</span></span><br><span class="line">    <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定锁对象，如果未提供 lock 参数，则使用当前对象作为锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = lock ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 Lazy 接口的 value 属性，提供线程安全的惰性初始化。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> _v1 = _value</span><br><span class="line">            <span class="comment">// 如果 _value 不是 UNINITIALIZED_VALUE，说明已经初始化，直接返回值。</span></span><br><span class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">val</span> _v2 = _value</span><br><span class="line">                <span class="comment">// 再次检查 _value，以防在等待锁的期间已经被其他线程初始化。</span></span><br><span class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果仍未初始化，则调用初始化函数，保存结果，并将初始化函数置为 null。</span></span><br><span class="line">                    <span class="keyword">val</span> typedValue = initializer!!()</span><br><span class="line">                    _value = typedValue</span><br><span class="line">                    initializer = <span class="literal">null</span></span><br><span class="line">                    typedValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 Lazy 接口的 isInitialized 方法，检查是否已经初始化。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = _value !== UNINITIALIZED_VALUE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 toString 方法，根据是否初始化返回不同的字符串。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="keyword">if</span> (isInitialized()) value.toString() <span class="keyword">else</span> <span class="string">&quot;Lazy value not initialized yet.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在序列化时替换当前对象，确保序列化后的对象是已经初始化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeReplace</span><span class="params">()</span></span>: Any = InitializedLazyImpl(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		 SynchronizedLazyImpl 实现了 Lazy、Serializable 接口，它的 value 属性重载了 Lazy 接口的 value。Lazy 接口的 value 属性用于获取当前 Lazy 实例的延迟初始化值。一旦初始化后，它不得在此 Lazy 实例的剩余生命周期内更改。</p>
<p>​		所以 SynchronizedLazyImpl 的 value 属性只有 get() 方法，没有 set() 方法。value 的 get() 方法会先判断 _value 属性是否是 UNINITIALIZED_VALUE，不是的话会返回  _value 的值。_value 使用<code>@Volatile</code>注解标注，相当于在 Java 中 使用 volatile 修饰 _value 属性。volatile 具有可见性、有序性，因此一旦 _value 的值修改了，其他线程可以看到其最新的值。</p>
<p>​		如果 _value 的值等于 UNINITIALIZED_VALUE，则调用 initializer 来获取值，通过<code>synchronized</code>来保证这个过程是线程安全的。</p>
<h4 id="kotlin中reified关键字的作用"><a href="#kotlin中reified关键字的作用" class="headerlink" title="kotlin中reified关键字的作用"></a>kotlin中reified关键字的作用</h4><p><code>reified</code> 关键字用于<strong>使参数类型在运行时可访问</strong>。</p>
<p>泛型是会进行类型擦除的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> c1: Class&lt;*&gt; = ArrayList&lt;<span class="built_in">Int</span>&gt;().javaClass</span><br><span class="line"><span class="keyword">val</span> c2: Class&lt;*&gt; = ArrayList&lt;String&gt;().javaClass</span><br><span class="line">println(c1 == c2)<span class="comment">// 输出为true</span></span><br></pre></td></tr></table></figure>

<p>所以想要在运行时获取参数的类型需要新添加一个类型参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c = T::<span class="keyword">class</span>.java <span class="comment">//直接获取报错 “Cannot use &#x27;T&#x27; as reified type parameter. Use a class instead”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过新加一个参数实现类型的获取</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>,clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt; )</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;clazz.simpleName: <span class="subst">$&#123;clazz.simpleName&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>,<span class="built_in">Int</span>::<span class="keyword">class</span>.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin中通过reified可以省略这个新加的参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> c = T::<span class="keyword">class</span>.java <span class="comment">//可以正常获取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reified必须要增加 inline的原因：</p>
<p>​		只有当函数被内联时，<code>reified</code> 类型参数的具体类型信息才能在运行时被访问和使用。</p>
<p>反编译下上面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void test(Object t) &#123;</span><br><span class="line">      int $i$f$test = <span class="number">0</span>;</span><br><span class="line">      Intrinsics.reifiedOperationMarker(<span class="number">4</span>, <span class="string">&quot;T&quot;</span>);</span><br><span class="line">      Class c = Object.<span class="keyword">class</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">      int t$iv = <span class="literal">true</span>;</span><br><span class="line">      int $i$f$test = <span class="literal">false</span>;</span><br><span class="line">      Class c$iv = Integer.<span class="keyword">class</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.println(c$iv);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​		test方法的逻辑都copy到了main方法中，如果不内联的话无法知道test方法参数的具体信息。其必须内联才能知道具体类型，从而将我们的实际泛型类型更新到具体的调用代码中,从而完成泛型类型 <strong>再生</strong> 。</p>
<p>参考：</p>
<p><a href="https://juejin.cn/post/7141254785214185503">Kotlin | 浅谈 reified 与泛型 那些事</a></p>
<h4 id="kotlin内联inline的作用"><a href="#kotlin内联inline的作用" class="headerlink" title="kotlin内联inline的作用"></a>kotlin内联inline的作用</h4><p>先说下属性内联：</p>
<p>​		Java中那些用final定义的常量<code>final int x = 10;</code>，这种编译时常量会在编译时进行内联，直接将具体的值替换到变量名被调用的地方，来减少调用链路。</p>
<p>​		在kotlin中使用<code>const val x = 10</code>来定义</p>
<p>​		kotlin还支持函数的内联，通过inline来实现。函数内联会将函数体copy每个调用的地方，导致字节码臃肿。但是kotlin中会出现这么一种情况，就是在一个函数的参数是函数类型，然后内部调用这个参数执行就相当于创建了一个匿名对象来执行函数lambda的逻辑。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    action.invoke()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@NotNull</span> Function0 action)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(action, <span class="string">&quot;action&quot;</span>);</span><br><span class="line">      action.invoke();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">      test((Function0)<span class="literal">null</span>.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line">      main();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数类型的参数会被编译成Function0接口对象，也就是说在入参的时候会创建一个临时Function0对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">test(f)</span><br></pre></td></tr></table></figure>

<p>上面的调用和下面的调用是等价的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f = <span class="keyword">object</span> : Function0&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">test(f)</span><br></pre></td></tr></table></figure>

<p><strong>使用inline关键字就可以将对应的逻辑直接copy到调用的地方，从而减少对象的创建。</strong>从而弥补高阶函数的缺陷。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    print(<span class="string">&quot;执行前&quot;</span>)</span><br><span class="line">    action.invoke()</span><br><span class="line">    print(<span class="string">&quot;执行后&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="string">&quot;执行前&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;执行后&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化了main方法内部的内联函数内部的函数类型的参数。</p>
<p><strong>inline用于优化高阶函数被多处调用的情况，如果没有使用对会产生多余的字节码。</strong></p>
<h4 id="kotlin中oninline的作用"><a href="#kotlin中oninline的作用" class="headerlink" title="kotlin中oninline的作用"></a>kotlin中oninline的作用</h4><p>oninline是用来关闭内联的，看下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> action2: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    action1.invoke()</span><br><span class="line">    action2.invoke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个内联函数的两个函数类型的参数，action1会内联，action2不会内联。</p>
<p><strong>这个关键字的使用场景是当这个函数类型的参数需要被当作对象来使用的时候，比如最为返回值就需要取消被内联优化。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action1: () -&gt; <span class="type">Unit</span>, <span class="keyword">noinline</span> action2: () -&gt; <span class="type">Unit</span>)</span></span>:() -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    action1.invoke()</span><br><span class="line">    <span class="keyword">return</span> action2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="kotlin中crossinline的作用"><a href="#kotlin中crossinline的作用" class="headerlink" title="kotlin中crossinline的作用"></a>kotlin中crossinline的作用</h4><p>内联函数的函数类型参数的lambda中可以有return，但是在内联后这个return会结束内联函数调用者的函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    action.invoke()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return会结束main函数的执行。</p>
<p>​		如果将action再进行一层作用域包裹，切断action和test的联系，这时候就无法结束main函数了。导致无法按照预期进行工作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(action: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    runOnUiThread &#123;</span><br><span class="line">        action.invoke()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		Kotlin为了避免这种情况的发生直接强制要求内联函数中不能间接调用函数参数。但是如果有真正的需要间接调用的场景的话就不能实现了。</p>
<p>crossinline就是为了解除上面这种限制的。但是同时会要求crossinline修饰的函数参数的lambda中不可以使用return。</p>
<p>参考：</p>
<p><a href="https://www.bilibili.com/video/BV1kz4y1f7sf/?t=4&spm_id_from=333.1350.jump_directly&vd_source=214b10aedbc4bde847f4f4260b4d4787">Kotlin 源码里成吨的 noinline 和 crossinline 是干嘛的？</a></p>
<h4 id="如何自己实现一个by"><a href="#如何自己实现一个by" class="headerlink" title="如何自己实现一个by"></a>如何自己实现一个by</h4><p>类委托没什么好看的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ISay</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateImp</span> : <span class="type">ISay</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;sayHello from DelegateImp&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImp2</span> : <span class="type">ISay</span> <span class="title">by</span> <span class="title">DelegateImp</span>()  <span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImp3</span>(delegate: ISay) : ISay <span class="keyword">by</span> delegate <span class="comment">//方式2</span></span><br></pre></td></tr></table></figure>

<p><em><em>属性委托的委托类必须具有 getValue(Nothing?, KProperty</em>&gt;)’方法</em>*，</p>
<p>对于可写属性还要包括<strong>setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String)</strong></p>
<ul>
<li><strong>thisRef</strong>： 请求其值的对象，即被委托对象的实例</li>
<li><strong>property</strong>： 被委托对象属性的元数据。包含了<code>被委托对象</code>属性的<code>名称、类型、可见性</code>等信息。</li>
<li><strong>value</strong>： <code>setValue()</code> 中要设置的值。</li>
</ul>
<p>举例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="comment">//对应属性中的get()，表示获取数据</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$thisRef</span>，<span class="subst">$&#123;property.name&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应属性中的set()，表示设置数据，只有var的属性会有</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$thisRef</span> , <span class="subst">$&#123;property.name&#125;</span> , <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> p1: String <span class="keyword">by</span> Delegate()</span><br><span class="line">   println(property.p1) <span class="comment">//getValue()</span></span><br><span class="line">   property.p1 = <span class="string">&quot;小马快跑&quot;</span> <span class="comment">//setValue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Kotlin</code>为我们提供了<code>ReadOnlyProperty</code>、<code>ReadWriteProperty</code>接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只读</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写都支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的话重写对应的方法即可</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DelegateRW</span> : <span class="type">ReadWriteProperty</span>&lt;<span class="type">Any, String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;getValue：<span class="variable">$thisRef</span>，<span class="subst">$&#123;property.name&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue：<span class="variable">$thisRef</span>，<span class="subst">$&#123;property.name&#125;</span>，<span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如何自己实现by-lazy方法"><a href="#如何自己实现by-lazy方法" class="headerlink" title="如何自己实现by lazy方法"></a>如何自己实现by lazy方法</h4><p><code>by lazy</code> 委托用于惰性初始化属性，它的实现类是SynchronizedLazyImpl，然后重写了Lazy接口的value属性的get方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">val</span> _v1 = _value</span><br><span class="line">            <span class="comment">// 判断是否初始化</span></span><br><span class="line">            <span class="keyword">if</span> (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">                <span class="keyword">return</span> _v1 <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">val</span> _v2 = _value</span><br><span class="line">                <span class="keyword">if</span> (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span> (_v2 <span class="keyword">as</span> T)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// initializer是初始化的lambda</span></span><br><span class="line">                    <span class="keyword">val</span> typedValue = initializer!!()</span><br><span class="line">                    _value = typedValue</span><br><span class="line">                    initializer = <span class="literal">null</span></span><br><span class="line">                    <span class="comment">// 返回首次初始化的值</span></span><br><span class="line">                    typedValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果要自己实现的话可以自定义一个实现类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyDelegate</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> initializer: () -&gt; T) : Lazy&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> value: T</span><br><span class="line">    	<span class="comment">// 这里进行初始化</span></span><br><span class="line">        <span class="keyword">get</span>() = initializer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInitialized</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">myLazy</span><span class="params">(initializer: () -&gt; <span class="type">T</span>)</span></span>: Lazy&lt;T&gt; = LazyDelegate(initializer)</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p3: String <span class="keyword">by</span> myLazy &#123; <span class="string">&quot; &quot;</span> &#125;</span><br><span class="line">    println(p3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上面自定义的类中并没有对数据进行额外的处理，每次获取数据都会进行一次初始化。所以这里仅仅作为探索原理的尝试，没有实际的用途。</p>
<h4 id="kotlin权限修饰符"><a href="#kotlin权限修饰符" class="headerlink" title="kotlin权限修饰符"></a>kotlin权限修饰符</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
<th>类成员可见性</th>
<th>顶层声明可见性</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>可以在任何地方被访问</td>
<td>全局可见</td>
<td>全局可见</td>
</tr>
<tr>
<td><code>private</code></td>
<td>只在声明它的文件或类中可见</td>
<td>类内部</td>
<td>同一个文件内</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>只在其自身所在的类及其子类中可见（不包括同一个包中的其他类）</td>
<td>类内部及子类</td>
<td>不适用</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>在同一个模块内部可见</td>
<td>同一个模块的所有地方</td>
<td>同一个模块的所有地方</td>
</tr>
</tbody></table>
<h4 id="kotlin的优点和缺点"><a href="#kotlin的优点和缺点" class="headerlink" title="kotlin的优点和缺点"></a>kotlin的优点和缺点</h4><p>缺点：kotlin可读性不高</p>
<h4 id="kotlin位运算符"><a href="#kotlin位运算符" class="headerlink" title="kotlin位运算符"></a>kotlin位运算符</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> number = <span class="number">12</span> <span class="comment">// 二进制表示为 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左移两位</span></span><br><span class="line"><span class="keyword">val</span> leftShift = number shl <span class="number">2</span> <span class="comment">// 结果为 48，二进制表示为 110000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右移两位</span></span><br><span class="line"><span class="keyword">val</span> rightShift = number shr <span class="number">2</span> <span class="comment">// 结果为 3，二进制表示为 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无符号右移两位</span></span><br><span class="line"><span class="keyword">val</span> unsignedRightShift = number ushr <span class="number">2</span> <span class="comment">// 结果为 3，二进制表示为 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位与运算</span></span><br><span class="line"><span class="keyword">val</span> andResult = number and <span class="number">9</span> <span class="comment">// 结果为 8，二进制表示为 1000（1100 &amp; 1001）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位或运算</span></span><br><span class="line"><span class="keyword">val</span> orResult = number or <span class="number">3</span> <span class="comment">// 结果为 15，二进制表示为 1111（1100 | 0011）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位异或运算</span></span><br><span class="line"><span class="keyword">val</span> xorResult = number xor <span class="number">5</span> <span class="comment">// 结果为 9，二进制表示为 1001（1100 ^ 0101）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位非运算</span></span><br><span class="line"><span class="keyword">val</span> invResult = number.inv() <span class="comment">// 对于32位整型，结果为 -13，二进制表示为所有位取反</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="kotlin中-的作用"><a href="#kotlin中-的作用" class="headerlink" title="kotlin中::的作用"></a>kotlin中::的作用</h4><ol>
<li>函数引用</li>
</ol>
<p>当你需要将一个函数作为参数传递给另一个函数时，可以使用<code>::</code>操作符引用该函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPositive</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbers = listOf(-<span class="number">10</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 使用函数引用传递isPositive函数</span></span><br><span class="line"><span class="keyword">val</span> positiveNumbers = numbers.filter(::isPositive)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>属性引用</li>
</ol>
<p>类似地，<code>::</code>操作符也可以用来引用一个属性，允许你获取或设置属性的值而不需要知道具体是哪个属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 引用顶层属性x</span></span><br><span class="line">    println(::x.<span class="keyword">get</span>()) <span class="comment">// 获取x的值</span></span><br><span class="line">    ::x.<span class="keyword">set</span>(<span class="number">20</span>) <span class="comment">// 设置x的值</span></span><br><span class="line">    println(x) <span class="comment">// 输出20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造函数引用</li>
</ol>
<p><code>::</code>操作符还可以用来引用类的构造函数，这在需要将构造函数作为函数参数传递或者需要延迟创建实例的场景下非常有用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> constructorReference = ::MyClass</span><br><span class="line">    <span class="keyword">val</span> instance = constructorReference(<span class="number">42</span>) <span class="comment">// 使用构造函数引用创建实例</span></span><br><span class="line">    println(instance.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>类引用</li>
</ol>
<p>当需要获取Kotlin类的<code>KClass</code>类型信息时，可以使用<code>::class</code>语法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> kclass = MyClass::<span class="keyword">class</span></span><br><span class="line"><span class="title class_">println</span>(kclass)</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p><code>::</code>操作符在Kotlin中是多才多艺的，它允许你引用函数、属性、构造函数和类本身，非常适合用于高阶函数、反射以及需要延迟执行操作的场景。通过使用这个操作符，你可以写出更加灵活和动态的Kotlin代码。</p>
<h4 id="Kotlin中-Parcelize的作用"><a href="#Kotlin中-Parcelize的作用" class="headerlink" title="Kotlin中@Parcelize的作用"></a>Kotlin中@Parcelize的作用</h4><p>​		<code>@Parcelize</code>是Kotlin Android Extensions的强大特性之一，能够显著简化在Android应用中使用<code>Parcelable</code>接口的复杂度。这让开发者能够更专注于应用的逻辑，而不是序列化代码的样板代码。</p>
<ol>
<li><strong>添加依赖</strong>：确保项目支持Kotlin Android Extensions，并且在<code>build.gradle</code>文件中启用了<code>kotlin-parcelize</code>插件。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目的 build.gradle (Project) 文件中</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:<span class="variable">$kotlin_version</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模块的 build.gradle (Module) 文件中</span></span><br><span class="line">apply plugin: <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">apply plugin: <span class="string">&#x27;kotlin-parcelize&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>使用<code>@Parcelize</code>注解你的类</strong>：在你的数据类前添加<code>@Parcelize</code>注解，并让你的类实现<code>Parcelable</code>接口。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) : Parcelable</span><br></pre></td></tr></table></figure>

<p>这样，就不需要手动实现<code>Parcelable</code>接口的内容了，<code>@Parcelize</code>会自动处理。</p>
<h4 id="kotlin中的open关键字"><a href="#kotlin中的open关键字" class="headerlink" title="kotlin中的open关键字"></a>kotlin中的open关键字</h4><p>​		在Kotlin中，所有的类默认都是<code>final</code>的，这意味着它们不能被继承。这与Java不同，在Java中，一个类默认是可以被继承的，除非它被标记为<code>final</code>。Kotlin采用这种设计是为了鼓励使用组合而不是继承，并提高代码的安全性。</p>
<p>​		当希望允许一个类被继承，或者一个成员（如函数或属性）被重写时，需要使用<code>open</code>关键字明确标记它们。这告诉Kotlin编译器这个类或成员是可以被扩展或修改的。</p>
<h4 id="kotlin-infix"><a href="#kotlin-infix" class="headerlink" title="kotlin infix"></a>kotlin infix</h4><p><code>infix</code>关键字允许调用一个方法而不需要使用点操作符和括号。</p>
<p>使用<code>infix</code>关键字的函数必须满足以下条件：</p>
<ol>
<li>它们必须是成员函数或扩展函数；</li>
<li>它们必须只有一个参数；</li>
<li>该参数不能有默认值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> friends = mutableListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">connectWith</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line">        friends.add(person)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> alice = Person(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> bob = Person(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用infix notation调用</span></span><br><span class="line">    alice connectWith bob</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不使用infix notation的等效调用</span></span><br><span class="line">    alice.connectWith(bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p><code>infix</code>函数提供了一种定义自然语言式的API的方法。它们在创建DSL（领域特定语言）、定义简洁的API接口时特别有用。</p>
<p>注意事项</p>
<ul>
<li><code>infix</code>函数的使用增加了代码的可读性，但在不恰当的场合过度使用可能会使代码的含义变得不那么明显，特别是对于不熟悉你代码的开发者来说。因此，建议在确实能提高代码清晰度和可读性的情况下使用。</li>
<li><code>infix</code>函数调用时不使用点操作符和括号，这可能导致在查看代码时不够明显，需要开发者对<code>infix</code>关键字有所了解。</li>
</ul>
<h4 id="kotlin密封类"><a href="#kotlin密封类" class="headerlink" title="kotlin密封类"></a>kotlin密封类</h4><p>密封类的特点</p>
<ol>
<li><strong>扩展性限制</strong>：密封类的子类只能在与密封类相同的文件中声明，这意味着所有的子类都是已知的和受限的。</li>
<li><strong>类型安全</strong>：使用密封类可以实现类型的安全使用，因为使用<code>when</code>表达式处理密封类的不同子类时，如果覆盖了所有的情况，就不需要再提供一个<code>else</code>分支。</li>
<li><strong>继承</strong>：密封类本身是抽象的，不能直接实例化，但它们可以有抽象成员。密封类的子类可以是数据类，也可以是常规类或对象。</li>
</ol>
<p>使用场景</p>
<ul>
<li><strong>表示有限的状态集</strong>：密封类是表示有限状态机、操作结果或者在某些特定场景下只有几种状态的理想选择。</li>
<li><strong>使用<code>when</code>表达式</strong>：与<code>when</code>表达式结合使用时，密封类能够确保处理了所有的情况，使得代码更安全、易于维护。</li>
</ul>
<p><a href="https://legacy.kotlincn.net/docs/reference/sealed-classes.html">kotlin官网</a></p>
<h4 id="const-val-和-val的区别"><a href="#const-val-和-val的区别" class="headerlink" title="const val 和 val的区别"></a>const val 和 val的区别</h4><p><code>val</code></p>
<ul>
<li><strong>使用场景</strong>：用于声明一个<strong>只读变量</strong>，其值在运行时确定，只能赋值一次。</li>
<li><strong>初始化时机</strong>：<code>val</code>变量可以在运行时进行初始化，支持基于运行时计算得到的值。例如，可以根据函数的返回值或运行时表达式来初始化。</li>
<li><strong>适用范围</strong>：可以在类的属性或局部变量中使用。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> instanceValue: <span class="built_in">Int</span> = someFunction() <span class="comment">// 运行时计算得到的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> localValue = anotherFunction() <span class="comment">// 局部变量，运行时确定值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const val</code></p>
<ul>
<li><strong>使用场景</strong>：用于声明编译时常量。这意味着变量的值在编译时就已经确定，并且是不可变的。</li>
<li><strong>初始化时机</strong>：<code>const val</code>声明的常量必须在编译时就确定其值，因此只能用基本类型的值或String类型直接初始化。</li>
<li><strong>适用范围</strong>：只能用在顶层变量、对象声明或伴生对象中的属性上，不能用于类的普通属性。此外，<code>const val</code>不能用于局部变量。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> compileTimeConstant = <span class="string">&quot;This is a compile-time constant&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> MyObject &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> objectConstant = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> companionConstant = <span class="number">3.14</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键区别总结</p>
<ul>
<li><strong>初始化时机和值的确定时间</strong>：<code>val</code>在运行时初始化，其值可以动态计算；而<code>const val</code>在编译时就确定其值，必须用字面量或其他编译时常量初始化。</li>
<li><strong>适用范围</strong>：<code>const val</code>的使用更受限，只能用于定义编译时的常量，而<code>val</code>更通用，可以定义类的只读属性或局部只读变量。</li>
<li><strong>内存效率</strong>：<code>const val</code>声明的常量在编译后不会创建对象实例，直接内嵌到使用它们的地方，这可能会略微提高性能和减少内存使用。</li>
</ul>
<h4 id="kotlin扩展函数同名"><a href="#kotlin扩展函数同名" class="headerlink" title="kotlin扩展函数同名"></a>kotlin扩展函数同名</h4><p>​		Kotlin的扩展函数为类功能的扩展提供了强大的灵活性，但在使用同名的扩展函数时需要特别注意，避免因导入冲突或不明确的调用而导致的编译错误。通过合理组织代码和使用别名导入，可以有效地解决这些问题。</p>
]]></content>
  </entry>
  <entry>
    <title>Recyclerview缓存机制</title>
    <url>/2023/12/15/RecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Recyclerview缓存机制"><a href="#Recyclerview缓存机制" class="headerlink" title="Recyclerview缓存机制"></a>Recyclerview缓存机制</h1><h2 id="Recyclerview基本使用"><a href="#Recyclerview基本使用" class="headerlink" title="Recyclerview基本使用"></a>Recyclerview基本使用</h2><p>xml中添加空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>item.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/text_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;测试&quot;</span> /&gt;</span></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<p>Adapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.Adapter&lt;RecyclerView.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  OnItemClickListener itemClickListener;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShareBean&gt; mData = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RecyclerAdapter</span><span class="params">(Context context, List&lt;ShareBean&gt; mData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mData = mData;</span><br><span class="line">        <span class="built_in">this</span>.mInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将布局转化为 View 并传递给 RecyclerView 封装好的 ViewHolder</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.ViewHolder <span class="title function_">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="type">int</span> viewType)</span>&#123;    </span><br><span class="line">        <span class="comment">// 实例化展示的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mInflater.inflate(R.layout.item_recyclerview, parent, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 实例化viewholder</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemViewHolder</span>(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据与视图进行绑定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">        ((ItemViewHolder) holder).mImageView.setImageResource(mData.get(position).getImage_id());</span><br><span class="line">        ((ItemViewHolder) holder).mTextView.setText(mData.get(position).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 Item 的数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mData == <span class="literal">null</span> ? <span class="number">0</span> : mData.size();;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span> <span class="keyword">extends</span> <span class="title class_">RecyclerView</span>.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        CardView mCardView;</span><br><span class="line">        CircleImageView mImageView;</span><br><span class="line">        TextView mTextView;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ItemViewHolder</span><span class="params">(View itemView)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(itemView);</span><br><span class="line">            mTextView = (TextView) itemView.findViewById(R.id.textView);</span><br><span class="line">            mCardView = (CardView) itemView.findViewById(R.id.cardView);</span><br><span class="line">            mImageView = (CircleImageView) itemView.findViewById(R.id.image);</span><br><span class="line">            mCardView.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (itemClickListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        itemClickListener.onItemClick(view, getPosition());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RecyclerView缓存的是什么？"><a href="#RecyclerView缓存的是什么？" class="headerlink" title="RecyclerView缓存的是什么？"></a>RecyclerView缓存的是什么？</h2><p>首先明确一点，Recyclerview缓存的是ViewHolder。</p>
<h2 id="RecyclerView缓存的目的？"><a href="#RecyclerView缓存的目的？" class="headerlink" title="RecyclerView缓存的目的？"></a>RecyclerView缓存的目的？</h2><ul>
<li>onCreateViewHolder：负责创建并初始化ViewHolder及其关联的视图，但不会填充视图内容。</li>
<li>onBindViewHolder：负责提取适当的数据，填充ViewHolder的视图内容。</li>
</ul>
<p>最优情况是——取得的缓存对象正好是原先的ViewHolder对象，这种情况下既不需要重新创建该对象，也不需要重新绑定数据，即拿即用。</p>
<p>次优情况是——取得的缓存对象虽然不是原先的ViewHolder对象，但由于二者的列表项类型(itemType)相同，其关联的视图可以复用，因此只需要重新绑定数据即可。</p>
<p>最后实在没办法了，才需要执行这2个方法的回调，即创建新的ViewHolder对象并绑定数据</p>
<p>应该通过对ViewHolder对象积极地缓存复用，来尽量减少对这2个方法的回调频次。</p>
<h2 id="RecyclerView缓存的实现"><a href="#RecyclerView缓存的实现" class="headerlink" title="RecyclerView缓存的实现"></a>RecyclerView缓存的实现</h2><h3 id="RecyclerView的滚动实现"><a href="#RecyclerView的滚动实现" class="headerlink" title="RecyclerView的滚动实现"></a>RecyclerView的滚动实现</h3><p>看源码分析从onTouchEvent方法的ACTION_MOVE事件开始，然后到scrollByInternal方法又到scrollStep方法最终又会调用到LayoutManager的方法来实现最终的滑动处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dx != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedX = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dy != <span class="number">0</span>) &#123;</span><br><span class="line">        consumedY = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而LayoutManager中的这两个方法又分别交给了他的实现类去实现，这里以LinearLayoutManager类为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置回收标记，表示在布局过程中可以回收和复用视图</span></span><br><span class="line">    mLayoutState.mRecycle = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 根据滚动的方向，设置布局的方向。delta &gt; 0表示向结束方向滚动，否则向开始方向滚动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> delta &gt; <span class="number">0</span> ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">    <span class="comment">// 获取滚动距离的绝对值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absDelta</span> <span class="operator">=</span> Math.abs(delta);</span><br><span class="line">    <span class="comment">// 更新LayoutManager的状态，包括布局方向、滚动距离等</span></span><br><span class="line">    updateLayoutState(layoutDirection, absDelta, <span class="literal">true</span>, state);</span><br><span class="line">    <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">            + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">    。。。。</span><br><span class="line">    <span class="comment">//距离大于实际能够滚动的距离，就滚动实际能够滚动的距离，否则滚动请求的距离</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">scrolled</span> <span class="operator">=</span> absDelta &gt; consumed ? layoutDirection * consumed : delta;</span><br><span class="line">    <span class="comment">// 根据实际的滚动距离，移动所有的子视图</span></span><br><span class="line">    mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">    <span class="comment">// 保存实际的滚动距离，以便后续使用</span></span><br><span class="line">    mLayoutState.mLastScrollDelta = scrolled;</span><br><span class="line">    <span class="comment">// 返回实际的滚动距离</span></span><br><span class="line">    <span class="keyword">return</span> scrolled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取填充项和进行回收项"><a href="#获取填充项和进行回收项" class="headerlink" title="获取填充项和进行回收项"></a>获取填充项和进行回收项</h3><p>这里又调用了fill方法，这个方法是用来获取填充项的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			...</span><br><span class="line">            <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">                <span class="comment">//在当前滚动偏移量基础上追加因新表项插入增加的像素（这句话对于“回收哪些表项”来说很关键）</span></span><br><span class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//回收表项</span></span><br><span class="line">                recycleByLayoutState(recycler, layoutState);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!layoutState.mRecycle || layoutState.mInfinite) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</span><br><span class="line">            <span class="comment">// 从列表头回收</span></span><br><span class="line">            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从列表尾回收</span></span><br><span class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="回收条件判断"><a href="#回收条件判断" class="headerlink" title="回收条件判断"></a>回收条件判断</h3><p>这里只看列表头回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向列表尾部滚动时回收滚出屏幕的表项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dt（该参数被用于检测滚出屏幕的表项）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recycleViewsFromStart</span><span class="params">(RecyclerView.Recycler recycler, <span class="type">int</span> scrollingOffset,<span class="type">int</span> noRecycleSpace)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> scrollingOffset - noRecycleSpace;</span><br><span class="line">        <span class="comment">//从头开始遍历 LinearLayoutManager，以找出应该会回收的表项</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="comment">// 如果表项的下边界 &gt; limit 这个阈值</span></span><br><span class="line">            <span class="keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit</span><br><span class="line">                    || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</span><br><span class="line">                <span class="comment">//回收索引为 0 到 i-1 的表项</span></span><br><span class="line">                recycleChildren(recycler, <span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看上面代码中有一个判断条件<code>mOrientationHelper.getDecoratedEnd(child) &gt; limit</code>，***在纵向列表中，“表项底部纵坐标 &gt; 某个值”意味着表项位于某条线的下方，即 limit 是列表中隐形的线，所有在这条线上方的表项都应该被回收。</p>
<p><strong>limit 隐形线</strong>的初始值 &#x3D; 列表当前可见表项的底部到列表底部的距离，即列表在不填充新表项时，可以滑动的最大距离。每一个新填充表项消耗的像素值都会被追加到 limit 值之上，即<strong>limit 隐形线</strong>会随着新表项的填充而不断地下移。</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><h4 id="第一级mCachedViews"><a href="#第一级mCachedViews" class="headerlink" title="第一级mCachedViews"></a>第一级mCachedViews</h4><p>会看代码执行到了<code>recycleChildren(recycler, 0, i);</code>，跟代码最终会调用<code>recycler.recycleView(view);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Recycler </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recycleView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取表项 ViewHolder </span></span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">            <span class="keyword">if</span> (holder.isTmpDetached()) &#123;</span><br><span class="line">                removeDetachedView(view, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                holder.unScrap();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                holder.clearReturnedFromScrapFlag();</span><br><span class="line">            &#125;</span><br><span class="line">            recycleViewHolderInternal(holder);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>getChildViewHolderInt(view)获取的是滑出屏幕的项的ViewHolder，然后交给了recycleViewHolderInternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">mViewCacheMax</span> <span class="operator">=</span> DEFAULT_CACHE_SIZE;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CACHE_SIZE</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">// mCachedViews的长度限制为2</span></span><br><span class="line">    	<span class="comment">// mCachedViews是一个ArrayList</span></span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">                <span class="comment">//先存在mCachedViews里面</span></span><br><span class="line">                <span class="comment">//这里的判断条件决定了复用mViewCacheMax中的ViewHolder时不需要重新绑定数据</span></span><br><span class="line">                <span class="keyword">if</span> (mViewCacheMax &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</span><br><span class="line">                        | ViewHolder.FLAG_REMOVED</span><br><span class="line">                        | ViewHolder.FLAG_UPDATE</span><br><span class="line">                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</span><br><span class="line">                    <span class="comment">//如果mCachedViews大小超限了，则删掉最老的被缓存的ViewHolder</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">cachedViewSize</span> <span class="operator">=</span> mCachedViews.size();</span><br><span class="line">                    <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这里将索引为0的元素放入到回收池RecycledViewPool中  </span></span><br><span class="line">                        recycleCachedViewAt(<span class="number">0</span>);</span><br><span class="line">                        cachedViewSize--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">targetCacheIndex</span> <span class="operator">=</span> cachedViewSize;</span><br><span class="line">                    <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK</span><br><span class="line">                            &amp;&amp; cachedViewSize &gt; <span class="number">0</span></span><br><span class="line">                            &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cacheIndex</span> <span class="operator">=</span> cachedViewSize - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> (cacheIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cachedPos</span> <span class="operator">=</span> mCachedViews.get(cacheIndex).mPosition;</span><br><span class="line">                            <span class="keyword">if</span> (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            cacheIndex--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        targetCacheIndex = cacheIndex + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//ViewHolder加到缓存中</span></span><br><span class="line">                    mCachedViews.add(targetCacheIndex, holder);</span><br><span class="line">                    cached = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若ViewHolder没有入缓存则存入回收池</span></span><br><span class="line">                <span class="keyword">if</span> (!cached) &#123;</span><br><span class="line">                    addViewHolderToRecycledViewPool(holder, <span class="literal">true</span>);</span><br><span class="line">                    recycled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码做了这么一件事，首先判断mCachedViews的元素数量，如果数量超过或者等于2就将最先添加到list的元素放到RecycledViewPool中，然后在mCachedViews中移除它。然后将传入的holder添加到mCachedViews中。</p>
<p>mCachedViews中的数量会限制为两个。移出屏幕的holder最先会添加到mCachedViews中，但是如果mViewCacheMax &lt;&#x3D; 0（setViewCacheSize方法可以修改这个值）或者holder有其中任何一个标识：</p>
<ul>
<li><code>ViewHolder.FLAG_INVALID</code>：表示这个视图是无效的，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_REMOVED</code>：表示这个视图已经被移除。</li>
<li><code>ViewHolder.FLAG_UPDATE</code>：表示这个视图的数据已经更新，需要重新绑定数据。</li>
<li><code>ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN</code>：表示这个视图的适配器位置未知</li>
</ul>
<p>都会将这个移出屏幕的holder越过mCachedViews直接放入RecycledViewPool中。<strong>所以从<code>mCachedViews</code>中复用的<code>ViewHolder</code>不需要重新绑定数据，从RecycledViewPool复用的<code>ViewHolder</code>需要重新绑定数据。</strong></p>
<h4 id="第二级RecycledViewPool"><a href="#第二级RecycledViewPool" class="headerlink" title="第二级RecycledViewPool"></a>第二级RecycledViewPool</h4><p>前面讲到会将mCachedViews中最老的元素放入RecycledViewPool中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存池实例</span></span><br><span class="line">        RecycledViewPool mRecyclerPool;</span><br><span class="line">        <span class="comment">// 将viewHolder存入缓存池</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">addViewHolderToRecycledViewPool</span><span class="params">(ViewHolder holder, <span class="type">boolean</span> dispatchRecycled)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            getRecycledViewPool().putRecycledView(holder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取 RecycledViewPool 实例</span></span><br><span class="line">        RecycledViewPool <span class="title function_">getRecycledViewPool</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRecyclerPool == <span class="literal">null</span>) &#123;</span><br><span class="line">                mRecyclerPool = <span class="keyword">new</span> <span class="title class_">RecycledViewPool</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mRecyclerPool;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RecycledViewPool</span> &#123;</span><br><span class="line">        <span class="comment">// 单类型 ViewHolder 列表</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">            <span class="comment">// 最终存储 ViewHolder 实例的列表</span></span><br><span class="line">            ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//每种类型的 ViewHolder 最多存 5 个</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//键值对:以 viewType 为键，ScrapData 为值，用以存储不同类型的 ViewHolder 列表</span></span><br><span class="line">        SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//ViewHolder 入池 按 viewType 分类入池，相同的 ViewType 存放在同一个列表中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putRecycledView</span><span class="params">(ViewHolder scrap)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewType</span> <span class="operator">=</span> scrap.getItemViewType();</span><br><span class="line">            <span class="comment">// 获取viewType类型的ArrayList</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;</span><br><span class="line">            <span class="comment">//如果超限了，则放弃入池</span></span><br><span class="line">            <span class="keyword">if</span> (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 入回收池之前重置 ViewHolder</span></span><br><span class="line">            scrap.resetInternal();</span><br><span class="line">            <span class="comment">// 最终 ViewHolder 入池</span></span><br><span class="line">            scrapHeap.add(scrap);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> ScrapData <span class="title function_">getScrapDataForType</span><span class="params">(<span class="type">int</span> viewType)</span> &#123;</span><br><span class="line">     		<span class="comment">// 根据type获取ScrapData 这是个静态类</span></span><br><span class="line">            <span class="type">ScrapData</span> <span class="variable">scrapData</span> <span class="operator">=</span> mScrap.get(viewType);</span><br><span class="line">            <span class="keyword">if</span> (scrapData == <span class="literal">null</span>) &#123;</span><br><span class="line">                scrapData = <span class="keyword">new</span> <span class="title class_">ScrapData</span>();</span><br><span class="line">                mScrap.put(viewType, scrapData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> scrapData;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">    		<span class="comment">// 存放ViewHolder的list</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是RecycledViewPool的详细逻辑，首先呢RecycledViewPool中以 viewType 为键，ScrapData 为值使用SparseArray进行存储。且每种类型最多存储5个，多的直接抛弃掉了。	</p>
<h4 id="屏幕内的缓存项"><a href="#屏幕内的缓存项" class="headerlink" title="屏幕内的缓存项"></a>屏幕内的缓存项</h4><p>在RecyclerView的dispatchLayoutStep2方法中会调用LayoutManager的<em>onLayoutChildren</em>方法，这个方法也是子类实现的。还是看LinearLayoutManager 中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> <span class="keyword">extends</span> <span class="title class_">ViewGroup</span> <span class="keyword">implements</span> <span class="title class_">ScrollingView</span>, NestedScrollingChild2 &#123;</span><br><span class="line">    <span class="comment">// RecyclerView布局的第二步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchLayoutStep2</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#LinearLayoutManager </span><br><span class="line">		<span class="comment">// 布局所有子表项</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLayoutChildren</span><span class="params">(Recycler recycler, State state)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在填充表项之前回收所有表项</span></span><br><span class="line">            detachAndScrapAttachedViews(recycler);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 填充表项</span></span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 暂时将当可见表项进行分离并回收</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detachAndScrapAttachedViews</span><span class="params">(Recycler recycler)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">            <span class="comment">// 遍历所有可见表项并回收他们</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">                scrapOrRecycleView(recycler, i, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在将表项一个个填充到列表之前会先将其先回收到<code>mAttachedScrap</code>中,下面看一下scrapOrRecycleView的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#RecyclerView</span><br><span class="line">	<span class="comment">// recycler是负责回收和复用视图的对象，index是需要处理的视图在当前布局中的位置，view是需要处理的视图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scrapOrRecycleView</span><span class="params">(Recycler recycler, <span class="type">int</span> index, View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">viewHolder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder应该被忽略（可能是因为它正在进行删除动画或者还没有绑定数据等原因），则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.shouldIgnore()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;ignoring view &quot;</span> + viewHolder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么从布局中移除这个视图，并将其回收</span></span><br><span class="line">        <span class="keyword">if</span> (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()</span><br><span class="line">                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) &#123;</span><br><span class="line">            removeViewAt(index);</span><br><span class="line">            <span class="comment">// 这里就是走的上面的一二级回收逻辑</span></span><br><span class="line">            recycler.recycleViewHolderInternal(viewHolder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，从布局中分离这个视图，但不回收它，而是将其添加到带复用视图列表中</span></span><br><span class="line">            detachViewAt(index);</span><br><span class="line">            recycler.scrapView(view);</span><br><span class="line">            <span class="comment">// 通知ViewInfoStore这个视图已经被分离，ViewInfoStore是用于存储视图信息的对象，例如视图的位置和大小等</span></span><br><span class="line">            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里会根据viewHolder的状态判断是放入回收池中还是调用scrapView方法放入mAttachedScrap中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">scrapView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过视图获取对应的ViewHolder</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> getChildViewHolderInt(view);</span><br><span class="line">        <span class="comment">// 如果ViewHolder有任何指定的标志，或者没有更新，或者可以复用更新的ViewHolder</span></span><br><span class="line">        <span class="comment">// 那么将这个ViewHolder添加到已附加的废弃视图列表中</span></span><br><span class="line">        <span class="keyword">if</span> (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">            <span class="comment">// 如果ViewHolder是无效的，且没有被移除，且适配器没有稳定的id，那么抛出异常</span></span><br><span class="line">            <span class="comment">// 因为无效的视图不能从视图列表中复用，它们应该从回收池中重新绑定</span></span><br><span class="line">            <span class="keyword">if</span> (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Called scrap view with an invalid view.&quot;</span></span><br><span class="line">                        + <span class="string">&quot; Invalid views cannot be reused from scrap, they should rebound from&quot;</span></span><br><span class="line">                        + <span class="string">&quot; recycler pool.&quot;</span> + exceptionLabel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已附加的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">            mAttachedScrap.add(holder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，如果已改变的废弃视图列表为空，那么创建这个列表</span></span><br><span class="line">            <span class="keyword">if</span> (mChangedScrap == <span class="literal">null</span>) &#123;</span><br><span class="line">                mChangedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置ViewHolder的废弃容器为当前的Recycler，并将其添加到已改变的废弃视图列表中</span></span><br><span class="line">            holder.setScrapContainer(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line">            mChangedScrap.add(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>放入mAttachedScrap中还是放入mChangedScrap取决于ViewHolder的状态。</p>
<p>mChangedScrap主要的使用场景是：</p>
<ol>
<li>开启了列表项动画(itemAnimator)，并且列表项动画的<code>canReuseUpdatedViewHolder(ViewHolder viewHolder)</code>方法返回false的前提下；</li>
<li>调用了notifyItemChanged、notifyItemRangeChanged这一类方法，通知列表项数据发生变化；</li>
</ol>
<p><strong>mChangedScrap主要是为列表项数据发生变化时的动画效果服务的</strong>。</p>
<p><strong>mAttachedScrap应对的则是剩下的绝大部分场景</strong>，比如：</p>
<ul>
<li>像notifyItemMoved、notifyItemRemoved这种列表项发生移动，但列表项数据本身没有发生变化的场景。</li>
<li>关闭了列表项动画，或者列表项动画的canReuseUpdatedViewHolder方法返回true，即允许重用原先的ViewHolder对象的场景。</li>
</ul>
<p>最后在dispatchLayoutStep3方法也就是布局的最后一个阶段会将mChangedScrap和mAttachedScrap里的内容清空。</p>
<p>这2个缓存结构实际上更多是为了避免出现像<em><strong>局部刷新</strong></em>这一类的操作，导致所有的列表项都需要重绘的情形。在预布局会有解释。</p>
<p>结论：**<code>mAttachedScrap</code>用于屏幕中可见表项的回收和复用，生命周期起始于<code>RecyclerView</code>布局开始，终止于<code>RecyclerView</code>布局结束。**</p>
<p>回收部分到此为止</p>
<h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><h4 id="复用时机"><a href="#复用时机" class="headerlink" title="复用时机"></a>复用时机</h4><p><em><strong>当移出屏幕的项重新回到界面</strong></em></p>
<p>回顾上面LayoutManager类的scrollBy方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scrollBy</span><span class="params">(<span class="type">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 填充视图并返回实际滚动的距离。这里的consumed表示实际能够滚动的距离，可能会小于请求的滚动距离</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">consumed</span> <span class="operator">=</span> mLayoutState.mScrollingOffset</span><br><span class="line">                + fill(recycler, mLayoutState, state, <span class="literal">false</span>);</span><br><span class="line">        。。。。</span><br><span class="line">        <span class="keyword">return</span> scrolled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用fill方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="type">int</span> <span class="title function_">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="type">boolean</span> stopOnFocusable)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainingSpace</span> <span class="operator">=</span> layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        <span class="type">LayoutChunkResult</span> <span class="variable">layoutChunkResult</span> <span class="operator">=</span> mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//不断循环获取新的表项用于填充，直到没有填充空间</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//填充新的表项</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">			</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutChunk方法就是填充新的项，看下一这个方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#LinearLayoutManager </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> &#123;</span><br><span class="line">        <span class="comment">//获得下一个表项</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> layoutState.next(recycler);</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将表项插入到列表中</span></span><br><span class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">                addView(view);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的layoutState.next(recycler);就是用来获取下一项的，获取后将它添加到ViewGroup中。next最终就会调用到tryGetViewHolderForPositionByDeadline方法中这个方法真正实现的复用逻辑。</p>
<h4 id="复用逻辑"><a href="#复用逻辑" class="headerlink" title="复用逻辑"></a>复用逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecyclerView</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Recycler</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获得指定位置的ViewHolder，要么从scrap，cache，RecycledViewPool中获取，要么直接重新创建</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        ViewHolder <span class="title function_">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="type">int</span> position,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> dryRun, <span class="type">long</span> deadlineNs)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">fromScrapOrHiddenOrCache</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">ViewHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//0 从changed scrap集合中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">                holder = getChangedScrapViewForPosition(position);</span><br><span class="line">                fromScrapOrHiddenOrCache = holder != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1. 通过position从attach scrap或一级回收缓存中获取ViewHolder</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">                <span class="comment">//2. 通过id在attach scrap集合和一级回收缓存中查找viewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                            type, dryRun);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3. 从自定义缓存中获取ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span> &amp;&amp; mViewCacheExtension != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">                    <span class="comment">// know it.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViewCacheExtension</span><br><span class="line">                            .getViewForPositionAndType(<span class="built_in">this</span>, position, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4.从缓存池中拿ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">                    ...</span><br><span class="line">                    holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//所有缓存都没有命中，只能创建ViewHolder</span></span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    holder = mAdapter.createViewHolder(RecyclerView.<span class="built_in">this</span>, type);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">bound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">                <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">                holder.mPreLayoutPosition = position;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只有invalid的viewHolder才能绑定视图数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offsetPosition</span> <span class="operator">=</span> mAdapterHelper.findPositionOffset(position);</span><br><span class="line">                <span class="comment">//获得ViewHolder后，绑定视图数据</span></span><br><span class="line">                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结上面代码：</p>
<p>上面设计到的数据结构有四个mChangedScrap、mAttachedScrap、mCachedViews、RecycledViewPool</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewHolder&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ScrapData</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> ArrayList&lt;ViewHolder&gt; mScrapHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">mMaxScrap</span> <span class="operator">=</span> DEFAULT_MAX_SCRAP;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mCreateRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">mBindRunningAverageNs</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   SparseArray&lt;ScrapData&gt; mScrap = <span class="keyword">new</span> <span class="title class_">SparseArray</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>代码检索总共会检索5次，第一次从mChangedScrap检索，第二次通过position从attach scrap或一级回收缓存中获取ViewHolder，第三次通过id在attach scrap集合和一级回收缓存中查找viewHolder，第四次从自定义缓存中获取ViewHolder，第五次从缓存池中拿ViewHolder，如果五次检索完都没有的画就会新创建一个viewHolder。</p>
<table>
<thead>
<tr>
<th>缓存结构</th>
<th>容器类型</th>
<th>容量限制</th>
<th>缓存用途</th>
<th>优先级顺序(数值越小，优先级越高)</th>
</tr>
</thead>
<tbody><tr>
<td>mChangedScrap&#x2F;mAttachedScrap</td>
<td>ArrayList</td>
<td>无，一般为屏幕内总的可见列表项数</td>
<td>临时存放仍在当前屏幕可见、但被标记为「移除」或「重用」的列表项</td>
<td>0</td>
</tr>
<tr>
<td>mCachedViews</td>
<td>ArrayList</td>
<td>默认为2</td>
<td>存放已被移出屏幕、但有可能很快重新进入屏幕的列表项</td>
<td>1</td>
</tr>
<tr>
<td>mViewCacheExtension</td>
<td>开发者自己定义</td>
<td>无</td>
<td>提供额外的可由开发人员自由控制的缓存层级</td>
<td>2</td>
</tr>
<tr>
<td>mRecyclerPool</td>
<td>SparseArray<ArrayList></td>
<td>每种itemType默认为5</td>
<td>按不同的itemType分别存放超出mCachedViews限制的、被移出屏幕的列表项</td>
<td>3</td>
</tr>
</tbody></table>
<h4 id="“mAttachedScrap用于屏幕中可见表项的回收和复用”"><a href="#“mAttachedScrap用于屏幕中可见表项的回收和复用”" class="headerlink" title="“mAttachedScrap用于屏幕中可见表项的回收和复用”"></a>“mAttachedScrap用于屏幕中可见表项的回收和复用”</h4><p>这是RecyclerView特殊的pre-layout &amp; post-layout 机制的产物。举个简单的例子，列表有1-4个表项，现删除了第3个表项，这会触发layout过程，RecyclerView的layout有好多个阶段，第一阶段列表的4个表项对应的ViewHolder都会被存入scrap列表，layout的最后阶段会去取用于用于展示的表项（1，2，4，5），此时1，2，4表项就可以从scap中获取，而5从recycler pool中获取</p>
<h3 id="预布局"><a href="#预布局" class="headerlink" title="预布局"></a>预布局</h3><p><a href="https://juejin.cn/post/6892809944702124045">https://juejin.cn/post/6892809944702124045</a></p>
<p><a href="https://juejin.cn/post/7181979065488769083">https://juejin.cn/post/7181979065488769083</a></p>
<p><a href="https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/6844904146684870669?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC">https://juejin.cn/post/7173816645511544840?searchId=20240116110602170B75B8DFFE106D03DC</a></p>
<p><a href="https://juejin.cn/post/6844903778303361038">https://juejin.cn/post/6844903778303361038</a></p>
]]></content>
  </entry>
  <entry>
    <title>Kotlin flow</title>
    <url>/2024/03/26/kotlin%20flow/</url>
    <content><![CDATA[<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​		在<strong>协程</strong>中，与仅返回单个值的挂起函数相反，Flow可按顺序发出多个值, 它以协程为基础构建，可提供多个值，从概念上来讲，Flow是可通过异步方式进行计算处理的一组数据序列，所发出值的类型必须相同。</p>
<p>​		Flow 需要在协程中使用, 因此配合协程，可以方便地切线程。</p>
<p>​		<strong>为什么需要Flow</strong>？flow既能提供异步线程框架，又能处理数据，相当于是协程+liveData的结合体。并且flow可以随协程取消，并且处理更复杂的数据流，也可以设置数据重发量并解决背压，这是LiveData做不到的。就是在写法上可能会有坑，操作符相对LiveData比较复杂，处理起来也比较麻烦，比如<code>collect</code>末端操作符要注意不能影响到主线程。</p>
<p>​		LiveData API设计得过于简单，难以应对Repository层可能出现的许多复杂的数据处理场景。</p>
<p>主要体现在以下三个方面：</p>
<ol>
<li>不支持线程切换</li>
<li>不支持背压处理</li>
<li>重度依赖 Lifecycle</li>
</ol>
<p>​		冷流就无法在构造器以外发射数据。</p>
<p>​		在 Kotlin 中，冷流（Cold Flow）是指在订阅者开始收集之前不会开始发射数据的流。这意味着冷流通常在每个新的收集操作中从头开始发射数据。</p>
<p>​		它无法在构造器之外发射数据，因为在流构造器外部发射数据会违反其冷流的特性。</p>
<p><strong>冷数据流</strong>:</p>
<ul>
<li>当执行订阅的时候，上游发布者才开始发射数据流。</li>
<li>订阅者与发布者是<strong>一一对应</strong>的关系，即当存在多个订阅者时，每个新的订阅者都会重新收到完整的数据。</li>
</ul>
<blockquote>
<p>​	如果是进行数据库查询操作每个订阅者都会发生一次查询，所以可以说冷流是一对一的。</p>
</blockquote>
<ul>
<li>flow 是冷流，<strong>flow有了订阅者 Collector 之后，发射出来的值才会实实在在的存在于内存之中</strong>，跟懒加载的概念很像。</li>
</ul>
<p><strong>热数据流</strong>:</p>
<ul>
<li><p><strong>从数据流收集数据不会触发任何提供方代码</strong>，不管是否被订阅，上游发布者都会发送数据流到内存中。</p>
</li>
<li><p>订阅者与发布者是<strong>一对多</strong>的关系，当上游发送数据时，多个订阅者都会收到消息。</p>
<blockquote>
<p>订阅者收到的消息都是最新的，意味着不会获取之前的消息。在这一时刻收集者的消息是同步的。</p>
</blockquote>
</li>
<li><p>StateFlow&#x2F;SharedFlow 是热流。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403131437875.png" alt="image-20240313143706797"></p>
<p>在<em>Cold Flow</em>中，在多个收集器的情况下，完整的流程将从每个收集器的开始而开始，执行任务并将值发送到它们相应的收集器。这就像一对一的映射。1个收集器的1个生产流量。这意味着冷流不能有多个收集器，因为它将为每个收集器创建一个新流。</p>
<p>在<em>Hot Flow</em>中，在多个收集器的情况下，流将继续发出值，收集器从它们开始收集的地方获取值。这就像 1 对 N 映射，N 个收集器对应1个生产流量，这意味着一个热流可以有多个收集器。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testFlow3</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">var</span> flow = flow &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.1000</span>) &#123;</span><br><span class="line">                emit(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.filter &#123; it &gt; <span class="number">500</span> &amp;&amp; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        flow.collect &#123;</span><br><span class="line">            println(<span class="string">&quot;value=<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">打印：</span><br><span class="line">打印的都是符合 it &gt; <span class="number">500</span> &amp;&amp; it % <span class="number">2</span> == <span class="number">0</span> 条件的数字</span><br></pre></td></tr></table></figure>

<p>flow调用流程</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403121738444.webp" alt="image.png"></p>
<p>从图片中可以看出如果不调用collect的话就不会调用emit函数。</p>
<h3 id="源码详解"><a href="#源码详解" class="headerlink" title="源码详解"></a>源码详解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123; emit(<span class="number">1</span>) &#125;.collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码一共包含三部分： flow闭包 &rarr;  emit &rArr; collect闭包</p>
<p><strong>生产者(flow函数）</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; = SafeFlow(block)</span><br></pre></td></tr></table></figure>

<p>​		传入的参数类型为：FlowCollector的扩展函数，而FlowCollector是接口，它有唯一的函数：emit(xx)。因此在flow函数的闭包里可以调用emit(xx)函数，flow闭包作为SafeFlow的成员变量block。<br> flow 函数返回SafeFlow，SafeFlow继承自AbstractFlow，AbstractFlow实现了collect函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#AbstractFlow.kt</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(SafeCollector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//构造SafeCollector</span></span><br><span class="line">        <span class="comment">//collector 作为SafeCollector的成员变量</span></span><br><span class="line">        <span class="keyword">val</span> safeCollector = SafeCollector(collector, coroutineContext)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//抽象函数，子类实现</span></span><br><span class="line">            collectSafely(safeCollector)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            safeCollector.releaseIntercepted()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>collect的闭包作为SafeCollector的成员变量collector，后面会用到。由此可见：flow函数仅仅只是构造了flow对象并返回。</p>
<p><strong>消费者(collect)</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// collect 方法在父类 AbstractFlow 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFlow</span>&lt;<span class="type">T</span>&gt; : <span class="type">Flow</span>&lt;<span class="type">T</span>&gt;, <span class="type">CancellableFlow</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> safeCollector = SafeCollector(collector, coroutineContext)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            collectSafely(safeCollector)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            safeCollector.releaseIntercepted()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># SafeFlow</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SafeFlow</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="built_in">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		collect 方法中通过 collector 封装了一个 SafeCollector 对象，并以其为参数执行了 SafeFlow.collectSafely 方法，而 collectSafely 方法只是执行了 block 代码块(<code>collector.block()</code>)，它是一个扩展函数，所以执行的示例代码中的 emit(1) 其实就是调用了 SafeCollector.emit(1)。</p>
<p><strong>小结：<code>flow &#123;&#125;</code> 方式(或flowOf, asFlow)创建的 Flow 实例是 SafeFlow 类型，其父类是 AbstractFlow 抽象类，当调用其 collect(FlowCollector) 方法时，首先会执行该 Flow 对象传入的 block 代码块，代码块中一般会有 emit 方法发射值，这个 emit 调用的就是 AbstractFlow.emit 方法，在其中做了安全判定后，会接着调用到 collect 中传入的 FlowCollector.emit 方法，对于 <code>collect &#123;&#125;</code> 的情况，emit 方法内部就是执行 collect 传入的 action 代码块。因为它在每次调用 collect 时才去触发发送数据的动作，所以说 Flow 是冷流</strong>。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403121812507.webp" alt="img"></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><strong>中间操作符</strong><br> 前面说过流的三要素：原始数据、对数据的操作、最终数据，对应到Flow上也是一样的。<br> flow的闭包里我们看做是原始数据，而filter、map、catch等看做是对数据的操作，collect闭包里看做是最终的数据。<br> filter、map等操作符属于中间操作符，它们负责对数据进行处理。</p>
<blockquote>
<p>中间操作符仅仅只是预先定义一些对流的操作方式，并不会主动触发动作执行</p>
</blockquote>
<p><strong>末端操作符</strong><br> 末端操作符也叫做终端操作符，调用末端操作符后，Flow将从上流发出数据，经过一些列中间操作符处理后，最后流到下流形成最终数据。<br> 如上面的collect操作符就是其中一种末端操作符。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">filter</span><span class="params">(<span class="keyword">crossinline</span> predicate: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: Flow&lt;T&gt; = transform &#123; value -&gt;</span><br><span class="line">    <span class="comment">//判断过滤条件是否满足，若是则发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (predicate(value)) <span class="keyword">return</span><span class="symbol">@transform</span> emit(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">unsafeTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@BuilderInference</span> <span class="keyword">crossinline</span> transform: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">R</span>&gt;.(<span class="type">value</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Flow&lt;R&gt; = unsafeFlow &#123; </span><br><span class="line">    <span class="comment">//调用当前对象collect</span></span><br><span class="line">    collect &#123; value -&gt;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@collect</span> transform(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">unsafeFlow</span><span class="params">(<span class="meta">@BuilderInference</span> <span class="keyword">crossinline</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//构造flow，重写collect</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span> : Flow&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            collector.block()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		filter操作符构造了新的flow对象，该对象重写了collect函数。当调用flow.collect时，先调用到filter对象的collect，进而调用到原始flow的collect，接着调用到原始flow对象的闭包，在闭包里调用的emit即为filter的闭包，<strong>若filter闭包里条件满足则调动emit函数，最后调用到collect的闭包。</strong></p>
<p>​		简单来说就是使用装饰者模式对原flow对象的collect方法进行装饰，添加当前操作符的功能。</p>
<p>理解中间操作符的要点：</p>
<blockquote>
<ol>
<li>中间操作符返回新的flow对象，重写了collect函数</li>
<li>collect函数会调用当前flow(调用filter的flow对象)的collect</li>
<li>collect函数做对应操作符的逻辑处理</li>
</ol>
</blockquote>
<h4 id="flowOn"><a href="#flowOn" class="headerlink" title="flowOn"></a>flowOn</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">flowOn</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: Flow&lt;T&gt; &#123;</span><br><span class="line">    checkFlowContext(context)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="comment">// 返回自身 Flow 实例</span></span><br><span class="line">        <span class="comment">// 这里我们传入了 Dispatchers.Default, 所以不符合这个条件</span></span><br><span class="line">        context == EmptyCoroutineContext -&gt; <span class="keyword">this</span></span><br><span class="line">        <span class="comment">// SafeFlow 不是该类型，因此也不走这个流程，实际上 FusibleFlow 是当连续多次调用 flowOn 后会创建的 Flow 对象</span></span><br><span class="line">        <span class="keyword">this</span> <span class="keyword">is</span> FusibleFlow -&gt; fuse(context = context)</span><br><span class="line">        <span class="comment">// 逻辑走到这里</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; ChannelFlowOperatorImpl(<span class="keyword">this</span>, context = context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">flow &#123; emit(<span class="number">1</span>) &#125;.flowOn(Dispatchers.Default).collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<p>​		上述实例代码转换一下即为: <code>SafeFlow.flowOn.collect &#123;&#125; --&gt; ChannelFlowOperatorImpl.collect &#123;&#125;</code>, 这里<strong>注意一下创建 ChannelFlowOperatorImpl 对象时传入的两个参数，第一个 this 指的是之前的 SafeFlow 对象，第二个 context 参数即是我们传入的调度器，它是一个协程上下文</strong>。</p>
<p>produceImpl 方法就是启动了一个新的协程，然后在协程中执行上层 flow 对象(所以 flowOn 会对它上游的部分起作用)中的代码块(里面调用了 SendingCollector.emit 方法)，然后通过 Channel.send 方法把这个 value 发送出去。此时运行中 flowOn 指定的线程中。</p>
<p>​		collector.emitAll 方法会通过上面的 channel 对象接收数据，并调用 FlowCollector.emit 方法来发射数据，最后执行到 <code>SafeFlow.flowOn.collect &#123;&#125;</code> collect 代码块中的逻辑。此时运行在父协程指定的线程中。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>​		通常我们需要在Repository层获取网络数据或者获取本地、内存的数据，有时候不同数据源的数据是需要进行结合或者变换的，所以这里用到Flow的可能性是比较大的。Repository对数据进行处理后，ViewModel拿到的其实就是一个完整可用的数据结构了，ViewModel就可以简单地用LiveData完成与UI层的数据传递。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flow处理Repository层数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObservableUserHome</span><span class="params">(username: <span class="type">String</span>)</span></span>: Flow&lt;Home?&gt; &#123;</span><br><span class="line">        <span class="comment">// 本地数据</span></span><br><span class="line">        <span class="keyword">return</span> UserDB.getUserHome(username)</span><br><span class="line">            <span class="comment">// 数据转换</span></span><br><span class="line">            .map &#123; Home(<span class="string">&quot;a&quot;</span>) &#125;</span><br><span class="line">            <span class="comment">// 网络数据</span></span><br><span class="line">            .flatMapConcat &#123;</span><br><span class="line">                flow &#123;</span><br><span class="line">                    emit(userService.getUserHome(User(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)).body())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flow并行协程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObservableUser</span><span class="params">(username: <span class="type">String</span>)</span></span>: Flow&lt;User?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> withContext(Dispatchers.Default) &#123;</span><br><span class="line">            flowOf(</span><br><span class="line">                <span class="comment">// 本地数据</span></span><br><span class="line">                UserDB.getObservableUser(username),</span><br><span class="line">                <span class="comment">// 网络数据</span></span><br><span class="line">                userService.getObservableUser(username).map &#123; it.body() &#125;</span><br><span class="line">            ).flattenConcat()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>getObservableUserHome</code>方法获取了本地数据之后，再经过一次数据转换，再去获取网络数据。这是典型的串行任务，如果没有串行任务就更简单了，去掉<code>flatMapConcat</code>就可以了。</p>
<p><code>getObservableUser</code>则是并行任务，获取本地数据和网络数据的两个flow是并发执行的。这里需要注意<code>flattenConcat()</code>操作符只能先接收前一个flow的<code>emit</code>，再接收后一个flow的<code>emit</code>。</p>
<p>在ViewModel层调用Repository层的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserViewModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObservableUser</span><span class="params">(userName: <span class="type">String</span>)</span></span>: LiveData&lt;User?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.getObservableUser(userName).asLiveData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getObservableUserHome</span><span class="params">(userName: <span class="type">String</span>)</span></span>: LiveData&lt;Home?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.getObservableUserHome(userName).asLiveData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UI层调用ViewModel方法就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    lifecycleScope.launchWhenCreated &#123;</span><br><span class="line">        viewModel.getObservableUser(<span class="string">&quot;&quot;</span>).observe(<span class="keyword">this</span><span class="symbol">@CoroutineActivity</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.getObservableUserHome(<span class="string">&quot;&quot;</span>).observe(<span class="keyword">this</span><span class="symbol">@CoroutineActivity</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://juejin.cn/post/7224145268740325435?searchId=2024031216310771AB22842B74E9535181">当，Kotlin Flow与Channel相逢</a></p>
<p><a href="https://juejin.cn/post/6966047022814232613">Kotlin协程之flow工作原理</a></p>
<p><a href="https://juejin.cn/post/7168511169781563428?searchId=2024031216310771AB22842B74E9535181#heading-5">Kotlin Flow啊，你将流向何方？</a></p>
<p><a href="https://juejin.cn/post/7298628950409019428?searchId=2024031216310771AB22842B74E9535181#heading-11">一文快速实战Kotlin协程与Flow</a></p>
<p><a href="https://juejin.cn/post/7031726493906829319?searchId=2024031118324076E557B5EED382D6FC41#heading-12">用Kotlin Flow解决Android开发中的痛点问题</a></p>
<p><a href="https://juejin.cn/post/7298628950409019428?searchId=2024031216310771AB22842B74E9535181#heading-11">一文快速实战Kotlin协程与Flow</a></p>
<p><a href="https://juejin.cn/post/7336751931375648820?searchId=2024031216310771AB22842B74E9535181">Flow操作符</a></p>
<h2 id="SharedFlow-StateFlow"><a href="#SharedFlow-StateFlow" class="headerlink" title="SharedFlow&#x2F;StateFlow"></a>SharedFlow&#x2F;StateFlow</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>​		StateFlow 和 SharedFlow 是热流，生产数据不依赖消费者消费，热流与消费者是一对多的关系，当有多个消费者时，它们之间的数据都是同一份。</p>
<p>​		 StateFlow 和 SharedFlow 分别是用来处理 <code>状态(state)</code> 和 <code>事件(event)</code> 的，它称呼 StateFlow 是 <code>a state-holder observable</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> uiState: StateFlow&lt;LatestNewsUiState&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tickFlow: SharedFlow&lt;Event&lt;String&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>对 UI 而言，state 是 UI 组件的状态，它应当始终都有一个值来表示其状态，且当有新的订阅者加入时，它也应知道当前的状态，即 StateFlow 的粘性。</li>
<li>而 event 事件只有在发生某些动作后才会触发，不需要有初始值。SharedFlow 默认非粘性的，当新的订阅者加入时，它不会重复发生已经发生过的事件。</li>
<li>对于状态而言，即使多次发送，我们只关注最新的状态；对于事件而言，如果多次发送，我们不想丢失任何一个前台的事件。</li>
</ul>
<p>​		当 <code>SharedFlow</code> 发送事件时，如果没有任何订阅者（观察者），那么这个事件将被丢弃，不会存储在 <code>SharedFlow</code> 的缓冲区中。</p>
<p>​		在MVI架构中StateFlow来承担Model（UI集合状态），ShareFlow来承担Intent（事件意图）。</p>
<p>​			</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>定义：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _state = MutableStateFlow(AppState(counter = <span class="number">0</span>))</span><br><span class="line"><span class="keyword">val</span> state = _state.asStateFlow()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _events = MutableSharedFlow&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> events = _events.asSharedFlow()</span><br></pre></td></tr></table></figure>

<p>发射数据：</p>
<p><strong>对于 MutableStateFlow：</strong></p>
<ul>
<li>直接赋值：state.value &#x3D; newState</li>
<li>原子更新：state.update { currentState -&gt; newState }</li>
</ul>
<p><strong>对于 MutableSharedFlow：</strong></p>
<ul>
<li>发射事件：events.emit(event)</li>
<li>尝试发射事件（非挂起）：events.tryEmit(event)</li>
</ul>
<p>订阅数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Observing state</span></span><br><span class="line">viewModel.state.collect &#123; appState -&gt;</span><br><span class="line">	println(<span class="string">&quot;Current counter value: <span class="subst">$&#123;appState.counter&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Observing events</span></span><br><span class="line">viewModel.events.collect &#123; event -&gt;</span><br><span class="line">    println(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际的配套使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _state = MutableStateFlow(AppState(counter = <span class="number">0</span>))</span><br><span class="line"><span class="keyword">val</span> state = _state.asStateFlow()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _events = MutableSharedFlow&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> events = _events.asSharedFlow()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processIntent</span><span class="params">(intent: <span class="type">AppIntent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (intent) &#123;</span><br><span class="line">        AppIntent.Increment -&gt; &#123;</span><br><span class="line">            <span class="comment">// AppState 是一个不可变的数据类（使用 data class 定义）。不可变对象的一个好处是它们是线程安全的，可以避免在并发环境下出现问题。通过使用 copy 方法，我们可以保持 AppState 的不可变性，同时更新状态。</span></span><br><span class="line">            <span class="keyword">val</span> newState = _state.value.copy(counter = _state.value.counter + <span class="number">1</span>)</span><br><span class="line">            _state.value = newState</span><br><span class="line">            _events.tryEmit(<span class="string">&quot;Counter incremented&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Model</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">AppState</span>(<span class="keyword">val</span> counter: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Intent</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">AppIntent</span> &#123;</span><br><span class="line">    <span class="keyword">object</span> Increment : AppIntent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> viewModel = AppViewModel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observing state</span></span><br><span class="line">    viewModel.state.collect &#123; appState -&gt;</span><br><span class="line">        println(<span class="string">&quot;Current counter value: <span class="subst">$&#123;appState.counter&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Observing events</span></span><br><span class="line">    viewModel.events.collect &#123; event -&gt;</span><br><span class="line">        println(<span class="string">&quot;Event: <span class="variable">$event</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sending intents</span></span><br><span class="line">    viewModel.processIntent(AppIntent.Increment)</span><br><span class="line">    viewModel.processIntent(AppIntent.Increment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码详解-1"><a href="#源码详解-1" class="headerlink" title="源码详解"></a>源码详解</h3><p>ShareFlow：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableSharedFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    replay: <span class="type">Int</span> = <span class="number">0</span>, <span class="comment">// 重放数据个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    extraBufferCapacity: <span class="type">Int</span> = <span class="number">0</span>, <span class="comment">// 额外缓存容量</span></span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND <span class="comment">// 缓存溢出策略</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MutableShared</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">BufferOverflow</span> &#123;</span><br><span class="line">    <span class="comment">// 挂起</span></span><br><span class="line">    SUSPEND,</span><br><span class="line">    <span class="comment">// 丢弃最早的一个</span></span><br><span class="line">    DROP_OLDEST,</span><br><span class="line">    <span class="comment">// 丢弃最近的一个</span></span><br><span class="line">    DROP_LATEST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要有三个参数：</p>
<ul>
<li>replay: 新订阅者 collect 时，发送 replay 个历史数据给它，默认新订阅者不会获取以前的数据。</li>
<li>extraBufferCapacity: MutableSharedFlow 缓存的数据个数为 replay + extraBufferCapacity; 缓存一方面用于粘性事件的发送，另一方面也为了处理背压问题，既下游的消费者的消费速度低于上游生产者的生产速度时，数据会被放在缓存中。</li>
<li>onBufferOverflow: 背压处理策略，缓存区满后怎么处理(挂起或丢弃数据)，默认挂起。注意，当没有订阅者时，只有最近 replay 个数的数据会存入缓存区，不会触发 onBufferOverflow 策略。</li>
</ul>
<p>StateFlow:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableStateFlow</span><span class="params">(value: <span class="type">T</span>)</span></span>: MutableStateFlow&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>​		构造函数只需传入一个初始值，它本质上是一个 replay &#x3D; 1 且没有缓冲区的 SharedFlow, 因此在第一次订阅时会先获取到初始值。</p>
<p>​		<strong>当新订阅者开始从数据流中收集数据时，它将接收信息流中的最近一个状态及任何后续状态</strong>，类似于LiveData。 StateFlow 使用 CAS 方式赋值，且默认防抖。基于此特性，适合描述 android 中的 Ui 状态。</p>
<p>​		</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># StateFlowImpl</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">expect</span>: <span class="type">T</span>, update: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        updateState(<span class="keyword">expect</span> ?: NULL, update ?: NULL)</span><br></pre></td></tr></table></figure>

<p>每次更新数据都会和旧数据做一次比较，只有不同时候才会更新数值。具有防抖的特性。</p>
<h3 id="冷流转热流"><a href="#冷流转热流" class="headerlink" title="冷流转热流"></a>冷流转热流</h3><p><strong>shareIn 转换：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">shareIn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scope: <span class="type">CoroutineScope</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    started: <span class="type">SharingStarted</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    replay: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: SharedFlow&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>有三个参数：</p>
<ul>
<li>scope: 用于共享数据流的 CoroutineScope, 此作用域函数的生命周期应长于任何使用方，使共享数据流在足够长的时间内保持活跃状态。</li>
<li>started: 启动策略</li>
<li>replay: 同上 replay 含义</li>
</ul>
<p>started 有三种取值：</p>
<ul>
<li>Eagerly: 立即启动，到 scope 作用域被结束时停止</li>
<li>Lazily: 当存在首个订阅者时启动，到 scope 作用域被结束时停止</li>
<li>WhileSubscribed: 在没有订阅者的情况下取消订阅上游数据流，避免不必要的资源浪费</li>
</ul>
<p>对于只执行一次的操作，可以使用 Lazily 或 Eagerly, 否则可以使用 WhileSubscribed 来实现一些优化。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">WhileSubscribed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    stopTimeoutMillis: <span class="type">Long</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    replayExpirationMillis: <span class="type">Long</span> = <span class="built_in">Long</span>.MAX_VALUE</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: SharingStarted</span><br></pre></td></tr></table></figure>

<p>它支持两个参数：</p>
<ul>
<li>stopTimeoutMillis: 最后一个订阅者结束订阅后多久停止订阅上游流</li>
<li>replayExpirationMillis: 数据 replay 的过时时间，超出时间后，新订阅者不会收到历史数据</li>
</ul>
<p><strong>stateIn 转换：</strong></p>
<p>和 SharedFlow 类似，也可以用 stateIn 将普通流转化成 StateFlow:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">stateIn</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    scope: <span class="type">CoroutineScope</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    started: <span class="type">SharingStarted</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    initialValue: <span class="type">T</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: StateFlow&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>跟 shareIn 不同的是需要传入一个初始值。</p>
<h3 id="StateFlow和ShareFlow对比"><a href="#StateFlow和ShareFlow对比" class="headerlink" title="StateFlow和ShareFlow对比"></a>StateFlow和ShareFlow对比</h3><ul>
<li>StateFlow就是一个replaySize&#x3D;1的sharedFlow,同时它必须有一个初始值，此外，每次更新数据都会和旧数据做一次比较，只有不同时候才会更新数值。</li>
<li>StateFlow<strong>重点在状态</strong>，ui永远有状态，所以StateFlow必须有初始值，同时对ui而言，过期的状态毫无意义，所以stateFLow永远更新最新的数据（和liveData相似），所以必须有粘滞度&#x3D;1的粘滞事件，让ui状态保持到最新。另外在一个时间内发送多个事件，不会管中间事件有没有消费完成都会执行最新的一条.(中间值会丢失)</li>
<li>SharedFlow<strong>侧重在事件</strong>，当某个事件触发，发送到队列之中，按照挂起或者非挂起、缓存策略等将事件发送到接受方，在具体使用时，SharedFlow更适合通知ui界面的一些事件，比如toast等，也适合作为viewModel和repository之间的桥梁用作数据的传输。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403131437907.png" alt="image-20240313143753850"></p>
<h5 id="A-SharedFlow"><a href="#A-SharedFlow" class="headerlink" title="A.SharedFlow"></a>A.SharedFlow</h5><ul>
<li>对于同一个数据流，可以允许有多个订阅者共享。</li>
<li>不调用<code>collect</code>收集数据，也会开始发送数据。</li>
<li>允许缓存历史数据(默认是非粘性，当设置缓存数据后即可实现为粘性, replay &#x3D; 1)</li>
<li>发送数据函数都是线程安全的。</li>
<li>不防抖。可以发送相同的值</li>
<li>无初始化值</li>
</ul>
<h5 id="B-StateFlow"><a href="#B-StateFlow" class="headerlink" title="B.StateFlow"></a>B.StateFlow</h5><ul>
<li>都允许多个消费者</li>
<li>都有只读与可变类型</li>
<li>永远只保存一个状态值，会把最新值重现给订阅者，即粘性。</li>
<li>防抖。设置重复的值不会重新发送给订阅者</li>
<li>必须传入初始值，保证值的空安全，永远有值</li>
</ul>
<h5 id="C-StateFlow与LiveData不同的是"><a href="#C-StateFlow与LiveData不同的是" class="headerlink" title="C. StateFlow与LiveData不同的是"></a>C. StateFlow与LiveData不同的是</h5><ul>
<li><strong>强制要求</strong>初始默认值</li>
<li>支持CAS模式赋值</li>
<li>默认支持<strong>防抖</strong> <strong>过滤</strong></li>
<li>value的空安全校验</li>
<li><code>Flow</code>丰富的异步数据流操作</li>
<li>默认没有<code>Lifecycle</code>支持，<code>flow</code>的<code>collect</code>是挂起函数，会一直等待数据流传递数据</li>
<li><strong>线程安全</strong>，<code>LiveData</code>的<code>postValue</code>虽然也可在异步使用，但会导致数据丢失。</li>
</ul>
<p>LiveData除了对于<code>Lifecycle</code>的支持，<code>StateFlow</code>基本都是处于优势</p>
<h3 id="与LiveData对比"><a href="#与LiveData对比" class="headerlink" title="与LiveData对比"></a>与LiveData对比</h3><p>LiveData的优势：</p>
<p>使用简单，轻量级，可感知生命周期，可观察</p>
<p>​		简单的组件可能功能不够强大，强大的组件用起来一般都比较复杂，二者不可兼得，然而无论是组件还是架构，合适的才是最好的</p>
<p>​		一般而言，对于 View 和 ViewModel 之间简单的响应式开发，使用 LiveData 就足够了，而对于一些复杂场景(切换线程，数据流变换等)，可以考虑使用 Flow 来处理异步数据流。</p>
<h3 id="与Flow对比"><a href="#与Flow对比" class="headerlink" title="与Flow对比"></a>与Flow对比</h3><p>实际举例：</p>
<p>​	创建Flow</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AccountManager &#123;</span><br><span class="line">    <span class="keyword">val</span> testFlow: Flow&lt;DaoTestBean?&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        AppDatabase.getInstance().testDao().getTestFlow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	订阅者角色</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launch &#123;</span><br><span class="line">    AccountManager.testFlow.flowWithLifecycle(lifecycle, Lifecycle.State.STARTED).collect &#123;</span><br><span class="line">        binding.main1Tv.text = <span class="string">&quot;<span class="subst">$&#123;it?.lastUseTime&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		testFlow 是冷流，订阅者与发布者一一对应，当 N 个页面都注册时，<strong>每次都对应一次数据库的查询操作</strong>，这是极其不合理的。</p>
<p><strong>使用热流优化：</strong></p>
<p><strong>发布者角色</strong>：<br> 根据业务，自行决定是使用 StateFlow or SharedFlow</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> coroutineIO = CoroutineScope(SupervisorJob() + Dispatchers.IO)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收初始状态及后续改变,类似于livedata</span></span><br><span class="line"><span class="keyword">val</span> testStateFlow: StateFlow&lt;DaoTestBean?&gt; =</span><br><span class="line">    AppDatabase.getInstance().testDao().getTestFlow().stateIn(coroutineIO, SharingStarted.Lazily, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只接收后续改变，类似于eventbus</span></span><br><span class="line"><span class="keyword">val</span> testSharedFlow:ShareFlow&lt;DaoTestBean?&gt; = testStateFlow.shareIn(coroutineIO, SharingStarted.Lazily)</span><br></pre></td></tr></table></figure>

<p>​		订阅者与发布者是<strong>一对多</strong>的关系，当上游发送数据时，多个订阅者都会收到消息。所以即使 N 个订阅者，数据库只会对应一次查询操作，至于在实际使用中是使用 StateFlow or SharedFlow，就看业务场景如何对应了。</p>
<p>SharedFlow支持被多个订阅者订阅，导致同一个事件会被多次消费，并不符合预期。</p>
<p>如果认为1还可以通过开发规范控制，SharedFlow的在<strong>无订阅者时会丢弃数据</strong>的特性则让其彻底无缘被选用承载必须被执行的事件</p>
<p><a href="https://juejin.cn/post/7222982459583152188?searchId=2024031216310771AB22842B74E9535181#heading-13">谱写Kotlin面试指南三部曲-Flow篇</a></p>
<p><a href="https://juejin.cn/post/7169843775240405022?searchId=2024031216310771AB22842B74E9535181#heading-12">Kotlin协程之一文看懂StateFlow和SharedFlow</a></p>
<p><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow?hl=zh-cn">StateFlow官方</a></p>
<p><a href="https://juejin.cn/post/7229991597084885048?searchId=2024031216310771AB22842B74E9535181">用错了Flow？每一次订阅都对应一次数据库的查询操作？Flow&#x2F;StateFlow&#x2F;SharedFlow 正确使用姿势</a></p>
<p><a href="https://juejin.cn/post/7169843775240405022?searchId=2024031216310771AB22842B74E9535181">Kotlin协程之一文看懂StateFlow和SharedFlow</a></p>
<p><a href="https://juejin.cn/post/7177619630050000954?searchId=2024031216310771AB22842B74E9535181">Android App封装 ——架构（MVI + kotlin + Flow）</a></p>
<p><a href="https://juejin.cn/post/7275975684148723746?searchId=2024031216310771AB22842B74E9535181#heading-11">Flow,SharedFlow,StateFlow的使用及原理: 有讲解源码</a></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2>]]></content>
  </entry>
  <entry>
    <title>kotlin泛型</title>
    <url>/2024/01/16/kotlin%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h3 id="泛型的基本声明方法"><a href="#泛型的基本声明方法" class="headerlink" title="泛型的基本声明方法"></a>泛型的基本声明方法</h3><p>函数声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span><span class="title">maxOf</span><span class="params">(a:<span class="type">T</span>,b:)</span></span>T</span><br></pre></td></tr></table></figure>

<p>类声明泛型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">List</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure>

<p>​                                                  </p>
<p>使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = maxOf&lt;String&gt;(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = List.Cons(<span class="number">1.0</span>,ListNil)</span><br></pre></td></tr></table></figure>

<h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能将实现了Comparable接口的数据传进来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">maxOf</span><span class="params">(a: <span class="type">T</span>, b: <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt;= b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的型变"><a href="#泛型的型变" class="headerlink" title="泛型的型变"></a>泛型的型变</h3><ul>
<li>不变</li>
</ul>
<p><strong>Nothing理论上是所有类型的子类</strong>，但这里的Lis<T>和Lis<Nothing>没有任何继承关系。 </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 此处会报错</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: List&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>协变</li>
</ul>
<p>协变点</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span>List<span class="type">&lt;T&gt;</span>.<span class="title">get</span><span class="params">(index:<span class="type">Int</span>)</span></span>:T</span><br></pre></td></tr></table></figure>

<p>函数返回值类型为泛型参数，这个返回值就叫做协变点。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里不会报错了</span></span><br><span class="line">    Lis.Cons(<span class="number">1.0</span>,Lis.Ni)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里对泛型添加out修饰  实现泛型的协变 Lis&lt;Nothing&gt;成为了Lis&lt;T&gt;的子类。</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Lis</span>&lt;<span class="type">out T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">object</span> Ni : Lis&lt;<span class="built_in">Nothing</span>&gt;()</span><br><span class="line">		<span class="comment">// 这里head的getter返回T 也是一个协变点</span></span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Cons</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">val</span> head: T, <span class="keyword">val</span> tail: Lis&lt;T&gt;) : Lis&lt;T&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$head</span>,<span class="variable">$tail</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>协变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>生产者Producer<Derived>兼容Producer<Base>.    <strong>能生产子类就能生产父类</strong></li>
<li>存在协变点的类的泛型参数必须声明为协变或不变</li>
<li>当泛型类作为泛型参数类实例的生产者时用协变</li>
<li>协变 <code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code></li>
</ol>
<p>​		生产者是要向外提供一些东西的，这里子类继承父类后会实现父类的方法。泛型如果是协变的，但是需要的地方是父类，又因为里氏替换原则子类可以代替父类（子类继承自父类），所以可以让Class<Son>成为Class<Father>的子类。</p>
<ul>
<li>逆变</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数参数类型为泛型参数。参数的位置就是逆变点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如</p>
<p>Int是Number的子类，但是能比较Int的不一定能比较Number，所以CompareTo<Number>是CompareTo<Int>的子类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 垃圾</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Waste</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 干垃圾</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DryWaste</span> : <span class="type">Waste</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾桶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dustbin</span>&lt;<span class="type">in T : Waste</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 扔垃圾</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;put <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">contravariant</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dustbin: Dustbin&lt;Waste&gt; = Dustbin&lt;Waste&gt;()</span><br><span class="line">    <span class="comment">// 干垃圾桶对象</span></span><br><span class="line">    <span class="keyword">val</span> dryWasteDustbin: Dustbin&lt;DryWaste&gt; = dustbin</span><br><span class="line">    <span class="comment">// 垃圾对象</span></span><br><span class="line">    <span class="keyword">val</span> waste = Waste()</span><br><span class="line">    <span class="comment">// 干垃圾对象 </span></span><br><span class="line">    <span class="keyword">val</span> dryWaste = DryWaste()</span><br><span class="line">    <span class="comment">// 扔垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到垃圾桶</span></span><br><span class="line">    dustbin.put(dryWaste)</span><br><span class="line">    <span class="comment">// 扔垃圾到干垃圾桶 这里报错：类型不匹配。要求:DryWaste实际:Waste</span></span><br><span class="line">    dryWasteDustbin.put(waste)</span><br><span class="line">    <span class="comment">// 扔干垃圾到干垃圾桶</span></span><br><span class="line">    dryWasteDustbin.put(dryWaste)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>逆变小结</strong></p>
<ol>
<li>子类Derived兼容父类Base</li>
<li>消费者Consumer.<Base>兼容Consumer<Derived>   <strong>能消费父类就能消费子类</strong></li>
<li>存在逆变点的类的泛型参数必须声明为逆变或不变</li>
<li>当泛型类作为泛型参数类实例的消费者时用逆变</li>
<li><code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​		泛型协变的语法规则：<code>&lt;out T&gt;</code> 类似于 Java 的  <code>&lt;? extends Bound&gt;</code>，它限定的类型是当前上边界类，所传入的类型得是Bound或它的子类，如果是接口的话就是当前上边界接口或者实现类，协变的泛型变量只读，不可以写，可以添加 null ，但是没意义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 协变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">out T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">// 这里可以将SimpleData&lt;Student&gt;()赋值给SimpleData&lt;Person&gt;</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">    <span class="keyword">val</span> list1: ArrayList&lt;<span class="keyword">out</span> Person&gt; = ArrayList&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>​		泛型逆变的语法规则：<code>&lt;in T&gt;</code> 类似于 Java 的 <code>&lt;? super Bound&gt;</code>，它限定的类型是当前<strong>下边界类</strong>，所传入的类型得是Bound或它的父类，如果是接口的话就是当前下边界接口或者其父接口，逆变的泛型变量只能写，不建议读。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="comment">// 逆变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">in T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1: Person = Student()</span><br><span class="line">  	<span class="comment">// 这里将SimpleData&lt;Person&gt;()赋值给SimpleData&lt;Student&gt; 必须是Student或Student的父类，比如Student的子类就会报错。</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric1: SimpleData&lt;Student&gt; = SimpleData&lt;Person&gt;()</span><br><span class="line">    <span class="keyword">val</span> list2: ArrayList&lt;<span class="keyword">in</span> Person&gt; = ArrayList&lt;Any&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不变的话就是没有对应的子父类关系</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>: <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleData</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person: Person = Student()</span><br><span class="line">    <span class="comment">//编译器不允许</span></span><br><span class="line">    <span class="keyword">val</span> personGeneric: SimpleData&lt;Person&gt; = SimpleData&lt;Student&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型的出现是为了解决什么问题"><a href="#泛型的出现是为了解决什么问题" class="headerlink" title="泛型的出现是为了解决什么问题"></a>泛型的出现是为了解决什么问题</h3><ol>
<li>减少重复代码</li>
<li>增加编译时类型的检查，避免一些运行时的类型错误问题</li>
</ol>
<p>比如往集合中添加元素，可以添加任何类型。但是取得时候不知道类型会报错。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b1b5b02cad3adceb3514735733af8d14_720w.webp" alt="img"></p>
<p>如果一只猫是一只动物，那一群猫是一群动物吗？一群狗是一群动物吗？Java数组认为是的。如果Cat是Animal的子类型，那么<code>Cat[]</code>也是<code>Animal[]</code>的子类型，我们称这种性质为<strong>协变</strong>（covariance）。<strong>Java中，数组是协变的</strong>。</p>
]]></content>
  </entry>
  <entry>
    <title>kotlin协程2</title>
    <url>/2024/03/26/kotlin%E5%8D%8F%E7%A8%8B2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​		协程是一种<strong>更高效和更简单的方式管理并发的框架</strong>，其轻量级线程编写在实际线程框架之上，通过利用函数的协作性质来充分利用它。</p>
<p>​		协程比线程更高效，因为它们是轻量级的，可以挂起和恢复而不会产生上下文切换的开销。这意味着它们可用于执行会阻塞线程的任务，而不会导致相同的性能损失。</p>
<ul>
<li><p>协程是轻量级的，创建一个线程栈大概需要1M左右，而一个协程栈大概只需要几K或者几十K</p>
</li>
<li><p>减少了线程切换的成本，协程可以挂起和恢复，它不会产生额外的开销，由程序自身控制</p>
</li>
<li><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>​	协程的作用是使用同步的方式写出异步的代码消灭了回调，然后将运行在不同线程的代码写在一个代码块里。协程让之前的并发代码写起来更简单。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispather.main)&#123;</span><br><span class="line">	<span class="keyword">val</span> user =  api.getUser()</span><br><span class="line">	nameTv.text = user.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p>协程框架大致有如下部分组成：</p>
<ul>
<li>协程作用域(<em>CoroutineScope</em>)</li>
<li>协程上下文(<em>CoroutineContext</em>)</li>
<li>协程调度器(<em>CoroutineDispatcher</em>)</li>
<li>作业(<em>Job</em>)</li>
</ul>
<h3 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h3><p>​		<em>CoroutineScope</em>是一种用于启动协程的盒子。可以同时对盒子里的所有协程执行操作，比如一次性取消盒子里的所有子协程。<strong>每个任务都会对应一个盒子，但是可以同时对所有的盒子进行操作。</strong></p>
<p>比如在Activity中通过lifecycleScope创建一个作用域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launchWhenXXX &#123;</span><br><span class="line">   <span class="keyword">val</span> user = fetchUser()         </span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看下它的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># LifecycleOwner</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> LifecycleOwner.lifecycleScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() = lifecycle.coroutineScope</span><br><span class="line">    </span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="comment">// CoroutineScope与此Lifecycle绑定。当Lifecycle被销毁时，这个范围将被取消。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> Lifecycle.coroutineScope: LifecycleCoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> existing = internalScopeRef.<span class="keyword">get</span>() <span class="keyword">as</span> LifecycleCoroutineScopeImpl?</span><br><span class="line">            <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> existing</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> newScope = LifecycleCoroutineScopeImpl(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                SupervisorJob() + Dispatchers.Main.immediate</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (internalScopeRef.compareAndSet(<span class="literal">null</span>, newScope)) &#123;</span><br><span class="line">                newScope.register()</span><br><span class="line">                <span class="keyword">return</span> newScope</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># Lifecycle</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleCoroutineScope</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>() : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">val</span> lifecycle: Lifecycle</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 activity created 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenCreated</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenCreated(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity started 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenStarted</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenStarted(block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 当 activity resumed 的时候执行协程体</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">launchWhenResumed</span><span class="params">(block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span>)</span></span>: Job = launch &#123;</span><br><span class="line">        lifecycle.whenResumed(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lifecycleScope</code> 是与 Android Jetpack Lifecycle 库集成的协程作用域，与组件（如 Activity 或 Fragment）的生命周期相关联。</li>
<li>当使用 <code>lifecycleScope.launch</code> 启动协程时，协程会在组件的生命周期内执行，并且会根据组件的生命周期自动取消。例如，如果在一个 Fragment 中启动了一个协程，当 Fragment 被销毁时，该协程也会被自动取消。</li>
</ul>
<p>ViewModel中的协程作用域通过viewModelScope来创建</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> user = fetchUser()</span><br><span class="line">            <span class="comment">// show user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchUser</span><span class="params">()</span></span>: User &#123;</span><br><span class="line">        <span class="keyword">return</span> withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">// fetch user</span></span><br><span class="line">            <span class="comment">// return user</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">CloseableCoroutineScope</span>(context: CoroutineContext) : Closeable, CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext = context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineContext.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong><code>ViewModelStore</code>:</strong> 负责存储 <code>ViewModel</code> 实例，并与 <code>Activity</code> 或 <code>Fragment</code> 的生命周期绑定。当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，<code>ViewModelStore</code> 也会清除所有存储的 <code>ViewModel</code> 实例。</p>
<p>​		<strong><code>CloseableCoroutineScope</code>:</strong> 实现了 <code>Closeable</code> 接口，并在 <code>ViewModel</code> 实例中被 <code>setTag</code> 保存。当 <code>ViewModel</code> 被清除时，<code>ViewModelStore</code> 会调用 <code>ViewModel</code> 的 <code>onCleared()</code> 方法，在此方法中会自动关闭 <code>viewModelScope</code>，即调用 <code>CloseableCoroutineScope.close()</code> 方法。</p>
<p>作用域还有GlobalScope，MainScope等。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">MainScope</span><span class="params">()</span></span>: CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)</span><br></pre></td></tr></table></figure>



<h3 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h3><p>​		Job, CoroutineDispatcher, ContinuationInterceptor 等都是 CoroutineContext 的子类，即它们都是协程上下文。CoroutineContext 中有一个重载了(+)操作符的plus方法，可以将 Job 和 CoroutineDispatcher 等元素集合起来，代表一个协程的场景。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">// 重载 [] 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 + 操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext = <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		它是一个包含了用户定义的一些各种不同元素的<code>Element</code>对象集合。其中主要元素是<code>Job</code>、协程调度器<code>CoroutineDispatcher</code>、还有包含协程异常<code>CoroutineExceptionHandler</code>、拦截器<code>ContinuationInterceptor</code>、协程名<code>CoroutineName</code>等。这些数据都是和协程密切相关的，每一个<code>Element</code>都有一个唯一key。</p>
<h3 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h3><p>​		它是在特定线程或线程组上执行协程的必要步骤。它们作为调度员负责将协程”分派“到底层线程，它决定着协程内部的代码将在哪个线程上执行。</p>
<p><strong>在主线程执行：</strong></p>
<ul>
<li>Dispatchers.Main</li>
<li>Dispatchers.Main.immediate</li>
</ul>
<p>​		两者不同点，Dispatchers.Main.immediate 的行为类似于Activity.runOnUiThread(…)，而Dispatchers.Main的行为就类似于Handler(Looper.getMainLooper()).post(…)</p>
<p>​		runOnUiThread在UI线程上运行指定的操作，如果当前线程是UI线程的话，该操作会立即执行，否则相关操作会被投递到UI线程的事件队列中去。</p>
<p>​		<code>Handler(Looper.getMainLooper()).post(...)</code>: 无论当前线程是否是主线程，都会被投递到UI线程的事件队列中去。</p>
<p><strong>后台线程执行：</strong></p>
<ul>
<li><em>Dispatchers.Default</em></li>
<li><em>Dispatchers.IO</em></li>
</ul>
<p><em>Dispatchers.Default</em>和<em>Dispatchers.IO</em>都可以允许在后台执行任务</p>
<p>​		<code>Dispatchers.Default</code> 通常用于执行计算密集型任务，比如处理大量数据或进行复杂计算。它 使用的线程池是一个固定大小的线程池，大小通常等于 CPU 核心的数量。这使得它适合并行执行计算密集型任务，而不会因为创建过多线程而导致资源耗尽。</p>
<p>​		<code>Dispatchers.IO</code> 专门用于执行 I&#x2F;O 密集型任务，比如读写文件、网络通信、数据库操作等。它使用的线程池则是一个可扩展的线程池，线程数量可以根据需要增长。这使得它适合 I&#x2F;O 密集型任务，因为这些任务可能会阻塞线程，而扩展的线程池可以提供更多线程来处理其他任务，从而保持应用的响应性。，但这个线程池被优化以适应 I&#x2F;O 操作的特性。</p>
<p><strong>其他</strong></p>
<p><em>Dispatchers.unconfined</em></p>
<p>简单来说，它只是在调用启动函数的线程上执行代码，并且它会立即执行。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>​		每个协程都与一个作业相关联。每当启动新协程时，它都会返回对作业的引用。协程的作业是可取消的，取消它会取消协程本身。但是如果我们想处理范围内的所有协程，就不再需要通过单独的作业来完成，我们可以使用<em>CoroutineScope</em>。</p>
<p>​		Job是继承自CoroutineContext的Element接口</p>
<p>再回头看ViewModel的作用域方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>launch返回的就是一个Job对象，然后机会所有的作用域都是通过launch来开启的。</p>
<p>常用方法：</p>
<ul>
<li>start() 开始</li>
</ul>
<p>​	<em>start</em>函数很直接，就是用来启动协程，这里就不过多描述</p>
<ul>
<li>join() 加入</li>
</ul>
<p>​		<em>join</em>函数是一个挂起函数，即它可以从协程或另一个挂起函数中调用。作业阻塞所有线程，直到写入它的协程或上下		完成其工作。只有当协程完成时，才会执行<strong>join()函数之后的行</strong>。</p>
<ul>
<li>cancel() 关闭</li>
</ul>
<p>​		<em>cancel</em>方法用于取消协程，而不用等待它完成它的工作。可以说它与<em>join</em>方法正好相反，在某种意义上，<em>join</em>方法等待协程完成其全部工作并阻塞所有其他线程，而<em>cancel</em> 方法在遇到时杀死协程协程（即停止协程）。</p>
<p>SupervisorJob是Job的一个子分支，它有一个作用就是如果子协程出现了异常，不会导致父协程以及其他兄弟协程取消关闭。</p>
<p>先看下使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">supervisorJob</span> <span class="operator">=</span> SupervisorJob()</span><br><span class="line"><span class="type">val</span> <span class="variable">scope</span> <span class="operator">=</span> CoroutineScope(Dispatchers.IO + supervisorJob)</span><br></pre></td></tr></table></figure>

<p>使用supervisorJob为context创建的作用域，不会因为一个子协程的异常导致全部协程取消。</p>
<p>​		综上所述，<em>SupervisorJob</em>更适合干一些独立互相不影响的任务，这样一旦某个任务出现了问题，对其他任务是没有任何影响的，比如说日常开发中一些UI需求，如果我点击的一个按钮出现了异常，但并不会影响手机状态栏的刷新</p>
<h2 id="suspend挂起"><a href="#suspend挂起" class="headerlink" title="suspend挂起"></a>suspend挂起</h2><p>​		被suspend修饰的函数叫做挂起函数，它们只能从另一个挂起函数或在协程中调用，它们可以在不阻塞当前线程的情况下挂起协程执行。</p>
<p>​		<strong>挂起是什么意思？</strong></p>
<p>​		挂起就是稍后会自动切回来的线程切换，切回来的动作在协程里叫做resume恢复。如果没有挂起的话suspend修饰没有意义。</p>
<p>​		下面是一个用来演示的伪代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(Dispatchers.Main) &#123;</span><br><span class="line">   <span class="keyword">val</span> image = suspendingGetImage(<span class="string">&quot;https://example.com/image.jpg&quot;</span>)</span><br><span class="line">   avatarIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendingGetImage</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getImage(s)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​			上面讲到Dispatchers.Main相当与将<strong>代码块的代码这部分就是协程</strong>通过Handler.post到主线程消息队列执行，然后<strong>主线程可以继续执行自己的任务。</strong>协程在执行到suspendingGetImage时会遇到<code>withContext(Dispatchers.IO)</code>会进行线程切换，在子线程执行完代码之后会自动的再次被post到主线程，然后继续执行后面的<code>avatarIv.setImageBitmap(image)</code>。</p>
<p>​		上面的主动让出线程然后自动恢复继续执行后面逻辑的这个过程叫做挂起。</p>
<p>​		挂起不一定必须有线程切换，如果将上面示例中的withContext(Dispatchers.IO)换成delay函数的话依然会挂起，但是不会切线程。所以说挂起和线程切换没有必然的联系。</p>
<p>​		在 Kotlin 协程中，挂起（Suspension）是一种特殊的状态，它允许协程在不阻塞线程的情况下暂停执行，并在条件满足时恢复执行。具体来说，挂起包含以下几个关键点：</p>
<ol>
<li><strong>非阻塞：</strong> 当协程挂起时，它不会阻塞底层的线程。这意味着线程可以用来执行其他任务，从而提高应用程序的并发性能。</li>
<li><strong>挂起点：</strong> 挂起发生在所谓的挂起点（Suspension Point）。挂起点通常是对挂起函数的调用。挂起函数是使用 <code>suspend</code> 关键字标记的函数，它们可以在执行过程中暂停协程，并在适当的时候恢复。</li>
<li><strong>恢复执行：</strong> 当挂起的条件（例如异步操作完成、延时结束等）得到满足时，协程会被恢复。恢复后，协程会从上次挂起的地方继续执行。</li>
<li><strong>调度器和线程：</strong> 挂起和恢复协程的执行可能伴随着线程的切换，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。调度器负责将协程的执行分派到合适的线程上。</li>
</ol>
<p><strong>suspend关键字的作用？</strong></p>
<p>​		suspend用来标志当前函数是一个挂起函数，需要在协程或者另外一个挂起函数中被调用。真正的挂起操作靠的是挂起函数里面的实际切换线程的代码，suspend作为函数使用者的提醒。</p>
<p><strong>怎么实现一个挂起函数？</strong></p>
<ul>
<li><p>什么时候定义？</p>
<p>原则：耗时</p>
</li>
<li><p>怎么写？</p>
<p>通常使用withContext这个挂起函数实现，它的功能最简单就是把线程切走又切回来。</p>
</li>
</ul>
<p><strong>非阻塞式挂起？</strong></p>
<p>​		非阻塞指的是不阻塞主线程，挂起的话一定是切到子线程了当然不会阻塞主线程。这个子线程会承载耗时操作，在等待的过程中就是阻塞的了。</p>
<h2 id="协程恢复"><a href="#协程恢复" class="headerlink" title="协程恢复"></a>协程恢复</h2><p>协程恢复时不一定会切回原线程，因为可能它的父协程是基于线程池的，在回调回父协程时可能换了个线程执行任务。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;主协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        println(<span class="string">&quot;协程开始 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        withContext(Dispatchers.IO) &#123;</span><br><span class="line">            println(<span class="string">&quot;挂起并切换到 IO 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            delay(<span class="number">1000</span>)  <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;恢复并继续在 Default 线程 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;主协程结束 - 线程：<span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">主协程开始 - 线程：main</span><br><span class="line">协程开始 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">挂起并切换到 IO 线程 - 线程：DefaultDispatcher-worker-<span class="number">1</span></span><br><span class="line">恢复并继续在 Default 线程 - 线程：DefaultDispatcher-worker-<span class="number">3</span></span><br><span class="line">主协程结束 - 线程：main</span><br></pre></td></tr></table></figure>



<h2 id="协程启动"><a href="#协程启动" class="headerlink" title="协程启动"></a>协程启动</h2><p>Kotlin 协程的启动方式主要有以下几种，每种方式都有其特定的用途和行为：</p>
<ol>
<li><p>**<code>launch</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Job</code> 实例，用于管理协程的生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> job = launch &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐使用，通过 CoroutineContext 参数去管理和控制协程的生命周期</span></span><br><span class="line"><span class="comment">// 例如：context = Dispatchers.Default + EmptyCoroutineContext</span></span><br><span class="line"><span class="keyword">val</span> coroutineScope = CoroutineScope(context)</span><br><span class="line"><span class="keyword">val</span> job = coroutineScope.launch &#123; </span><br><span class="line">    getName(id) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>async</code>**：在协程作用域中启动一个新的协程，不阻塞当前线程，返回一个 <code>Deferred</code> 实例，用于获取协程的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async启动的Job是Deferred类型，它可以有返回结果，通过await方法获取</span></span><br><span class="line"><span class="comment">// public suspend fun await(): T</span></span><br><span class="line"><span class="keyword">val</span> id = coroutineScope.async &#123; getName(id) &#125;</span><br><span class="line">id.await()</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>runBlocking</code>**：创建一个新的协程并阻塞当前线程，直到协程完成。通常用于桥接协程和非协程代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">    <span class="comment">// 协程体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>withContext</code>**：在指定的调度器上下文中执行协程代码块，并返回结果。用于在不同的调度器之间切换协程的执行上下文。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    <span class="comment">// 在 IO 调度器上执行的协程体，返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>launch() 和 async()之间的主要区别在于 :</p>
<ul>
<li><em>launch()</em> 将创建一个新的协程并立即启动它</li>
<li><em>async()</em> 将创建一个新的协程但不会启动它直到某些东西在结果<em>Deferred</em> 上调用 <em>await()</em></li>
</ul>
<p>​		launch 更多是用来发起一个无需结果的耗时任务（如批量文件删除、创建），这个工作不需要返回结果。<em>async</em> 函数则是更进一步，用于异步执行耗时任务，并且需要返回值（如网络请求、数据库读写、文件读写），在执行完毕通过<em>await()</em> 函数获取返回值。</p>
<p>启动协程需要三样东西，分别是上下文(CoroutineContext)、启动模式(CoroutineStart)、协程体。</p>
<p>看源码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext, <span class="comment">// 上下文</span></span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT, <span class="comment">// 启动模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		上下文可以看上面章节，启动模式一共有四种：</p>
<ul>
<li><strong>DEFAULT:</strong> 默认启动模式。协程会在被调度的第一时间开始执行。</li>
<li><strong>LAZY:</strong> 懒启动模式。协程只有在需要的时候才会开始执行，比如调用 <code>start</code>、<code>join</code> 或 <code>await</code> 方法时。</li>
<li><strong>ATOMIC:</strong> 原子启动模式。协程会立即开始执行，但如果协程在启动后立即被取消，它将不会执行任何操作。</li>
<li><strong>UNDISPATCHED:</strong> 立即启动模式。协程会在当前线程立即开始执行，直到遇到第一个挂起点。之后，它将根据其上下文恢复执行。</li>
</ul>
<p>协程体就是launch大括号里的代码内容了。</p>
<h2 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h2><p><strong>kotlin编译器</strong> 会对带有 <code>suspend</code> 的方法在最终的字节码生成上进行额外更改，这个过程又被称作 <strong>CPS转换</strong> (下面会再解释)，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">suspend fun <span class="title function_">xx</span><span class="params">()</span></span><br><span class="line">-&gt;</span><br><span class="line">Object <span class="title function_">xx</span><span class="params">(Continuation c)</span></span><br></pre></td></tr></table></figure>

<p>在字节码中，我们原有的函数方法参数中会再增加一个 <code>Continuation</code> ，而 <code>Continuation</code> 就相当于一个参数传递的纽带(或者你也可以理解其就是一个 <code>CallBack</code> )，负责保存函数的执行状态、执行 挂起与恢复 操作，具体如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 参数类似于 <code>Android</code> 开发中的 <code>context</code> 一样，其代表了当前的配置，对使用协程的同学而言，context就相当于<strong>当前协程所运行的环境与参数</strong> ，而 <code>resumeWith()</code> 则是负责对我们函数方法进行挂起与恢复</p>
<h2 id="协程源码解读"><a href="#协程源码解读" class="headerlink" title="协程源码解读"></a>协程源码解读</h2><h3 id="协程的创建和启动"><a href="#协程的创建和启动" class="headerlink" title="协程的创建和启动"></a>协程的创建和启动</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">	<span class="comment">// 协程体</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​	回看launch的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span> <span class="comment">// 协程体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job</span><br></pre></td></tr></table></figure>

<p>​		block就是对应的协程体，在经过编译后这部分内容会被编译成SuspendLambda 的子类。</p>
<p>​		<strong>SuspendLambda 实现了 Continuation 续体接口，其 resume 方法可以恢复协程的执行；另外它将协程体封装成 SuspendLambda 对象，其内以状态机的形式消除回调地狱，并实现逻辑的顺序执行</strong>。</p>
<p>SuspendLambda 的继承关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Continuation: 续体，恢复协程的执行</span><br><span class="line">    - BaseContinuationImpl: 实现 resumeWith(Result) 方法，控制状态机的执行，定义了 invokeSuspend 抽象方法</span><br><span class="line">        - ContinuationImpl: 增加 intercepted 拦截器，实现线程调度等</span><br><span class="line">            - SuspendLambda: 封装协程体代码块</span><br><span class="line">                - 协程体代码块生成的子类: 实现 invokeSuspend 方法，其内实现状态机流转逻辑</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.cn/post/7137905800504148004#heading-8">https://juejin.cn/post/7137905800504148004#heading-8</a></p>
<ol>
<li>协程和语言级别</li>
</ol>
<p>协程确实是 Kotlin 提供的一种并发框架，它允许以同步的方式编写异步代码。不过，协程不仅仅是 Kotlin 特有的，其他语言也有类似的概念，如 Python 的异步 IO (asyncio)、JavaScript 的 async&#x2F;await 等。</p>
<ol start="2">
<li>挂起和线程切换</li>
</ol>
<p>挂起并不总是意味着线程切换。挂起函数可以释放当前线程，使其可供其他任务使用，但协程在恢复时可能在相同的线程或不同的线程上继续执行，这取决于协程的调度器（<code>CoroutineDispatcher</code>）。</p>
<ol start="3">
<li>CPS 转换和回调</li>
</ol>
<p>CPS（Continuation-Passing Style）转换是协程实现中的一个关键技术。它将协程的代码转换为一系列连续的回调。每当协程遇到挂起点时，它都会保存当前的状态（包括局部变量等）并暂停执行。恢复协程时，会从上次挂起的地方继续执行。这个过程是由 Kotlin 编译器和协程库自动处理的，对开发者来说是透明的。</p>
<ol start="4">
<li>挂起函数</li>
</ol>
<p>挂起函数是通过 <code>suspend</code> 关键字标记的函数，它们可以在不阻塞线程的情况下暂停和恢复协程的执行。挂起函数可以调用其他挂起函数，形成一个挂起函数的调用链。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a href="https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6">https://juejin.cn/post/7310124656995614746?searchId=202403132132587DA36B493F54602244C6</a></p>
<p>​		协程是 Kotlin 提供的一种语言级别的并发框架，它允许以编写同步代码的方式来实现异步操作。在协程中，挂起机制可以实现线程的非阻塞切换。挂起允许协程在某个挂起点暂停执行，并在满足条件时自动恢复，这个过程可能伴随着线程的切换。</p>
<p>​		具体实现逻辑是，首先通过 <code>suspend</code> 关键字定义挂起函数，然后在协程作用域内调用这些挂起函数。这些函数在执行过程中可能会挂起协程，并在适当的时候恢复。挂起和恢复的过程由协程框架管理，涉及到 Continuation-Passing Style (CPS) 转换，这个转换过程会将协程的执行逻辑转换为一系列连续的回调，<strong>这些回调封装了协程在恢复后要执行的逻辑</strong>。</p>
<p>​		协程是kotlin语言级别的并发框架，它可以通过同步代码的方式实现异步的操作。在协程中通过挂起实现的线程切换。挂起就是可以在切换线程之后可以自己再切回来。具体的实现逻辑是，首先通过Suspend定义挂起函数，然后在协程作用域内启动。这个函数经过cps转换会添加一个回调。这个回调封装的是协程挂起恢复后要执行的逻辑。</p>
<h4 id="在工具类中创建协程进行耗时操作"><a href="#在工具类中创建协程进行耗时操作" class="headerlink" title="在工具类中创建协程进行耗时操作"></a>在工具类中创建协程进行耗时操作</h4><p>非单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNonContextClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> job = SupervisorJob()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Default + job)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            <span class="comment">// 在这里执行异步操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">cleanup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        job.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> AudioPlayerImpl : AudioPlayer, CoroutineScope <span class="keyword">by</span> MainScope() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceAll</span><span class="params">(songList: <span class="type">List</span>&lt;<span class="type">SongEntity</span>&gt;, song: <span class="type">SongEntity</span>)</span></span> &#123;</span><br><span class="line">        launch(Dispatchers.Main.immediate) &#123;</span><br><span class="line">            withContext(Dispatchers.IO) &#123;</span><br><span class="line">                <span class="comment">// 这里执行异步操作</span></span><br><span class="line">                db.playlistDao().clear()</span><br><span class="line">                db.playlistDao().insertAll(songList)</span><br><span class="line">            &#125;</span><br><span class="line">            _playlist.value = songList</span><br><span class="line">            _currentSong.value = song</span><br><span class="line">            play(song)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MainScope()</code> 是绑定到主线程的生命周期的，通常在应用程序终止时，这个作用域会自动被取消。</p>
<h4 id="Dispatchers-Default和Dispatchers-IO的线程池"><a href="#Dispatchers-Default和Dispatchers-IO的线程池" class="headerlink" title="Dispatchers.Default和Dispatchers.IO的线程池"></a>Dispatchers.Default和Dispatchers.IO的线程池</h4><p><a href="https://juejin.cn/post/7114968347325759501#heading-11">Kotlin 协程之线程池探索之旅(与Java线程池PK)</a></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/202403201859132.webp" alt="image.png"></p>
<p>Dispatchers.IO 侧重于任务本身是阻塞型的，比如文件、数据库、网络等操作，此时是不怎么占用CPU的。而Dispatchers.Default 侧重于计算型的任务，可能会长时间占用CPU。</p>
<p><em>Dispatchers.Default</em> 由线程池支持，最大线程数为 2 或 CPU 核心数。它可以用于计算密集型任务。</p>
<p><em>Dispatchers.IO</em> 类似于<em>Default</em>，但最大线程数为 64 或 CPU 核心数。通过调整系统属性可以进一步增加最大线程数。用于 IO 任务，例如大部分时间都处于等待的工作，而非密集型</p>
<h4 id="协程线程池原理"><a href="#协程线程池原理" class="headerlink" title="协程线程池原理"></a>协程线程池原理</h4><ul>
<li>全局队列（阻塞+非阻塞）+ 本地队列。</li>
<li>IO 任务分发还有个缓存队列。</li>
<li>线程从队列里寻找任务（包括偷）并执行，若是使用IO 分发器，则超出限制的任务将会放到缓存队列里。</li>
</ul>
<h4 id="协程线程池和Java线程池的区别"><a href="#协程线程池和Java线程池的区别" class="headerlink" title="协程线程池和Java线程池的区别"></a>协程线程池和Java线程池的区别</h4><ul>
<li>Java 线程池开放API，比较灵活，调用者可以根据不同的需求组合不同形式的线程池，没有区分任务的特点（阻塞&#x2F;非阻塞）。</li>
<li>协程线程池专供协程使用，区分任务特点，进而进行更加合理的调度。</li>
</ul>
<h4 id="coroutineScope和CoroutineScope-launch的区别"><a href="#coroutineScope和CoroutineScope-launch的区别" class="headerlink" title="coroutineScope和CoroutineScope.launch的区别"></a>coroutineScope和CoroutineScope.launch的区别</h4><p><code>coroutineScope</code></p>
<ul>
<li><strong>类型</strong>：<code>coroutineScope</code>是一个挂起函数，可以在其他挂起函数或协程中调用。</li>
<li><strong>作用域继承</strong>：它创建一个新的协程作用域，并继承外部的协程作用域（包括协程上下文和取消状态）。</li>
<li><strong>等待子协程</strong>：在<code>coroutineScope</code>块内启动的所有协程都完成之前，<code>coroutineScope</code>会挂起当前协程。这意味着<code>coroutineScope</code>块之后的代码会等待块内的所有协程完成后才执行。</li>
<li><strong>使用场景</strong>：当你需要在某个挂起函数中启动多个协程，并且要等待这些协程全部完成时，<code>coroutineScope</code>是一个好的选择。</li>
</ul>
<p><code>CoroutineScope.launch</code></p>
<ul>
<li><strong>类型</strong>：<code>launch</code>是一个扩展函数，用于在给定的<code>CoroutineScope</code>上启动新的协程。</li>
<li><strong>作用域创建</strong>：它需要一个<code>CoroutineScope</code>实例来调用，并在这个实例的作用域内启动新的协程。这个作用域通常由外部提供，比如通过<code>Activity</code>的<code>lifecycleScope</code>、<code>viewModelScope</code>或自定义的<code>CoroutineScope</code>。</li>
<li><strong>不等待子协程</strong>：<code>launch</code>会立即返回一个<code>Job</code>对象，并且不会等待协程内部的代码执行完毕。调用<code>launch</code>的代码会继续执行，而不会阻塞等待<code>launch</code>块内的协程完成。</li>
<li><strong>使用场景</strong>：当你需要在协程作用域内启动一个新的协程，并且不需要等待这个新启动的协程完成时，<code>launch</code>是合适的选择。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用coroutineScope</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadUserData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123; <span class="comment">/* 加载并处理用户数据 */</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> job2 = launch &#123; <span class="comment">/* 加载用户的其他信息 */</span> &#125;</span><br><span class="line">        <span class="comment">// 等待job1和job2完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// coroutineScope块外的代码会等待所有内部协程完成后才执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CoroutineScope.launch</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">startJob</span><span class="params">()</span></span> &#123;</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="comment">// 在CoroutineScope的作用域内启动新的协程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的代码不会等待launch块内的协程完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li>使用<code>coroutineScope</code>可以确保在其代码块内启动的所有协程都完成之后，才继续执行后续代码，适合控制一组协程的执行。</li>
<li>使用<code>CoroutineScope.launch</code>可以在指定的协程作用域内启动一个新的协程，适合无需等待协程完成的场景。</li>
</ul>
<p><a href="https://juejin.cn/post/7212311942613385253?searchId=20240313204055C36AC19ED84D47206D72#heading-30">写给Android工程师的协程指南</a></p>
<p><a href="https://juejin.cn/post/7137905800504148004">Kotlin协程之再次读懂协程工作原理</a></p>
<p><a href="https://juejin.cn/post/6890348438873964551">Kotlin协程之深入理解协程工作原理</a></p>
<p><a href="https://juejin.cn/post/7220235452292137019#heading-8">谱写Kotlin面试指南三部曲-协程篇</a></p>
<p><a href="https://juejin.cn/post/6901956626324914184#heading-2">Kotlin协程之基础使用</a></p>
<p><a href="https://www.bilibili.com/video/BV1JE411R7hp/?spm_id_from=333.788.recommend_more_video.-1&vd_source=214b10aedbc4bde847f4f4260b4d4787">扔物线协程视频</a></p>
]]></content>
  </entry>
  <entry>
    <title>okhttp详解</title>
    <url>/2023/12/15/OkHttp/</url>
    <content><![CDATA[<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:</span><br><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder().xxx.build()</span><br></pre></td></tr></table></figure>

<p>创建使用了建造者模式，对复杂对象创建过程进行封装，bulider的链式调用可以灵活的配置OkHttpClient对象的属性。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">异步：</span><br><span class="line">	   <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">       <span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">        LogCat.e( Thread.currentThread())</span><br><span class="line">        client.newCall(request).enqueue(<span class="keyword">object</span> : Callback &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// 这里还是在子线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">同步：</span><br><span class="line">		thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                loge(response)</span><br><span class="line">                <span class="comment">// 在这里处理同步响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="comment">// 处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>同步请求：</strong><ul>
<li><strong>同步请求是在当前线程上执行的。</strong>这意味着，如果在主线程上执行同步请求，它会阻塞主线程，直到请求完成。</li>
<li>同步请求通常用于后台线程或不涉及用户界面的操作，因为它们可能会导致应用界面冻结，用户体验差。</li>
<li>在同步请求中，您在代码中直接等待响应，只有在请求完成后才能继续执行后续代码。</li>
</ul>
</li>
<li><strong>异步请求：</strong><ul>
<li><strong>异步请求是在后台线程上执行的，不会阻塞当前线程。</strong>这允许在请求完成之前继续执行其他操作，包括更新用户界面。</li>
<li>异步请求通常用于与用户界面交互的操作，以确保用户界面保持响应性。</li>
<li>在异步请求中，通常提供一个回调函数，该回调函数将在请求完成时执行，允许处理响应数据。</li>
</ul>
</li>
</ol>
<h2 id="请求生成"><a href="#请求生成" class="headerlink" title="请求生成"></a>请求生成</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">client?.newCall(request)?.execute()</span><br><span class="line"></span><br><span class="line">#OkHttpClient::newCall:最终生成一个RealCall对象</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call = RealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">#RealCall::execute()：开启同步请求</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">	<span class="comment">// 检查是否已经被执行</span></span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 将当前realcall加入到OkHttpClient的调度器中  因为是同步 不需要线程池开启子线程 所以直接return getResponseWithInterceptorChain()</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">#Dispatcher::enqueue()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查 call 是否为 WebSocket 请求</span></span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">		<span class="comment">// 查找具有相同主机的已经存在的异步请求</span></span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 将符合条件的调用从readyAsyncCalls提升到runningAsyncCalls</span></span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 确保在多线程环境下，异步调用的执行数量不会超过预定的限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">#Dispatcher::promoteAndExecute():</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个可变列表用于存储将要执行的异步调用</span></span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个标志变量用于表示是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 块，确保以下操作在互斥锁的保护下进行</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 readyAsyncCalls 队列的迭代器</span></span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 readyAsyncCalls 队列中的异步调用</span></span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 runningAsyncCalls 中的异步调用数已经达到了最大请求数（maxRequests），则停止添加新的异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 asyncCall.callsPerHost（每个主机的并发请求数）已经达到了最大请求数（maxRequestsPerHost），则继续下一个异步调用</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 readyAsyncCalls 队列中移除该异步调用</span></span><br><span class="line">            i.remove()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加该异步调用所在主机的并发请求数</span></span><br><span class="line">            asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 executableCalls 列表中，准备执行</span></span><br><span class="line">            executableCalls.add(asyncCall)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该异步调用添加到 runningAsyncCalls 列表中，表示正在执行</span></span><br><span class="line">            runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有异步调用正在执行，更新 isRunning 变量</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 executableCalls 列表，执行每个异步调用</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">			<span class="comment">// 这里开启了线程池调用</span></span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回是否有异步调用正在执行</span></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealCall::AsyncCall:: executeOn()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数开始时，确保当前线程不持有锁</span></span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">false</span> <span class="comment">// 用于跟踪执行是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用传入的 executorService 来执行当前异步调用（实际上是执行该异步任务）</span></span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果执行成功，设置 success 为 true</span></span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="comment">// 如果执行被拒绝，创建一个 InterruptedIOException 异常，并将原始异常作为其原因</span></span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">&quot;executor rejected&quot;</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 noMoreExchanges 方法，通知没有更多的交换操作，同时调用 responseCallback 的 onFailure 方法传递异常</span></span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：无论执行是否成功，都会执行的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 如果执行不成功，调用 client.dispatcher.finished(this) 来表示该调用不再运行</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncCall::<span class="keyword">class</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AsyncCall继承了Runnable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 给当前线程命名，通常用于日志记录和调试</span></span><br><span class="line">    threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span> <span class="comment">// 用于标记回调是否已经触发</span></span><br><span class="line">        timeout.enter() <span class="comment">// 进入超时状态，启动计时器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 getResponseWithInterceptorChain() 获取响应对象</span></span><br><span class="line">            <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记回调已经触发</span></span><br><span class="line">            signalledCallback = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 responseCallback 的 onResponse() 方法，将响应传递给回调函数</span></span><br><span class="line">            responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 不要触发回调两次！如果回调已经触发，记录日志</span></span><br><span class="line">                Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 responseCallback 的 onFailure() 方法，将异常传递给回调函数</span></span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">            cancel() <span class="comment">// 取消当前调用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// 如果回调尚未触发，创建一个异常，将其作为取消原因传递给回调函数</span></span><br><span class="line">                <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">                canceledException.addSuppressed(t)</span><br><span class="line">                responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 抛出异常以终止线程</span></span><br><span class="line">            <span class="keyword">throw</span> t</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何，都要通知客户端调度程序当前调用已完成</span></span><br><span class="line">            client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器的通过责任链模式挨个执行每个拦截器的任务，最后将请求的response返回给最上层</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后的具体网络请求实现还是得看 getResponseWithInterceptorChain()</span></span><br><span class="line"></span><br><span class="line">RealCall:: getResponseWithInterceptorChain()</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 构建拦截器链，创建一个拦截器列表</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加用户自定义的普通拦截器</span></span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 重试、重定向拦截器</span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</span></span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 读取、写入缓存的拦截器</span></span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 与服务器建立连接的拦截器</span></span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 WebSocket 请求，添加用户自定义的网络拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加最终真正执行网络请求的拦截器</span></span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有拦截器合并为链，并调用其proceed()开始处理本次请求</span></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,</span><br><span class="line">        interceptors = interceptors,</span><br><span class="line">        index = <span class="number">0</span>,</span><br><span class="line">        exchange = <span class="literal">null</span>,</span><br><span class="line">        request = originalRequest,</span><br><span class="line">        connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用拦截器链的 proceed 方法，处理请求并获取响应</span></span><br><span class="line">				<span class="comment">// 主要还是得看这个方法</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果请求被取消，关闭响应并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">            response.closeQuietly()</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// 捕获 IOException 异常，标记已经调用 noMoreExchanges 方法，并重新抛出异常</span></span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最终块：如果没有调用过 noMoreExchanges 方法，则调用它来释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealInterceptorChain:: proceed()</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 检查当前拦截器索引是否小于拦截器列表的大小</span></span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加调用计数</span></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查新请求的 URL 是否与当前请求的 URL 主机和端口相同</span></span><br><span class="line">        check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器链中的下一个拦截器</span></span><br><span class="line">    <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">		<span class="comment">// 获取当前index的拦截器对象</span></span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用拦截器的 intercept 方法，获取响应对象，如果为 null，则抛出异常</span></span><br><span class="line">		<span class="comment">// 这里的intercept方法传入的是下一个拦截器，</span></span><br><span class="line">		<span class="comment">// 在当中回调用下一个拦截器的proceed方法response = realChain.proceed(request)</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">        <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果存在交换操作（exchange），检查下一个拦截器是否只调用 proceed() 一次</span></span><br><span class="line">        check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应对象是否有响应体</span></span><br><span class="line">    check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回获取的响应对象</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>对OKHttp有了解吗，拦截器这一块有了解吗？</li>
<li>有没有用到过，或则自定义拦截器，怎么用的</li>
<li>拦截器一定会被执行吗</li>
<li>责任链模式和策略模式有什么区别</li>
</ol>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/RetryAndFollowUpInterceptor%EF%BC%9A%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8%20d608e513720d4f7e85d2a65cb9df191a.md"><strong>RetryAndFollowUpInterceptor：</strong>重试、重定向拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/BridgeInterceptor%EF%BC%9A%E5%B0%86%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%94%A8%E6%88%B7%E5%93%8D%E5%BA%94%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20536849dff4944c349e970fdc8ae1619b.md">BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CacheInterceptor%EF%BC%9A%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%209e0ba47ba1524aafb889cf0008e1b86e.md">CacheInterceptor：读取、写入缓存的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/ConnectInterceptor%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20bd971853d1ed4038ba3426d485bf6af5.md">ConnectInterceptor 建立连接的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/CallServerInterceptor%EF%BC%9A%E6%9C%80%E7%BB%88%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%20b4e0c43b2b424fa686714b168d39b7e1.md"><strong>CallServerInterceptor：</strong>最终真正执行网络请求的拦截器</a></p>
<p><a href="OkHttp%203c411a77d17e43fa951fe85fce347f45/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%20a209e906006a4e67a7e39c2b1bebec7b.md">自定义拦截器</a></p>
<h2 id="RetryAndFollowUpInterceptor：重试、重定向拦截器"><a href="#RetryAndFollowUpInterceptor：重试、重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor：重试、重定向拦截器"></a>RetryAndFollowUpInterceptor：重试、重定向拦截器</h2><p>重定向:</p>
<p>重定向简单理解则是客户端请求服务端时，服务端让客户端请求别的网站，服务端会在响应中添加新的请求地址，客户端去请求这个新的地址。</p>
<p>问题一：重试的判断条件</p>
<p>问题二：怎么主动控制禁止网络请求重试</p>
<p>问题三：循环重试会不会走入死循环</p>
<p>问题四：重定向怎么实现的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> client: OkHttpClient) : Interceptor &#123;</span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 将传入的 Interceptor.Chain 强制转换为 RealInterceptorChain</span></span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">var</span> request = chain.request <span class="comment">// 获取请求</span></span><br><span class="line">    <span class="keyword">val</span> call = realChain.call <span class="comment">// 获取调用</span></span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span> <span class="comment">// 跟随请求计数</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span> <span class="comment">// 之前的响应</span></span><br><span class="line">    <span class="keyword">var</span> newExchangeFinder = <span class="literal">true</span> <span class="comment">// 是否是新的交换</span></span><br><span class="line">    <span class="keyword">var</span> recoveredFailures = listOf&lt;IOException&gt;() <span class="comment">// 已恢复的失败列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="comment">// 创建ExchangeFinder，此类用于创建和寻找Exchange，Exchange主要处理此次请求中的IO的连接管理和事件请，会在后续的拦截器中进行分析</span></span><br><span class="line">        call.enterNetworkInterceptorExchange(request, newExchangeFinder) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response: Response</span><br><span class="line">        <span class="keyword">var</span> closeActiveExchange = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (call.isCanceled()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 此处调用下一个拦截器获取respnse</span></span><br><span class="line">				<span class="comment">// 将Request交给给下个节点，此处的下个节点为BridgeInterceptor，若下层节点处理过程中扔出错误会被下面的catch捕获</span></span><br><span class="line">                response = realChain.proceed(request) </span><br><span class="line">                newExchangeFinder = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">                <span class="comment">// 尝试通过路由连接失败，请求尚未发送</span></span><br><span class="line">			   <span class="comment">// 重点方法，决定能否重试的关键方法，此方法返回为true才可重试，看重试小节中的分析</span></span><br><span class="line">                <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">                <span class="comment">// 通过recover方法检测路由异常是否能重新连接</span></span><br><span class="line">                <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e.firstConnectException</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recoveredFailures += e</span><br><span class="line">                &#125;</span><br><span class="line">                newExchangeFinder = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 走到这里，则一定拿到了服务器的响应</span></span><br><span class="line">		   <span class="comment">// 若循环中的代码完整执行过，则priorResponse不为空，也就意味着需要重定向（不太严谨的说法），类似链表的结构保存下来整个响应路径</span></span><br><span class="line">            <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">					          response = response.newBuilder()</span><br><span class="line">								              .priorResponse(priorResponse.newBuilder()</span><br><span class="line">						                  .body(<span class="literal">null</span>)</span><br><span class="line">						                  .build())</span><br><span class="line">								              .build()</span><br><span class="line">				        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// exchange为Exchange类，主要处理此次网络连接的IO操作</span></span><br><span class="line">            <span class="keyword">val</span> exchange = call.interceptorScopedExchange</span><br><span class="line">            <span class="comment">// 处理重定向的重点方法，此方法会根据返回的response和连接管理器判断是否需要重定向，看下重定向小节</span></span><br><span class="line">            <span class="keyword">val</span> followUp = followUpRequest(response, exchange)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">                    call.timeoutEarlyExit()</span><br><span class="line">                &#125;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 没有跟随请求，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">            <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">                closeActiveExchange = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span> response <span class="comment">// 跟随请求有请求体，直接返回响应</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.body?.closeQuietly() <span class="comment">// 关闭响应体</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Too many follow-up requests: <span class="variable">$followUpCount</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request = followUp <span class="comment">// 使用跟随请求作为新的请求</span></span><br><span class="line">            priorResponse = response</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            call.exitNetworkInterceptorExchange(closeActiveExchange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题一：</p>
<p>首先确认代码体主要是一个while true 死循环，然后看下面这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果recover返回了false 则直接抛出异常 中断了重试</span></span><br><span class="line"><span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">          <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">          <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recoveredFailures += e.firstConnectException</span><br><span class="line">          &#125;</span><br><span class="line">          newExchangeFinder = <span class="literal">false</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>出现异常的大部分情况都会返回false  从而抛出异常，如果命中了可以重试的异常则会走continue 停止当前循环开启下一次循环从而开启下一次的请求。</p>
<p>然后看看recover的具体实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">	**RetryAndFollowUpInterceptor::**recover()</span><br><span class="line"><span class="comment">// 定义一个名为recover的私有函数，用于处理异常情况并决定是否需要进行错误恢复。</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    e: <span class="type">IOException</span>,                 <span class="comment">// 传入的异常对象，通常是与网络请求相关的IOException。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    call: <span class="type">RealCall</span>,                 <span class="comment">// RealCall对象，用于执行HTTP请求的实际调用。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    userRequest: <span class="type">Request</span>,           <span class="comment">// 用户发起的请求对象。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    requestSendStarted: <span class="type">Boolean</span>     <span class="comment">// 标志位，表示请求是否已经开始发送。</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 如果客户端配置禁止在连接失败时重试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求已经开始发送，并且该请求是一次性的（不能重新发送），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果异常是不可恢复的（例如，连接超时等），则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有更多的路由可以尝试，则不进行错误恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于错误恢复，使用相同的路由选择器创建一个新的连接。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// 返回true表示需要进行错误恢复操作。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">**RetryAndFollowUpInterceptor::**requestIsOneShot</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestIsOneShot</span><span class="params">(e: <span class="type">IOException</span>, userRequest: <span class="type">Request</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> requestBody = userRequest.body</span><br><span class="line">  <span class="keyword">return</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) ||  <span class="comment">//isOneShot()是需要程序员重写RequestBody的方法，不重写的情况下默认返回为false</span></span><br><span class="line">      e <span class="keyword">is</span> FileNotFoundException  <span class="comment">//若下层节点处理过程中抛出FileNotFoundException也不允许重试</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**RetryAndFollowUpInterceptor::**isRecoverable</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isRecoverable</span><span class="params">(e: <span class="type">IOException</span>, requestSendStarted: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 协议异常则不许重试，举一个协议异常的例子，没有使用代理却返回响应码407需要代理验证，此类与协议规范冲突的错误大多数为ProtocolException</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 若产生中断异常，Socket超时或者在非IO异常（路由异常）时可能可以重试（requestSendStarted是catch中捕获的最初的异常决定的）</span></span><br><span class="line">    <span class="comment">// 若捕获异常为RouteException，requestSendStarted为false</span></span><br><span class="line">    <span class="comment">// 若捕获异常为IOException，且异常的具体类型为ConnectionShutdownException时，requestSendStarted也为false</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">is</span> SocketTimeoutException &amp;&amp; !requestSendStarted</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//ssl握手异常，且具体错误属于是证书异常，则不允许重试，因为重试也肯定失败</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.cause <span class="keyword">is</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//证书校验失败 不匹配 也不允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="comment">// 翻译：如果产生连接代理出现问题，且是抛出IO异常，此时要返回true，尝试新的路由路线</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结上述中不可重试的情况，分为两种情况一种是<strong>程序员不希望重试</strong>一种是<strong>下层抛出异常</strong>。</p>
<p>问题二：</p>
<ul>
<li>配置<code>OkhttpClient</code>时设置<code>retryOnConnectionFailure</code>为<code>false</code>，所有请求将不可重试。</li>
<li>使用请求体请求时，<code>Body</code>继承自<code>RequestBody</code>并重写<code>isOneShot()</code>返回为<code>true</code>，可以做到过滤某些请求。</li>
</ul>
<p>问题三：</p>
<p>不会，首先重试的条件是苛刻的，绝大多数重试情况都只是网络波动，且在判断是否可重试时，有非常关键的一个条件，有没有可以重试的路线，一直重试必然会导致路线全部使用完，此时也一定会跳出循环。</p>
<p>问题四：</p>
<p>需要重定向说明之前的请求完成了然后需要再请求别的网址，看下面这段代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里将followup 赋值给了request 然后在下一个循环开启对应请求。		</span></span><br><span class="line">request = followUp</span><br><span class="line">priorResponse = response</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将之前的请求响应内容保存下来。 priorResponse是上次循环上面代码保存下来的</span></span><br><span class="line"><span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">		response = response.newBuilder()</span><br><span class="line">							.priorResponse(priorResponse.newBuilder()</span><br><span class="line">						  .body(<span class="literal">null</span>)</span><br><span class="line">						  .build())</span><br><span class="line">						.build()</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"><a href="#BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器" class="headerlink" title="BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器"></a>BridgeInterceptor：将用户请求转换为服务器请求，将服务器响应转换为用户响应的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> cookieJar: CookieJar) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Throws(IOException::class)</span></span><br><span class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取用户发起的请求</span></span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="comment">// 创建一个请求构建器，用于修改请求头信息</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求体</span></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取请求体的内容类型</span></span><br><span class="line">        <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Type字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体的内容长度</span></span><br><span class="line">        <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置请求头中的Content-Length字段</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, contentLength.toString())</span><br><span class="line">            <span class="comment">// 移除Transfer-Encoding字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果内容长度为-1，设置Transfer-Encoding为chunked</span></span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>)</span><br><span class="line">            <span class="comment">// 移除Content-Length字段，以防止冲突</span></span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Host字段，添加Host字段，使用请求URL的主机名</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Host&quot;</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Connection字段，添加Connection字段为Keep-Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有Accept-Encoding字段，并且没有Range字段，添加Accept-Encoding字段为gzip</span></span><br><span class="line">		<span class="comment">// Accept-Encoding用于提供客户端支持的压缩方式，与响应头的Content-Encoding对应</span></span><br><span class="line">    <span class="comment">// Range表示客户端想要此次请求资源的某一部分如：Range: bytes=0-50, 100-150，表示只要0-50和100-150字节两个部分</span></span><br><span class="line">    <span class="comment">// 若没有指定上述两个请求头属性，则压缩方式指定为gzip</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="literal">true</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CookieJar中加载Cookies，并添加到请求头中的Cookie字段</span></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求头中没有User-Agent字段，添加User-Agent字段为指定的userAgent</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行网络请求，获取网络响应</span></span><br><span class="line">		<span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将网络响应的头部信息传递给CookieJar，以便处理和存储Cookies</span></span><br><span class="line">		cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个响应构建器，用于修改网络响应</span></span><br><span class="line">		<span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">	    .request(userRequest)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果需要进行透明的gzip解压缩，并且响应头中包含Content-Encoding字段为gzip，且响应允许有响应体</span></span><br><span class="line">		<span class="comment">// 若上述使用gzip，则需要进行解压</span></span><br><span class="line">    <span class="comment">// Content-Encoding代表此次响应体的编码</span></span><br><span class="line">		<span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">		    <span class="string">&quot;gzip&quot;</span>.equals(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">		    networkResponse.promisesBody()) &#123;</span><br><span class="line">    <span class="comment">// 获取网络响应体</span></span><br><span class="line">    <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">    <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个GzipSource，用于解压gzip压缩的响应体</span></span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="comment">// 移除响应头中的Content-Encoding和Content-Length字段</span></span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">            .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        <span class="comment">// 设置响应构建器的头部信息</span></span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="comment">// 获取响应体的Content-Type</span></span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">        <span class="comment">// 设置响应体为解压后的内容</span></span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回修改后的响应</span></span><br><span class="line">		<span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说这个拦截器并不复杂主要也就是封装请求头。重要的还是涉及计网的部分，这部分有关http的知识在<a href="https://www.notion.so/bbcad4bff70d4beb8269b08602dd95e8?pvs=21">计网</a>查询。</p>
<h2 id="CacheInterceptor：读取、写入缓存的拦截器"><a href="#CacheInterceptor：读取、写入缓存的拦截器" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h2><h3 id="CacheInterceptor：读取、写入缓存的拦截器-1"><a href="#CacheInterceptor：读取、写入缓存的拦截器-1" class="headerlink" title="CacheInterceptor：读取、写入缓存的拦截器"></a>CacheInterceptor：读取、写入缓存的拦截器</h3><p>先来个图总结cache的路径：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled.png" alt="Untitled"></p>
<p>主要看下面这个博客的内容。</p>
<p>总结下一些主要的东西：</p>
<ol>
<li>cache默认是null如果需要缓存需要在构建的时候添加。</li>
<li>走缓存还是走网络请求是通过<code>CacheStrategy</code> 类来判断的，判断公式为：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%2055.png" alt="Untitled 1"></p>
<p>具体代码体现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">      <span class="comment">// 若该请求没有对应的缓存响应，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 若该请求为HTTPS请求，但是缓存响应中没有保存TLS握手相关信息，则忽略缓存响应，需要网络请求</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过cacheResponse的响应码来判断响应是否允许被缓存，若不允许则忽略缓存响应，需要网络请求 </span></span><br><span class="line">      <span class="comment">// (其实参与判断的还有noStore指令的值) </span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CacheControl类：包含来自服务端或客户端的缓存指令，这些指令表明了什么响应可以被存储，</span></span><br><span class="line">      <span class="comment">// 这些存储的响应可以满足哪些需求。</span></span><br><span class="line">      <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">      <span class="comment">// noCache指令说明：noCache指令可以出现在请求、响应当中。若出现在响应的位置，它表明在发布</span></span><br><span class="line">      <span class="comment">// 缓存副本之前，必须向源服务器验证缓存的有效性；若出现在请求中，它表明不要使用一个缓存来回应</span></span><br><span class="line">      <span class="comment">// 该需求。  </span></span><br><span class="line">      <span class="comment">// hasConditions方法：若Request包含If-Modified-Since或If-None-Match其中一个Header，</span></span><br><span class="line">      <span class="comment">// 则该方法返回true。</span></span><br><span class="line">      <span class="comment">// 这里If语句的意思：若请求不允许使用缓存响应，或者请求头有If-Modified-Since/If-None-Match，  	  // 则忽略缓存响应，需要网络请求。(客户端发送的请求自己就带有If-Modified-Since或If-None-Match</span></span><br><span class="line">      <span class="comment">// ，缓存响应也是不会被使用的，OkHttp在下面的代码中是有为请求添加If-Modified-Since或</span></span><br><span class="line">      <span class="comment">// If-None-Match的Header的逻辑的) </span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">      <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果cacheResponse没有noCache指令(发布缓存前不用向源服务器验证)，并且cacheResponse</span></span><br><span class="line">      <span class="comment">// 仍然在存活时间内，则不需要进行网络请求，直接使用缓存响应  </span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加 If-None-Match/If-Modified-Since 的Header到请求头中，服务器通过验证这些Header，</span></span><br><span class="line">      <span class="comment">// 来判断客户端的缓存是否还有效，若缓存仍然有效，则返回304，响应中不会包含Response Body  </span></span><br><span class="line">      <span class="keyword">val</span> conditionName: String</span><br><span class="line">      <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">          conditionValue = etag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = lastModifiedString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = servedDateString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 If-None-Match/If-Modified-Since 的Header可以添加，则忽略缓存响应，需要网络请求   </span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>) <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在原来的Request上面添加包含If-None-Match/If-Modified-Since的Header  </span></span><br><span class="line">      <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="comment">// 返回一个包含网络请求和缓存响应的策略  </span></span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码总结看下面的博客。这段代码是真正控制缓存的关键。</p>
<ol>
<li>cache类的主要作用是在本地对<code>Response</code>进行<code>CRUD</code>（增删改查四种数据库操作）的操作。</li>
<li>CacheStrategy类具体判断networkRequest、cacheResponse是在computeCandidate方法实现的。具体看下面的博客。</li>
</ol>
<p><a href="https://www.cnblogs.com/giagor/p/15706508.html">探索OkHttp系列 (四) 缓存机制 - Giagor - 博客园</a></p>
<p>首先这个缓存器只会缓存GET请求，其次如果需要缓存的话需要在构建Request的时候添加cache</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient.Builder().cache(Cache(File(<span class="keyword">this</span>.externalCacheDir, <span class="string">&quot;okhttpcache&quot;</span>), <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>)).build()</span><br><span class="line"><span class="keyword">val</span> request = Request.Builder().url(<span class="string">&quot;http://www.baidu.com&quot;</span>).build()</span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">object</span> : Callback)</span><br></pre></td></tr></table></figure>

<p>其次在Request的构造中有一个cacheControl方法这个方法会传入<code>CacheControl</code> 类，这个类可以在request中定制缓存策略。在Cache的官方头注释中有对这个类各种策略的使用示例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cacheControl = CacheControl.Builder()</span><br><span class="line">    .maxAge(<span class="number">1</span>, TimeUnit.HOURS) <span class="comment">// 缓存有效期为1小时</span></span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">    .url(<span class="string">&quot;https://example.com/api/data&quot;</span>)</span><br><span class="line">    .cacheControl(cacheControl)</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>Cache类解析</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">  directory: File,</span><br><span class="line">  maxSize: <span class="built_in">Long</span>,</span><br><span class="line">  fileSystem: FileSystem</span><br><span class="line">) : Closeable, Flushable &#123;</span><br><span class="line">	 <span class="comment">// 这里使用的是磁盘缓存</span></span><br><span class="line">  <span class="comment">// 缓存最最重要的属性，看名字也知道缓存策略为硬盘LRU缓存，下述分析DiskLruCache</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cache = DiskLruCache(</span><br><span class="line">        fileSystem = fileSystem,	      <span class="comment">// 主机的本地文件系统，内部使用OKIO实现IO操作</span></span><br><span class="line">        directory = directory,            <span class="comment">// 缓存目录</span></span><br><span class="line">        appVersion = VERSION,			  <span class="comment">// 版本</span></span><br><span class="line">        valueCount = ENTRY_COUNT,         <span class="comment">// 缓存文件的类型，此处是2，因为一条缓存映射两个实体文件头和体</span></span><br><span class="line">        maxSize = maxSize,				  <span class="comment">// 缓存大小</span></span><br><span class="line">        taskRunner = TaskRunner.INSTANCE  <span class="comment">// 日志追踪线程池</span></span><br><span class="line">    )</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存使用的是磁盘缓存，缓存目录是添加cache时加的目录。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/Untitled%202.png" alt="Untitled 2"></p>
<p>先来看看cache缓存数据的时候</p>
<p>Cache::put()缓存的只是响应头数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Cache::put()</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(response: <span class="type">Response</span>)</span></span>: CacheRequest? &#123;</span><br><span class="line">    <span class="keyword">val</span> requestMethod = response.request.method</span><br><span class="line">	<span class="comment">// 如果请求方法为POST,PATCH,PUT,DELETE,MOVE,则移除此缓存</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remove(response.request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只允许get方法缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestMethod != <span class="string">&quot;GET&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t cache non-GET responses. We&#x27;re technically allowed to cache HEAD requests and some</span></span><br><span class="line">        <span class="comment">// POST requests, but the complexity of doing so is high and the benefit is low.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果 Vary 响应头中包含星号，也无法缓存此响应</span></span><br><span class="line">    <span class="comment">// vary 详情请看https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary</span></span><br><span class="line">    <span class="comment">// vary简单理解则是记录下来需要缓存的响应头的值</span></span><br><span class="line">    <span class="keyword">if</span> (response.hasVaryAll()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry是Cache.Entry 非 DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">val</span> entry = Entry(response)</span><br><span class="line">    <span class="keyword">var</span> editor: DiskLruCache.Editor? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用DiskLruCache的edit(), 此方法则会根据传入的参数获取DiskLruCache.Entry, 看下述2.DiskLruCache#edit中的解析</span></span><br><span class="line">        editor = cache.edit(key(response.request.url)) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// 执行写入操作,看下Cache.Entry#writeTo</span></span><br><span class="line">        entry.writeTo(editor)</span><br><span class="line">        <span class="comment">// 返回RealCacheRequest,此时会创建响应体文件, 看下RealCacheRequest</span></span><br><span class="line">        <span class="keyword">return</span> RealCacheRequest(editor)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">        abortQuietly(editor)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面都是对这个方法中所调用方法的解析</strong></p>
<p>DiskLruCache::edit() 中的解析</p>
<p>这个方法主要是在journal文件中写入DIRTY 然后返回val editor &#x3D; Editor(entry)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">edit</span><span class="params">(key: <span class="type">String</span>, expectedSequenceNumber: <span class="type">Long</span> = ANY_SEQUENCE_NUMBER)</span></span>: Editor? &#123;</span><br><span class="line">	<span class="comment">// 初始化DiskLruCache</span></span><br><span class="line">    initialize()</span><br><span class="line">	<span class="comment">// 检测缓存有没有关闭,若关闭则抛出异常</span></span><br><span class="line">    checkNotClosed()</span><br><span class="line">    <span class="comment">// 判断key是否有效</span></span><br><span class="line">    validateKey(key)</span><br><span class="line">    <span class="comment">// 获取lruEntries中key的value, 第一次则一定为null</span></span><br><span class="line">    <span class="keyword">var</span> entry: Entry? = lruEntries[key]</span><br><span class="line">    <span class="comment">// 若是添加操作则expectedSequenceNumber使用默认值ANY_SEQUENCE_NUMBER,if不会命中</span></span><br><span class="line">    <span class="comment">// 若是更新操作才有可能命中此if</span></span><br><span class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">        (entry == <span class="literal">null</span> || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Snapshot is stale.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 若entry绑定了Editor则也返回null</span></span><br><span class="line">    <span class="keyword">if</span> (entry?.currentEditor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Another edit is in progress.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 第一次添加不会命中,因为entry为null, lockingSourceCount是当前正在打开的输入流的总数</span></span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span> &amp;&amp; entry.lockingSourceCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// 无法写入此文件，因为读者仍在阅读它</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在清理过程中, 超过设置的缓存大小且移除Entry失败时会使mostRecentTrimFailed = true, 若需要重建journal, 日志文件创建失败会使mostRecentRebuildFailed = true, 这两种情况下会命中if</span></span><br><span class="line">    <span class="keyword">if</span> (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">        <span class="comment">// The OS has become our enemy! If the trim job failed, it means we are storing more data than</span></span><br><span class="line">        <span class="comment">// requested by the user. Do not allow edits so we do not go over that limit any further. If</span></span><br><span class="line">        <span class="comment">// the journal rebuild failed, the journal writer will not be active, meaning we will not be</span></span><br><span class="line">        <span class="comment">// able to record the edit, causing file leaks. In both cases, we want to retry the clean up</span></span><br><span class="line">        <span class="comment">// so we can get out of this state!</span></span><br><span class="line">        <span class="comment">// 翻译如下: 操作系统已成为我们的敌人！如果修剪作业失败，则意味着我们存储的数据多于用户请求的数据。不允许编辑，因此我们不会进一步超出该限制。如果日志重建失败，日志写入器将不会处于活动状态，这意味着我们将无法记录编辑，从而导致文件泄漏。在这两种情况下，我们都想重试清理，以便摆脱这种状态！</span></span><br><span class="line">        cleanupQueue.schedule(cleanupTask)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">    <span class="comment">// 翻译:在创建文件之前刷新日志以防止文件泄漏</span></span><br><span class="line">    <span class="comment">// 先在journal文件中写入DIRTY</span></span><br><span class="line">    <span class="keyword">val</span> journalWriter = <span class="keyword">this</span>.journalWriter!!</span><br><span class="line">    journalWriter.writeUtf8(DIRTY)</span><br><span class="line">    .writeByte(<span class="string">&#x27; &#x27;</span>.toInt())</span><br><span class="line">    .writeUtf8(key)</span><br><span class="line">    .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    journalWriter.flush()</span><br><span class="line">	<span class="comment">// 若写入journal文件失败则hasJournalErrors = true</span></span><br><span class="line">    <span class="keyword">if</span> (hasJournalErrors) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// Don&#x27;t edit; the journal can&#x27;t be written.</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建Entry,此Entry为DiskLruCache.Entry</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123; </span><br><span class="line">        entry = Entry(key)</span><br><span class="line">        lruEntries[key] = entry</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Editor、作用就是具体的输入流和输出流的操作者</span></span><br><span class="line">    <span class="keyword">val</span> editor = Editor(entry)</span><br><span class="line">    entry.currentEditor = editor</span><br><span class="line">    <span class="keyword">return</span> editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DiskLruCache.Entry 的解析</strong></p>
<p><code>DiskLruCache</code>中存储的缓存实体对象，一个<code>Entry</code>对象代表一条缓存。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">internal</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> key: String</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度数组，下标0代表头文件大小，下标1代表响应体内容文件大小</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> lengths: LongArray = LongArray(valueCount) </span><br><span class="line">    <span class="comment">// 像日志一样，分为tmp和正式文件，真正的缓存也是如此</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> cleanFiles = mutableListOf&lt;File&gt;() <span class="comment">//正式缓存文件集合</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">val</span> dirtyFiles = mutableListOf&lt;File&gt;()	<span class="comment">//脏缓存文件集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前缓存是否可用</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> readable: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前编辑或读取完成时必须删除此条目，则为真。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> zombie: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在进行的编辑，如果此条目未被编辑，则为 null。将此设置为 null 时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> currentEditor: Editor? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此条缓存打开的输入流的总数。当将此值递减为零时，则该条目是僵尸条目，必须删除该条目。</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> lockingSourceCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sequenceNumber: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">   		<span class="comment">// 以key为文件名创建File对象</span></span><br><span class="line">        <span class="keyword">val</span> fileBuilder = StringBuilder(key).append(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">val</span> truncateTo = fileBuilder.length</span><br><span class="line">        <span class="comment">// valueCount为2 循环两次</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until valueCount) &#123;</span><br><span class="line">            fileBuilder.append(i)</span><br><span class="line">            cleanFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            fileBuilder.append(<span class="string">&quot;.tmp&quot;</span>)</span><br><span class="line">            dirtyFiles += File(directory, fileBuilder.toString())</span><br><span class="line">            <span class="comment">// 删除后缀</span></span><br><span class="line">            fileBuilder.setLength(truncateTo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache.Entry#writeTo</p>
<p>这个方法就是将请求头信息写入文件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeTo</span><span class="params">(editor: <span class="type">DiskLruCache</span>.<span class="type">Editor</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 按照响应头的报文格式写入文件</span></span><br><span class="line">  editor.newSink(ENTRY_METADATA).buffer().use &#123; sink -&gt;</span><br><span class="line">    sink.writeUtf8(url).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(requestMethod).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong(varyHeaders.size.toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="comment">// 写入Vary</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until varyHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(varyHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(varyHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeDecimalLong((responseHeaders.size + <span class="number">2</span>).toLong()).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until responseHeaders.size) &#123;</span><br><span class="line">      sink.writeUtf8(responseHeaders.name(i))</span><br><span class="line">          .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">          .writeUtf8(responseHeaders.value(i))</span><br><span class="line">          .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">    sink.writeUtf8(SENT_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(sentRequestMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    sink.writeUtf8(RECEIVED_MILLIS)</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeDecimalLong(receivedResponseMillis)</span><br><span class="line">        .writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isHttps) &#123;</span><br><span class="line">      sink.writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      sink.writeUtf8(handshake!!.cipherSuite.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">      writeCertList(sink, handshake.peerCertificates)</span><br><span class="line">      writeCertList(sink, handshake.localCertificates)</span><br><span class="line">      sink.writeUtf8(handshake.tlsVersion.javaName).writeByte(<span class="string">&#x27;\n&#x27;</span>.toInt())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CacheInterceptor</span>(<span class="keyword">internal</span> <span class="keyword">val</span> cache: Cache?) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 获取当前的HTTP请求</span></span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中获取之前的缓存</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前时间、请求和缓存响应计算缓存策略</span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存策略中的网络请求和缓存响应</span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪缓存策略的结果</span></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取HTTP请求的事件监听器</span></span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存候选项存在但不适用于当前请求，则关闭它。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果禁止使用网络且缓存不足，则返回一个响应表示无法满足请求</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">            .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">            .body(EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.satisfactionFailure(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不需要网络请求，则直接返回缓存响应</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build().also &#123;</span><br><span class="line">                listener.cacheHit(call, it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有缓存响应，通知监听器</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 发起网络请求并获取网络响应</span></span><br><span class="line">    networkResponse = chain.proceed(networkRequest)</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 如果出现I/O错误或其他异常，确保不会泄漏缓存响应的主体（body）</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">	    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果同时有缓存响应和网络响应，表示进行条件获取（conditional get）操作</span></span><br><span class="line">		<span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 状态码给了304 说明服务器的Last-Modified字段对比一致 资源未修改可以使用缓存</span></span><br><span class="line">		    <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应状态码为304（未修改），则合并两个响应</span></span><br><span class="line">		        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 关闭网络响应的主体</span></span><br><span class="line">		        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 更新缓存，将合并后的响应存储到缓存中</span></span><br><span class="line">		        cache!!.trackConditionalCacheHit()</span><br><span class="line">		        cache.update(cacheResponse, response)</span><br><span class="line"></span><br><span class="line">		        <span class="comment">// 返回合并后的响应，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">	        &#125;</span><br><span class="line">			    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		        <span class="comment">// 如果网络响应不是304，关闭缓存响应的主体</span></span><br><span class="line">			        cacheResponse.body?.closeQuietly()</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">// 走到这里说明缓存失效需要处理返回的数据</span></span><br><span class="line">			<span class="comment">// 创建网络响应对象，同时处理缓存响应和网络响应的主体</span></span><br><span class="line">			<span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">				    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">				    .networkResponse(stripBody(networkResponse))</span><br><span class="line">				    .build()</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">		        <span class="comment">// 如果响应需要缓存并且满足缓存条件，将请求提供给缓存</span></span><br><span class="line">		        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        </span><br><span class="line">		        <span class="comment">// 返回一个响应，同时执行缓存写入操作，并通知监听器</span></span><br><span class="line">		        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">		            <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这会记录条件缓存未命中</span></span><br><span class="line">                listener.cacheMiss(call)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的HTTP方法会使缓存无效，尝试从缓存中删除相应的项</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">            <span class="comment">// 缓存无法删除，忽略异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回最终的响应</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a new source that writes bytes to [cacheRequest] as they are read by the source</span></span><br><span class="line"><span class="comment">   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we</span></span><br><span class="line"><span class="comment">   * may never exhaust the source stream and therefore not complete the cached response.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cacheWritingResponse</span><span class="params">(cacheRequest: <span class="type">CacheRequest</span>?, response: <span class="type">Response</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// 如果缓存请求为空，或者响应的主体为空，则直接返回响应</span></span><br><span class="line">    <span class="keyword">if</span> (cacheRequest == <span class="literal">null</span> || response.body == <span class="literal">null</span>) <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取缓存请求的未缓冲主体</span></span><br><span class="line">    <span class="keyword">val</span> cacheBodyUnbuffered = cacheRequest.body()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的主体源</span></span><br><span class="line">    <span class="keyword">val</span> source = response.body!!.source()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建缓存主体，使用缓冲</span></span><br><span class="line">    <span class="keyword">val</span> cacheBody = cacheBodyUnbuffered.buffer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于写入缓存的主体源</span></span><br><span class="line">    <span class="keyword">val</span> cacheWritingSource = <span class="keyword">object</span> : Source &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cacheRequestClosed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(sink: <span class="type">Buffer</span>, byteCount: <span class="type">Long</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> bytesRead: <span class="built_in">Long</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bytesRead = source.read(sink, byteCount)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheRequest.abort() <span class="comment">// 写入缓存响应失败，中止缓存请求。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!cacheRequestClosed) &#123;</span><br><span class="line">                    cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                    cacheBody.close() <span class="comment">// 缓存响应已完整写入！</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据写入缓存主体</span></span><br><span class="line">            sink.copyTo(cacheBody.buffer, sink.size - bytesRead, bytesRead)</span><br><span class="line">            cacheBody.emitCompleteSegments()</span><br><span class="line">            <span class="keyword">return</span> bytesRead</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">timeout</span><span class="params">()</span></span> = source.timeout()</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Throws(IOException::class)</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheRequestClosed &amp;&amp;</span><br><span class="line">                !discard(ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                cacheRequestClosed = <span class="literal">true</span></span><br><span class="line">                cacheRequest.abort()</span><br><span class="line">            &#125;</span><br><span class="line">            source.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取响应的Content-Type和Content-Length</span></span><br><span class="line">    <span class="keyword">val</span> contentType = response.header(<span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> contentLength = response.body.contentLength()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的响应，使用缓存写入的主体</span></span><br><span class="line">    <span class="keyword">return</span> response.newBuilder()</span><br><span class="line">        .body(RealResponseBody(contentType, contentLength, cacheWritingSource.buffer()))</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OKHttp的缓存设计"><a href="#OKHttp的缓存设计" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h3><p>OkHttp的缓存设计基于HTTP协议中定义的缓存机制。它允许客户端缓存请求的响应数据，减少不必要的网络请求，从而提高应用的性能和响应速度。下面是OkHttp缓存设计的关键点：</p>
<ol>
<li><p><strong>缓存存储</strong>：</p>
<ul>
<li>OkHttp使用<code>Cache</code>类管理缓存。该类负责存储、检索和清除缓存响应。</li>
</ul>
</li>
<li><p><strong>可缓存性</strong>：</p>
<ul>
<li>OkHttp中决定一个响应是否可以被缓存是基于HTTP头部信息，如<code>Cache-Control</code>、<code>Last-Modified</code>和<code>ETag</code>。</li>
</ul>
</li>
<li><p><strong>缓存策略</strong>：</p>
<ul>
<li>通过<code>CacheStrategy</code>类确定是返回缓存的响应还是发起网络请求。该策略考虑请求头中的缓存指令和响应头中的验证器（如ETag或者Last-Modified）。</li>
</ul>
</li>
<li><p><strong>缓存验证</strong>：</p>
<ul>
<li>当缓存的响应被认为是过时的，OkHttp会在新的请求中添加条件头部（例如<code>If-None-Match</code>或<code>If-Modified-Since</code>）去验证缓存。如果服务器返回304（Not Modified），表明缓存仍然有效，客户端可以继续使用缓存的数据。否则，使用新的响应数据。</li>
</ul>
</li>
<li><p><strong>缓存拦截器</strong>：</p>
<ul>
<li><code>CacheInterceptor</code>是OkHttp中管理缓存逻辑的拦截器。它会检查请求的缓存指令，根据现有的缓存响应和请求条件，选择是从缓存返回数据还是发起新的网络请求。</li>
</ul>
</li>
<li><p><strong>新鲜度和过期</strong>：</p>
<ul>
<li>缓存的响应要在一定时间内被认定为新鲜的，基于<code>Cache-Control</code>的<code>max-age</code>指令、<code>Expires</code>头部或者启发式的计算。如果响应不再新鲜，OkHttp将尝试重新验证缓存。</li>
</ul>
</li>
<li><p><strong>同步和异步请求</strong>：</p>
<ul>
<li>OkHttp的缓存策略对于同步和异步请求都适用。但它会确保在异步请求中，缓存操作和网络调用都是在后台线程中执行，不会阻塞主线程。</li>
</ul>
</li>
<li><p><strong>透明处理</strong>：</p>
<ul>
<li>对于OkHttp的使用者来说，缓存大部分时间是透明的，只需要配置好<code>Cache</code>对象，并附着到OkHttp客户端即可。实际的缓存逻辑由库内部管理。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li>OkHttp的缓存策略和逻辑遵循HTTP协议，但它也提供了一定程度的自定义，应用开发者可以通过设置请求头部来影响缓存的行为。</li>
</ul>
</li>
<li><p><strong>缓存持久性</strong>：</p>
<ul>
<li>OkHttp的缓存把响应数据存储在文件系统中，即使应用被杀死，这些缓存数据仍然可以在下次应用启动时被访问。</li>
</ul>
</li>
</ol>
<p>​		OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p><code>Http</code>的缓存规则分为两大类：<strong>强制缓存，对比缓存</strong>，与缓存规则相关的信息，均包含在报文的<code>Header</code>中。</p>
<p><strong>强制缓存</strong></p>
<p>​		强制缓存的实现依靠于<code>Expires</code>和<code>Cache-Control</code>这两个字段。<code>Expires</code> 通过这个 Header ，服务端可以告诉客户端缓存的过期时间，表示在过期时间内该资源都不会被更改，可以不用再向自己请求了。但因为客户端时间和服务器时间的差异，在在 HTTP&#x2F;1.1 协议中引入了 <code>Cache-Control</code> 机制，通过这个 Header 可以在服务端与客户端之间沟通缓存信息。常见的缓存指令如下</p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center"><strong>客户端</strong>可以缓存</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center"><strong>客户端</strong>和<strong>代理服务器</strong>都可以缓存</td>
</tr>
<tr>
<td align="center">max-age&#x3D;xxx</td>
<td align="center">缓存数据在xxx秒后过期</td>
</tr>
<tr>
<td align="center">no-cache</td>
<td align="center">需要使用对比缓存来验证缓存数据</td>
</tr>
</tbody></table>
<p><strong>对比缓存</strong></p>
<p>​		浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若缓存资源仍有效，服务器会返回304状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>通过Last-Modified &#x2F; If-Modified-Since与Cache-Control配合判断，<code>Last-Modified</code> 位于响应头，<code>If-Modified-Since</code> 位于请求头。</p>
<ul>
<li><p><code>Last-Modified</code>：该响应资源最后的修改时间，服务器在响应请求的时候可以填入该字段。</p>
</li>
<li><p>If-Modified-Since：客户端缓存过期时（<code>max-age</code> 到达），发现该资源具有 <code>Last-Modified</code> 字段，可以在 Header 中填入 <code>If-Modified-Since</code> 字段，并填入<code>Last-Modified</code>记录的时间。服务端收到该时间后会与该资源的最后修改时间进行比较。</p>
<ul>
<li><p>若该资源已经被修改 ，则会返回状态码200，并对整个资源响应。</p>
</li>
<li><p>否则说明该资源在访问时未被修改，则会响应状态码 304，告知客户端可以使用缓存的资源</p>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>​		强制缓存和对比缓存可以同时存在，<strong>强制缓存优先级高于对比缓存</strong>，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p>当强制缓存和对比缓存同时存在时：</p>
<ol>
<li>对于强制缓存，服务端通知客户端一个缓存时间，在缓存时间内客户端可以直接使用缓存的资源，不在缓存时间内，若客户端需要获取数据，则需要执行对比缓存策略。</li>
<li>对于比较缓存，客户端将缓存信息中的<code>Etag</code>和<code>Last-Modified</code>通过请求发送给服务器，由服务器校验，若返回304状态码，则客户端可以使用缓存中的资源。否则返回200并对整个资源响应。</li>
</ol>
<h2 id="ConnectInterceptor-建立连接的拦截器"><a href="#ConnectInterceptor-建立连接的拦截器" class="headerlink" title="ConnectInterceptor 建立连接的拦截器"></a>ConnectInterceptor 建立连接的拦截器</h2><p>该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。</p>
<p><a href="https://www.cnblogs.com/giagor/p/15706524.html">探索OkHttp系列 (五) 连接建立与复用 - Giagor - 博客园</a></p>
<h3 id="HTTP中的连接复用机制"><a href="#HTTP中的连接复用机制" class="headerlink" title="HTTP中的连接复用机制"></a><strong><strong>HTTP中的连接复用机制</strong></strong></h3><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Http协议需要首先建立Socket连接（即TCP&#x2F;IP连接），同时我们了解到TCP&#x2F;IP连接需要进行三次握手，断开连接需要完成四次挥手。在完成了对某一域名的Socket连接之后，借助此Socket来进行Http数据的交互。那么第一次交互完成之后，如果需要进行与此域名的第二次交互，就可以利用前一次的Socket连接进行。因此OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。</p>
<h3 id="okHttp如何复用TCP连接？"><a href="#okHttp如何复用TCP连接？" class="headerlink" title="okHttp如何复用TCP连接？"></a><strong>okHttp如何复用TCP连接？</strong></h3><p>这个其实主要说的是 <code>ConnectInterceptor</code> 拦截器中初始化 <code>Exchange</code> 时内部做的事，具体如下：</p>
<p><code>OkHttp</code> 使用连接池 <code>RealConnectionPool</code> 管理所有连接，连接池将所有活动的连接存储在池中，并维护了一个空闲的链接列表(<code>TaskQueue</code>)，当需要新的连接时，<strong>优先尝试从这个池中找</strong>，如果没找到，则 <strong>重新创建</strong> 一个 <code>RealConnection</code> 连接对象，并将其添加到连接池中。在具体的寻找连接的过程中，一共进行了下面5次尝试：</p>
<ol>
<li>尝试重连 <code>RealCall</code> 中的 <code>connection</code>，此时不需要重新获取连接；</li>
<li>尝试从连接池中获取一个连接，不带路由与多路复用；</li>
<li>再次尝试从连接池中获取一个连接，带路由，不带多路复用；</li>
<li>手动创建一个新连接；</li>
<li>再次尝试从连接池中获取一个连接，带路由与多路复用；</li>
</ol>
<p>当然 <code>OkHttp</code> 也支持自定义连接池，具体如下：</p>
<p><img src="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png" alt="https://developer.qcloudimg.com/http-save/1094110/29501c56af8785f644965998240d4a29.png"></p>
<p>上述代码中，创建了一个新的连接池，并设置其保留最多 <code>maxIdleConnections</code> 个空闲连接，并且连接的存活期为 <code>keepAliveDuration</code> 分钟。</p>
<h3 id="okhttp连接池使用流程"><a href="#okhttp连接池使用流程" class="headerlink" title="okhttp连接池使用流程"></a>okhttp连接池使用流程</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20211209161223068.png" alt="image-20211209161223068"></p>
<h3 id="从连接池中获取可用连接部分代码分析"><a href="#从连接池中获取可用连接部分代码分析" class="headerlink" title="从连接池中获取可用连接部分代码分析"></a>从连接池中获取可用连接部分代码分析</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个连接去承载新的流，优先使用现有连接，接着是连接池中的连接，最后是创建一个新的连接</span></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RealConnection &#123;</span><br><span class="line">  <span class="comment">// 检查取消事件  </span></span><br><span class="line">  <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.尝试去重用call的连接  </span></span><br><span class="line">  <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">  <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">    synchronized(callConnection) &#123;</span><br><span class="line">      <span class="comment">// 检查这个连接是否可用和可复用  </span></span><br><span class="line">      <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">        <span class="comment">// 连接不可用，在call中移除该连接，并返回该连接对应的Socket，随后要关闭它  </span></span><br><span class="line">        toClose = call.releaseConnectionNoEvents()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here</span></span><br><span class="line">    <span class="comment">// because we already acquired it.</span></span><br><span class="line">    <span class="comment">// 如果连接可以使用，那么就返回该连接  </span></span><br><span class="line">    <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">      check(toClose == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> callConnection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The call&#x27;s connection was released.</span></span><br><span class="line">    <span class="comment">// 关闭Socket  </span></span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line">    eventListener.connectionReleased(call, callConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need a new connection. Give it fresh stats.</span></span><br><span class="line">  refusedStreamCount = <span class="number">0</span></span><br><span class="line">  connectionShutdownCount = <span class="number">0</span></span><br><span class="line">  otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.尝试从连接池中获取连接(第一次)</span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Nothing in the pool. Figure out what route we&#x27;ll try next.</span></span><br><span class="line">  <span class="comment">// 连接池里没有东西，计算下一条要尝试的路由  </span></span><br><span class="line">  <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">  <span class="keyword">val</span> route: Route</span><br><span class="line">  <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Use a route from a preceding coalesced connection.</span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = nextRouteToTry!!</span><br><span class="line">    nextRouteToTry = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 从现有的routeSelection中获取一个路由  </span></span><br><span class="line">    routes = <span class="literal">null</span></span><br><span class="line">    route = routeSelection!!.next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 计算一个新的routeSelector，这是一个阻塞操作  </span></span><br><span class="line">    <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">    <span class="comment">// 如果routeSelector为null，那么就先创建一个RouteSelector  </span></span><br><span class="line">    <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">      <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从routeSelector中获取一个新的routeSelection  </span></span><br><span class="line">    <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">    routeSelection = localRouteSelection</span><br><span class="line">    <span class="comment">// 获取routeSelection中的路由列表  </span></span><br><span class="line">    routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">    <span class="comment">// the pool. We have a better chance of matching thanks to connection coalescing.</span></span><br><span class="line">    <span class="comment">// 3.现在我们有了一组IP地址，再次尝试从连接池中获取连接，由于连接合并，这次我们有更大的希望</span></span><br><span class="line">    <span class="comment">// 从连接池里获取一个连接(第二次)  </span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">      eventListener.connectionAcquired(call, result)</span><br><span class="line">      <span class="comment">// 返回连接</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从routeSelection中获取一个路由，用于新连接的创建  </span></span><br><span class="line">    route = localRouteSelection.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect. Tell the call about the connecting call so async cancels work.</span></span><br><span class="line">  <span class="comment">// 4.创建新连接  </span></span><br><span class="line">  <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">  call.connectionToCancel = newConnection</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行TCP+TLS握手(Https请求才会做TLS握手)，这是一个阻塞的操作    </span></span><br><span class="line">    newConnection.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we raced another call connecting to this host, coalesce the connections. This makes for 3</span></span><br><span class="line">  <span class="comment">// different lookups in the connection pool!</span></span><br><span class="line">  <span class="comment">// 5.如果有另一个调用也是连接到相同的主机，并且该调用已经创建了新连接，将连接放到了连接池里，</span></span><br><span class="line">  <span class="comment">// 那么就使用连接池里的连接(第三次)  </span></span><br><span class="line">  <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">    <span class="comment">// 保存路由  </span></span><br><span class="line">    nextRouteToTry = route</span><br><span class="line">    <span class="comment">// 将前面新创建的连接的Socket关闭  </span></span><br><span class="line">    newConnection.socket().closeQuietly()</span><br><span class="line">    eventListener.connectionAcquired(call, result)</span><br><span class="line">    <span class="comment">// 返回连接池中的连接</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 第三次在连接池中获取连接，依然没找到，意味着要使用新创建的连接 */</span>  </span><br><span class="line">      </span><br><span class="line">  synchronized(newConnection) &#123;</span><br><span class="line">    <span class="comment">// 6.将先创建的连接放进连接池里面</span></span><br><span class="line">    connectionPool.put(newConnection)</span><br><span class="line">    call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">  <span class="comment">// 返回新创建的连接  </span></span><br><span class="line">  <span class="keyword">return</span> newConnection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CallServerInterceptor：执行网络请求的拦截器"><a href="#CallServerInterceptor：执行网络请求的拦截器" class="headerlink" title="CallServerInterceptor：执行网络请求的拦截器"></a>CallServerInterceptor：执行网络请求的拦截器</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallServerInterceptor</span>(<span class="keyword">private</span> <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span>) : Interceptor &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="comment">// 以Request作为Key，获取候选缓存  </span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据「当前时间、请求、候选缓存」，创建缓存策略  </span></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="comment">// 如果该请求不需要使用网络，那么networkRequest就为null  </span></span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="comment">// 如果不存在该请求对应的缓存，那么cacheResponse为null  </span></span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且没有对应的缓存，那么直接报错，返回状态码504  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.satisfactionFailure(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">    <span class="comment">// 如果该请求不使用网络，并且有对应的缓存，那么就进入If语句，返回缓存</span></span><br><span class="line">    <span class="comment">// (代码执行到这里，说明networkRequest和cacheResponse不能同时为null)  </span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 经过上面的两个If语句，代码执行到这里，说明networkRequest不为null，也就是该请求要使用网络 */</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示网络请求的响应  </span></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 进行网络请求，获取下一个拦截器返回的Response  </span></span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">      <span class="comment">// 释放资源  </span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 之前已经获取到请求对应的缓存  </span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若网络请求返回的响应中，包含状态码304，说明之前的缓存数据有效，返回cacheResponse对应</span></span><br><span class="line">      <span class="comment">// 的缓存结果（HTTP_NOT_MODIFIED对应状态码304）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">  			<span class="comment">// 混合 缓存Response的Header 和 网络获取的Response的Header        </span></span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存过期，收回资源  </span></span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* 在上面的一大段If语句中，若响应码为304，则缓存资源有效，返回缓存资源，若响应码不为304， */</span>  </span><br><span class="line">	<span class="comment">/* 则表示缓存资源过期，关闭缓存资源 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取网络请求的结果  </span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 对网络请求获取的Response进行缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This will log a conditional cache miss only.</span></span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果请求方法不需要缓存，则移除缓存  </span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回网络的请求结果  </span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>自定义拦截器有两种应用拦截器和网络拦截器分别在两个位置，一个是在拦截器链头部，一个是在<strong>CallServerInterceptor和</strong>ConnectInterceptor中间。</p>
<p>他俩的区别：</p>
<ul>
<li>添加方式</li>
</ul>
<p>头：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>尾：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h4 id="对OKHttp有了解吗，拦截器这一块有了解吗？"><a href="#对OKHttp有了解吗，拦截器这一块有了解吗？" class="headerlink" title="对OKHttp有了解吗，拦截器这一块有了解吗？"></a>对OKHttp有了解吗，拦截器这一块有了解吗？</h4><p>OKHttp有五种自己的拦截器：</p>
<ol>
<li><p><code>RetryAndFollowUpInterceptor</code>：负责失败的网络重试和 URL 重定向。</p>
</li>
<li><p><code>BridgeInterceptor</code>：将应用程序原始的请求转换为可以通过网络发送的请求，同样也将来自服务器的响应转换为可以给应用程序使用的响应。如：添加 Content-Length ， Gzip 等编解码， cookies 的处理都在这。</p>
</li>
<li><p><code>CacheInterceptor</code>：这是 OkHttp 实现缓存的关键， CacheInterceptor 将查看服务器响应头中的缓存指令并尝试从应用程序配置的 Cache 中获取潜在的缓存响应。</p>
</li>
<li><p><code>ConnectInterceptor</code>：它通过向服务器建立实际的网络连接来开始网络请求的链。</p>
</li>
<li><p><code>CallServerInterceptor</code>：这是网络链的最后一个拦截器，它会将请求数据发送给服务器并从服务器获取响应数据。</p>
<p>还有两种自定义的拦截器：</p>
<ul>
<li><p>这两种拦截器的区别在于添加方法不同，所以添加后的位置也不一样。</p>
<ul>
<li>添加方式</li>
</ul>
<p>应用拦截器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      interceptors += interceptor</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>网络拦截器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">OkHttpClient:Builder:: addInterceptor()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNetworkInterceptor</span><span class="params">(interceptor: <span class="type">Interceptor</span>)</span></span> = apply &#123;</span><br><span class="line">      networkInterceptors += interceptor</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他们不是只能添加一个拦截器能添加多个，只是位置只有两个，看下面代码了解吧。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意都是List </span></span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;interceptors&quot;</span>) <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.interceptors.toImmutableList()</span><br><span class="line"><span class="meta">@get:JvmName</span>(<span class="string">&quot;networkInterceptors&quot;</span>) <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; =</span><br><span class="line">      builder.networkInterceptors.toImmutableList()</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors. <span class="comment">// 这里添加的自定义头拦截器 </span></span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors <span class="comment">// 添加自定义拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>位置代表的执行顺序</li>
</ul>
<p>应用拦截器只会执行一次，网络拦截器可能会执行多次，比如再请求重试的情况下。也有可能在CacheInterceptor命中了缓存就不会进行网络请求。</p>
<ul>
<li>功能</li>
</ul>
<p>应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</p>
</li>
</ul>
</li>
</ol>
<h4 id="有没有用到过自定义拦截器，怎么用的"><a href="#有没有用到过自定义拦截器，怎么用的" class="headerlink" title="有没有用到过自定义拦截器，怎么用的"></a>有没有用到过自定义拦截器，怎么用的</h4><p>实现 <code>Interceptor</code> 接口并重写 <code>intercept</code> 方法。可以在 <code>intercept</code> 方法中对 <code>request</code> 和 <code>response</code> 进行监控或者修改。</p>
<p>以下是一个简单的打印请求日志的自定义拦截器：</p>
<p>kotlin</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingInterceptor</span> : <span class="type">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">        <span class="keyword">val</span> request = chain.request()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印请求信息</span></span><br><span class="line">        println(<span class="string">&quot;Sending request to <span class="subst">$&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求并获取响应</span></span><br><span class="line">        <span class="keyword">val</span> response = chain.proceed(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印响应信息</span></span><br><span class="line">        println(<span class="string">&quot;Received response from <span class="subst">$&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>OkHttpClient</code> 配置中添加自定义的拦截器：</p>
<p>kotlin</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> client = OkHttpClient.Builder()</span><br><span class="line">    .addInterceptor(LoggingInterceptor())</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>以上示例的拦截器会打印每个请求的发送和响应接收信息。同时注意到添加拦截器的方法以 <code>.addInterceptor()</code> 的形式插入到了 OkHttpClient 的构建过程中。这样，新建的 OkHttpClient 实例就具备了我们自定义处理逻辑的能力。</p>
<h4 id="拦截器一定会被执行吗"><a href="#拦截器一定会被执行吗" class="headerlink" title="拦截器一定会被执行吗"></a>拦截器一定会被执行吗</h4><p>​		在OkHttp中，拦截器是否会被执行取决于多个因素。首先，应用拦截器（通过<code>addInterceptor()</code>方法添加的拦截器）一定会被执行一次。</p>
<p>然而，网络拦截器（通过<code>addNetworkInterceptor()</code>方法添加的拦截器）可能不会被执行，或者可能会被执行多次。例如，当发生错误重试或网络重定向时，网络拦截器可能会被执行多次。</p>
<p>另外，如果在拦截器链中的某个拦截器返回了<code>null</code>，那么后面的拦截器将不会被执行。</p>
<h4 id="简单说下OKHttp一个网络请求的流程"><a href="#简单说下OKHttp一个网络请求的流程" class="headerlink" title="简单说下OKHttp一个网络请求的流程"></a>简单说下OKHttp一个网络请求的流程</h4><p>​		<strong>先创建OkHttpClient</strong><code>val client = OkHttpClient.Builder().xxx.build()</code>,<strong>然后创建请求体</strong><code>request = Request.Builder().url(&quot;http://www.baidu.com&quot;).build()</code> 这里定义了请求地址。<strong>然后使用enqueue或者execute开启请求</strong> <code>client?.newCall(request)?.execute()</code>。 </p>
<p>​		其中newCall(request)会将请求封装成一个reallCall对象。然后调用reallCall的enqueue方法开启请求。这个方法的入参是一个callback 接口对象，这是用来返回请求结果的，然后最终会回调 <code>getResponseWithInterceptorChain()</code>方法的结果。这个就是通过拦截器链处理请求的方法。这个后面再说。</p>
<p>​		execute方法里会先将当前请求放入调度器的任务队列中，然后再适当的时机将他添加到线程池中启动。reallCall继承自Runnable真正的任务内容再run方法中。这里还是使用getResponseWithInterceptorChain返回结果</p>
<p>​		getResponseWithInterceptorChain中定义了拦截器链其中包括五个自带的拦截器和两个自定义的拦截器，其中的拦截器按照顺序来看依次是，应用拦截器、重试重定向拦截器、请求响应转换拦截器、缓存拦截器、链接建立拦截器、自定义的网络拦截器、然后是最后读写拦截器 。开启拦截器链进行请求</p>
<p>​		先是重试重定向拦截器，先说重试，在方法中有一个while (true)的死循环循环中有个try catch用来捕获请求过程中出现的异常，如果命中了可以重试的异常就不会抛出而是继续下一次的循环，开启新的请求。重定向的话会根据响应的code （30x）判断是否需要重定向，是的话重新赋值request进行新的请求。如果重试和重定向都没命中会直接返回response </p>
<p>​		请求响应转换拦截器，主要是对请求头和相应头的处理</p>
<p>​		缓存拦截器，这个拦截器默认是null，如果需要的话需要在构造的时候手动添加且只会缓存get请求。假设添加了话，它会根据后面拦截器返回的网络请求结果networkRequest和cacheResponse来进行一个策略判断，两个都是null直接504，networkRequest为null，cacheResponse不为null则直接返回cacheResponse，networkRequest不为null，cacheResponse为null则返回networkRequest满足条件的话缓存networkRequest。两个都不为null，网络Response状态码若为304，则混合请求头后更新缓存，并返回缓存；若状态码为200,返回网络Response,满足缓存条件则缓存Response。 然后cacheResponse的存储使用的是磁盘缓存。</p>
<p>​		建立连接的拦截器，该拦截器的作用是<strong>获得一个健康可用的与目标服务器的连接</strong>，然后就将请求交给下一个拦截器处理。OkHttp维护一个连接对象（Socket对象）复用池，在需要发起网络交互前，先尝试从对象池中查找是否有与本次请求的域名建立好的有效Socket连接，如果有，就不需要再去进行三次握手建立新的Socket连接。没有的话就会新创建一个连接。</p>
<p>​		网络请求的拦截器，间接调用编码器的一些方法对数据进行接收和输出以及对一些状态码的处理。</p>
<h4 id="OKHttp的缓存设计-1"><a href="#OKHttp的缓存设计-1" class="headerlink" title="OKHttp的缓存设计"></a>OKHttp的缓存设计</h4><p>​		OkHttp的缓存设计基于HTTP协议中定义的缓存机制，是否使用缓存取决于networkRequest和cacheResponse，这俩的赋值取决于CacheStrategy.Factory。</p>
<p>​		CacheStrategy.Factory存储了之前缓存的响应的响应头：Date、Expires、Last-Modified、ETag、Age、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>，以及请求中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since">If-Modified-Since</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match">If-None-Match</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a>。先判断这些字段和响应码、判断通过后再通过有效时间判断是否可用，某些情况下还会通过请求验证服务端返回<code>304</code>则意味着缓存可以继续使用，若是<code>200</code>则使用新的响应数据。</p>
<h4 id="OKHttp设计的精髓在哪里"><a href="#OKHttp设计的精髓在哪里" class="headerlink" title="OKHttp设计的精髓在哪里"></a>OKHttp设计的精髓在哪里</h4><p>​		责任链模式的设计</p>
<h4 id="OKHttp连接池作用是什么"><a href="#OKHttp连接池作用是什么" class="headerlink" title="OKHttp连接池作用是什么"></a>OKHttp连接池作用是什么</h4><p>​		复用 TCP 连接，减少三次握手的次数。</p>
<h4 id="假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗"><a href="#假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗" class="headerlink" title="假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗"></a>假设一个请求百度API，一个请求腾讯APi，连接池可以复用吗</h4><p>​		复用时会通过<strong>主机名和端口号</strong>判断是否可用。</p>
<h4 id="连接池怎么复用"><a href="#连接池怎么复用" class="headerlink" title="连接池怎么复用"></a>连接池怎么复用</h4><p>​		OkHttp中的连接池最大空闲连接的数量为5，并且最大的空闲时间为5分钟，这里的最大空闲连接数量是相对于一个地址而言。</p>
]]></content>
  </entry>
  <entry>
    <title>Android 内存泄漏相关</title>
    <url>/2023/12/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h3 id="ART虚拟机"><a href="#ART虚拟机" class="headerlink" title="ART虚拟机"></a>ART虚拟机</h3><p>每个 Android 应用在启动时都会创建一个新的进程，和一个对应的运行时环境实例，当中包括堆（Heap）的分配和垃圾回收等功能。在操作系统中，每个进程都有自己的独立地址空间，这包括了堆、栈、代码和数据段。</p>
<p>一个运行中的程序（进程）的内存空间被划分为几个区域，每个区域有特定的用途和属性：</p>
<ol>
<li><strong>栈（Stack）</strong>：<ul>
<li>栈是由编译器自动管理的内存区域，用于存储程序执行时的函数调用信息。</li>
<li>它包括函数的参数值、返回地址以及局部变量等。</li>
<li>栈的特点是后进先出（LIFO）的数据结构，每当一个函数被调用时，它的信息就被推入（push）栈中，当函数调用完成后，这些信息就会被弹出（pop）栈。</li>
<li>分配时机：栈空间通常在程序开始执行时由操作系统自动分配，随着函数的调用和返回，会动态地增长和缩减。</li>
<li>分配者：操作系统负责分配一个初始栈空间给进程，并在运行时对栈进行管理。</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>堆是用于动态内存分配的区域，程序在运行时可以从堆上分配或释放内存。</li>
<li>在C语言中，动态内存分配是通过<code>malloc</code>、<code>calloc</code>、<code>realloc</code>和<code>free</code>等函数实现的。</li>
<li>在Android开发中，Java虚拟机（JVM）或其他运行环境（如Dalvik虚拟机或Android Runtime, ART）管理堆内存，程序员通常不需要手动管理这部分内存，因为垃圾回收器会自动回收不再使用的对象。</li>
<li>分配时机：堆空间的分配是在程序运行时根据需要进行的，通常是程序员通过代码请求分配。</li>
<li>分配者：在C和C++等语言中，是由程序员通过调用<code>malloc</code>、<code>new</code>等函数显式申请的。在Java、C#等使用垃圾回收机制的语言中，由虚拟机或运行时环境负责管理。</li>
</ul>
</li>
<li><strong>BSS段（Block Started by Symbol）</strong>：<ul>
<li>BSS段用于存储程序中的未初始化的全局变量和静态变量。</li>
<li>在程序启动时，BSS段会被操作系统初始化为零或空指针。</li>
<li>分配时机：BSS段的空间分配发生在程序启动时，在程序被加载到内存时自动分配。</li>
<li>分配者：操作系统在加载程序时，会根据可执行文件的信息为BSS段分配内存，并将其初始化为零。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>数据段用来存储程序中已初始化的全局变量和静态变量。</li>
<li>这些变量的初始值存储在程序的可执行文件中，并在程序加载到内存时被初始化。</li>
<li>分配时机：数据段也是在程序启动时分配的，当程序被加载到内存时进行。</li>
<li>分配者：操作系统根据程序的可执行文件内容，在加载程序时为数据段分配内存，并赋予初始值。</li>
</ul>
</li>
<li><strong>程序代码区（Text Segment 或 Code Segment）</strong>：<ul>
<li>程序代码区，也称为文本段，包含了程序的机器指令代码。</li>
<li>这部分内存通常是只读的，以防止程序在运行时被意外修改。</li>
<li>它对应的是程序源代码文件中的实际指令和函数定义。</li>
<li>分配时机：程序代码区的分配同样发生在程序启动时，即当程序被加载到内存中时。</li>
<li>分配者：操作系统根据可执行文件中的代码段来分配内存，并将程序代码加载到这一段内存中。</li>
</ul>
</li>
</ol>
<h3 id="JVM、ART、DVM-的区别"><a href="#JVM、ART、DVM-的区别" class="headerlink" title="JVM、ART、DVM 的区别"></a>JVM、ART、DVM 的区别</h3><p>Java虚拟机（JVM）和Android虚拟机（如Dalvik虚拟机和Android Runtime，ART）都是为了运行基于Java语言编写的程序而设计的，但它们在设计理念、架构和运行环境上存在一些关键区别：</p>
<h4 id="功能原理："><a href="#功能原理：" class="headerlink" title="功能原理："></a>功能原理：</h4><p><strong>JVM</strong>：</p>
<p>我们写的java文件,经过编译生成.class文件,然后经过java虚拟机类加载 就成了.class类,也就是我们运行时访问的XXX.class类。JVM底层会将字节码转换为机器码,然后运行在CPU内.也可以这么理解:<strong>JVM就是个转换器,他将我们写的代码转换为CPU可以识别的代码,然后运行在CPU内</strong>。</p>
<p>或者说: JVM将CPU可以识别的代码,翻译成我们认识的java代码,让我们来写,我们写完后,它再负责翻译回去,让CPU执行。不同平台有不同的JVM,所以我们写一套代码,就能转换成不同平台的机器码,也就可以运行在不同平台上,这就是java跨平台的原理.</p>
<p><strong>DVM</strong>：</p>
<p>在app启动后,我们执行到对应功能的时候,就将这部分功能对应的代码 转换为 机器码,保存起来然后执行,可以理解为:<strong>用到才转换,所以也被称为JIT(just in time)</strong>.</p>
<p>优点：节省内存</p>
<p>缺点：执行速度慢</p>
<p><strong>ART</strong>：</p>
<p>主要有两个改善的地方.</p>
<ul>
<li><p>1 将转换为机器码的过程提前到了安装apk的时候.</p>
</li>
<li><p>2 内存分配方式和垃圾回收机制做了极大的优化.</p>
<p>DVM是基于JIT实现的,也就是边编译边执行,在运行到对应功能的时候,才将代码转换为机器码,然后交给CPU去执行.</p>
<p>而ART则不然,ART是在app安装的时候,就提前将所有代码转换为机器码保存下来,等到执行的时候,直接取出来在CPU中执行,也就是说,<strong>ART将转换为机器码这件事提前了. 所以叫做AOT(ahead of time)</strong>.</p>
</li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><strong>JVM</strong>：</p>
<ul>
<li>基于堆栈，每个线程都有自己的方法调用栈，栈帧中存储局部变量和操作数。</li>
<li>运行标准Java字节码，通常以<code>.class</code>文件的形式存在。</li>
<li>可在多种操作系统上运行，是跨平台的。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li><p>Dalvik有自己的字节码，不使用Java字节码</p>
</li>
<li><p>基于寄存器，更适合于资源受限的系统，如移动设备。</p>
</li>
<li><p>执行专为Dalvik设计的.dex格式文件，这是一种紧凑、针对Dalvik优化的字节码格式。</p>
</li>
<li><p>ART通过预编译（AOT编译）将应用程序转换为本机代码，从而提高性能。Dalvik采用的是JIT即时编译技术。</p>
</li>
<li><p>专门为Android系统设计，不是通用的跨平台解决方案。</p>
</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><strong>JVM</strong>：</p>
<ul>
<li>采用即时编译（JIT）技术，在程序运行时将字节码编译成本地代码，实现性能优化。</li>
<li>服务器和桌面环境中的JVM会进行大量的性能优化以提高吞吐量和减少延迟。</li>
</ul>
<p><strong>Dalvik&#x2F;ART</strong>：</p>
<ul>
<li>Dalvik使用JIT编译，但受限于移动设备的性能和电池寿命的限制。</li>
<li>ART使用AOT编译，应用程序在安装时就被编译成本地代码，并在运行时进行JIT编译优Java虚拟机（JVM）和Android虚拟机（主要是指Dalvik虚拟机和Android运行时ART）都是为了在不同的硬件和操作系统平台上运行编译后的代码而设计的，但它们在设计哲学、实现方式和优化目标上有所不同。</li>
</ul>
<p>以下是JVM和Android虚拟机（Dalvik和ART）的一些主要区别：</p>
<h4 id="目标平台："><a href="#目标平台：" class="headerlink" title="目标平台："></a>目标平台：</h4><ul>
<li><strong>JVM</strong>：设计用于运行跨平台的Java应用程序，通常安装在个人电脑、服务器和大型系统上。</li>
<li><strong>Android虚拟机</strong>：专门为低功耗、有限内存的移动设备设计。</li>
</ul>
<h4 id="执行代码格式："><a href="#执行代码格式：" class="headerlink" title="执行代码格式："></a>执行代码格式：</h4><ul>
<li><strong>JVM</strong>：执行Java字节码，通常是<code>.class</code>文件或<code>.jar</code>文件中的代码。</li>
<li><strong>Dalvik</strong>：执行为Android优化的Dex（Dalvik Executable）格式代码。</li>
<li><strong>ART</strong>：虽然也支持Dex格式，但在应用安装时会将Dex编译成系统特定的本地机器码。</li>
</ul>
<h4 id="编译方法："><a href="#编译方法：" class="headerlink" title="编译方法："></a>编译方法：</h4><ul>
<li><strong>JVM</strong>：主要使用即时编译（JIT），应用程序在运行时编译成本地代码。</li>
<li><strong>Dalvik</strong>：使用解释执行，但也有JIT编译提高性能。</li>
<li><strong>ART</strong>：使用预先编译（AOT），在安装时将应用编译成本地代码，以及在运行时通过JIT进行优化。</li>
</ul>
<h4 id="垃圾回收（GC）："><a href="#垃圾回收（GC）：" class="headerlink" title="垃圾回收（GC）："></a>垃圾回收（GC）：</h4><ul>
<li><strong>JVM</strong>：提供多种垃圾回收器，可根据应用需求选择（如G1、CMS、Parallel等）。</li>
<li><strong>Dalvik</strong>：使用一个简单的GC机制，适合内存有限的设备。</li>
<li><strong>ART</strong>：提供改进的GC机制，包括分代垃圾回收和并发垃圾回收，以减少应用暂停时间。</li>
</ul>
<h4 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h4><ul>
<li><strong>JVM</strong>：在服务器和桌面环境中，性能优化侧重于最大化吞吐量和减少GC暂停时间。</li>
<li><strong>Android虚拟机</strong>：在移动设备上，优化侧重于启动速度，运行效率和响应速度，以及减少内存使用。</li>
</ul>
<h4 id="开发和分发模型："><a href="#开发和分发模型：" class="headerlink" title="开发和分发模型："></a>开发和分发模型：</h4><ul>
<li><strong>JVM</strong>：通常用于开发通用Java应用程序，可以在任何安装了兼容JVM的系统上运行。</li>
<li><strong>Android虚拟机</strong>：用于开发Android应用程序，这些应用程序通过Google Play商店或其他方式分发给Android用户。</li>
</ul>
<p>综上所述，JVM和Android虚拟机虽然都是虚拟机，但是它们在设计上是为了满足不同平台和需求而优化的。JVM更加通用和多功能，而Android虚拟机则是专门为移动设备和Android操作系统优化。</p>
<h3 id="ART-Java-堆组成"><a href="#ART-Java-堆组成" class="headerlink" title="ART Java 堆组成"></a>ART Java 堆组成</h3><p>当 Android 虚拟机启动时，便会创建 Java 堆，后续所有 Java 对象所需要的内存都会从这个堆中分配，所以我们先来说说 Java 堆的组成。Java 堆由 <strong>ImageSpace、ZygoteSpace、Non moving space、LargeObjectSpace、MainSpace</strong> 这五个部分组成，下面是对每个组成的说明。</p>
<ul>
<li><strong>ImageSpace</strong>：用来存放系统库的对象，大小不固定。</li>
<li><strong>ZygoteSpace</strong>：存放 Zygote 进程在启动过程中预加载和创建的各种对象，应用进程为 2M 左右，Zygote 进程为 64M，挨着 Image Space。</li>
<li><strong>Non moving space</strong>：如果非 zygote 或 Native 进程启动时，便会将 ZygoteSpace 切分出 62M 左右，当做 non moving space，用来存放一些生命周期较长的对象。</li>
<li><strong>LargeObjectSpace</strong>：用来存放大对象，大对象是大于 12K 的基本类型数组和 String 对象。</li>
<li><strong>MainSpace</strong>：大对象以外的大部分的 Java 对象都会存放在这块空间。</li>
</ul>
<p>虽然 Java 堆的组成很多，但实际上应用代码中的 Java 对象几乎只会存放 MainSpace 和 LargeObjectSpace 这两个空间中，其他的空间都是给系统库或者 Zygote 使用的。Java 堆的空间是有限的，加起来只有 512M；</p>
<h3 id="Java对象内存申请"><a href="#Java对象内存申请" class="headerlink" title="Java对象内存申请"></a>Java对象内存申请</h3><p>Java 中创建并加载一个对象有 2 种方式。</p>
<ol>
<li>显示加载：使用 Class.forName() 或者 ClassLoader.loadClass 方式加载对象。</li>
<li>隐式加载：使用 new，反射或者访问静态变量或者函数加载对象。</li>
</ol>
<p>这 2 种方式到最后都会调用 AllocObjectWithAllocator 接口到 Java 堆中申请内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> mirror::Object* <span class="title">Heap::AllocObjectWithAllocator</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      ObjPtr&lt;mirror::Class&gt; klass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">size_t</span> byte_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      AllocatorType allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">const</span> PreFenceVisitor&amp; pre_fence_visitor)</span> </span>&#123;</span><br><span class="line">                                                      </span><br><span class="line">  ……</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.检测是否是LargeObject，如果是则在LargeObjectSpace申请内存</span></span><br><span class="line">  <span class="keyword">if</span> (kCheckLargeObject &amp;&amp; <span class="built_in">UNLIKELY</span>(<span class="built_in">ShouldAllocLargeObject</span>(klass, byte_count))) &#123;</span><br><span class="line">    obj = <span class="built_in">AllocLargeObject</span>&lt;kInstrumented, PreFenceVisitor&gt;(self, &amp;klass, byte_count,</span><br><span class="line">                                                           pre_fence_visitor);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ……</span><br><span class="line">  <span class="comment">//2. 非LargeObject，则调用TryToAllocate在mainspace申请内存</span></span><br><span class="line">  obj = <span class="built_in">TryToAllocate</span>&lt;kInstrumented, <span class="literal">false</span>&gt;(self, allocator, byte_count, &amp;bytes_allocated,</span><br><span class="line">                                          &amp;usable_size, &amp;bytes_tl_bulk_allocated);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(obj == <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="comment">//3. 申请失败的情况下则调用gc后再次申请</span></span><br><span class="line">    obj = <span class="built_in">AllocateInternalWithGc</span>(self,</span><br><span class="line">                                 allocator,</span><br><span class="line">                                 kInstrumented,</span><br><span class="line">                                 byte_count,</span><br><span class="line">                                 &amp;bytes_allocated,</span><br><span class="line">                                 &amp;usable_size,</span><br><span class="line">                                 &amp;bytes_tl_bulk_allocated,</span><br><span class="line">                                 &amp;klass);</span><br><span class="line">    ……        </span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">Ptr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虚拟机为 Java 对象申请内存时,会先检测是否是大对象：如果是大对象，则会调用 AllocLargeObject 在 LargeObjectSpace 中申请；如果不是，则调用 TryToAllocate 在 MainSpace 中申请。如果申请失败，就会执行 GC 后继续申请。</p>
<h3 id="Java对象内存释放"><a href="#Java对象内存释放" class="headerlink" title="Java对象内存释放"></a>Java对象内存释放</h3><p>在 Java 堆中申请内存时，如果申请失败，或者申请完毕后超过了阈值，就会执行 GC。</p>
<p>对于 ART 虚拟机的垃圾回收器来说，<strong>是通过可达性分析来判断一个对象是否可以被回收</strong>。<strong>GarbageCollector</strong> 会对 <strong>space</strong> 中的每一个对象的引用链进行分析，如果这个对象的引用链最终被 <strong>GC Root</strong> 持有，就说明这个对象不可回收。否则，就可以回收。如下图所示，对象 object 5、object 6、object 7 虽然互有关联，但是它们没有被 GC Roots 持有， 因此会被判定为可回收的对象。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9297dd5668e34c8e97422a9dc4ad4f58%7Etplv-k3u1fbpfcp-jj-mark%3A1512%3A0%3A0%3A0%3Aq75.awebp" alt="image.png"></p>
<p>GC Root 有下面几项：</p>
<ol>
<li>栈中引⽤的对象：比如应用中主线程的 Handler，它是不会退出的，如果在 Handler 中持有了一个对象，那么这个对象就是被主线程栈所引用的对象，属于 GC Root 可达。这样一来，在 GarbageCollector 执行 GC 时就不会释放这个对象。</li>
<li>静态变量、常量引⽤的对象：被静态变量应用的对象也是属于 GC Root 可达，只有我们手动置为 null 才能释放这个对象。</li>
<li>本地⽅法栈 Native ⽅法引⽤的对象：通过 JNI 调用，传递到 Native 层并被 Native 的函数引用的对象。</li>
</ol>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>通过上面对 Java 堆的原理的讲解，我们了解了这 2 个知识点：</p>
<ol>
<li>Java 堆的空间是有限的，加起来只有 512M；</li>
<li>只有在切断 Java 对象和 GC Root 的关联后，虚拟机的 GC 机制才会回收该对象。</li>
</ol>
<p>基于这 2 个底层的知识点，我们就可以总结出 Java 堆内存优化的 3 条方法论：</p>
<ol>
<li><strong>减少加载进程</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>及时清理加载进</strong> <strong>Java</strong> <strong>堆的数据</strong></li>
<li><strong>增加</strong> <strong>Java</strong> <strong>堆空间可用大小</strong></li>
</ol>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><ul>
<li>通过new分配新对象时，堆中剩余空间不足，因此需要先进行GC。这种情况会导致当前线程阻塞。</li>
<li>到达阈值</li>
<li>手动调用系统API System.gc()时，会产生一次GC动作。</li>
<li>系统空闲。这个空闲判断条件也很多，比如进到后台，或者消息队列没数据等等。 后台GC，这里的“后台”并不是指应用切到后台才会执行的GC，而是GC在运行时基本不会影响其他线程的执行，所以也可以理解为并发GC。</li>
<li>启动时候出现gc，主要还是在于内存压力，到达一定的压力水位，就会触发GC</li>
</ul>
<p>C有不同的程度的，内存不足的时候的GC是最深度的，对性能影响也最大。达到不同的预测，GC的程度不一样，刚到达阈值的时候，可能就只是轻度的GC，轻度的就是标记清除，中度的就是复制拷贝回收。</p>
<h3 id="Java堆内存的获取"><a href="#Java堆内存的获取" class="headerlink" title="Java堆内存的获取"></a>Java堆内存的获取</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">loge(<span class="string">&quot;JVM试图使用的最大内存量，即应用程序可以使用的最大堆内存 ：<span class="subst">$&#123;Runtime.getRuntime().maxMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM当前已经从系统获取的内存量，包括已使用的内存和未使用的内存  ：<span class="subst">$&#123;Runtime.getRuntime().totalMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM中未使用的内存量  ：<span class="subst">$&#123;Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br><span class="line">loge(<span class="string">&quot;JVM的最大内存减去当前已经被使用的内存，得出的结果是应用程序还可以继续使用的内存量: <span class="subst">$&#123;Runtime.getRuntime().maxMemory() - Runtime.getRuntime().totalMemory() + Runtime.getRuntime().freeMemory()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="OOM产生"><a href="#OOM产生" class="headerlink" title="OOM产生"></a>OOM产生</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Heap::IsOutOfMemoryOnAllocation</span><span class="params">([[maybe_unused]] AllocatorType allocator_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">size_t</span> alloc_size, <span class="comment">// 请求分配的内存大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">bool</span> grow)</span> </span>&#123;  <span class="comment">// 是否允许内存增长 </span></span><br><span class="line">  <span class="type">size_t</span> old_target = target_footprint_.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">// 获取当前目标内存占用</span></span><br><span class="line">  <span class="comment">// 无限循环，计算新内存占用</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> old_allocated = num_bytes_allocated_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 在当前已分配的内存基础上增加了新请求分配的内存。</span></span><br><span class="line">    <span class="type">size_t</span> new_footprint = old_allocated + alloc_size;</span><br><span class="line">    <span class="comment">// 判断新占用是否超过限制。UNLIKELY提示编译器该条件发生概率低</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &lt;= old_target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// growth_limit_ ：堆内存的最大值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(new_footprint &gt; growth_limit_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>old_target</code> 相当于是一个可以变动的内存占用警戒线，而 <code>growth_limit_</code> 是不可超越的最大内存使用边界。如果内存使用超出了 <code>old_target</code> 但未到 <code>growth_limit_</code>，程序可能还有一定的弹性空间来调整内存使用；但是一旦超出 <code>growth_limit_</code>，则通常没有余地。</p>
<h3 id="OOM产生路径"><a href="#OOM产生路径" class="headerlink" title="OOM产生路径"></a>OOM产生路径</h3><p><a href="https://juejin.cn/post/7240636469462597690#heading-2">https://juejin.cn/post/7240636469462597690#heading-2</a></p>
<h3 id="ART-GC历史"><a href="#ART-GC历史" class="headerlink" title="ART GC历史"></a>ART GC历史</h3><h4 id="Dalvik-GC-（直到Android-4-4-KitKat）"><a href="#Dalvik-GC-（直到Android-4-4-KitKat）" class="headerlink" title="Dalvik GC （直到Android 4.4 KitKat）"></a>Dalvik GC （直到Android 4.4 KitKat）</h4><ul>
<li>初始的Dalvik虚拟机采用的是“标记-清除”（Mark-Sweep）算法。</li>
<li>在必要时执行“Stop-the-World”（STW）垃圾回收，这意味着所有工作线程都必须暂停，直到垃圾回收过程完成。</li>
</ul>
<h4 id="ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）"><a href="#ART-GC-（Android-5-0-Lollipop-和-5-1-Marshmallow）" class="headerlink" title="ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:"></a>ART GC （Android 5.0 Lollipop 和 5.1 Marshmallow）:</h4><ul>
<li>引入了“分代GC”（Generational GC），它对对象按照存活时间进行分类，短暂对象和长期对象分别管理，以提高效率。</li>
<li>引入了预编译技术，改善了垃圾回收的性能。</li>
</ul>
<h4 id="ART-GC-（Android-6-0-Nougat）"><a href="#ART-GC-（Android-6-0-Nougat）" class="headerlink" title="ART GC （Android 6.0 Nougat）:"></a>ART GC （Android 6.0 Nougat）:</h4><ul>
<li>ART&#x2F;Dalvik Android团队使用汇编语言重写了整个对象分配过程，进一步提高了效率和性能。</li>
</ul>
<h4 id="ART-GC-（Android-8-0-9-0）"><a href="#ART-GC-（Android-8-0-9-0）" class="headerlink" title="ART GC （Android 8.0 ~ 9.0）:"></a>ART GC （Android 8.0 ~ 9.0）:</h4><ul>
<li>引入了“并发复制GC”（Concurrent Copying GC），称为CMS（Concurrent Mark-Sweep）的改进版本，减少了应用的暂停时间。</li>
</ul>
<h4 id="ART-GC-（Android-10开始）"><a href="#ART-GC-（Android-10开始）" class="headerlink" title="ART GC （Android 10开始）:"></a>ART GC （Android 10开始）:</h4><ul>
<li>重新引入了“分代GC”，并作为“并发复制GC”的一个扩展，进一步优化内存管理和减少暂停时间</li>
</ul>
<p>在 Generational CC 中，堆内存并没有显式地划分为不同的代，而是在运行时 把不同的 region 标记为新生代或者老年代；</p>
<p>下面是JVM对用户空间的划分</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/3a21f3fd821143708a0ea69ca309bad1%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="在这里插入图片描述"></p>
<p>Android虚拟机将堆内存同样分为三个区域：<strong>年轻代，年老代，永久代</strong>，针对年轻代和老年代，ART和Dalvik又做了细分。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/5b4db7c314164ebab2619e5e7efc27e7%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0-20231228163627586.awebp" alt="在这里插入图片描述"></p>
<p><strong>ZygoteSpace：Zygote进程启动过程中创建的所有对象。这些对象是所有进程共享</strong></p>
<p><strong>ImageSpcace：存放预加载的类，Android Framework中通用的类都都是存储在这里</strong></p>
<p><strong>Large Obj Space：存放大于12k的类对象的空间</strong></p>
<p><strong>Main Allooc Space：存放小对象的空间</strong></p>
<p><strong>Non Moving Space&#x2F;Linear Alloc：只读的线性内存空间，主要用来存储虚拟机中在进程生命周期都不会结束清理的永久数据的类对象。</strong></p>
<p>ZygoteSpace和ImageSpace存放共享的预加载的类，这样可以提高启动速度，还有根据对象的大小和特性划分LargeObjSpace，AllocSpace和Non Moving Space可以采用不同的垃圾回收策略，提高gc的效率和性能。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1*bsfQgcHVbxeFsXOGv5onPA-20231228165437394.png" alt="img"></p>
<h3 id="Android中的GC"><a href="#Android中的GC" class="headerlink" title="Android中的GC"></a>Android中的GC</h3><p>Android中的GC是通过<strong>HeapTaskDaemon</strong>线程来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapTaskDaemon</span> <span class="keyword">extends</span> <span class="title class_">Daemon</span> &#123;</span><br><span class="line">    <span class="comment">// 单例模式，内部类中创建该类的唯一实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HeapTaskDaemon</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapTaskDaemon</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，设置守护线程的线程名为 &quot;HeapTaskDaemon&quot;。</span></span><br><span class="line">    HeapTaskDaemon() &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;HeapTaskDaemon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法，用于中断指定的线程。</span></span><br><span class="line">    <span class="comment">// 这个方法会通知 VMRuntime 停止堆任务处理器。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        VMRuntime.getRuntime().stopHeapTaskProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 守护线程的核心执行方法。</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，确保线程安全。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果守护线程正在运行，则通知 VMRuntime 启动堆任务处理器。</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line">              VMRuntime.getRuntime().startHeapTaskProcessor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 运行堆任务。</span></span><br><span class="line">        <span class="comment">// 这个方法可能会执行垃圾收集（GC）或其他与堆管理相关的任务。</span></span><br><span class="line">        VMRuntime.getRuntime().runHeapTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeapTaskDaemon 是一个守护线程（程序运行时在后台提供一种通用服务的线程），随着 Zygote 进程启动便会启动，该线程的 run 方法也比较简单，就是执行 runInternal 这个抽象函数，该抽象函数的实现方法中会执行 VMRuntime.getRuntime().runHeapTasks() 方法，runHeapTasks() 函数会执行 RunAllTasks 这个 Native 函数，它位于 <a href="https://link.juejin.cn/?target=https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/task_processor.cc">task_processor.cc</a> 这个类中。</p>
<p>通过源码一路跟踪下来，可以看到 HeapTaskDaemon 线程的 run 方法中真正做的事情，实际只是在无限循环的调用 GetTask 函数获取 HeapTask 并执行。GetTask 中会不断从 tasks 集合中取出 HeapTask 来执行，并且对于需要延时的 HeapTask ，会阻塞到目标时间。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155739553.png" alt="image-20231229155739553"></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231229155809976.png" alt="image-20231229155809976"></p>
<h3 id="GC导致应用程序卡顿"><a href="#GC导致应用程序卡顿" class="headerlink" title="GC导致应用程序卡顿"></a>GC导致应用程序卡顿</h3><p>GC导致了用户线程的停止，这个机制叫做STW，为了防止出现 GC开始时对象没引用被标记为垃圾，GC过程中对象又被引用这种情况。</p>
<p>回收策略：分代回收 分区回收</p>
<p>垃圾检测算法：引用计数 可达性分析</p>
<p>回收算法：标记复制 标记清除  标记整理</p>
<h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p><strong>标记清除</strong>：</p>
<ul>
<li><p>Mark阶段（标记阶段）：搜索内存中的Java对象（对ART虚拟机而言，就是遍历mirror Object对象），对那些能搜到的对象进行标记。</p>
</li>
<li><p>Sweep阶段（清除阶段）：释放那些没有被标记的对象所占据的内存。</p>
<p>整个过程需要将整个程序暂停，清除完成之后才恢复程序运行，而且这个算法会带来碎片化的问题。</p>
</li>
</ul>
<p><strong>复制算法</strong>：复制算法会将存活的对象复制到一块内存，然后将遗留下来的对象进行清理，这种算法不会产生碎片问题，但是会占用更多的内存，因为要一块空间来复制存活的对象。 年轻代</p>
<p><strong>标记整理</strong>：先从根节点标记哪些是被对象引用的。第二阶段将所有存活的对象压缩移动到内存的另一端，按顺序排放，最后清除所有边界以外的空间。 老年代</p>
<p><strong>分代算法</strong>：分代垃圾回收算法（Generational Garbage Collection）是基于对象生命周期不同的假设来进行垃圾回收的策略。它把对象分为几个“代”，通常至少分为两代：年轻代（Young Generation）和老年代（Old Generation）。</p>
<h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><ul>
<li>局部变量表：正在执丸行的函数的参数、临时变量，临时值</li>
<li>方法区中的静态变量：如类的静态变量</li>
<li>方法区中的常量池：如常量池中的常量引用实例</li>
<li>本地方法栈中的变量：NI调用Native方法所引用的实例</li>
<li>同步锁持有的对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kotlin协程</title>
    <url>/2023/12/15/kotlin%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0ODk4OTI%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20231225183233003.png" alt="在这里插入图片描述"></p>
<h3 id="协程基础"><a href="#协程基础" class="headerlink" title="协程基础"></a>协程基础</h3><h4 id="协程的创建"><a href="#协程的创建" class="headerlink" title="协程的创建"></a>协程的创建</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式  CoroutineName: <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = CoroutineName(<span class="string">&quot;continuation 01&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 代码执行结果：  表明coroutineContext传递下来的</span></span><br><span class="line">    Suspend Lambda表达式  CoroutineName: CoroutineName(continuation <span class="number">01</span>)</span><br><span class="line">    <span class="comment">// 表明协程体执行结束后 结果的返回是由传入的Continuation实现的</span></span><br><span class="line">    resuming with result Success(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>深入createCoroutine这个方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br></pre></td></tr></table></figure>

<ul>
<li>简单总结:</li>
</ul>
<p>         suspend{      &#x2F;&#x2F;…     } 这部分代码被包装成了<code>createCoroutine</code>的<code>Receiver</code>,<strong>方法的参数<code>completion</code>会在协程执行完成后掉用，就是协程的完成回调。</strong></p>
<p>        而方法返回的Continuation只用于开启协程和承担协程体。<strong>如果它的内部还有协程的话，它就会作为completion参数传入内部协程。</strong></p>
<ul>
<li>原理：</li>
</ul>
<p>        <code>createCoroutine</code>方法返回的<code>Continuation</code>是<code>SafeContinuation</code>的实例(SafeContinuation继承自Continuation)，但是这只是一个“马甲”。</p>
<p>        SafeContinuation构造方法中有个名为delegate的属性，delegate 的属性是一个被委托的属性，它的类型是 Continuation<T>，实际上它所委托的对象就是这个由编译器生成的 Continuation 实现类的实例一个内部匿名类。</p>
<p>        先来看一下createCoroutineUnintercepted这个方法的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// gpt说这个函数是用来 暴露给协程调试器的占位函数</span></span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">// 这里的this 指的是上面的Suspend Lambda 表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">// 此处的create 和 下面的createCoroutineFromSuspendFunction</span></span><br><span class="line">        <span class="comment">// 可以参考 下面的对代码的一个反编译</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        这个实现类的类名是由编译器根据文件名、函数名和一些其他信息生成的，通常是类似于 <FileName>Kt<FunctionName>continuation$1 这样的形式。<strong>这个匿名内部类继承自SuspendLambda类，而SuspendLambda类又是Continuation接口的实现类。</strong></p>
<p>简单提一下匿名内部类的实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure>

<p>      Suspend Lambda表达式一个函数对应了一个类 ，这里的实现挺悬乎的 它是由编译器实现的这部分内容，SuspendLambda有一个抽象函数invokeSuspend，编译生成的匿名内部类中这个函数的实现就是我们的协程体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Function1</span> <span class="variable">var0</span> <span class="operator">=</span> (Function1)(<span class="keyword">new</span> <span class="title class_">Function1</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Nullable</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  ResultKt.throwOnFailure(var1);</span><br><span class="line">                  <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;Suspend Lambda表达式  CoroutineName: &quot;</span> + (CoroutineName)<span class="built_in">this</span>.getContext().get((CoroutineContext.Key)CoroutineName.Key);</span><br><span class="line">                  System.out.println(var2);</span><br><span class="line">                  <span class="keyword">return</span> Boxing.boxInt(<span class="number">5</span>);</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">            Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">            <span class="comment">// 把completion传入，并创建一个新的Function1，作为Continuation返回，</span></span><br><span class="line">            <span class="comment">// 这就是创建出来的协程体对象，协程的工作核心就是它内部的状态机，</span></span><br><span class="line">            <span class="comment">// invokeSuspend函数</span></span><br><span class="line">            <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">            <span class="keyword">return</span> var2;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Continuation</span> <span class="variable">var4</span> <span class="operator">=</span> ContinuationKt.createCoroutine(var0, (Continuation)(<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">         <span class="meta">@NotNull</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineName <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CoroutineName</span>(<span class="string">&quot;continuation 01&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext)<span class="built_in">this</span>.getContext();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;resuming with result &quot;</span> + Result.toString-impl(result);</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;));</span><br><span class="line">      <span class="type">Unit</span> <span class="variable">var1</span> <span class="operator">=</span> Unit.INSTANCE;</span><br><span class="line">      Result.<span class="type">Companion</span> <span class="variable">var2</span> <span class="operator">=</span> Result.Companion;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      var4.resumeWith(Result.constructor-impl(var1));</span><br></pre></td></tr></table></figure>

<p>      总结一下就是createCoroutine方法所生成的对象是一个<code>SafeContinuation</code>的实例，同时这个实例中有一个委托属性，它所委托的对象是一个匿名内部类。匿名内部类继承自SuspendLambda类，而这个类又是Continuation接口的实现类。而Suspend Lambda表达式的函数体实现在了SuspendLambda类的抽象类invokeSuspend方法中。</p>
<p>     协程的启动就是创建出来的对象调用了resume方法，这个方法的调用最终会来到<strong>BaseContinuationImpl::resumeWith</strong>方法中，这个方法中调用了当前协程的invokeSuspend方法状态机相关的东西就在里面，从而开启了协程。</p>
<p>     上面的内容解释了所返回的Continuation对象的具体内容。也就是为什么调用了他的<code>resume</code>后协程会启动的原因。</p>
<ul>
<li>外部传入的那个Continuation的对象completion的的流向</li>
</ul>
<p>      首先completion是createCoroutine方法传入的参数，然后传给了createCoroutineUnintercepted方法，在这个方法里它的流向有两个分支，目前只说第一条，之后它被传入了create方法，前面说了suspend lambda 表达式对应一个匿名内部类，这个类里的create方法就是对应的实现，目前看代码能分析到这里。<strong>以类的构造方法参数传参的方式</strong>就到了BaseContinuationImpl::resumeWith方法中。先来看代码实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 在每个恢复的延续上调用“resume”调试探针，以便调试库基础设施</span></span><br><span class="line">        <span class="comment">// 可以精确跟踪挂起的调用堆栈的哪一部分已经恢复</span></span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="comment">// completion到了这里</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! <span class="comment">// completion为null直接抛出异常防止出现更严重的错误</span></span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里调用invokeSuspend开启了状态机</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// 此状态机实例正在终止</span></span><br><span class="line">            <span class="comment">// completion又开启了一层判断</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                <span class="comment">// 通过循环展开递归</span></span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 达到顶层完成——通过completion调用resumeWith返回结果</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来一个整体流程的函数原理</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#Continuation.kt</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutine(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; =</span><br><span class="line">    <span class="comment">//返回SafeContinuation 对象</span></span><br><span class="line">    <span class="comment">//SafeContinuation 构造函数需要2个参数，一个是delegate，另一个是协程状态</span></span><br><span class="line">    <span class="comment">//此处默认是挂起</span></span><br><span class="line">    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        <span class="comment">//此处的this 即为匿名内部类对象 MyAnonymous，它间接继承了BaseContinuationImpl</span></span><br><span class="line">        <span class="comment">//调用MyAnonymous 重写的create 函数</span></span><br><span class="line">        <span class="comment">//create 函数里new 新的MyAnonymous 对象</span></span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#IntrinsicsJvm.kt</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    <span class="comment">//判断是否是ContinuationImpl 类型的Continuation</span></span><br><span class="line">    <span class="comment">//我们的demo里是true，因此会继续尝试调用拦截器</span></span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kt</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">    <span class="comment">//查看是否已经有拦截器，如果没有，则从上下文里找，上下文没有，则用自身，最后赋值。</span></span><br><span class="line">    <span class="comment">//在我们的demo里上下文里没有，用的是自身</span></span><br><span class="line">    intercepted</span><br><span class="line">        ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">            .also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">#CoroutineDispatcher.kt</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        <span class="comment">// 这里构造出了一个DispatchedContinuation对象 </span></span><br><span class="line">        <span class="comment">// 其中的this指的是context[ContinuationInterceptor] 取出的调度器</span></span><br><span class="line">        <span class="comment">// continuation 是createCoroutineUnintercepted方法中create创建的对象</span></span><br><span class="line">        <span class="comment">// 也就是下面伪代码中的MyAnonymous类的对象</span></span><br><span class="line">        <span class="comment">// DispatchedContinuation(this, continuation)</span></span><br><span class="line">        <span class="comment">// 这里返回了一个DispatchedContinuation对象，它继承自Runnable和Continuation。</span></span><br><span class="line">        <span class="comment">// 然后可以回到上面的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后得出的Continuation 赋值给SafeContinuation 的成员变量：delegate。</span><br><span class="line">至此，SafeContinuation 对象已经构造完毕，接着继续看如何用它开启协程。</span><br><span class="line"></span><br><span class="line">#SafeContinuationJvm.kt</span><br><span class="line"><span class="keyword">actual</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// lock-free loop</span></span><br><span class="line">        <span class="keyword">val</span> cur = <span class="keyword">this</span>.result <span class="comment">// atomic read</span></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            <span class="comment">//初始化状态为UNDECIDED，因此直接return</span></span><br><span class="line">            cur === CoroutineSingletons.UNDECIDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>,</span><br><span class="line">                    CoroutineSingletons.UNDECIDED, result.value)) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">//如果是挂起，将它变为恢复状态，并调用恢复函数</span></span><br><span class="line">           <span class="comment">//demo 里初始化状态为COROUTINE_SUSPENDED，因此会走到这</span></span><br><span class="line">            cur === COROUTINE_SUSPENDED -&gt; <span class="keyword">if</span> (SafeContinuation.RESULT.compareAndSet(<span class="keyword">this</span>, COROUTINE_SUSPENDED,</span><br><span class="line">                    CoroutineSingletons.RESUMED)) &#123;</span><br><span class="line">                <span class="comment">//delegate 为之前创建的Continuation，demo 里因为没有拦截，因此为MyAnonymous</span></span><br><span class="line">                delegate.resumeWith(result)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Already resumed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ContinuationImpl.kotlin</span><br><span class="line">#BaseContinuationImpl类的成员函数</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">            <span class="keyword">val</span> completion = completion!!</span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//invokeSuspend 即为MyAnonymous 里的方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="comment">//如果返回值是挂起状态，则函数直接退出</span></span><br><span class="line">                    <span class="keyword">if</span> (outcome === kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    kotlin.Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    kotlin.Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//执行到这，最终执行外层的completion，在demo里会输出&quot;result:$result&quot;</span></span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程的挂起"><a href="#协程的挂起" class="headerlink" title="协程的挂起"></a>协程的挂起</h3><p>        先来思考问题，挂起函数挂起需要哪些条件？ 什么情况下会真正的挂起？</p>
<p>在这之前先看两个函数变换：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，形参为函数类型。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty</span><span class="params">(block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后</span></span><br><span class="line"><span class="comment">// 在JVM 平台函数类型参数最终是用匿名内部类</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty(<span class="meta">@NotNull</span> Function0  block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function0的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function0</span>&lt;<span class="type">out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span>: R</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// suspend类型的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">launchEmpty1</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里成了Function1</span></span><br><span class="line"><span class="keyword">public</span> static <span class="keyword">final</span> void launchEmpty1(<span class="meta">@NotNull</span> Function1 block) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function1的定义  相较于Function0多了个参数. 对于挂起函数来说这个参数就是Continuation类型的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function1</span>&lt;<span class="type">in P1, out R</span>&gt; : <span class="type">Function</span>&lt;<span class="type">R</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/** Invokes the function with the specified argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">P1</span>)</span></span>: R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看挂起函数的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里函数的类型就是 suspend () -&gt; T</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspend</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;test suspend&quot;</span>)</span><br><span class="line">    thread &#123;</span><br><span class="line">        println(<span class="string">&quot;test suspend in thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        上面这段代码会被提示<code>Redundant &#39;suspend&#39; modifier </code>，意思是suspend是多余的。内部没有执行其他的挂机函数挂起没意义。</p>
<p>简单创建一个原始协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">launchFish</span><span class="params">(block: <span class="type">suspend</span> () -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建协程，返回值为SafeContinuation(实现了Continuation 接口)</span></span><br><span class="line">    <span class="comment">//入参为Continuation 类型，参数名为completion，顾名思义就是</span></span><br><span class="line">    <span class="comment">//协程结束后(正常返回&amp;抛出异常）将会调用它。</span></span><br><span class="line">    <span class="keyword">var</span> coroutine = block.createCoroutine(<span class="keyword">object</span> : Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">            <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协程结束后调用该函数</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;result:<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//开启协程</span></span><br><span class="line">    coroutine.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(array: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里调用launchFish函数</span></span><br><span class="line">    <span class="comment">// 这里传入一个 lambda 好像会自动被包装成suspend lambda</span></span><br><span class="line">    <span class="comment">// suspend 修饰的函数类型，当调用者实现其函数体时，传入的实参将会继承自SuspendLambda</span></span><br><span class="line">    launchFish &#123;</span><br><span class="line">        println(<span class="string">&quot;I am coroutine&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下反编译后的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAnonymous</span> <span class="keyword">extends</span> <span class="title class_">SuspendLambda</span> <span class="keyword">implements</span> <span class="title class_">Function1</span> &#123;</span><br><span class="line">    <span class="type">int</span> label;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object var1)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">var4</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        <span class="keyword">switch</span>(<span class="built_in">this</span>.label) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;I am coroutine&quot;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                System.out.println(var2);</span><br><span class="line">                <span class="comment">// 这里永远会返回Unit.INSTANCE; 协程永远不会挂起</span></span><br><span class="line">                <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">        <span class="type">Function1</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">        <span class="keyword">return</span> var2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">launchFish</span><span class="params">(<span class="meta">@NotNull</span> MyAnonymous block)</span> &#123;</span><br><span class="line">    <span class="type">Continuation</span> <span class="variable">coroutine</span> <span class="operator">=</span> ContinuationKt.createCoroutine(block, (<span class="keyword">new</span> <span class="title class_">Continuation</span>() &#123;</span><br><span class="line">        <span class="meta">@NotNull</span></span><br><span class="line">        <span class="keyword">public</span> CoroutineContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (CoroutineContext) EmptyCoroutineContext.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resumeWith</span><span class="params">(<span class="meta">@NotNull</span> Object result)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="string">&quot;result:&quot;</span> + Result.toString-impl(result);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            System.out.println(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="comment">//这里开启协程</span></span><br><span class="line">    coroutine.resumeWith(Result.constructor-impl(var3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="meta">@NotNull</span> String[] array)</span> &#123;</span><br><span class="line">    <span class="type">MyAnonymous</span> <span class="variable">myAnonymous</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAnonymous</span>();</span><br><span class="line">    launchFish(myAnonymous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用suspendCoroutine</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">suspendFunc02</span><span class="params">(a: <span class="type">String</span>, b: <span class="type">String</span>)</span></span></span><br><span class="line">         = suspendCoroutine&lt;<span class="built_in">Int</span>&gt; &#123; continuation -&gt;</span><br><span class="line">    thread &#123;</span><br><span class="line">    continuation.resumeWith(Result.success(<span class="number">5</span>)) <span class="comment">// ... 1 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码反编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title function_">suspendFunc02</span><span class="params">(<span class="meta">@NotNull</span> String a, <span class="meta">@NotNull</span> String b, <span class="meta">@NotNull</span> Continuation $completion)</span> &#123;</span><br><span class="line">     <span class="type">SafeContinuation</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeContinuation</span>(IntrinsicsKt.intercepted($completion));</span><br><span class="line">     <span class="type">Continuation</span> <span class="variable">continuation</span> <span class="operator">=</span> (Continuation)var4;</span><br><span class="line">     <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">     ThreadsKt.thread$<span class="keyword">default</span>(<span class="literal">false</span>, <span class="literal">false</span>, (ClassLoader)<span class="literal">null</span>, (String)<span class="literal">null</span>, <span class="number">0</span>, (Function0)(<span class="keyword">new</span> <span class="title class_">KotlinTestKt$suspendFunc02$2$1</span>(continuation)), <span class="number">31</span>, (Object)<span class="literal">null</span>);</span><br><span class="line">     <span class="comment">// getOrThrow用于判断结果是否已经确定，</span></span><br><span class="line">     <span class="comment">// 如果没有确定，则将协程挂起并返回一个特殊的值。</span></span><br><span class="line">     <span class="comment">// 如果结果已经确定，它将检查结果类型，如果是失败的结果，则抛出异常，否则返回结果本身。</span></span><br><span class="line">     <span class="type">Object</span> <span class="variable">var10000</span> <span class="operator">=</span> var4.getOrThrow();</span><br><span class="line">     <span class="keyword">if</span> (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) &#123;</span><br><span class="line">        DebugProbesKt.probeCoroutineSuspended($completion);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> var10000;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>        suspendCoroutine会接收suspendFunc02函数的suspend所转化出的completion，也就是获取当前函数的Continuation实例，用来作为协程执行完毕后的回调函数。而其内部会生成一个用于执行协程体的SafeContinuation对象。</p>
<p>        如果不使用suspendCoroutine获取当前协程的续体，则无法实现真正的挂起与resume。</p>
<p>        所谓协程的挂起其实就是程序执行流程<strong>发生异步调用</strong>时，异步调用是否发生，取决于resume函数与对应的挂起函数的调用是否在相同的调用栈上，切换函数调用栈的方法可以是切换到其他线程上执行，也可以是不切换线程但在当前函数返回之后的某一个时刻再执行。 </p>
<p>        上面扯的有些复杂了，是否挂起要看内部协程返回的值，如果只会<code>return Unit.INSTANCE;</code> 那么永远不会挂起。在<strong>发生异步调用</strong>时会返回对应的标志挂起的值，SafeContinuation类的作用也非常简单，它可以确保只有发生异步调用时才会挂起。</p>
<h4 id="协程的恢复"><a href="#协程的恢复" class="headerlink" title="协程的恢复"></a>协程的恢复</h4><p>        首先要知道一个知识点：一个协程体的invokeSuspend被调用有两种情况，第一种是在它刚被创建时从<code>CoroutineStart::invoke</code>到<code>(suspend () -&gt; T).startCoroutineCancellable</code>再到<code>(suspend () -&gt; T).createCoroutineUnintercepted</code>然后会走到<code>create(completion)</code>也就是在反编译后的那个create方法，紧接着就会调用它的invokeSuspend方法来执行协程体。</p>
<p>        第二种是它被作为completion传入了子协程中，在<code>BaseContinuationImpl::resumeWith</code>方法中被子协程回调结果时调用走<code>completion.resumeWith(outcome)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">startLaunch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        println(<span class="string">&quot;parent coroutine running&quot;</span>)</span><br><span class="line"></span><br><span class="line">        getStuInfoV1()</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;after suspend&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStuInfoV1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        println(<span class="string">&quot;son coroutine running&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的整体流程图：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/99353b7e71c69.jpg" alt="img"></p>
<h4 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h4><p>        协程通过传递Continuation来控制异步调用流程。</p>
<p>        协程的创建和运行过程，我们的协程体本身就是一个Continuation实例，正因如此挂起函数才能在协程体内运行。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<p>        协程是一种控制流的抽象，当协程被挂起时，它会将当前的执行状态（包括程序计数器、寄存器等）保存到一个回调函数中，这个回调函数就是挂起函数的 Continuation。这样，在协程恢复执行时，它会从保存的执行状态继续执行，而不是从头开始执行。这种机制使得协程能够在不同的时间点之间暂停和恢复执行，从而实现更加灵活的控制流程。</p>
<p>        当前调用流程的执行状态进入等待状态。在协程内部挂起函数的调用处被称为挂起点，挂起点如果出现异步调用，那么当前协程就被挂起，直到对应的Continuation的resume函数被调用才会恢复执行。</p>
<h4 id="协程上下文"><a href="#协程上下文" class="headerlink" title="协程上下文"></a>协程上下文</h4><p>        先看一段Continuation实现的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        CoroutineContext作为一个接口内部的成员对象存在。且是val的，所有Continuation的实现类通过<code>public override val context: CoroutineContext       get() = EmptyCoroutineContext</code>的方式进行重写。</p>
<p>        CoroutineContext的结构类似List，具体可看其实现源码。其内部元素的结构是Element，且元素本身就实现了CoroutineContext对象。这看上去就好像Int实现了List<Int>接口一样，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? =</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">        operation(initial, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>        list中的元素都有一个index，表示元素的索引，而这里协程上下文元素的key就是<br>协程上下文这个集合中元素的索引，不同之处是这个索引“长”在了数据里面，这意味着协程上下文的数据在“出生”时就找到了自己的位置。</p>
<p>        <strong>协程上下文的内部实现实际上是一个单链表</strong>，Kotlin协程上下文的内部实现是通过一个单链表来实现的，这个单链表中包含了多个协程上下文元素。每个协程上下文元素都包含了一些协程上下文属性，例如调度器、异常处理器等等。通过将这些协程上下文元素链接起来，就可以形成一个完整的协程上下文。当协程执行时，它会按照链表中的顺序依次应用每个协程上下文元素中的属性，以实现对协程的控制和管理。因此，单链表是协程上下文内部实现的核心部分。具体论证观察CoroutineContext类的plus方法的实现。</p>
<h4 id="协程拦截器"><a href="#协程拦截器" class="headerlink" title="协程拦截器"></a>协程拦截器</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">suspend</span> &#123;</span><br><span class="line">        delay(<span class="number">500</span>)</span><br><span class="line">        println(<span class="string">&quot;Suspend Lambda表达式&quot;</span>)</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;.createCoroutine(<span class="keyword">object</span> : Continuation&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> context</span><br><span class="line">            <span class="keyword">get</span>() = LogInterceptor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;resuming with result <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).resume(<span class="built_in">Unit</span>)</span><br><span class="line"><span class="comment">//  延长线程存活时间</span></span><br><span class="line">    sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义拦截器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogInterceptor</span> : <span class="type">ContinuationInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt;</span><br><span class="line">        <span class="keyword">get</span>() = ContinuationInterceptor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> LogContinuation(continuation)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogContinuation</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;) :</span><br><span class="line">    Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 此处对协程的表达进行了拦截</span></span><br><span class="line">        println(<span class="string">&quot;before resumeWith: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        continuation.resumeWith(result)</span><br><span class="line">        println(<span class="string">&quot;after resumeWith.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 日志打印</span></span><br><span class="line"><span class="comment">// 此处拦截的是createCoroutine方法创建出的continuation执行resumeWith开启协程</span></span><br><span class="line"><span class="comment">// 协程启动挂起</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">after resumeWith.</span><br><span class="line"><span class="comment">// 此处拦截的是所传入的continuation来进行结果回调时调用resumeWith</span></span><br><span class="line"><span class="comment">// 协程执行结束恢复</span></span><br><span class="line">before resumeWith: Success(kotlin.<span class="built_in">Unit</span>)</span><br><span class="line">Suspend Lambda表达式</span><br><span class="line">resuming with result Success(<span class="number">5</span>)</span><br><span class="line">after resumeWith.</span><br></pre></td></tr></table></figure>

<h4 id="协程调度器"><a href="#协程调度器" class="headerlink" title="协程调度器"></a>协程调度器</h4><p><strong>CoroutineContext 里存放着协程的分发器。</strong></p>
<ul>
<li><p><strong>Dispatchers.Main</strong>  UI 线程，在Android里为主线程</p>
</li>
<li><p><strong>Dispatchers.IO</strong>  IO 线程，主要执行IO 操作</p>
</li>
<li><p><strong>Dispatchers.Default</strong> 主要执行CPU密集型操作，比如一些计算型任务</p>
</li>
<li><p><strong>Dispatchers.Unconfined</strong>  不限定具体的线程类型，当前调度器在哪个线程，就在该线程上进行执行。也就是和它的父协程保持一致。</p>
</li>
</ul>
<h3 id="协程框架"><a href="#协程框架" class="headerlink" title="协程框架"></a>协程框架</h3><h4 id="自定义一个delay函数"><a href="#自定义一个delay函数" class="headerlink" title="自定义一个delay函数"></a>自定义一个delay函数</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(time: <span class="type">Long</span>, unit: <span class="type">TimeUnit</span> = TimeUnit.MILLISECONDS)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    suspendCoroutine&lt;<span class="built_in">Unit</span>&gt; &#123; continuation -&gt;</span><br><span class="line">        executor.schedule(&#123;</span><br><span class="line">            continuation.resume(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;, time, unit)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = Executors.newScheduledThreadPool(<span class="number">1</span>) &#123; runnable -&gt;</span><br><span class="line">    Thread(runnable, <span class="string">&quot;Scheduler&quot;</span>).apply &#123; isDaemon = <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程作用域种类"><a href="#协程作用域种类" class="headerlink" title="协程作用域种类"></a>协程作用域种类</h3><p>GlobalScope。即全局协程作用域，在这个范围内启动的协程可以一直运行直到应用停止运行。GlobalScope 本身不会阻塞当前线程，且启动的协程相当于守护线程，不会阻止 JVM 结束运行</p>
<p>runBlocking。一个顶层函数，和 GlobalScope 不一样，它会阻塞当前线程直到其内部所有相同作用域的协程执行结束</p>
<p>自定义 CoroutineScope。可用于实现主动控制协程的生命周期范围，对于 Android 开发来说最大意义之一就是可以在 Activity、Fragment、ViewModel 等具有生命周期的对象中按需取消所有协程任务，从而确保生命周期安全，避免内存泄露</p>
<h3 id="async和launch的区别"><a href="#async和launch的区别" class="headerlink" title="async和launch的区别"></a>async和launch的区别</h3><p><code>async</code> 可以返回协程的执行结果，而 <code>launch</code> 不行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            <span class="keyword">val</span> asyncA = async &#123;</span><br><span class="line">                delay(<span class="number">3000</span>)</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> asyncB = async &#123;</span><br><span class="line">                delay(<span class="number">4000</span>)</span><br><span class="line">                <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">            log(asyncA.await() + asyncB.await())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log(time)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async的最后一行为返回值</p>
<h3 id="Kotlin-协程库四个-Dispatcher"><a href="#Kotlin-协程库四个-Dispatcher" class="headerlink" title="Kotlin 协程库四个 Dispatcher"></a>Kotlin 协程库四个 Dispatcher</h3><p>**<code>Dispatchers.Main</code>**：这是主调度器，通常用于 Android 或其它 UI 框架中。它会在主线程上运行协程，用于更新 UI 或做其它需要在主线程完成的操作。例如更新 TextView 或 RecyclerView 等 UI 组件</p>
<p>**<code>Dispatchers.Default</code>**：默认调度器，用于执行长时间运行并且需要大量 CPU 资源的任务，比如排序列表或者解析大型 JSON 数据等 CPU 密集型任务。</p>
<p>**<code>Dispatchers.IO</code>**：I&#x2F;O 调度器，适用于大量 I&#x2F;O 操作，如网络请求，文件读写等。</p>
<p>**<code>Dispatchers.Unconfined</code>**：无限制的调度器，协程会在启动的立即执行，直到第一个挂起点。当挂起函数结束后，协程会在挂起函数结束的线程上恢复执行。它适用于一些不需要特定线程，同时又需要立即执行的情况。但使用时要小心，因为它很容易造成一些意想不到的问题。</p>
<h3 id="协程中的线程局部变量的原子性和可见性"><a href="#协程中的线程局部变量的原子性和可见性" class="headerlink" title="协程中的线程局部变量的原子性和可见性"></a>协程中的线程局部变量的原子性和可见性</h3><p>在使用了线程池的调度器（例如 <code>Dispatchers.IO</code> 或 <code>Dispatchers.Default</code>）来运行一个 <code>withContext()</code> 块时，整个withContext内的代码块可能没有运行在同一个线程上。</p>
<p>例如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">withContext(Dispatchers.IO) &#123;</span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Prints &quot;IO dispatcher worker 1&quot; </span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// This is a suspend function</span></span><br><span class="line">    println(Thread.currentThread().name) <span class="comment">// Might print &quot;IO dispatcher worker 2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>suspendSomeIoOperation()</code> 是一个挂起函数，当它挂起时，当前线程可能会去运行其他的任务。当操作 A 完成后，可能会有一个不同的线程（从线程池中选择）来恢复这个协程的执行。因此，<code>threadName1</code> 和 <code>threadName2</code> 可能会是不同的，即使他们都在同一个 <code>withContext()</code> 块中。</p>
<p>这个特性有两个影响：</p>
<ol>
<li><strong>不保证线程局部变量的一致性</strong>：线程局部变量<strong>不是</strong>跨线程的，如果你的协程在两个不同的线程上运行，那么你将看到线程局部变量的不同版本。</li>
<li><strong>不保证并发操作的原子性和可见性</strong>：如果你的协程代码块包含对共享资源的写操作，那么你需要确保这些操作是线程安全的，否则可能会出现并发问题，如数据竞争。</li>
</ol>
<p>如果希望让整个 <code>withContext&#123;&#125;</code> 块始终在同一个线程上运行，应该使用一个单线程的调度器，比如 <code>newSingleThreadContext(&quot;myThread&quot;)</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">launch(newSingleThreadContext(<span class="string">&quot;MyOwnThread&quot;</span>)) &#123;</span><br><span class="line">        log(<span class="string">&quot;newSingleThreadContext&quot;</span>)</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            log(<span class="string">&quot;Unconfined 4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 Mutex 或 @Volatile 来实现线程安全的示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutex = Mutex()</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutex.withLock &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// 启动100个协程进行累加</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>@Volatile</code> 注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        </span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter) <span class="comment">// @Volatile 不保证原子性，意味着 counter++ 不是一个原子操作，还可能会存在竞态条件，所以结果可能会小于100。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicInteger</code> 类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> counter = AtomicInteger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        counter.incrementAndGet()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="comment">// Start multiple coroutines</span></span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                increment()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(counter.<span class="keyword">get</span>()) <span class="comment">// Will always print 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="job-join"><a href="#job-join" class="headerlink" title="job.join()"></a>job.join()</h3><p><code>join()</code>的作用是挂起当前协程，直到这个 <code>Job</code> 完成。这个方法使得您可以等待一个协程任务执行完毕。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;job completed!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Waiting for job...&quot;</span>)</span><br><span class="line">    job.join()</span><br><span class="line">    println(<span class="string">&quot;Job is done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，主协程被阻塞并等待由 <code>job.join()</code> 返回。只有在 <code>job</code> 协程完成之后， “Job is done!” 才会被打印出来。</p>
<h3 id="传播取消操作"><a href="#传播取消操作" class="headerlink" title="传播取消操作"></a>传播取消操作</h3><p>一般情况下，协程的取消操作会通过协程的层次结构来进行传播：如果取消父协程或者父协程抛出异常，那么子协程都会被取消；而如果子协程被取消，则不会影响同级协程和父协程，但如果子协程抛出异常则也会导致同级协程和父协程被取消 </p>
<p>使用SupervisorJob</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> supervisorJob = SupervisorJob()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(Dispatchers.Main + supervisorJob)</span><br><span class="line"></span><br><span class="line">scope.launch &#123;</span><br><span class="line">    <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用supervisorScope</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">// 这里的子协程失败不会影响其他子协程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协程和线程对比"><a href="#协程和线程对比" class="headerlink" title="协程和线程对比"></a>协程和线程对比</h3><p>系统的最小执行单元是线程，一个线程同一时间点也只能执行一个任务，使用协程也不可能改变这种情况。</p>
<p>只能说使用了协程后，线程的并发灵活度会提高：当线程需要等待某个 suspend 函数返回时，在等待的过程中此线程还可以用于执行其它协程任务，从而提高线程的灵活度，避免线程空转。</p>
<p>协程是程序本身实现的切换机制，不需要陷入系统内核，轻松高并发。</p>
<p>代码对比下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">thread &#123;</span><br><span class="line">        <span class="comment">// I/O 阻塞操作</span></span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">打印：   </span><br><span class="line">[Thread-<span class="number">0</span>] thread</span><br></pre></td></tr></table></figure>

<p>这种只会在阻塞操作操作结束后才会打印日志。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">al job = Job()</span><br><span class="line"><span class="keyword">val</span> scope = CoroutineScope(job + Dispatchers.IO)</span><br><span class="line">thread &#123;</span><br><span class="line">        scope.launch &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            log(<span class="string">&quot;launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;thread&quot;</span>)</span><br><span class="line">        <span class="comment">// 防止JVM退出</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>)</span><br><span class="line">  </span><br><span class="line">打印：  </span><br><span class="line">  [Thread-<span class="number">0</span>] thread</span><br><span class="line">	[DefaultDispatcher-worker-<span class="number">1</span>] launch</span><br></pre></td></tr></table></figure>

<p>线程在利用空闲时间执行了后续操作。</p>
<h3 id="协程的四个基础概念"><a href="#协程的四个基础概念" class="headerlink" title="协程的四个基础概念"></a>协程的四个基础概念</h3><ol>
<li><p><strong>协程构建器（Coroutine Builders）</strong>：在 Kotlin 中，使用协程构建器如 <code>launch</code>、<code>async</code>等来启动一个新的协程。</p>
<ul>
<li><p><code>launch</code>: 它创建一个新的协程并同时启动。<code>launch</code> 返回一个 <code>Job</code>，你可以用它来取消协程。此协程不会返回结果。</p>
</li>
<li><p><code>async/start</code>: 创建一个新的协程并返回一个 <code>Deferred&lt;T&gt;</code> —— 一种轻量级的非阻塞性 future，它表示一个带有结果的 promise。可以使用它的 <code>.await()</code> 方法获取结果。</p>
</li>
<li><p><code>runBlocking</code>: 这是一个特殊的构建器，它创建了一个新的协程并阻塞当前线程直到其完成。</p>
</li>
</ul>
</li>
<li><p><strong>挂起函数（Suspend Functions）</strong>：<code>suspend</code>关键字标记的函数称为挂起函数。这种函数可以”挂起”，即在不阻塞当前线程的情况下，暂停其执行，并稍后在适当的时间点继续执行。挂起函数只能在协程或其他挂起函数中调用。</p>
<ul>
<li>这些函数可以在协程内部进行长期运行的操作（如网络请求或数据库查询），而不会阻塞线程。这就是它们的”挂起”能力。挂起函数通过 <code>suspend</code> 关键字来定义，并且只能在协程或其他挂起函数中调用。</li>
</ul>
</li>
<li><p><strong>调度器（Dispatchers）</strong>：<code>Dispatchers</code>确定协程运行在哪个线程或线程池上。例如，<code>Dispatchers.IO</code> 用于磁盘和网络 I&#x2F;O，<code>Dispatchers.Default</code> 用于计算密集型任务，<code>Dispatchers.Main</code> 用于更新 UI。</p>
<ul>
<li><p><code>Dispatchers.Main</code>：这个调度器被限定在主线程中执行，这对大部分UI框架来说非常必要。然而，不同平台有自己的主线程计划。例如，Android会有 <code>Dispatchers.Main</code>，用于更新UI，执行时会检查是否在主线程里，不是的话它会调度到主线程执行。</p>
</li>
<li><p><code>Dispatchers.IO</code>：设计用于磁盘和网络 I&#x2F;O，因此不应用于计算密集型工作。IO调度器基于ForkJoinPool，它使用一个利用主机CPU数量的线程数量，但网络和磁盘允许线程无限制地增长和缩小。此调度模式的设计是为了允许大量的线程可以等待I&#x2F;O操作（如读写磁盘，网络数据读写）完成而无需消耗大量内存。</p>
</li>
<li><p><code>Dispatchers.Default</code>：用于计算密集型任务，这个调度器用于可能阻塞但CPU密集型工作，如算法和复杂计算。默认调度器内部使用了固定大小的线程池，大小为Kotlin runtime可以计算的CPU数量，默认大小为CPU核心数量减1，但至少为1。</p>
</li>
<li><p><code>Dispatchers.Unconfined</code>：一个特殊的调度器，它在调用者线程中立即执行调度的协程。但只有当挂起函数被调用，或者显式使用不同的调度器，那么协程的执行将会挂起并重新调度它的执行线程。</p>
<p>不添加调度器的话默认使用父协程的调度器。</p>
</li>
</ul>
</li>
<li><p><strong>作用域（Scopes）</strong>：协程的执行属于某种特定的作用域。作用域控制了相关协程的生命周期。例如，在 Android 中你可能会使用 <code>viewModelScope</code>，这样当 ViewModel 销毁时，所有的协程也将被取消。</p>
<ul>
<li><p><code>GlobalScope</code>：它绑定到整个应用程序的生命周期。你一旦启动了全局作用域的协程，它只有在应用程序完全停止运行后才会被销毁。</p>
<p>它默认的调度器是Dispatchers.Default</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">      log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>CoroutineScope</code>：本身并非作用域，但却经常拿来创建作用域。它需要一个 <code>Job</code>（或者可以供其他方式提供一个 <code>CoroutineContext</code>）作为参数。<code>CoroutineScope</code> 不提供默认的 <code>Job</code>，所以如果你使用 <code>CoroutineScope(EmptyCoroutineContext)</code> 创建作用域，那么它所启动的协程就一定会使用 <code>GlobalScope</code>。所以，最佳实践是，总是用 <code>CoroutineScope(Job())</code> 来创建作用域。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">CoroutineScope(Job()).launch &#123;</span><br><span class="line">        log(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>MainScope</code></p>
<p>默认运行在主线程的作用域</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mainScope.launch &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="keyword">throw</span>  NullPointerException(<span class="string">&quot;空指针&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> result = withContext(Dispatchers.IO) &#123;</span><br><span class="line">            <span class="comment">//网络请求...</span></span><br><span class="line">            <span class="string">&quot;请求结果&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            <span class="comment">//网络请求3...</span></span><br><span class="line">        &#125;</span><br><span class="line">        btn.text = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    mainScope.cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><code>viewModelScope</code>：Android KTX库提供了一个创建在 <code>ViewModel</code> 生命周期内工作的协程的作用域。当 <code>ViewModel</code> 清理时，所有作用域内的协程都会自动取消。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>lifecycleScope</code>：这个也是由Android KTX库提供的，它提供了一个绑定到 <code>Android Lifecycle</code> 生命周期的作用域（如 <code>Activity</code> 或 <code>Fragment</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lifecycleScope.launch &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.IO</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Default</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch(</span><br><span class="line">            Dispatchers.Unconfined</span><br><span class="line">        ) &#123;</span><br><span class="line">            log(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        launch &#123;</span><br><span class="line">            log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印：</span><br><span class="line">[main] <span class="number">4</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">2</span>] <span class="number">2</span></span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] <span class="number">3</span></span><br><span class="line">[main] <span class="number">1</span></span><br><span class="line">[main] <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CoroutineStart协程启动模式"><a href="#CoroutineStart协程启动模式" class="headerlink" title="CoroutineStart协程启动模式"></a><code>CoroutineStart</code>协程启动模式</h3><ol>
<li><code>DEFAULT</code>    默认启动模式，我们可以称之为饿汉启动模式，因为协程创建后立即开始调度，虽然是立即调度，单不是立即执行，有可能在执行前被取消。</li>
<li><code>LAZY</code>    懒汉启动模式，启动后并不会有任何调度行为，直到我们需要它执行的时候才会产生调度。也就是说只有我们主动的调用<code>Job</code>的<code>start</code>、<code>join</code>或者<code>await</code>等函数时才会开始调度。</li>
<li><code>ATOMIC</code>  一样也是在协程创建后立即开始调度，但是它和<code>DEFAULT</code>模式有一点不一样，通过<code>ATOMIC</code>模式启动的协程执行到第一个挂起点之前是不响应<code>cancel </code>取消操作的，<code>ATOMIC</code>一定要涉及到协程挂起后<code>cancel </code>取消操作的时候才有意义。</li>
<li><code>UNDISPATCHED</code> 协程在这种模式下会直接开始在当前线程下执行，直到运行到第一个挂起点。这听起来有点像 <code>ATOMIC</code>，不同之处在于<code>UNDISPATCHED</code>是不经过任何调度器就开始执行的。当然遇到挂起点之后的执行，将取决于挂起点本身的逻辑和协程上下文中的调度器。</li>
</ol>
<h3 id="协程生命周期"><a href="#协程生命周期" class="headerlink" title="协程生命周期"></a>协程生命周期</h3><ol>
<li>新建：此时协程已经创建，但尚未开始运行。例如，当使用 <code>CoroutineStart.LAZY</code> 选项调用 <code>launch</code> 或 <code>async</code> 时，创建的协程仅在显式调用其 <code>Job</code> 的 <code>start</code> 或 <code>join</code> 方法时才开始执行。</li>
<li>活动：此阶段的协程正在执行其任务。通常，协程会在 <code>launch</code> 或 <code>async</code> 调用后立即进入此状态 (除非你指定了 <code>CoroutineStart.LAZY</code> 选项)。</li>
<li>完成：协程成功完成其任务并正常结束，或者因异常被终止。对于异常的情况，如果协程是由 <code>launch</code> 创建的，则需要在协程体内部进行异常处理。而对于 <code>async</code> 创建的协程，异常会被延期处理，直至 <code>await()</code> 的调用。</li>
<li>取消：通过调用协程的 <code>Job</code> 的 <code>cancel</code> 方法，可以取消协程。这将导致协程中断执行。当协程被取消时，所有挂起函数将会抛出 <code>CancellationException</code>。协程可以通过定期检查其状态 (使用 <code>isActive</code> 属性或 <code>yield</code> 函数)，或通过在挂起函数处对 <code>CancellationException</code> 进行响应来响应取消操作。</li>
</ol>
<h3 id="协程的阻塞和非阻塞"><a href="#协程的阻塞和非阻塞" class="headerlink" title="协程的阻塞和非阻塞"></a>协程的阻塞和非阻塞</h3><p>看下下面的代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            log(<span class="string">&quot;launch start&quot;</span>)</span><br><span class="line">            launch(Dispatchers.IO) &#123;</span><br><span class="line">                log(<span class="string">&quot;Job start&quot;</span>)</span><br><span class="line">                testSuspends()</span><br><span class="line">                log(<span class="string">&quot;Job end&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="string">&quot;launch end&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">5000</span>)</span><br><span class="line">        log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">打印：</span><br><span class="line">[main] start</span><br><span class="line">[main] launch start</span><br><span class="line">[main] launch end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] Job start</span><br><span class="line">[main] end</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] testSuspends</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">3</span>] Job end</span><br></pre></td></tr></table></figure>

<p>协程的非阻塞是相对于线程的，当遇到协程挂起后会越过他执行后面的任务，等挂起恢复后再执行回复原来的执行。</p>
<h3 id="解析源码"><a href="#解析源码" class="headerlink" title="解析源码"></a>解析源码</h3><p>下面的代码模拟在主线程中实现异步加载操作，然后在回到主线程处理数据。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[main] runBlocking</span><br><span class="line">[DefaultDispatcher-worker-<span class="number">1</span>] testSuspends</span><br><span class="line">[main] result: <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>分析代码：</p>
<p>代码可以分为两大部分，第一部分是上面的<code>runBlocking </code>协程块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">runBlocking &#123;</span><br><span class="line">        log(<span class="string">&quot;runBlocking&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = testSuspends()</span><br><span class="line">        log(<span class="string">&quot;result: <span class="variable">$result</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这部分代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">runBlocking</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> currentThread = Thread.currentThread() <span class="comment">// Thread[main,5,main]</span></span><br><span class="line">  	<span class="comment">// 在给定的协程上下文中获取 ContinuationInterceptor，它是用于控制协程的调度的拦截器</span></span><br><span class="line">    <span class="keyword">val</span> contextInterceptor = context[ContinuationInterceptor] <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">val</span> eventLoop: EventLoop?</span><br><span class="line">    <span class="keyword">val</span> newContext: CoroutineContext</span><br><span class="line">    <span class="keyword">if</span> (contextInterceptor == <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 如果没有指定调度器，那么创建或者使用私有的事件循环。</span></span><br><span class="line">        eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">      	<span class="comment">// 这里的context是EmptyCoroutineContext eventLoop是BlockingEventLoop</span></span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if context&#x27;s interceptor is an event loop that we shall use (to support TestContext)</span></span><br><span class="line">        <span class="comment">// or take an existing thread-local event loop if present to avoid blocking it (but don&#x27;t create one)</span></span><br><span class="line">        eventLoop = (contextInterceptor <span class="keyword">as</span>? EventLoop)?.takeIf &#123; it.shouldBeProcessedFromContext() &#125;</span><br><span class="line">            ?: ThreadLocalEventLoop.currentOrNull()</span><br><span class="line">        newContext = GlobalScope.newCoroutineContext(context)</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 创建一个 BlockingCoroutine 实例，它是一个运行在指定线程和事件循环中的协程。</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">    <span class="comment">// 开始执行协程，CoroutineStart.DEFAULT 是启动方式，表示立即执行协程体 block</span></span><br><span class="line">    coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br><span class="line">  	<span class="comment">// 等待协程结束并返回结果。线程会在这里阻塞，直到协程执行完毕。</span></span><br><span class="line">    <span class="keyword">return</span> coroutine.joinBlocking()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>走到<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>开始执行开启这个协程，这里传入了三个参数，首先是<code>CoroutineStart.DEFAULT</code>表示直接开启协程，<code>coroutine</code>是上面创建的BlockingCoroutine对象它是一个运行在指定线程和事件循环中的协程。<code>EventLoop</code> 的功能主要是管理和调度协程在当前线程中的执行。它维护了一个队列，用来存储在当前线程中需要执行的协程。<code>block</code>就是协程体也就是打括号内的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AbstractCoroutine:</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// receiver和this都是传入的coroutine也就是BlockingCoroutine对象。</span></span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里将receiver, this也就是传入的coroutine和block 又传入了CoroutineStart中，其中这个this代表coroutine。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>, receiver: <span class="type">R</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 走到了这里 </span></span><br><span class="line">            DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">            ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">            UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">            LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码<code>coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</code>显示传入的是CoroutineStart.DEFAULT，显而易见 根据规则走到了<code>block.startCoroutineCancellable(receiver, completion)</code>这个分支。</p>
<p><strong>这里再回顾一下block就是协程体runBlocking大括号内的东西，它的类型是<code>suspend CoroutineScope.() -&gt; T</code>，receiver是BlockingCoroutine，completion也是，都是传入的那个BlockingCoroutine实例。</strong></p>
<p><strong>receiver和completion都是传入的coroutine也就是BlockingCoroutine对象。</strong></p>
<p>继续往下走</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion)   <span class="comment">// 重新创建续体对象（SuspendLambda子类对象）</span></span><br><span class="line">      .intercepted() <span class="comment">// 从协程上下文中获取调度器拦截原续体，将其包装为DispatchedContinuation类型</span></span><br><span class="line">      .resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里解释一下里面的内容</p>
<p><code>runSafely</code>单纯的只是给包裹了一层try catch 出现异常的话就<code>completion.resumeWith(Result.failure(e))</code>，</p>
<p><code>createCoroutineUnintercepted</code>的话可以看一下代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(probeCompletion)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  			<span class="comment">// 如果不是，说明是一个普通的挂起函数，不包含协程的实现细节。</span></span><br><span class="line">        <span class="comment">// 那么要手动创建一个协程来包装这个函数。</span></span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">          	<span class="comment">// 将这个挂起函数视为一个接受Continuation参数并返回Any?的函数，</span></span><br><span class="line">            <span class="comment">// Any?表示可能返回null或任何类型结果。</span></span><br><span class="line">            <span class="comment">// 然后使用已经得到的`probeCompletion`作为参数调用它。</span></span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里进行了一个判断<code>this is BaseContinuationImpl</code>，这里有个知识点就是这里this是上面的block 它的类型是<code>suspend CoroutineScope.() -&gt; T</code>但是经过Kotlin编译器编译之后它就会成为SuspendLambda类的对象，这是编译器自己完成的。</p>
<p>而SuspendLambda是继承自ContinuationImpl的，所以这里会走到<code>create(probeCompletion)</code>。</p>
<p><code>create</code>的实现可以看源代码的反编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      。。。</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Continuation <span class="title function_">create</span><span class="params">(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation completion)</span> &#123;</span><br><span class="line">      Intrinsics.checkNotNullParameter(completion, <span class="string">&quot;completion&quot;</span>);</span><br><span class="line">      <span class="type">Function2</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="keyword">new</span> &lt;anonymous constructor&gt;(completion);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Object var2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((&lt;undefinedtype&gt;)<span class="built_in">this</span>.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;), <span class="number">1</span>, (Object)<span class="literal">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的create函数的内容总结就是传入了一个completion然后生成一个completion，这个传入的completion是就是在runBlocking方法中创建的BlockingCoroutine对象。</p>
<p><code>&lt;anonymous constructor&gt;</code> 是一个匿名构造函数，接受 <code>completion</code> 作为参数，它返回的 <code>Continuation</code> 对象封装了一个协程。这个协程对象就是自身实例。</p>
<p> 目前来看<code>createCoroutineUnintercepted(receiver, completion)</code>这段代码会生成一个SuspendLambda对象，然后调用<code>intercepted()</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"> <span class="comment">// 从上下文中获取拦截器，实现续体对象包装</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br></pre></td></tr></table></figure>

<p><strong>从当前续体对象(SuspendLambda的子类对象)的上下文中获取拦截器(调度器对象)拦截当前续体对象，将其包装为<code>DispatchedContinuation</code>类型的续体</strong>。这里的<code>this</code>是<code>runBlocking</code>的构造方法中<code>eventLoop = ThreadLocalEventLoop.eventLoop</code>这行代码创建了一个<code>BlockingEventLoop</code>对象作为调度器，<code>context[ContinuationInterceptor]</code>取出了这个对象然后构造返回了<code>DispatchedContinuation</code>对象。<code>DispatchedContinuation</code>构造中的this传入的是前面创建的<code>BlockingEventLoop</code>对象，<code>continuation</code>是创建<code>SuspendLambda</code>对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br></pre></td></tr></table></figure>

<p>到现在为止前半部分的代码执行的结果</p>
<p><code>DispatchedContinuation[BlockingEventLoop@4f49f6af, Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)@461ad730]</code></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20231225114546894.png" alt="image-20231225114546894"></p>
<p>创建出<code>DispatchedContinuation</code>对象后执行它的<code>resumeCancellableWith</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">DispatchedContinuation：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  	<span class="comment">// 如果续体类型是DispatchedContinuation，调用resumeCancellableWith()启动协程</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">  			<span class="comment">// 判断是否需要调度 这里默认是true</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 切换线程后开始执行协程代码</span></span><br><span class="line">          	<span class="comment">// this 就是SuspendLambda包装的DispatchedContinuation</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的dispatcher是前面创建的<code>BlockingEventLoop</code>对象,<code>dispatcher.isDispatchNeeded(context)</code>这里默认会返回true，后面就会走到<code>BlockingEventLoop</code>的</p>
<p><code>dispatch</code>方法，其父类EventLoopImplBase中有具体的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop:</span><br><span class="line"></span><br><span class="line"><span class="comment">// `dispatch` 函数用于将给定的任务（block）调度到适当的执行上下文中。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> = enqueue(block)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enqueue` 函数将任务加入队列。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(task: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enqueueImpl(task)) &#123; <span class="comment">// 如果任务成功入队</span></span><br><span class="line">        unpark() <span class="comment">// 解除阻塞，准备执行任务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DefaultExecutor.enqueue(task) <span class="comment">// 如果任务未成功入队，使用默认执行器加入任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueueImpl</span><span class="params">(task: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    _queue.loop &#123; queue -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isCompleted) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果当前已完成，不再接受新任务</span></span><br><span class="line">        <span class="keyword">when</span> (queue) &#123;</span><br><span class="line">            <span class="literal">null</span> -&gt; <span class="keyword">if</span> (_queue.compareAndSet(<span class="literal">null</span>, task)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果队列为空，尝试将任务作为第一个元素入队</span></span><br><span class="line">            <span class="keyword">is</span> Queue&lt;*&gt; -&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果队列非空，尝试在队列尾部添加任务</span></span><br><span class="line">                <span class="keyword">when</span> ((queue <span class="keyword">as</span> Queue&lt;Runnable&gt;).addLast(task)) &#123;</span><br><span class="line">                    Queue.ADD_SUCCESS -&gt; <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 添加成功</span></span><br><span class="line">                    Queue.ADD_CLOSED -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭，无法添加</span></span><br><span class="line">                    Queue.ADD_FROZEN -&gt; _queue.compareAndSet(queue, queue.next()) <span class="comment">// 队列被冻结，尝试更新队列状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">when</span> &#123;</span><br><span class="line">                queue === CLOSED_EMPTY -&gt; <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 队列已关闭且为空，无法添加</span></span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 如果队列是单个任务，转换为完整队列并添加任务</span></span><br><span class="line">                    <span class="keyword">val</span> newQueue = Queue&lt;Runnable&gt;(Queue.INITIAL_CAPACITY, singleConsumer = <span class="literal">true</span>)</span><br><span class="line">                    newQueue.addLast(queue <span class="keyword">as</span> Runnable)</span><br><span class="line">                    newQueue.addLast(task)</span><br><span class="line">                    <span class="keyword">if</span> (_queue.compareAndSet(queue, newQueue)) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 更新队列并添加任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先将任务入队列，上面的runBlocking函数最后返回的是<code>coroutine.joinBlocking()</code>，分析下这个函数干了啥。</p>
<p>joinBlocking是coroutine中的函数，看一下它的创建。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">eventLoop = ThreadLocalEventLoop.eventLoop</span><br><span class="line">    newContext = GlobalScope.newCoroutineContext(context + eventLoop)</span><br><span class="line">    <span class="keyword">val</span> coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, eventLoop)</span><br><span class="line">		coroutine.start(CoroutineStart.DEFAULT, coroutine, block)</span><br></pre></td></tr></table></figure>

<p>看joinBlocking的具体实现</p>
<p>eventLoop就是<code>ThreadLocalEventLoop.eventLoop</code>创建的BlockingEventLoop对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">BlockingCoroutine：</span><br><span class="line"><span class="comment">// `joinBlocking` 函数用于在阻塞模式下等待协程完成，并返回协程的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinBlocking</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">    registerTimeLoopThread() <span class="comment">// 注册当前线程到时间循环。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop?.incrementUseCount() <span class="comment">// 增加事件循环的使用计数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> InterruptedException().also &#123; cancelCoroutine(it) &#125; <span class="comment">// 如果线程被中断，抛出中断异常。</span></span><br><span class="line">                <span class="keyword">val</span> parkNanos = eventLoop?.processNextEvent() ?: <span class="built_in">Long</span>.MAX_VALUE <span class="comment">// 处理下一个事件，或等待最大时间。</span></span><br><span class="line">                <span class="keyword">if</span> (isCompleted) <span class="keyword">break</span> <span class="comment">// 如果协程已完成，则退出循环。</span></span><br><span class="line">                parkNanos(<span class="keyword">this</span>, parkNanos) <span class="comment">// 阻塞当前线程指定的纳秒数。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 无论如何都会执行的清理代码。</span></span><br><span class="line">            eventLoop?.decrementUseCount() <span class="comment">// 减少事件循环的使用计数。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 另一个清理代码块。</span></span><br><span class="line">        unregisterTimeLoopThread() <span class="comment">// 取消注册当前线程到时间循环。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取协程的结果。</span></span><br><span class="line">    <span class="keyword">val</span> state = <span class="keyword">this</span>.state.unboxState() <span class="comment">// 获取协程的状态。</span></span><br><span class="line">    (state <span class="keyword">as</span>? CompletedExceptionally)?.let &#123; <span class="keyword">throw</span> it.cause &#125; <span class="comment">// 如果是异常完成，则抛出异常。</span></span><br><span class="line">    <span class="keyword">return</span> state <span class="keyword">as</span> T <span class="comment">// 返回协程的结果。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>val parkNanos = eventLoop?.processNextEvent() ?: Long.MAX_VALUE // 处理下一个事件，或等待最大时间。</code> 这里是不是有点熟悉，想不想handler的消息轮训。看下<code>processNextEvent</code>的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EventLoop：</span><br><span class="line"><span class="comment">// `processNextEvent` 函数预定于处理下一个协程事件，并返回下一个事件发生之前的时间（以纳秒为单位）。</span></span><br><span class="line"><span class="comment">// 如果没有事件需要处理，它返回 Long.MAX_VALUE，这是一个常用的约定，表示无限的延迟时间。</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">processNextEvent</span><span class="params">()</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试处理一个非受限的事件，如果成功处理，返回 0。</span></span><br><span class="line">    <span class="comment">// 如果没有事件处理，会返回 Long.MAX_VALUE，这意味着没有事件需要立即处理。</span></span><br><span class="line">    <span class="keyword">if</span> (!processUnconfinedEvent()) <span class="keyword">return</span> <span class="built_in">Long</span>.MAX_VALUE</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `processUnconfinedEvent` 处理一个非受限的协程的事件。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">processUnconfinedEvent</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 获取非受限的任务队列。</span></span><br><span class="line">    <span class="keyword">val</span> queue = unconfinedQueue ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 从队列中移除一个任务，如果队列为空则返回 false。</span></span><br><span class="line">    <span class="keyword">val</span> task = queue.removeFirstOrNull() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 执行取出的任务。</span></span><br><span class="line">    task.run()</span><br><span class="line">    <span class="comment">// 如果成功执行了任务，返回 true。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显<code>task.run()</code>开启了任务，这里先看看任务是怎么入队列的<code>resumeCancellableWith</code> → <code>dispatcher.dispatch(context, this)</code>→<code>enqueue(task: Runnable)</code>→<code>enqueueImpl</code>。这个流程走完将任务入队列，具体的任务task是个<code>DispatchedContinuation</code>对象就是<code>createCoroutineUnintercepted(receiver, completion).intercepted()</code>这步生成的。它同时实现了Continuation和Runnable接口。</p>
<p>run方法实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 这是`Runnable`的一个重写方法，当任务运行时会被执行。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="comment">// 确保在任务被调度之前已经初始化了`resumeMode`。</span></span><br><span class="line">      assert &#123; resumeMode != MODE_UNINITIALIZED &#125;</span><br><span class="line">      <span class="comment">// 获取任务的上下文。</span></span><br><span class="line">      <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">      <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 将代理转换为`DispatchedContinuation`，它包含需要继续的协程。</span></span><br><span class="line">          <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">          <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">          <span class="comment">// 临时设置当前持续上下文为协程的上下文。</span></span><br><span class="line">          withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">              <span class="keyword">val</span> context = continuation.context</span><br><span class="line">              <span class="comment">// 尝试从代理获取状态，它可能是一个结果或异常。</span></span><br><span class="line">              <span class="keyword">val</span> state = takeState() </span><br><span class="line">              <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line">              <span class="comment">// 检查是否应该可以取消任务，以及它是否仍然活跃。</span></span><br><span class="line">              <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                  <span class="comment">// 如果任务被取消，则使用取消异常来继续协程。</span></span><br><span class="line">                  <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                  cancelCompletedResult(state, cause)</span><br><span class="line">                  continuation.resumeWithStackTrace(cause)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 否则，正常地继续协程，用异常或成功的结果。</span></span><br><span class="line">                  <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                      continuation.resumeWithException(exception)</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// 这里走进了resumewith</span></span><br><span class="line">                      continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">          <span class="comment">// 捕获任务执行期间发生的任何致命异常。</span></span><br><span class="line">          fatalException = e</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 完成任务后，进行必要的清理，处理任何致命异常。</span></span><br><span class="line">          <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">          handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">		<span class="comment">// 调用resumeWith</span></span><br><span class="line">    resumeWith(Result.success(value)) <span class="comment">// Success(kotlin.Unit)</span></span><br></pre></td></tr></table></figure>

<p><code>continuation.resume(getSuccessfulResult(state))</code>这里的continuation是<code>createCoroutineUnintercepted(receiver, completion)</code>这里生成的SuspendLambda对象，具体为<code>Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</code>。</p>
<p>SuspendLambda是继承自BaseContinuationImpl的，所以这里resumeWith的实现在BaseContinuationImpl。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// current: Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt)</span></span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">  	<span class="comment">// param: null</span></span><br><span class="line">    <span class="keyword">var</span> param = result</span><br><span class="line">   	<span class="comment">// 进入死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        probeCoroutineResumed(current)</span><br><span class="line">        with(current) &#123;</span><br><span class="line">          	<span class="comment">// completion：BlockingCoroutine  这个是在runBlocking方法中创建的。</span></span><br><span class="line">            <span class="keyword">val</span> completion = completion!! </span><br><span class="line">            <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">// 走到这里执行invokeSuspend方法</span></span><br><span class="line">                    <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                    <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                    Result.success(outcome)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                    Result.failure(exception)</span><br><span class="line">                &#125;</span><br><span class="line">            releaseIntercepted() </span><br><span class="line">            <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123; </span><br><span class="line">                current = completion</span><br><span class="line">                param = outcome</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                completion.resumeWith(outcome)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码执行到了<code>val outcome = invokeSuspend(param)</code>,这里的实现得看反编译的代码，仅看invokeSuspend方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BuildersKt.runBlocking$<span class="keyword">default</span>((CoroutineContext)<span class="literal">null</span>, (Function2)(<span class="keyword">new</span> <span class="title class_">Function2</span>((Continuation)<span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">int</span> label;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">invokeSuspend</span><span class="params">(<span class="meta">@NotNull</span> Object $result)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">var3</span> <span class="operator">=</span> IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">      Object var10000;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>.label) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            TestActivityKt.log(<span class="string">&quot;runBlocking&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.label = <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 在这里又执行了testSuspends方法</span></span><br><span class="line">            var10000 = MainKt.testSuspends(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var3) &#123;</span><br><span class="line">               <span class="keyword">return</span> var3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ResultKt.throwOnFailure($result);</span><br><span class="line">            var10000 = $result;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> <span class="variable">var2</span> <span class="operator">=</span> ((Number)var10000).intValue();</span><br><span class="line">      <span class="keyword">return</span> Unit.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面又走到了<code>MainKt.testSuspends(this);</code> ，这就像递归一样，走到了下一个方法中。再看下<code>testSuspends</code>的实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSuspends</span><span class="params">()</span></span> = withContext(Dispatchers.IO) &#123;</span><br><span class="line">    delay(<span class="number">10000</span>)</span><br><span class="line">    log(<span class="string">&quot;testSuspends&quot;</span>)</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会走到withContext中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span>,  <span class="comment">// Dispatchers.IO</span></span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span>  <span class="comment">// kotlinx.coroutines.CoroutineScope.() -&gt; kotlin.Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span> &#123; uCont -&gt;  <span class="comment">// Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)</span></span><br><span class="line">        <span class="keyword">val</span> oldContext = uCont.context <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, BlockingEventLoop@7d322cad]</span></span><br><span class="line">        <span class="keyword">val</span> newContext = oldContext.newCoroutineContext(context)  <span class="comment">// [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO] 将BlockingEventLoop顶掉了</span></span><br><span class="line">        newContext.ensureActive()</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文相同，则直接执行代码块而不进行任何调度。                                   </span></span><br><span class="line">        <span class="keyword">if</span> (newContext === oldContext) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont)</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果旧上下文和新上下文使用的是相同的`ContinuationInterceptor`，则使用`UndispatchedCoroutine`执行代码块。                                                      </span></span><br><span class="line">        <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont)</span><br><span class="line">            withCoroutineContext(coroutine.context, <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 对于所有其他情况，创建一个`DispatchedCoroutine`，并且以可以取消的方式启动协程。</span></span><br><span class="line">				<span class="comment">// newContext： [BlockingCoroutine&#123;Active&#125;@7bbc8656, Dispatchers.IO]    </span></span><br><span class="line">				<span class="comment">// uCont： Continuation at com.app.tsmo.ui.MainKt$main$1.invokeSuspend(Main.kt:11)                                                      </span></span><br><span class="line">        <span class="keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        <span class="comment">// 启动协程并设置代码块。</span></span><br><span class="line">				<span class="comment">// coroutine                                                       </span></span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        <span class="comment">// 获取协程的结果。</span></span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要是通过<code>suspendCoroutineUninterceptedOrReturn</code>获取了续体和它的context来构建DispatchedCoroutine。</p>
<p><code>createCoroutineUnintercepted(receiver, completion).intercepted()</code> 这段代码生成的对象为<code>DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</code>。 传入的Dispatchers为Dispatchers.IO。Dispatchers.IO返回的对象为<code>public val IO: CoroutineDispatcher = DefaultIoScheduler</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">          	<span class="comment">// 这里的dispatcher为DefaultIoScheduler </span></span><br><span class="line">          	<span class="comment">// context：[DispatchedCoroutine&#123;Active&#125;@19976a65, Dispatchers.IO]</span></span><br><span class="line">          	<span class="comment">// this：DispatchedContinuation[Dispatchers.IO, Continuation at com.app.tsmo.ui.MainKt$testSuspends$2.invokeSuspend(Main.kt)@1593948d]</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看下DefaultIoScheduler::dispatch</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#DefaultIoScheduler</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  	<span class="comment">// default：LimitedDispatcher</span></span><br><span class="line">    default.dispatch(context, block)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> default = UnlimitedIoScheduler.limitedParallelism(</span><br><span class="line">        systemProp(</span><br><span class="line">            IO_PARALLELISM_PROPERTY_NAME,</span><br><span class="line">            <span class="number">64.</span>coerceAtLeast(AVAILABLE_PROCESSORS)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">最终挖到</span><br><span class="line">#LimitedDispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">  			<span class="comment">// 这里的dispatcher是UnlimitedIoScheduler</span></span><br><span class="line">        dispatchInternal(block) &#123; worker -&gt;</span><br><span class="line">            dispatcher.dispatch(<span class="keyword">this</span>, worker)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">所以最终调用的是UnlimitedIoScheduler下的dispatcher</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        DefaultScheduler.dispatchWithContext(block, BlockingContext, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">DefaultScheduler继承自SchedulerCoroutineDispatcher</span><br><span class="line">#SchedulerCoroutineDispatcher</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchWithContext</span><span class="params">(block: <span class="type">Runnable</span>, context: <span class="type">TaskContext</span>, tailDispatch: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        coroutineScheduler.dispatch(block, context, tailDispatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里到了协程线程池的知识点了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//block 为DispatchedContinuation</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//构建Task对象,block 本身就是Task类型</span></span><br><span class="line">    <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">    <span class="comment">//当前线程是否是Worker类型，也就是说当前线程是否是线程池内的线程</span></span><br><span class="line">    <span class="keyword">val</span> currentWorker = currentWorker()<span class="comment">//①</span></span><br><span class="line">    <span class="comment">//如果是，则尝试提交任务到本地队列，否则返回任务本身</span></span><br><span class="line">    <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)<span class="comment">//②</span></span><br><span class="line">    <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有提交到本地队列，则提交到全局队列 </span></span><br><span class="line">        <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;<span class="comment">//③</span></span><br><span class="line">            <span class="comment">//添加队列失败则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要跳过唤醒线程，主要用在IO分发器</span></span><br><span class="line">    <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;<span class="comment">//④</span></span><br><span class="line">        <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//非阻塞任务，唤醒cpu 线程</span></span><br><span class="line">        signalCpuWork()<span class="comment">//⑤</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//阻塞任务，唤醒blocking 线程</span></span><br><span class="line">        signalBlockingWork(skipUnpark = skipUnpark)<span class="comment">//⑥</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看下构建的线程池的参数</p>
<p>最先线程数非常大，核心线程数与cpu核数相关。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> CORE_POOL_SIZE = systemProp(</span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>,</span><br><span class="line">    AVAILABLE_PROCESSORS.coerceAtLeast(<span class="number">2</span>), <span class="comment">// 获取运行时java虚拟机的核心数 比2大的话CORE_POOL_SIZE就是这个值</span></span><br><span class="line">    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 可以自定义</span></span><br><span class="line">System.setProperty(<span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>, <span class="string">&quot;20&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><a href="https://juejin.cn/post/7137905800504148004">https://juejin.cn/post/7137905800504148004</a></p>
<h3 id="大概流程图"><a href="#大概流程图" class="headerlink" title="大概流程图"></a>大概流程图</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/9047de897d71447aa30e5b50b9e0a917%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="Kotlin协程工作流程"></p>
<p>在14，15 这两步一直循环到有可用的值就开始返回。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程面试题</title>
    <url>/2024/03/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="说说对多线程的理解？"><a href="#说说对多线程的理解？" class="headerlink" title="说说对多线程的理解？"></a>说说对多线程的理解？</h4><p>​		多线程是一种并发编程技术，允许程序同时执行多个线程，每个线程独立执行不同的任务。多线程有助于充分利用多核处理器和提高程序性能。然而，多线程编程也引入了一些挑战，如竞态条件、死锁等，需要仔细处理。</p>
<p>​		多线程是指在一个程序中同时运行多个线程（thread），每个线程独立执行不同的任务或代码段。多线程的好处是可以提高程序的并发性和响应性，即在同一时间内执行多个任务或操作，从而提高程序的执行效率和用户体验。</p>
<p>多线程的实现方式通常包括以下步骤：</p>
<ol>
<li>创建线程：程序需要创建多个线程来并发执行不同的任务或操作。</li>
<li>线程同步：多个线程之间需要协调执行顺序、共享资源等，因此需要使用同步机制来保证线程之间的正确性。常用的同步机制包括互斥锁、条件变量、信号量等。</li>
<li>线程调度：操作系统会根据一定的调度策略来分配CPU时间片给不同的线程执行。线程调度的策略通常包括抢占式调度和协作式调度两种方式。</li>
<li>线程结束：线程执行完任务后需要结束，释放占用的资源。线程结束的方式通常有两种，一种是线程自动结束，另一种是线程被其他线程或主线程强制结束。</li>
</ol>
<p>多线程的优点包括：</p>
<ol>
<li>提高程序的响应速度和并发性，能够同时处理多个任务或操作。</li>
<li>提高程序的效率，能够利用多核处理器的并行计算能力。</li>
<li>提高用户体验，能够快速响应用户的操作。</li>
</ol>
<p>多线程的缺点包括：</p>
<ol>
<li>线程之间的同步和数据共享会增加程序的复杂性和难度。</li>
<li>线程的创建、销毁和切换会消耗系统资源，需要考虑线程的数量和调度策略。</li>
<li>线程之间的竞争和死锁等问题容易出现，需要设计合理的同步机制和调度策略。</li>
</ol>
<h4 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全?"></a><strong>怎么保证线程安全?</strong></h4><p>​		保证线程安全的方法包括使用锁（如 synchronized、ReentrantLock）、使用线程安全的数据结构（如 ConcurrentHashMap）、使用原子操作等。这些方法可以防止多个线程同时访</p>
<p>​		问共享数据而导致的竞态条件和数据不一致的问题。线程安全的实现方式取决于具体的应用场景和需求。</p>
<h4 id="保证安全之后，怎么避免出现死锁？"><a href="#保证安全之后，怎么避免出现死锁？" class="headerlink" title="保证安全之后，怎么避免出现死锁？"></a><strong>保证安全之后，怎么避免出现死锁？</strong></h4><p>避免死锁的方法包括：</p>
<ol>
<li><strong>锁的顺序</strong>：确保多个线程获取锁的顺序一致，以减少死锁的可能性。</li>
<li><strong>超时机制</strong>：为获取锁设置超时时间，避免长时间等待。</li>
<li><strong>死锁检测</strong>：定期检测系统中是否存在死锁，并采取措施解除死锁。</li>
<li><strong>使用高级锁</strong>：某些高级锁（如 <code>ReentrantLock</code>）提供了更灵活的控制，可以更容易地避免死锁。</li>
</ol>
<h4 id="除了锁之外，还有什么方法实现多线程的同步问题？"><a href="#除了锁之外，还有什么方法实现多线程的同步问题？" class="headerlink" title="除了锁之外，还有什么方法实现多线程的同步问题？"></a><strong>除了锁之外，还有什么方法实现多线程的同步问题？</strong></h4><p>​		除了锁，还可以使用信号量、条件变量、原子操作、并发数据结构等方法来实现多线程的同步问题。这些方法可以根据具体的场景选择，以提供更好的性能和可维护性。</p>
]]></content>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2024/01/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h2><p>竞态是指计算的正确性依赖于相对时间顺序或者线程的交错。竞态并不一定就会导致计算结果不正确，它只是不排除计算结果时而正确时而错误的可能。</p>
<p>通俗来讲就是两个及以上的线程对共享变量的操作会存在操作覆盖和操作失败的情况。</p>
<p>以**goodsCount++**为例子，这个操作在字节码层面的伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load(shop.goodsCount , r1) //指令1，将变量 shop.goodsCount 的值从内存读到寄存器 r1</span><br><span class="line">increment(r1) //指令2，将寄存器 r1 的值加1</span><br><span class="line">store(shop.goodsCount , r1) //指令3，将寄存器 r1 的内容写入变量 shop.goodsCount 所对应的内存空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程 A 在执行完指令1，开始执行或者正在执行指令2时，线程 B 可能已经执行完了指令3，这使得线程 A 当前持有的共享变量 shop.goodsCount 是旧值，当线程 A 执行完指令3时，这就使得线程 B 对共享变量的更新被覆盖了，即造成了更新丢失。</p>
<blockquote>
<p>竞态可以看做是由于访问（读取、更新）同一组共享变量的多个线程所执行的操作被相互交错而导致的。而上述代码中遇到的<strong>更新丢失</strong>和<strong>读到脏数据</strong>问题就是由于竞态的存在而导致的</p>
<p>需要注意的是，竞态的产生前提是涉及到了多个线程和共享变量。如果系统仅包含单个线程，或者不涉及共享变量，那么就不会产生竞态。对于局部变量（包括形式参数和方法体内定义的变量），由于不同的线程访问的是各自的那一份局部变量，<strong>因此局部变量的使用不会导致竞态</strong><br>链接：<a href="https://juejin.cn/post/6899452217528025095">https://juejin.cn/post/6899452217528025095</a></p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程安全问题概括来说表现为三个方面：<strong>原子性、可见性、有序性</strong></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>对于涉及共享变量访问的操作，若该操作从其执行线程以外的其它任意线程来看是不可分割的，那么该操作就是<strong>原子操作</strong>，相应的就称该操作具有<strong>原子性</strong>。</p>
<p>简单来说就是如果当前线程的一块逻辑，相对于其他线程来说要么是已经执行完了要么是还未执行，不会出现执行到一半的情况。</p>
<p>Java 中有两种方式来提供原子性：</p>
<ul>
<li>第一种是使用锁（Lock）。锁具有排他性，它能够保障共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，从而消除了竞态</li>
<li>第二种是利用处理器提供的 CAS 指令。CAS 指令实现原子性的方式与锁在本质上是相同的，差别在于锁通常是在软件这一层面实现的，而 CAS 是直接在硬件（处理器和内存）这一层次实现的，可以被看做“硬件锁”</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的其它线程可能无法立即读取到这个更新的结果，甚至永远也无法读取到，这体现了多线程安全性问题中的一个：可见性。<strong>可见性是指一个线程对共享变量的更新结果对于其它读取相应共享变量的线程而言是否可见的问题。</strong>多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据，而这往往会导致我们的程序出现意想不到的问题。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640.jpg" alt="640"></p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>指令重排一般分为以下三种：</p>
<ul>
<li><p><strong>编译器优化重排</strong></p>
<p>编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下会出现执行<code>instance.doSomething();</code>时instance还未完成初始化的情况。</p>
<p>使用关键字new创建一个对象，大致分为一下过程：</p>
<ul>
<li>在栈空间创建引用地址</li>
<li>以类文件为模版在堆空间对象分配内存</li>
<li>成员变量初始化</li>
<li>使用构造函数初始化</li>
<li>将引用值赋值给左侧存储变量</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>​		并发的实现和是否拥有多个处理器无关，即使只有单个处理器也能够通过处理器<strong>时间片分配</strong>技术来实现并发。操作系统通过给每个线程分配一小段占有处理器使用权的时间来供其运行，然后在每个线程的运行时间结束后又快速切换到下一个线程来运行，多个线程以这种断断续续的方式来实现并发并完成各自的任务。</p>
<p>​		操作系统会分出一个个时间片，每个线程每次运行会分配到若干个时间片，时间片决定了一个线程可以连续占用处理器运行的时间长度，一般是只有几十毫秒，单处理器上的多线程就是通过这种<strong>时间片分配</strong>的方式来实现并发。当一个进程中的一个线程由于其时间片用完或者由于其自身的原因被迫或者主动暂停其运行时，另外一个线程（当前进程中的线程或者其它进程中的线程）就可以被线程调度器选中来占用处理器并开始运行。这种一个线程被剥夺处理器的使用权并暂停运行，另外一个线程被赋予处理器的使用权并开始运行的过程就称为线程上下文切换。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>线程调度是指操作系统为线程分配处理器使用权的过程。主要的调度方式有两种：</p>
<ul>
<li>协同式线程调度。在这种策略下，线程的执行时机由线程本身来决定，线程通过主动通知系统切换到另一个线程的方式来让出处理器的使用权。该策略的优点是实现简单，可以通过精准控制线程的执行顺序来避免线程安全性问题。缺点是可能会由于单个线程的代码缺陷问题导致无法切换到下一个线程，最终导致进程被阻塞</li>
<li>抢占式线程调度。这也是 Java 平台使用的线程调度策略。在这种策略下，由操作系统来决定当前处理器时间片交由哪个线程来使用，线程无法决定具体的运行时机和运行顺序。虽然我们可以通过 <code>Thread.yieid()</code> 方法来让出时间片，但是无法主动抢夺时间片，且虽然 Thread 类也提供了设置线程优先级的方法，但线程的具体执行顺序还是取决于其运行系统。该策略的优点是不会由于一个线程的问题导致整个进程被阻塞，且提高了并发性。缺点是实现较为复杂，且会带来多线程安全性问题。</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<p>在没有锁的情况下，当一个Thread创建后，start()调用后就会变成Runnable状态，然后当该线程抢到时间片后，就会Running状态（即开始运行），当执行完毕后便会结束Terminated，当然在运行中如果调用wait()后便会转为等待状态Waiting，然后一直到其他线程调用notify()或者notifyAll()才会被唤醒会，进入Runnable状态，然后抢时间片，重新Running。</p>
<p>如果涉及到锁的时候，当该线程抢到锁后，其他线程便会处于Blocked状态，等到该线程释放锁之后，那些阻塞的线程拿到锁后进入Runnable状态，然后Running：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/640" alt="图片"></p>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>线程创建时的内存分配默认大小是1M，也就是1024k</p>
<h2 id="synchronize使用"><a href="#synchronize使用" class="headerlink" title="synchronize使用"></a>synchronize使用</h2><p>先举个线程不安全的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRunnable</span> : <span class="type">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">            a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> runnable = LockRunnable()</span><br><span class="line">    <span class="keyword">val</span> thread1 = Thread(runnable)</span><br><span class="line">    <span class="keyword">val</span> thread2 = Thread(runnable)</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread2.join()</span><br><span class="line">        thread1.join()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    println(LockRunnable.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待两个线程执行完成之后a的值理论上应该是2000，但是实际上值是不确定的。</p>
<p>使用synchronized来保证线程安全</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat (<span class="number">1000</span>) &#123;</span><br><span class="line">           synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">               a++</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<h2 id="synchronize原理"><a href="#synchronize原理" class="headerlink" title="synchronize原理"></a>synchronize原理</h2><p>先看一个知识点，Java对象是在堆区里，它是由对象头、实例数据和对齐填充数据组成的，而一个对象的锁状态信息就是记录在对象头里的。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/2931590af3214062b83e36980a36a0b2.jpeg" alt="在这里插入图片描述"></p>
<p><code>mark word</code>用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上<code>mark word</code>长度为32bit，64位系统上长度为64bit。为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/6402" alt="图片"></p>
<p>根据对象锁状态的不同，系统位数所记载的信息也不同。比如无锁状态下前25位就代表hashcode。</p>
<p>来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lockObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">            <span class="comment">//需要同步的代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同步块部分的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: 3: monitorenter				 	  // monitorenter指令进入同步块</span><br><span class="line">         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit						  // monitorexit指令退出同步块 getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         7: ldc           #3                  // String hello block</span><br><span class="line">         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: monitorexit	</span><br></pre></td></tr></table></figure>

<p>进入到synchronized同步块中，需要通过monitorenter指令获取到对象的monitor（也通常称之为对象锁）后才能往下进行执行，在处理完对应的方法内部逻辑之后通过monitorexit指令来释放所持有的monitor，以供其他并发实体进行获取。</p>
<p>再具体的原理可以看重量级锁的释放锁部分</p>
<h2 id="synchronize锁状态"><a href="#synchronize锁状态" class="headerlink" title="synchronize锁状态"></a>synchronize锁状态</h2><table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody></table>
<p>一个对象其实有四种锁状态,级别由低到高:</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<h4 id="1、无锁"><a href="#1、无锁" class="headerlink" title="1、无锁"></a>1、无锁</h4><p>释放轻量级锁，没有线程在尝试获取锁，也没有线程持有锁（正在执行同步代码块），就是无锁。</p>
<h4 id="2、偏向锁（JDK15被废弃）"><a href="#2、偏向锁（JDK15被废弃）" class="headerlink" title="2、偏向锁（JDK15被废弃）"></a>2、偏向锁（JDK15被废弃）</h4><p>偏向锁顾名思义，偏向于第一个访问锁的线程。偏向锁在<strong>资源无竞争</strong>情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</p>
<p>当开启偏向锁功能时，创建的新对象是可偏向状态，此时mark word中的thread id为0，也叫做匿名偏向。当该对象第一次被CAS成功时，成为「偏向锁」。</p>
<p>当一个线程访问同步块并获取锁时，会在<strong>对象头</strong>和<strong>栈帧中的锁记录</strong>里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>当第二个线程出现并尝试获取锁，无论如何都会升级成「轻量级锁」。</strong></p>
<ul>
<li>如果第一个线程正在执行同步代码块，锁偏向的线程继续拥有锁，当前线程升级该锁为「轻量级锁」。</li>
<li>如果第一个线程不在执行同步代码块，先将对象头的<code>mark word</code>改为无锁状态，再升级为「轻量级锁」。</li>
</ul>
<h4 id="3、轻量级锁"><a href="#3、轻量级锁" class="headerlink" title="3、轻量级锁"></a>3、轻量级锁</h4><p>升级到「轻量级锁」的条件是：<strong>存在多个线程尝试CAS获取同一把锁，尽管彼此之间互不影响。</strong>而「轻量级锁」继续膨胀为「重量级锁」的条件是：<strong>只要CAS失败，就升级</strong>，即发生了：一个线程正在执行同步代码块的同时，另一个线程尝试获取锁。</p>
<p><strong>获取锁</strong></p>
<ol>
<li><p>发现是无锁状态，线程会<strong>把锁的Mark Word复制到自己的Displaced Mark Word（栈帧中的一块空间）</strong> ，然后通过CAS尝试将锁的Mark Word修改为一根指针，指向自己的Displaced Mark Word（Displaced Mark Word与原mark word的内容一模一样，保存了HashCode，GC年龄等信息）</p>
</li>
<li><p>发现处于轻量级锁状态</p>
</li>
</ol>
<ul>
<li>如果轻量级锁的mark word指向自己的Displaced Mark Word，代表重入锁，那么获取锁成功（如果是重入，会将markword改为null，空指针，即0）</li>
<li>如果轻量级锁的markword不是指向自己，锁膨胀，升级为「重量级锁」</li>
</ul>
<p><strong>CAS失败直接膨胀</strong></p>
<h4 id="4、-重量级锁"><a href="#4、-重量级锁" class="headerlink" title="4、 重量级锁"></a>4、 重量级锁</h4><p>由原来线程主动去抢锁对象变成由系统内核来决定最后锁对象分配给谁</p>
<p>从轻量级锁开始膨胀：</p>
<ol>
<li>创建monitor对象</li>
<li>CAS将锁状态修改为「膨胀中」<ul>
<li>失败，说明别人在膨胀了，等待，然后返回别人生成的monitor</li>
<li>成功：<ul>
<li>将markword保存至monitor</li>
<li>设置持有monitor的线程</li>
<li>将monitor地址设置为mark word</li>
<li>返回monitor对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>monitor对象的结构：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323439323038312d346138373535313231393063396463342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f313130312f666f726d61742f77656270" alt="img"></p>
<ul>
<li>Contention List(cxq)：所有请求锁的线程将被首先放置到该竞争队列，是先进后出的栈结构</li>
<li>Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List</li>
<li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li>
<li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li>
<li>Owner：获得锁的线程称为Owner</li>
<li>!Owner：释放锁的线程</li>
</ul>
<p>ContentionList，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p><strong>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。</strong>当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p>
<p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p>
<h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a><strong>获取锁</strong></h5><blockquote>
<p>对于重量级锁，尝试获取锁具体是指：尝试用CAS将monitor对象的Owner从nullptr改变为自己</p>
</blockquote>
<p>当一个线程尝试获得重量级锁时</p>
<ul>
<li>首先尝试「自旋」，调用trySpin方法获取锁，如果第一次失败，再进行一次trySpin方法（最坏情况拿不到锁会调用两次trySpin），然后『用CAS的方式进入cxq』</li>
<li>进入cxq后，陷入「死循环」，死循环中，可能会从cxq转移到EntryList，可能阻塞，也可能调用trySpin方法自旋。后文再详细分析「死循环」</li>
</ul>
<h5 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h5><p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
<p><strong>自旋逻辑</strong>：trySpin</p>
<p>首选预自旋11次（避免预自旋次数设置为0，源码后面对这个参数加了1），如果没拿到锁：</p>
<p>开始自旋5000次（假设是第一次开始自旋，上限就为5000）</p>
<ul>
<li>成功，下次+100，下次可以最多自旋5100次</li>
<li>失败，下次- 200，下次可以最多自旋4800次，不会少于1000次</li>
</ul>
<p><strong>死循环</strong></p>
<p>死循环主要是在「阻塞」和「自旋」之间切换</p>
<ul>
<li>park阻塞，注意不会移动到WaitSet中</li>
<li>unpark唤醒，再次调用trySpin方法自旋获取锁，如果失败，陷入阻塞</li>
</ul>
<p>只有释放锁时，才会调用unpark唤醒，进入自旋状态，此时并不是一定能拿到锁的。</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>monitor有个计数器recursions，起初为0，Monitorenter + 1，Monitorexit - 1，减为0会释放锁</p>
<ol>
<li>通过CAS的方式将Monitor结构的Owner修改为nullptr</li>
<li>根据QMode参数的不同，执行不同的逻辑</li>
</ol>
<p>因为QMode默认值为0，我们来看一下<strong>默认的逻辑</strong>：</p>
<ul>
<li>如果EntryList和cxq均为空：什么也不做</li>
<li>如果EntryList非空：就取EntryList首元素唤醒</li>
<li>如果EntryList为空，cxq非空：将cxq的所有线程放到EntryList，再唤醒EntryList首元素；</li>
</ul>
<p>锁被持有时，EntryList和cxq的所有线程都阻塞，有且只有锁释放这唯一一个行为能够唤醒其中的一个线程。</p>
<h2 id="wait-notify底层原理"><a href="#wait-notify底层原理" class="headerlink" title="wait&#x2F;notify底层原理"></a>wait&#x2F;notify底层原理</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><ol>
<li>将当前线程包装成ObjectWaiter对象，放入WaitSet中，并调用park挂起</li>
<li>执行「释放锁」的逻辑。</li>
</ol>
<blockquote>
<p>只有notify方法有可能将线程从WaitSet拯救出来，处于WaitSet的线程永远是阻塞状态，不可能参与锁竞争</p>
</blockquote>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>从WaitSet中取出第一个线程，根据Policy的不同，将这个线程放入EntryList或者cxq队列中的起始或末尾位置</p>
<p>默认Policy为2，即：</p>
<ul>
<li>EntryList队列为空，将线程放入EntryList</li>
<li>EntryList队列非空，将线程放入cxq队列的头部位置（栈顶）；</li>
</ul>
<p>强调一下：notify方法只是将线程从WaitSet移动到EntryList或者cxq，不是直接让它开始自旋CAS。</p>
<h2 id="synchronized内存特性"><a href="#synchronized内存特性" class="headerlink" title="synchronized内存特性"></a>synchronized内存特性</h2><p><strong>内存可见性</strong></p>
<ul>
<li><strong>获取锁（进入 <code>synchronized</code> 块）</strong>：当一个线程获取锁并进入 <code>synchronized</code> 块时，它会清空本地内存（如果有的话），然后从主内存中读取共享变量的最新值。</li>
<li><strong>释放锁（退出 <code>synchronized</code> 块）</strong>：当一个线程释放锁并退出 <code>synchronized</code> 块时，它会将在 <code>synchronized</code> 块中对共享变量的所有修改刷新（写回）到主内存中。</li>
</ul>
<p><strong>原子性</strong></p>
<ul>
<li><code>synchronized</code>通过<code>monitorenter</code>和<code>monitorexit</code> 指令来保证原子性</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量</li>
<li>E：旧值</li>
<li>N：新值</li>
</ul>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p>简单来说：</p>
<p>​		当我要修改当前变量的值时，如果它的值和旧值一样说明没有被修改过，就将新值赋值给当前变量。如果它的值和旧值不一样。说明已经被修改过就啥都不干了。</p>
<p>​		如果它再次获取当前的值然后进入新的比较操作的话这个重新尝试的过程被称为<strong>自旋</strong>。</p>
<p>​		Synchronized属于<strong>悲观锁</strong>，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于<strong>乐观锁</strong>，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<p>​		<strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong>可见性</strong>：</p>
<p>第一项是保证此变量对所有线程的可见性，这里的“性”是指<strong>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再对主内存进行读取操作，新变量值才会对线程B可见。</p>
<p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
<p><strong>禁止指令重排序优化</strong></p>
<p>普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的<br>执行顺序一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程A执行的代码</span></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">SingletonExample</span>(); <span class="comment">//步骤1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//步骤2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B执行的代码</span></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    instance.doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2可能会比步骤1先执行</p>
<p>JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。如下所示：</p>
<blockquote>
<p>LoadLoadBarrier<br>volatile 读操作<br>LoadStoreBarrier</p>
<p>StoreStoreBarrier<br>volatile 写操作<br>StoreLoadBarrier</p>
</blockquote>
<p>当编译器遇到<code>volatile</code>变量的写操作时，会在写操作之前插入一个StoreStore屏障，防止写操作和之前的写操作发生重排；并在写操作之后插入一个StoreLoad屏障，防止写操作和之后的读写操作发生重排。</p>
<p>同样，当编译器遇到<code>volatile</code>变量的读操作时，会在读操作之后插入一个LoadLoad屏障，防止读操作和之后的读操作发生重排。</p>
<p>内存屏障（Memory Barrier），也称为内存栅栏，是一种用于处理器指令的同步机制，可以防止指令重排序。内存屏障主要分为以下四种类型： ，   </p>
<ol>
<li><strong>LoadLoad屏障</strong>：这种屏障确保在其前面的读操作（Load）不会被重排序到其后面的读操作之后。</li>
<li><strong>StoreStore屏障</strong>：这种屏障确保在其前面的写操作（Store）不会被重排序到其后面的写操作之后。</li>
<li><strong>LoadStore屏障</strong>：这种屏障确保在其前面的读操作不会被重排序到其后面的写操作之后。</li>
<li><strong>StoreLoad屏障</strong>：这种屏障确保在其前面的写操作不会被重排序到其后面的读操作之后。</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>) <span class="comment">// true设置为公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientThread</span>(name: String) : Thread(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(currentThread().name + <span class="string">&quot;开始尝试获取锁&quot;</span>)</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;成功获取锁&quot;</span>)</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()</span><br><span class="line">            println(currentThread().name + <span class="string">&quot;完成释放锁&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> t1 = ClientThread(<span class="string">&quot;线程1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t2 = ClientThread(<span class="string">&quot;线程2&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> t3 = ClientThread(<span class="string">&quot;线程3&quot;</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：					</span><br><span class="line">线程<span class="number">2</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">1</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">3</span>开始尝试获取锁</span><br><span class="line">线程<span class="number">2</span>成功获取锁</span><br><span class="line">线程<span class="number">3</span>成功获取锁</span><br><span class="line">线程<span class="number">2</span>完成释放锁</span><br><span class="line">线程<span class="number">3</span>完成释放锁</span><br><span class="line">线程<span class="number">1</span>成功获取锁</span><br><span class="line">线程<span class="number">1</span>完成释放锁</span><br></pre></td></tr></table></figure>

<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ol>
<li><strong>公平锁</strong>：公平锁是指多个线程按照申请锁的顺序来获取锁。也就是说，锁会被授予等待时间最长的线程。这种方式可以防止资源饥饿，但是在锁的释放和获取之间会产生较大的开销，因此公平锁的整体吞吐量会比非公平锁小。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>类的构造函数可以接受一个布尔值，用来表示这个锁是否是公平的。</li>
<li><strong>非公平锁</strong>：非公平锁是指多个线程获取锁的顺序并不固定，也就是说，有可能新请求的线程比已经在等待的线程更早获取到锁。这种方式可能会导致某些线程等待时间过长甚至无限期等待，也就是所谓的饥饿现象。但是非公平锁的优点是吞吐量大，因为线程获取锁的速度通常比公平锁快，上下文切换次数也少。在Java中，<code>java.util.concurrent.locks.ReentrantLock</code>默认就是非公平锁。</li>
</ol>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p>
<p><strong>核心原理：</strong>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，<strong>AQS中的队列是CLH变体的虚拟双向队列（FIFO）</strong>，AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1ebefeb23a184f2a9b515bf01eb430da%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="img"></p>
<p>AQS 中的 CLH 变体等待队列拥有以下特性</p>
<ol>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋（进入一个循环中，不断检查锁是否已经被释放，而不是进入睡眠状态）获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ol>
<h3 id="ReentrantLock与AQS的关联"><a href="#ReentrantLock与AQS的关联" class="headerlink" title="ReentrantLock与AQS的关联"></a>ReentrantLock与AQS的关联</h3><p>追一下ReentrantLock加锁时的源码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lock = ReentrantLock(<span class="literal">true</span>)</span><br><span class="line">lock.lock()</span><br></pre></td></tr></table></figure>

<p>lock()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#ReentrantLock</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个sync是FairSync对象或NonfairSync对象，是sync抽象类的实现类。然后看一下Sync的定义，AbstractQueuedSynchronizer就是AQS。下面都以NonfairSync非公平锁为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> <span class="comment">// 公平锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Syn</span> <span class="comment">// 非公平锁</span></span><br></pre></td></tr></table></figure>

<p>sync.lock()的实现看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Sync</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!initialTryLock())</span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个initialTryLock方法就是用来尝试获取锁的，这个方法尝试获取一个可重入的独占锁，如果成功则返回true，如果失败则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">initialTryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用CAS操作尝试将锁的状态从0（未锁定）改变为1（已锁定）</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; </span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁已经被某个线程持有，检查锁的所有者是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getExclusiveOwnerThread() == current) &#123;</span><br><span class="line">        <span class="comment">// 如果锁的所有者是当前线程，说明这是一个重入操作</span></span><br><span class="line">        <span class="comment">// 获取锁的当前状态并加1，表示锁被重入了一次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查锁的状态是否超过了int的最大值，如果超过，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 将锁的状态设置为新的值</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果锁的所有者不是当前线程，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setState(c)就是设置之前说的那个表示同步状态的state值，如果获取锁成功将锁的所有者设置为当前线程，获取失败的话返回false开始执行 acquire(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AbstractQueuedSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            acquire(<span class="literal">null</span>, arg, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"># NonfairSync</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查锁的状态是否为0（未被锁定）</span></span><br><span class="line">    <span class="comment">// 如果锁的状态为0，使用CAS操作尝试将锁的状态从0改变为传入的acquires值</span></span><br><span class="line">    <span class="comment">// 如果操作成功，说明当前线程成功获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (getState() == <span class="number">0</span> &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 将锁的所有者设置为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="comment">// 返回true，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果锁的状态不为0或者CAS操作失败，返回false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会再次重试获取锁，如果获取失败的话就执行acquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">acquire</span><span class="params">(Node node, <span class="type">int</span> arg, <span class="type">boolean</span> shared,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> interruptible, <span class="type">boolean</span> timed, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些变量</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">spins</span> <span class="operator">=</span> <span class="number">0</span>, postSpins = <span class="number">0</span>; <span class="comment">// 用于控制&quot;自旋&quot;的变量</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>, first = <span class="literal">false</span>; <span class="comment">// interrupted记录线程是否被中断，first记录node是否是队列的第一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// pred记录node的前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个无限循环，直到成功获取锁或者线程被中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line">        <span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            !(first = (head == pred))) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cleanQueue();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">                Thread.onSpinWait();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> acquired;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">                <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (shared)</span><br><span class="line">                    acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    acquired = tryAcquire(arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">                cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果节点是null，则根据是否共享锁创建相应类型的节点</span></span><br><span class="line">            <span class="keyword">if</span> (shared)</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">            node.waiter = current;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            node.setPrevRelaxed(t);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                tryInitializeHead();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node))</span><br><span class="line">                node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果CAS失败，回滚操作</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">            --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">            Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">            node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> nanos;</span><br><span class="line">            spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">            <span class="keyword">if</span> (!timed)</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">            node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">            <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束，调用cancelAcquire方法取消获取锁，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> cancelAcquire(node, interrupted, interruptible);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个队列就是上面说的CLH变体的虚拟双向队列，acquire方法开启了一个死循环直到当前线程成功获取锁或者线程被中断才终止循环。</p>
<p>分析for内的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node不是第一个节点，并且node有前驱节点，那么检查前驱节点的状态</span></span><br><span class="line"><span class="keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="literal">null</span>) ? <span class="literal">null</span> : node.prev) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(first = (head == pred))) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点被取消，那么清理队列并继续下一轮循环</span></span><br><span class="line">    <span class="keyword">if</span> (pred.status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cleanQueue();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred.prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点没有前驱，那么让出CPU，继续下一轮循环</span></span><br><span class="line">        Thread.onSpinWait();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码首先检查当前节点是否是第一个节点，如果不是，并且当前节点有前驱节点，那么就检查前驱节点的状态。如果前驱节点的状态小于0，那么说明前驱节点已经被取消，此时需要调用cleanQueue()方法清理队列，然后继续下一轮循环。</p>
<p>如果前驱节点没有前驱，那么就调用<code>Thread.onSpinWait()</code>方法让出CPU，并继续下一轮循环。<code>Thread.onSpinWait()</code>是Java 9引入的一个新方法，它可以用来提示JVM当前线程正在进行自旋操作，这样JVM可以采取一些优化措施，如减少线程的调度优先级，以避免占用过多的CPU资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果node是第一个节点，或者没有前驱节点，那么尝试获取锁</span></span><br><span class="line"><span class="keyword">if</span> (first || pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">boolean</span> acquired;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是共享锁，那么调用tryAcquireShared方法尝试获取锁</span></span><br><span class="line">        <span class="comment">// 如果是独占锁，那么调用tryAcquire方法尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (shared)</span><br><span class="line">            acquired = (tryAcquireShared(arg) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquired = tryAcquire(arg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果尝试获取锁时发生异常，那么取消获取，抛出异常</span></span><br><span class="line">        cancelAcquire(node, interrupted, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是尝试获取锁。如果<code>node</code>是第一个节点或者没有前驱节点，那么就会尝试获取锁。</p>
<p>在这段代码中，如果锁是共享锁，那么就调用<code>tryAcquireShared(arg)</code>方法尝试获取锁，如果成功获取锁（返回值大于等于0），那么<code>acquired</code>就会被设置为<code>true</code>。如果锁是独占锁，那么就调用<code>tryAcquire(arg)</code>方法尝试获取锁，如果成功获取锁，那么<code>acquired</code>就会被设置为<code>true</code>。</p>
<p>如果在尝试获取锁的过程中发生异常，那么就调用<code>cancelAcquire(node, interrupted, false)</code>方法取消获取，并抛出异常。</p>
<p>这段代码是一个典型的锁获取过程，它使用了Java的并发编程技术来实现线程安全的锁获取。</p>
<p>获取锁之后会进行一个清理的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果成功获取到锁，那么进行一些清理操作，然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                    node.prev = <span class="literal">null</span>;</span><br><span class="line">                    head = node;</span><br><span class="line">                    pred.next = <span class="literal">null</span>;</span><br><span class="line">                    node.waiter = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (shared)</span><br><span class="line">                        signalNextIfShared(node);</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是在成功获取锁之后进行一系列的操作。如果成功获取了锁（<code>acquired</code>为<code>true</code>），并且当前节点是第一个节点（<code>first</code>为<code>true</code>），那么就会进行一些清理和设置操作。</p>
<p>在代码中，如果成功获取了锁，并且当前节点是第一个节点，那么就会将当前节点的<code>prev</code>属性设置为<code>null</code>，将<code>head</code>设置为当前节点，将前驱节点的<code>next</code>属性设置为<code>null</code>，并将当前节点的<code>waiter</code>属性设置为<code>null</code>。这些操作都是为了清理和设置节点的状态。</p>
<p>接下来，如果获取的是共享锁，那么就会调用<code>signalNextIfShared(node)</code>方法通知下一个等待的节点。如果在获取锁的过程中线程被中断，那么就会调用<code>current.interrupt()</code>方法来中断当前线程。</p>
<p>最后，如果成功获取了锁，那么就返回1，表示成功获取了锁。</p>
<p>这段代码是一个典型的并发编程的代码片段，它使用了Java的并发编程技术来实现线程安全的锁获取和释放。</p>
<p>根据原来的代码流程来看，第一次进来node会是null会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared)</span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">SharedNode</span>();</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  node = <span class="keyword">new</span> <span class="title class_">ExclusiveNode</span>();</span><br></pre></td></tr></table></figure>

<p>这个shared默认是false，会给node赋值一个ExclusiveNode实例，然后开始下一个循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExclusiveNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123; &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">      <span class="keyword">volatile</span> Node prev;       <span class="comment">// initially attached via casTail</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next;       <span class="comment">// visibly nonnull when signallable</span></span><br><span class="line">      Thread waiter;            <span class="comment">// visibly nonnull when enqueued</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="type">int</span> status;</span><br><span class="line">      。。。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后会走到下面这个逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱节点是null，尝试将当前节点加入队列</span></span><br><span class="line">    node.waiter = current;  <span class="comment">// 将当前线程设置为节点的等待线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取队列的尾节点</span></span><br><span class="line">    node.setPrevRelaxed(t);  <span class="comment">// 将尾节点设置为当前节点的前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        tryInitializeHead();  <span class="comment">// 如果尾节点为null，尝试初始化头节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!casTail(t, node)) </span><br><span class="line">        node.setPrevRelaxed(<span class="literal">null</span>);  <span class="comment">// 如果使用CAS设置尾节点失败，回滚操作，将当前节点的前驱设置为null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.next = node;  <span class="comment">// 如果CAS成功，将当前节点设置为新的尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首相将节点的waiter属性设置为当前线程，然后判断tail，这个tail是队列的尾节点，如果是第一次初始化队列的话会为null，然后就走了tryInitializeHead方法，这个方法内部会通过CAS的方式给tail初始化。</p>
<p><code>casTail(t, node)</code>是一个CAS操作，它尝试将队列的尾节点从<code>t</code>更新为<code>node</code>。如果在这个过程中，其他线程已经修改了尾节点，那么CAS操作会失败，这时就需要进行回滚操作，将当前节点的前驱设置为<code>null</code>。如果CAS操作成功，那么就将当前节点设置为新的尾节点。</p>
<p>看下下面部分的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (first &amp;&amp; spins != <span class="number">0</span>) &#123;</span><br><span class="line">    --spins;  <span class="comment">// 如果节点是第一个节点，并且spins不为0，减少spins的值</span></span><br><span class="line">    Thread.onSpinWait();  <span class="comment">// 等待其他线程释放锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.status == <span class="number">0</span>) &#123;</span><br><span class="line">    node.status = WAITING;  <span class="comment">// 如果节点状态为0，将其设置为等待状态</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">long</span> nanos;</span><br><span class="line">    spins = postSpins = (<span class="type">byte</span>)((postSpins &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);  <span class="comment">// 更新spins和postSpins的值</span></span><br><span class="line">    <span class="keyword">if</span> (!timed)</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);  <span class="comment">// 如果不是定时等待，调用park方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="number">0L</span>)</span><br><span class="line">        LockSupport.parkNanos(<span class="built_in">this</span>, nanos);  <span class="comment">// 如果是定时等待，调用parkNanos方法使线程进入等待状态</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果等待时间已经过去，跳出循环</span></span><br><span class="line">    node.clearStatus();  <span class="comment">// 清除节点状态</span></span><br><span class="line">    <span class="keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 如果线程被中断并且是可中断的，跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，如果当前节点是第一个节点并且<code>spins</code>不为0，那么就减少<code>spins</code>的值，并调用<code>Thread.onSpinWait()</code>方法进行自旋等待，这是一种轻量级的等待方式，相比于阻塞等待，它可以在等待时间较短的情况下减少线程切换的开销。如果当前节点的状态是0，那么就将其状态设置为等待状态。如果当前节点的状态不是0，那么就会更新<code>spins</code>和<code>postSpins</code>的值，并根据是否是定时等待来决定是调用<code>LockSupport.park(this)</code>方法使线程进入阻塞等待状态，还是调用<code>LockSupport.parkNanos(this, nanos)</code>方法使线程进入定时阻塞等待状态。如果等待时间已经过去，那么就跳出循环。然后，清除节点状态。最后，如果线程被中断并且是可中断的，那么就跳出循环。</p>
<p>上面就是一个加锁的逻辑</p>
<p>解锁的话从<strong>unlock</strong>方法入手探索，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#AbstractOwnableSynchronizer</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            signalNext(head);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> #Sync</span><br><span class="line"> <span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// 获取当前锁的状态并减少指定的数量</span></span><br><span class="line">    <span class="comment">// 检查当前线程是否是锁的所有者，如果不是，抛出IllegalMonitorStateException</span></span><br><span class="line">    <span class="keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> (c == <span class="number">0</span>);  <span class="comment">// 检查是否可以释放锁（锁的状态是否为0）</span></span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">// 如果可以释放锁，将锁的所有者设置为null</span></span><br><span class="line">    setState(c);  <span class="comment">// 更新锁的状态</span></span><br><span class="line">    <span class="keyword">return</span> free;  <span class="comment">// 返回是否成功释放了锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果tryRelease失败的话就执行signalNext方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">signalNext</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 检查头节点是否存在，以及头节点的下一个节点是否存在并且其状态不为0</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; (s = h.next) != <span class="literal">null</span> &amp;&amp; s.status != <span class="number">0</span>) &#123;</span><br><span class="line">        s.getAndUnsetStatus(WAITING);  <span class="comment">// 清除下一个节点的等待状态</span></span><br><span class="line">        LockSupport.unpark(s.waiter);  <span class="comment">// 唤醒下一个等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是唤醒下一个在等待锁的线程。它首先检查头节点（通常是当前占用锁的线程）是否存在，以及头节点的下一个节点（通常是等待锁的下一个线程）是否存在并且其状态不为0。如果满足这些条件，那么它将清除下一个节点的等待状态，并使用<code>LockSupport.unpark(s.waiter)</code>方法唤醒下一个等待的线程。</p>
<h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><p>原理弄清楚了，顺便总结了几点Synchronized和ReentrantLock的区别：</p>
<ol>
<li>Synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现；</li>
<li>Synchronized的锁状态是无法在代码中直接判断的，但是ReentrantLock可以通过<code>ReentrantLock#isLocked</code>判断；</li>
<li>Synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的；</li>
<li>Synchronized是不可以被中断的，而<code>ReentrantLock#lockInterruptibly</code>方法是可以被中断的；</li>
<li>在发生异常时Synchronized会自动释放锁（由javac编译时自动实现），而ReentrantLock需要开发者在finally块中显示释放锁；</li>
<li>ReentrantLock获取锁的形式有多种：如立即返回是否成功的tryLock(),以及等待指定时长的获取，更加灵活；</li>
<li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说），而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td>锁实现机制</td>
<td>对象头监视器模式</td>
<td>依赖 AQS</td>
</tr>
<tr>
<td>灵活性</td>
<td>不灵活</td>
<td>支持响应中断、超时、尝试获取锁</td>
</tr>
<tr>
<td>释放锁形式</td>
<td>自动释放锁</td>
<td>显示调用 unlock()</td>
</tr>
<tr>
<td>支持锁类型</td>
<td>非公平锁</td>
<td>公平锁 &amp; 非公平锁</td>
</tr>
<tr>
<td>条件队列</td>
<td>单条件队列</td>
<td>多个条件队列</td>
</tr>
<tr>
<td>是否支持可重入</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>参考连接：</p>
<p><a href="https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23">https://juejin.cn/post/7278983339544018956?searchId=2024011715534989E1E0C6BD2FF21A3E66#heading-23</a></p>
<p><a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12</a></p>
<p><a href="https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA">https://juejin.cn/post/6844903600334831629?searchId=202401171700138376AADE4B451922ABCA</a></p>
<p><a href="https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA">https://mp.weixin.qq.com/s/Oj9Q4nh0L8udp0nRym-GaA</a></p>
<p><a href="https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_39867049/article/details/127489796?spm=1001.2014.3001.5501</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android View</title>
    <url>/2023/12/15/view%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Android-view-绘制流程"><a href="#Android-view-绘制流程" class="headerlink" title="Android view 绘制流程"></a>Android view 绘制流程</h1><h2 id="布局加载过程"><a href="#布局加载过程" class="headerlink" title="布局加载过程"></a>布局加载过程</h2><ul>
<li><p>我们所写的布局最终都会经过setContentView(layoutResID)加载到Activity上显示出来，那么简单的跟踪下流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">  		<span class="comment">// 这里调用了PhoneWindow的setContentView方法</span></span><br><span class="line">      getWindow().setContentView(layoutResID);</span><br><span class="line">      initWindowDecorActionBar();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">      	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">        installDecor();  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        mContentParent.removeAllViews();  </span><br><span class="line">    &#125;  </span><br><span class="line">  		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">        cb.onContentChanged();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;  </span><br><span class="line">                mDecor = generateDecor();  </span><br><span class="line">                mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);  </span><br><span class="line">                mDecor.setIsRootNamespace(<span class="literal">true</span>);  </span><br><span class="line">                <span class="comment">//...  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;  </span><br><span class="line">              	<span class="comment">// 这里引入R.layout.screen_simple add到了DecorView上 并将R.id.content传递给mContentParent 可以看下面的源码部分</span></span><br><span class="line">                mContentParent = generateLayout(mDecor);  </span><br><span class="line">                mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">                <span class="keyword">if</span> (mTitleView != <span class="literal">null</span>) &#123;  </span><br><span class="line">                   <span class="comment">//根据FEATURE_NO_TITLE隐藏，或者设置mTitleView的值  </span></span><br><span class="line">                    <span class="comment">//...  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    mActionBar = (ActionBarView) findViewById(com.android.internal.R.id.action_bar);  </span><br><span class="line">                    <span class="keyword">if</span> (mActionBar != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        <span class="comment">//设置ActionBar标题、图标神马的；根据FEATURE初始化Actionbar的一些显示  </span></span><br><span class="line">                        <span class="comment">//...  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> ViewGroup <span class="title function_">generateLayout</span><span class="params">(DecorView decor)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 先是一系列的属性设置贴了一些平时常用的</span></span><br><span class="line">    <span class="comment">// 取消标题栏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowNoTitle, <span class="literal">false</span>)) &#123;</span><br><span class="line">        requestFeature(FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowActionBar, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow an action bar if there is no title.</span></span><br><span class="line">        requestFeature(FEATURE_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置全屏</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowFullscreen, <span class="literal">false</span>)) &#123;</span><br><span class="line">        setFlags(FLAG_FULLSCREEN, FLAG_FULLSCREEN &amp; (~getForcedWindowFlags()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> getAttributes();</span><br><span class="line">    <span class="comment">// 一系列的窗口属性设置</span></span><br><span class="line">    <span class="comment">// 如：SDK 31 新增的高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.Window_windowBlurBehindEnabled, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getForcedWindowFlags() &amp; WindowManager.LayoutParams.FLAG_BLUR_BEHIND) == <span class="number">0</span>) &#123;</span><br><span class="line">            params.flags |= WindowManager.LayoutParams.FLAG_BLUR_BEHIND;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        params.setBlurBehindRadius(a.getDimensionPixelSize(</span><br><span class="line">                android.R.styleable.Window_windowBlurBehindRadius, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 整体布局文件</span></span><br><span class="line">    <span class="type">int</span> layoutResource;</span><br><span class="line">    <span class="comment">// 根据一系列判断选择 SDK 中的布局一般默认是 R.layout.screen_simple</span></span><br><span class="line">    <span class="keyword">if</span> (...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载到DecorView上</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到 screen_simple.xml 布局的内容部分 （R.id.content）</span></span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">contentParent</span> <span class="operator">=</span> (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> contentParent; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">DecorView:</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="type">int</span> layoutResource)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 通过 LayoutInflater 将 screen_simple.xml 解析成 View</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">root</span> <span class="operator">=</span> inflater.inflate(layoutResource, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 addView 将 root 添加到 DecorView 上</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">ViewGroup</span>.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前最终的布局层次</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
</li>
</ul>
<p>此时只是完成了基础的activity的DecirView的初始化 我们实现的布局还没有解析到布局上</p>
<p>回头看setContentView()方法，目前上面的部分实现了installDecor()，也就是初始化完成了DecorView 并解析了R.layout.screen_simple到上面，并将里面的FrameLayout（R.id.content）的引用传递出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhoneWindow：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123; </span><br><span class="line">    	<span class="comment">// 这里初始化了DecorView</span></span><br><span class="line">      installDecor();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      mContentParent.removeAllViews();  </span><br><span class="line">  &#125;  </span><br><span class="line">		<span class="comment">// 这里解析了我们自己传入的布局</span></span><br><span class="line">  mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br><span class="line">  <span class="keyword">final</span> <span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> getCallback();  </span><br><span class="line">  <span class="keyword">if</span> (cb != <span class="literal">null</span> &amp;&amp; !isDestroyed()) &#123;  </span><br><span class="line">      cb.onContentChanged();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面就是解析自己的布局过程，就是下面这行代码开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);  </span><br></pre></td></tr></table></figure>

<p>往下挖源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater:	</span><br><span class="line">	<span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前上下文的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">    <span class="comment">// 如果开启了调试模式，打印日志，显示正在从哪个资源文件加载视图</span></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">              + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据XML预编译生成compiled_view.dex, 然后通过反射来生成对应的View，从而减少XmlPullParser解析Xml的时间</span></span><br><span class="line">    <span class="comment">// 尝试从预编译的资源中加载视图，如果成功则返回视图 </span></span><br><span class="line">    <span class="comment">// 目前这个方法被禁用</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取XML资源解析器</span></span><br><span class="line">    <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用解析器，根据root和attachToRoot参数来加载视图</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后关闭解析器</span></span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用同步块，确保多线程环境下的安全性</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        <span class="comment">// 开始性能追踪，用于调试和性能优化</span></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;inflate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取上下文和属性集</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">inflaterContext</span> <span class="operator">=</span> mContext;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AttributeSet</span> <span class="variable">attrs</span> <span class="operator">=</span> Xml.asAttributeSet(parser);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">lastContext</span> <span class="operator">=</span> (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="type">View</span> <span class="variable">result</span> <span class="operator">=</span> root; <span class="comment">// root 赋值给 result</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果根视图不为空并且根视图的 ViewRootImpl 不为空，通知渲染器进行昂贵帧的处理</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; root.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将解析器推进到第一个START_TAG 也就是根View</span></span><br><span class="line">            advanceToRootNode(parser);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName(); <span class="comment">// 拿到根 View 名字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Creating root view: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;**************************&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// 如果根节点是 &lt;merge&gt;，则需要合并布局</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果根视图为空或者不需要附加到根视图，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; can be used only with a valid &quot;</span></span><br><span class="line">                            + <span class="string">&quot;ViewGroup root and attachToRoot=true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 执行合并布局</span></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 根据标签创建视图</span></span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图为空且 temp 不为空 且 temp 的 ViewRootImpl 不为空，通知渲染器处理昂贵帧</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> &amp;&amp; temp != <span class="literal">null</span> &amp;&amp; temp.getViewRootImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    temp.getViewRootImpl().notifyRendererOfExpensiveFrame();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 布局参数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果根视图不为空，则生成根视图的布局参数</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Creating params from root: &quot;</span> + root);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初始化布局参数</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// 如果不需要附加到根视图，则设置布局参数给 temp</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; start inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----&gt; done inflating children&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将创建的根 View 添加到 root 也就是 mContentParent 中</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 决定返回传入的根视图还是在 XML 中找到的顶层视图</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            <span class="comment">// XML 解析异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 其他异常，抛出 InflateException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                    getParserStateDescription(inflaterContext, attrs)</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">            <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 不要保留对上下文的静态引用</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束性能追踪</span></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">     View <span class="title function_">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreThemeAttr)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果标签名为 &quot;view&quot;，则尝试获取 &quot;class&quot; 属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;view&quot;</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="literal">null</span>, <span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不忽略主题属性，则尝试应用主题包装器</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">        <span class="comment">// 从属性中获取主题信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">TypedArray</span> <span class="variable">ta</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeResId</span> <span class="operator">=</span> ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果主题资源 ID 不为 0，则使用 ContextThemeWrapper 包装上下文</span></span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">ContextThemeWrapper</span>(context, themeResId);</span><br><span class="line">        &#125;</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试直接创建视图  </span></span><br><span class="line">      	<span class="comment">// 这里是使用Factory2创建view </span></span><br><span class="line">        <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line">				</span><br><span class="line">       <span class="comment">// 如果创建失败进入 if</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果直接创建失败，则尝试通过其他方式创建</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123; <span class="comment">// 表示 sdk 中的 View (Text、Button...)</span></span><br><span class="line">                    view = onCreateView(context, parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 表示自定义 View 或者 support 包中的 View (androidx.appcompat.widget.AppCompatButton...)</span></span><br><span class="line">                    view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InflateException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 InflateException，则直接抛出</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ClassNotFoundException，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 如果是其他异常，则创建 InflateException 并抛出</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">InflateException</span> <span class="variable">ie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(</span><br><span class="line">                getParserStateDescription(context, attrs)</span><br><span class="line">                + <span class="string">&quot;: Error inflating class &quot;</span> + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        <span class="keyword">throw</span> ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结上述源码：</p>
<p>LayoutInflater::inflate 开启了布局解析，<code>XmlResourceParser parser = res.getLayout(resource);</code>获取了布局解析器，然后<code>inflate(parser, root, attachToRoot);</code> 进入了具体的解析流程。从<code>final View temp = createViewFromTag(root, name, inflaterContext, attrs);</code>进入createViewFromTag方法，然后走下如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> tryCreateView(parent, name, context, attrs);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lastContext</span> <span class="operator">=</span> mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">           mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                   view = onCreateView(context, parent, name, attrs);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   view = createView(context, name, <span class="literal">null</span>, attrs);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<p>tryCreateView是尝试创建view，看看具体代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">tryCreateView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(TAG_1995)) &#123;</span><br><span class="line">            <span class="comment">// Let&#x27;s party like it&#x27;s 1995!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlinkLayout</span>(context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        View view;</span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; mPrivateFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很简单就是通过mFactory2&#x2F;mFactory来创建view。</p>
<p>其中Activity的父类AppCompatActivity中的构造方法中会执行一个initDelegate()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">        。。。</span><br><span class="line">        <span class="comment">// 添加上下文可用监听器</span></span><br><span class="line">    addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 AppCompatDelegate 实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AppCompatDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> getDelegate();</span><br><span class="line">            <span class="comment">// 安装视图工厂 这里开启了Factory</span></span><br><span class="line">            delegate.installViewFactory();</span><br><span class="line">            <span class="comment">// 调用 AppCompatDelegate 的 onCreate 方法，并传入从 SavedStateRegistry 恢复的状态</span></span><br><span class="line">            delegate.onCreate(getSavedStateRegistry()</span><br><span class="line">                    .consumeRestoredStateForKey(DELEGATE_TAG));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDelegateImpl:</span><br><span class="line"> 		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">installViewFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">        <span class="keyword">if</span> (layoutInflater.getFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 这里setFactory2 将this也就是AppCompatDelegateImpl</span></span><br><span class="line">            LayoutInflaterCompat.setFactory2(layoutInflater, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(layoutInflater.getFactory2() <span class="keyword">instanceof</span> AppCompatDelegateImpl)) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;The Activity&#x27;s LayoutInflater already has a Factory installed&quot;</span></span><br><span class="line">                        + <span class="string">&quot; so we can not install AppCompat&#x27;s&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码走完又可以回到这部分了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view;</span><br><span class="line">    <span class="keyword">if</span> (mFactory2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时调用的onCreateView方法的实现应该是在AppCompatDelegateImpl中，看下具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> View <span class="title function_">createView</span><span class="params">(View parent, <span class="keyword">final</span> String name, <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> AttributeSet attrs)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 AppCompatViewInflater 为空，进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mAppCompatViewInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        <span class="type">String</span> <span class="variable">viewInflaterClassName</span> <span class="operator">=</span></span><br><span class="line">                a.getString(R.styleable.AppCompatTheme_viewInflaterClass);</span><br><span class="line">        <span class="keyword">if</span> (viewInflaterClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果未指定自定义的 ViewInflater 类名，使用默认的 AppCompatViewInflater</span></span><br><span class="line">            mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用反射加载自定义的 ViewInflater 类</span></span><br><span class="line">                Class&lt;?&gt; viewInflaterClass =</span><br><span class="line">                        mContext.getClassLoader().loadClass(viewInflaterClassName);</span><br><span class="line">                mAppCompatViewInflater =</span><br><span class="line">                        (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor()</span><br><span class="line">                                .newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 加载失败时，使用默认的 AppCompatViewInflater，并打印错误日志</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Failed to instantiate custom view inflater &quot;</span></span><br><span class="line">                        + viewInflaterClassName + <span class="string">&quot;. Falling back to default.&quot;</span>, t);</span><br><span class="line">                mAppCompatViewInflater = <span class="keyword">new</span> <span class="title class_">AppCompatViewInflater</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否继承上下文，用于处理 &lt;include&gt; 标签的情况</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inheritContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (IS_PRE_LOLLIPOP) &#123;</span><br><span class="line">        <span class="comment">// 在 Android 5.0 之前的版本，处理 &lt;include&gt; 标签的继承上下文情况</span></span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector == <span class="literal">null</span>) &#123;</span><br><span class="line">            mLayoutIncludeDetector = <span class="keyword">new</span> <span class="title class_">LayoutIncludeDetector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutIncludeDetector.detect(attrs)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前视图是 &lt;include&gt; 的根视图，则继承上下文</span></span><br><span class="line">            inheritContext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 &lt;include&gt; 标签，根据深度或者使用旧的启发式方法来判断是否继承上下文</span></span><br><span class="line">            inheritContext = (attrs <span class="keyword">instanceof</span> XmlPullParser)</span><br><span class="line">                    ? ((XmlPullParser) attrs).getDepth() &gt; <span class="number">1</span></span><br><span class="line">                    : shouldInheritContext((ViewParent) parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 AppCompatViewInflater 的 createView 方法创建视图</span></span><br><span class="line">    <span class="keyword">return</span> mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,</span><br><span class="line">            IS_PRE_LOLLIPOP, <span class="comment">/* 只在 Android 5.0 之前读取 android:theme 属性 */</span></span><br><span class="line">            <span class="literal">true</span>, <span class="comment">/* 无论何时都读取 app:theme 属性作为后备，基于传统原因 */</span></span><br><span class="line">            VectorEnabledTintResources.shouldBeUsed() <span class="comment">/* 只有在启用时对上下文进行着色处理 */</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里又走到了createView方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">createView</span><span class="params">(<span class="meta">@Nullable</span> View parent, <span class="meta">@NonNull</span> <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">          <span class="meta">@NonNull</span> AttributeSet attrs, <span class="type">boolean</span> inheritContext,</span></span><br><span class="line"><span class="params">          <span class="type">boolean</span> readAndroidTheme, <span class="type">boolean</span> readAppTheme, <span class="type">boolean</span> wrapContext)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">originalContext</span> <span class="operator">=</span> context;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can emulate Lollipop&#x27;s android:theme attribute propagating down the view hierarchy</span></span><br><span class="line">      <span class="comment">// by using the parent&#x27;s context</span></span><br><span class="line">      <span class="keyword">if</span> (inheritContext &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">          context = parent.getContext();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (readAndroidTheme || readAppTheme) &#123;</span><br><span class="line">          <span class="comment">// We then apply the theme on the context, if specified</span></span><br><span class="line">          context = themifyContext(context, attrs, readAndroidTheme, readAppTheme);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wrapContext) &#123;</span><br><span class="line">          context = TintContextWrapper.wrap(context);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We need to &#x27;inject&#x27; our tint aware Views in place of the standard framework versions</span></span><br><span class="line">      <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;TextView&quot;</span>:</span><br><span class="line">              view = createTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageView&quot;</span>:</span><br><span class="line">              view = createImageView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Button&quot;</span>:</span><br><span class="line">              view = createButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;EditText&quot;</span>:</span><br><span class="line">              view = createEditText(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;Spinner&quot;</span>:</span><br><span class="line">              view = createSpinner(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ImageButton&quot;</span>:</span><br><span class="line">              view = createImageButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckBox&quot;</span>:</span><br><span class="line">              view = createCheckBox(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RadioButton&quot;</span>:</span><br><span class="line">              view = createRadioButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;CheckedTextView&quot;</span>:</span><br><span class="line">              view = createCheckedTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;AutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;MultiAutoCompleteTextView&quot;</span>:</span><br><span class="line">              view = createMultiAutoCompleteTextView(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;RatingBar&quot;</span>:</span><br><span class="line">              view = createRatingBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;SeekBar&quot;</span>:</span><br><span class="line">              view = createSeekBar(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&quot;ToggleButton&quot;</span>:</span><br><span class="line">              view = createToggleButton(context, attrs);</span><br><span class="line">              verifyNotNull(view, name);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// The fallback that allows extending class to take over view inflation</span></span><br><span class="line">              <span class="comment">// for other tags. Note that we don&#x27;t check that the result is not-null.</span></span><br><span class="line">              <span class="comment">// That allows the custom inflater path to fall back on the default one</span></span><br><span class="line">              <span class="comment">// later in this method.</span></span><br><span class="line">              view = createView(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span> &amp;&amp; originalContext != context) &#123;</span><br><span class="line">          <span class="comment">// If the original context does not equal our themed context, then we need to manually</span></span><br><span class="line">          <span class="comment">// inflate it using the name so that android:theme takes effect.</span></span><br><span class="line">          view = createViewFromTag(context, name, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// If we have created a view, check its android:onClick</span></span><br><span class="line">          checkOnClickListener(view, attrs);</span><br><span class="line">          backportAccessibilityAttributes(context, view, attrs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> view;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总结上面：AppCompatActivity 默认设置了 Factory2，并且其实现创建 View 是直接通过 new 的方式，并没有使用反射。</p>
<p>上面一节有个方法需要注意下，就是布局的子view是如果添加到根view的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/LayoutInflater.java</span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">    				...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 创建出根 View  后面小节着重分析这里是如何创建 View 的  重点在这</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">temp</span> <span class="operator">=</span> createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">								</span><br><span class="line">						...</span><br><span class="line">                <span class="comment">// 解析布局中的其他 View 并且添加到 temp 根 View 中</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span><br><span class="line"><span class="params">        AttributeSet attrs, <span class="type">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数的深度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> parser.getDepth();</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pendingRequestFocus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 逐个 View 解析</span></span><br><span class="line">    <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">            parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:focusable=&quot;true&quot;, 获取View的焦点</span></span><br><span class="line">            pendingRequestFocus = <span class="literal">true</span>;</span><br><span class="line">            consumeChildElements(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析android:tag标签</span></span><br><span class="line">            parseViewTag(parser, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// 解析include标签，include标签不能作为根布局</span></span><br><span class="line">            <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;include /&gt; cannot be the root element&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            parseInclude(parser, context, parent, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">            <span class="comment">// merge标签必须作为根布局</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InflateException</span>(<span class="string">&quot;&lt;merge /&gt; must be the root element&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据元素名解析，生成View</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> createViewFromTag(parent, name, context, attrs);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) parent;</span><br><span class="line">            <span class="keyword">final</span> ViewGroup.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> viewGroup.generateLayoutParams(attrs);</span><br><span class="line">            <span class="comment">// rInflateChildren方法内部调用的rInflate方法，深度优先遍历解析所有的子View</span></span><br><span class="line">            rInflateChildren(parser, view, attrs, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 添加解析的View</span></span><br><span class="line">            viewGroup.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequestFocus) &#123;</span><br><span class="line">        parent.restoreDefaultFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果finishInflate为true，则调用onFinishInflate方法</span></span><br><span class="line">    <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">        parent.onFinishInflate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为AppCompatActivity 默认设置了 Factory2，且Factory2只能设置一次，如果activity集成了AppCompatActivity那么只能通过反射设置Factory2了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory2</span><span class="params">(Factory2 factory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactorySet) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;A factory has already been set on this LayoutInflater&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Given factory can not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFactorySet = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mFactory = mFactory2 = factory;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFactory = mFactory2 = <span class="keyword">new</span> <span class="title class_">FactoryMerger</span>(factory, factory, mFactory, mFactory2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过反射将mFactorySet重新设置为true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//上面提到过：Android布局加载器使用mFactorySet标记是否设置过Factory，如设置过抛出一次</span></span><br><span class="line">  <span class="comment">//所以需要通过反射设置mFactorySet为false</span></span><br><span class="line">  <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LayoutInflater.class.getDeclaredField(<span class="string">&quot;mFactorySet&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  field.setBoolean(layoutInflater, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用factory2设置布局加载工厂</span></span><br><span class="line"><span class="type">SkinLayoutInflaterFactory</span> <span class="variable">skinLayoutInflaterFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkinLayoutInflaterFactory</span></span><br><span class="line">  (activity);</span><br><span class="line">LayoutInflaterCompat.setFactory2(layoutInflater, skinLayoutInflaterFactory);</span><br></pre></td></tr></table></figure>

<p><strong>setContentView总结：</strong></p>
<p>在<code>Activity</code>实例创建好并且执行<code>attach()</code>方法的时候，会为<code>Activity</code>创建一个<code>PhoneWindow</code>，接下来就到了<code>onCreate()</code>的生命周期，在调用<code>setContentView()</code>的时候，如果还没有初始化<code>ContentParent</code>，说明是第一次进行<code>setContentView()</code>，那么就会初始化<code>DecorView</code>，还会给<code>DecorView</code>添加一个系统页面样式的<code>子View(R.layout.screen_simple)</code>，那么在系统样式的<code>ViewGroup</code>中，就可以通过<code>id</code>找到用来加载自定义布局的<code>ContentParent</code>，再通过<code>inflate</code>就可以将我们自己写的<code>xml</code>文件<code>(R.layout.main)</code>转化为一颗<code>ViewTree</code>了，这颗<code>ViewTree</code>就在<code>ContentParent</code>里面。</p>
<p>所以<code>setContentView()</code>的作用最终可以总结为：</p>
<ul>
<li><strong>创建<code>DecorView</code></strong></li>
<li><strong>创建<code>ContentParent</code></strong></li>
<li><strong>自定义布局转化为<code>ViewTree</code>，放在<code>ContentParent</code>中</strong></li>
</ul>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA">https://mp.weixin.qq.com/s/RrMj_LJnHNackrVGOgD3TA</a><br><a href="https://www.jianshu.com/p/5a71014e7b1b">https://www.jianshu.com/p/5a71014e7b1b</a></p>
<p><a href="https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11">https://juejin.cn/post/7153807668988084237?searchId=20231213152107D629041C241AE4A8D0D3#heading-11</a></p>
<p><a href="https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff">https://www.jiangkang.tech/article/64ec557c-e702-4d38-a261-08a0957925ff</a><br><a href="https://www.jianshu.com/p/8e554406bd15">https://www.jianshu.com/p/8e554406bd15</a></p>
<h2 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h2><p>上面布局解析完之后还不可见，在activity处于<code>onResume()</code>生命周期时才会展示布局。</p>
<p><code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中执行的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> isForward, <span class="type">boolean</span> shouldSendCompatFakeFocus, String reason)</span> &#123;</span><br><span class="line">      	...</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">// 这里的decor就是上面setContentView加载的DecorView</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">          	<span class="comment">// 每一个Activity都会对应一个WindowManager对象（Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象）</span></span><br><span class="line">            <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">            WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 将DecorView add进WindowManager中</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">						。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>wm.addView</code>最终会走到WindowManagerGlobal的addView中。<code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。之后会调用<code>ViewRootImpl</code>的<code>setView</code>方法。这个方法中会调用<code>requestLayout()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 将布局请求安排到消息队列中，以便在下一个消息循环中执行。</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">// 获取 Looper 并创建同步屏障</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">          	<span class="comment">// 在 Choreographer 中调度遍历的回调</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">这里的mTraversalRunnable是个Runnable对象</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(<span class="string">&quot;ViewAncestor&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 到这里终于看到了绘制的起点了</span></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>onResume 总结：</strong></p>
<p>在<code>onResume()</code>中会调用<code>WindowManager</code>中的<code>addView()</code>添加<code>DecorView</code>，当<code>WindowManager</code>管理<code>ViewTree</code>的时候会给<code>ViewTree</code>分配一个<code>ViewRootImpl</code>，<code>ViewRootImpl</code>的第一个作用就是管理<code>ViewTree</code>的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个<code>Activity</code>的情况下，每个<code>Activity</code>都有自己的<code>PhoneWindow</code>、<code>DecorView</code>以及<code>WindowManagerImpl</code>，<code>WindowManagerGlobal</code>持有每个<code>Activity</code>的<code>RootView</code>，<code>mWindowSession</code>和<code>mWindow</code>是用来和<code>WMS</code>进行双向通信的。</p>
<p>看一下performTraversals的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123; </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRootMeasureSpec</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">int</span> rootDimension)</span> &#123; </span><br><span class="line">   <span class="type">int</span> measureSpec; </span><br><span class="line">   <span class="keyword">switch</span> (rootDimension) &#123; </span><br><span class="line">   <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT: </span><br><span class="line">   <span class="comment">// Window can&#x27;t resize. Force root view to be windowSize.   </span></span><br><span class="line">   measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY);</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   ...... </span><br><span class="line">  &#125; </span><br><span class="line"> <span class="keyword">return</span> measureSpec; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView是一个FrameLayout下面会直接进入FrameLayout的measure方法，参数就是上面生成的childWidthMeasureSpec和childHeightMeasureSpec。</p>
<h3 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h3><ul>
<li><p><strong>MeasureSpec 的理解</strong></p>
<p>MeasureSpec是一个32位的int值，用于描述View的大小和模式。它的高2位表示模式（mode），低30位表示大小（size）MeasureSpec有三种模式：</p>
<ol>
<li><p>精确模式（<strong>MeasureSpec.EXACTLY</strong>）：在这种模式下，View的大小已经确定，为SpecSize所指定的值。例如，当我们将控件的layout_width或layout_height指定为具体数值或者为<strong>MATCH_PARENT</strong>时，都是控件大小已经确定的情况，都是精确尺寸</p>
</li>
<li><p>最大模式（<strong>MeasureSpec.AT_MOST</strong>）：在这种模式下，父控件给出的是最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。例如，当控件的layout_width或layout_height指定为<strong>WRAP_CONTENT</strong>时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。</p>
</li>
<li><p>未指定模式（<strong>MeasureSpec.UNSPECIFIED</strong>）：在这种模式下，父控件不会干涉子View想要多大的尺寸，子View可以随意使用空间，不受限制。例如，在ScrollView或NestedScrollView中，子View的测量模式可能会被设置为MeasureSpec.UNSPECIFIED，这样子View就可以根据自己的内容来决定自己的大小。</p>
</li>
</ol>
</li>
</ul>
<p><strong>MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求</strong></p>
<ul>
<li><p><strong>mode的值</strong></p>
<p>-<strong>2147483648</strong>   对应的二进制表示是 <code>0b10000000000000000000000000011000</code>。在这个二进制中，最低的两位 <code>00</code> 表示测量模式为 <code>AT_MOST</code>。 </p>
<p><strong>1073742099</strong> 对应的二进制表示是 <code>0b10000000000000000000000100100011</code>。在这个二进制中，最低的两位 <code>11</code> 表示测量模式为 <code>EXACTLY</code>。</p>
</li>
<li><p><strong>ViewGroup的Measure</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewGroup:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildWithMargins</span><span class="params">(View child, <span class="type">int</span> parentWidthMeasureSpec, <span class="type">int</span> widthUsed, <span class="type">int</span> parentHeightMeasureSpec, <span class="type">int</span> heightUsed)</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，你在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">MarginLayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>以LinearLayout为例 解析Measure过程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>先分析下Android View 的结构：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/a61d8913dedb4eb8b211ef901e65cac3~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png"></p>
<p>我们写的布局最终会add到上面图片的FrameLayout中。</p>
<p>然后开始FrameLayout的measure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;  </span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>measureChildWithMargins的源码就是上面的ViewGroup的Measure的代码。</p>
<p>上面的performTraversals方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的宽</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="comment">// 获取的MeasureSpec的mode是EXACTLY 值为屏幕的高</span></span><br><span class="line"><span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br></pre></td></tr></table></figure>

<p>再结合view视图层次DecorView的下一级是ViewRoot这是个LinearLayout。ViewRoot 是系统的View，它的LayoutParams默认都是match_parent。</p>
<p>根据上面的计算规则：</p>
<p>ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size。</p>
<p><strong>目前ViewRoot的measure方法的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。</strong></p>
<p>measure方法会调用onMeasure方法开启计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinearLayout：</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ViewRoot的子view有两个ViewStub和id.content.</p>
<p>调用ViewRoot.measure后会调用，LinearLayout 的onMeasure 方法开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用。</p>
<p>根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿<strong>ViewRoot 的MeasureSpec</strong> 和 <strong>android.R.id.content的LayoutParams</strong> 做计算了，计算过程就是调用getChildMeasureSpec的方法。</p>
<p>来看下计算过程，首先ViewRoot.measure的两个MeasureSpec参数值 mode都是EXACTLY，size是屏幕的宽高。content的width和height都是matchparent。那么看下getChildMeasureSpec方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getChildMeasureSpec</span><span class="params">(<span class="type">int</span> spec, <span class="type">int</span> padding, <span class="type">int</span> childDimension)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">resultSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resultMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// 只看这个分支</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// 根据条件走到这个分支</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 后传递给content的Measure方法</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>id&#x2F;content是个FrameLayout然后又开启了新的计算流程。</p>
<p>这个计算流程就开始计算我们自己写的布局了，再看下原布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.ui.TestActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;....&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先应该是先计算最外面的LinearLayout，根据规则LinearLayout的measure(int widthMeasureSpec, int heightMeasureSpec)的两个MeasureSpec的mode都应该是<strong>EXACTLY</strong></p>
<p>然后开启LinearLayout的onMeasure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后根据LinearLayout的measure结合TextView的LayoutParams计算得到传递给TextView的MeasureSpaec。</p>
<p>这里看看LinearLayout的measure的源码，因为orientation&#x3D;”vertical”所以会走measureVertical(widthMeasureSpec, heightMeasureSpec);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">measureVertical</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>; <span class="comment">// 总高度，子控件累加总高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大子控件的宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">childState</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子view测量状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">alternativeMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 没有设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">weightedMaxWidth</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 设置weight的子view的最大宽度</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allFillParent</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 子控件全设置match_parent</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子控件累加总权重（子控件设置了layout_weight）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getVirtualChildCount();<span class="comment">// 子控件总数量</span></span><br><span class="line"><span class="comment">// 这里获取了LinearLayout的Mode</span></span><br><span class="line">  	<span class="comment">// 根据上面分析widthMode都是EXACTLY</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">widthMode</span> <span class="operator">=</span> MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">heightMode</span> <span class="operator">=</span> MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matchWidth</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 有子View宽度设置为match_parent</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">skippedMeasure</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否跳过重新测量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">baselineChildIndex</span> <span class="operator">=</span> mBaselineAlignedChildIndex; <span class="comment">// 基线子view</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 跟setMeasureWithLargestChildEnabled()有关</span></span><br><span class="line">		<span class="comment">// 当设定为true，所有有设定了weight的子View的最小高度是：最大的View的高度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useLargestChild</span> <span class="operator">=</span> mUseLargestChild;</span><br><span class="line"><span class="comment">// 最大子控件的高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestChildHeight</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">consumedExcessSpace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 需要测量的子View总数，不需要测量指的是设定了weight</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nonSkippedChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据子view数量开启循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 测量view为null占据的高度，默认返回0</span></span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == View.GONE) &#123;</span><br><span class="line">           i += getChildrenSkipCount(child, i);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nonSkippedChildCount++;</span><br><span class="line">        <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">            mTotalLength += mDividerHeight;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 获取当前子view的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 处理 weight</span></span><br><span class="line">        totalWeight += lp.weight;</span><br><span class="line">		</span><br><span class="line">      	<span class="comment">// 判断当前子view的height == 0 且 weight &gt; 0  </span></span><br><span class="line">      	<span class="comment">// 根据布局来看 useExcessSpace应该为false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useExcessSpace</span> <span class="operator">=</span> lp.height == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 子View的高度是具体的，可以这直接算出来，不需算子View的高度</span></span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            skippedMeasure = <span class="literal">true</span>; <span class="comment">// 该子View直接忽略二次计算</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// useExcessSpace 为false  无法精确计算子View</span></span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">              <span class="comment">// 假设为true的话 让子view的height为WRAP_CONTENT</span></span><br><span class="line">                lp.height = LayoutParams.WRAP_CONTENT;</span><br><span class="line">            &#125;</span><br><span class="line">				<span class="comment">// 判断Weight的值，为0则usedHeight为mTotalLength  mTotalLength表示目前为止已经测量过的子视图的总高度</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">usedHeight</span> <span class="operator">=</span> totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>;</span><br><span class="line">          	<span class="comment">// 开始走getChildMeasureSpec流程。 这里是获取TextView的MeasureSpec 然后走它的onMeasure方法</span></span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, <span class="number">0</span>,</span><br><span class="line">                    heightMeasureSpec, usedHeight);</span><br><span class="line">				<span class="comment">// 获取child的高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeight</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line">            <span class="keyword">if</span> (useExcessSpace) &#123;</span><br><span class="line">                lp.height = <span class="number">0</span>;</span><br><span class="line">                consumedExcessSpace += childHeight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">          	<span class="comment">// 获取总共的长度 </span></span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                   lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (useLargestChild) &#123;</span><br><span class="line">                largestChildHeight = Math.max(childHeight, largestChildHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((baselineChildIndex &gt;= <span class="number">0</span>) &amp;&amp; (baselineChildIndex == i + <span class="number">1</span>)) &#123;</span><br><span class="line">           mBaselineChildTop = mTotalLength;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we are trying to use a child index for our baseline, the above</span></span><br><span class="line">        <span class="comment">// book keeping only works if there are no children above it with</span></span><br><span class="line">        <span class="comment">// weight.  fail fast to aid the developer.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;A child of LinearLayout with index &quot;</span></span><br><span class="line">                    + <span class="string">&quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;</span></span><br><span class="line">                    + <span class="string">&quot;won&#x27;t work.  Either remove the weight, or don&#x27;t set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;mBaselineAlignedChildIndex.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// The width of the linear layout will scale, and at least one</span></span><br><span class="line">            <span class="comment">// child said it wanted to match our width. Set a flag</span></span><br><span class="line">            <span class="comment">// indicating that we need to remeasure at least that view when</span></span><br><span class="line">            <span class="comment">// we know our width.</span></span><br><span class="line">            matchWidth = <span class="literal">true</span>;</span><br><span class="line">            matchWidthLocally = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span> lp.leftMargin + lp.rightMargin;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">        maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line">        childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line"></span><br><span class="line">        allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line">        <span class="keyword">if</span> (lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Widths of weighted Views are bogus if we end up</span></span><br><span class="line"><span class="comment">             * remeasuring, so keep them separate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            weightedMaxWidth = Math.max(weightedMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += getChildrenSkipCount(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 底部是否有分割线，计算最高高度</span></span><br><span class="line">    <span class="keyword">if</span> (nonSkippedChildCount &gt; <span class="number">0</span> &amp;&amp; hasDividerBeforeChildAt(count)) &#123;</span><br><span class="line">        mTotalLength += mDividerHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">            (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置了 measureWithLargestChild 且 总高度无法确定，需要重新计算 mToatalLength</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 添加padding</span></span><br><span class="line">                mTotalLength += measureNullChild(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LinearLayout.LayoutParams)</span><br><span class="line">                    child.getLayoutParams();</span><br><span class="line">            <span class="comment">// Account for negative margins</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add in our padding</span></span><br><span class="line">    mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSize</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查最小高度</span></span><br><span class="line">    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据heightMeasureSpec计算最后结果，heightSizeAndState存储最终的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heightSizeAndState</span> <span class="operator">=</span> resolveSizeAndState(heightSize, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;</span><br><span class="line">    <span class="comment">// Either expand children with weight to take up available space or</span></span><br><span class="line">    <span class="comment">// shrink them if they extend beyond our current bounds. If we skipped</span></span><br><span class="line">    <span class="comment">// measurement on any children, we need to measure them now.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainingExcess</span> <span class="operator">=</span> heightSize - mTotalLength</span><br><span class="line">            + (mAllowInconsistentMeasurement ? <span class="number">0</span> : consumedExcessSpace);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 简单来说就是 skippedMeasure为true说明之前的测量被跳过了需要重新测量</span></span><br><span class="line">  	<span class="comment">// 或者使用了Weight属性 要启动二次测量</span></span><br><span class="line">    <span class="keyword">if</span> (skippedMeasure</span><br><span class="line">            || ((sRemeasureWeightedChildren || remainingExcess != <span class="number">0</span>) &amp;&amp; totalWeight &gt; <span class="number">0.0f</span>)) &#123;</span><br><span class="line">      	<span class="comment">// 计算总的weight，mWidgetSum是外部设定，totalWeight是首次计算出来的</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">remainingWeightSum</span> <span class="operator">=</span> mWeightSum &gt; <span class="number">0.0f</span> ? mWeightSum : totalWeight;</span><br><span class="line"></span><br><span class="line">        mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">float</span> <span class="variable">childWeight</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">            <span class="keyword">if</span> (childWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 计算分配的值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">share</span> <span class="operator">=</span> (<span class="type">int</span>) (childWeight * remainingExcess / remainingWeightSum);</span><br><span class="line">              	<span class="comment">// 剩余分配高度</span></span><br><span class="line">                remainingExcess -= share;</span><br><span class="line">              	<span class="comment">// 剩余比重总和</span></span><br><span class="line">                remainingWeightSum -= childWeight;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> childHeight;</span><br><span class="line">                <span class="keyword">if</span> (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                  	<span class="comment">// 子View直接是largestChildHeight</span></span><br><span class="line">                    childHeight = largestChildHeight;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lp.height == <span class="number">0</span> &amp;&amp; (!mAllowInconsistentMeasurement</span><br><span class="line">                        || heightMode == MeasureSpec.EXACTLY)) &#123;</span><br><span class="line">                    <span class="comment">// 子view是没有height，直接为分配高度</span></span><br><span class="line">                    childHeight = share;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 子View有height，另外还要加上分配的高度</span></span><br><span class="line">                    childHeight = child.getMeasuredHeight() + share;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childHeightMeasureSpec</span> <span class="operator">=</span> MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        Math.max(<span class="number">0</span>, childHeight), MeasureSpec.EXACTLY);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childWidthMeasureSpec</span> <span class="operator">=</span> getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">              	<span class="comment">// 重新测量子View</span></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Child may now not fit in vertical dimension.</span></span><br><span class="line">                childState = combineMeasuredStates(childState, child.getMeasuredState()</span><br><span class="line">                        &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">margin</span> <span class="operator">=</span>  lp.leftMargin + lp.rightMargin;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">measuredWidth</span> <span class="operator">=</span> child.getMeasuredWidth() + margin;</span><br><span class="line">          	<span class="comment">// 计算子View的最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth, measuredWidth);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">matchWidthLocally</span> <span class="operator">=</span> widthMode != MeasureSpec.EXACTLY &amp;&amp;</span><br><span class="line">                    lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                    matchWidthLocally ? margin : measuredWidth);</span><br><span class="line"></span><br><span class="line">            allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> mTotalLength;</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +</span><br><span class="line">                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add in our padding</span></span><br><span class="line">        mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Should we recompute the heightSpec based on the new total length?</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alternativeMaxWidth = Math.max(alternativeMaxWidth,</span><br><span class="line">                                       weightedMaxWidth);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We have no limit, so make all weighted views as tall as the largest child.</span></span><br><span class="line">        <span class="comment">// Children will have already been measured once.</span></span><br><span class="line">        <span class="keyword">if</span> (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getVirtualChildAt(i);</span><br><span class="line">                <span class="keyword">if</span> (child == <span class="literal">null</span> || child.getVisibility() == View.GONE) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span></span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> <span class="variable">childExtra</span> <span class="operator">=</span> lp.weight;</span><br><span class="line">                <span class="keyword">if</span> (childExtra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    child.measure(</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),</span><br><span class="line">                                    MeasureSpec.EXACTLY),</span><br><span class="line">                            MeasureSpec.makeMeasureSpec(largestChildHeight,</span><br><span class="line">                                    MeasureSpec.EXACTLY));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        maxWidth = alternativeMaxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum width</span></span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            heightSizeAndState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">        forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>LinearLayout的onMeasure中的child.measure启动了TextView的onMeasure():</p>
<p>源码就不展示了，大概就是根据传入的获取MeasureSpec计算自己的宽度和高度，然后通过setMeasuredDimension方法将获取的值赋值给mMeasuredWidth和mMeasuredHeight。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimensionRaw</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        mMeasuredWidth = measuredWidth;</span><br><span class="line">        mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个值就是layout进行定位的值。</p>
<h3 id="Layout过程"><a href="#Layout过程" class="headerlink" title="Layout过程"></a>Layout过程</h3><p>回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>

<p>measure执行完之后就该执行layout了，mView.getMeasuredWidth()和mView.getMeasuredHeight()就是上个阶段计算得到的值。</p>
<p>还是先看FrameLayout的layout干了啥</p>
<p>FrameLayout没有自己实现layout函数，得看ViewGroup里的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="literal">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mTransition != <span class="literal">null</span>) &#123;</span><br><span class="line">              mTransition.layoutChange(<span class="built_in">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">super</span>.layout(l, t, r, b);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// record the fact that we noop&#x27;d it; request layout when transition finishes</span></span><br><span class="line">          mLayoutCalledWhileSuppressed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>发现没啥东西，还是得看super.layout(l, t, r, b);的实现，也就是View中的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      .....</span><br><span class="line">     <span class="comment">//设置View位于父视图的坐标轴  主要是初始化了四个值  mLeft  mTop  mRight mBottom</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> setFrame(l, t, r, b); </span><br><span class="line">      <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">      <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">              ViewDebug.trace(<span class="built_in">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">          onLayout(changed, l, t, r, b);</span><br><span class="line">          mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line">      mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在View中onLayout是空实现，所以回到FrameLayout中看具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, <span class="literal">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">layoutChildren</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, <span class="type">boolean</span> forceLeftGravity)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getChildCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentLeft</span> <span class="operator">=</span> getPaddingLeftWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentRight</span> <span class="operator">=</span> right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentTop</span> <span class="operator">=</span> getPaddingTopWithForeground();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">parentBottom</span> <span class="operator">=</span> bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> childLeft;</span><br><span class="line">                <span class="type">int</span> childTop;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">gravity</span> <span class="operator">=</span> lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                    gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">layoutDirection</span> <span class="operator">=</span> getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">absoluteGravity</span> <span class="operator">=</span> Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">verticalGravity</span> <span class="operator">=</span> gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                        <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                        childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        childTop = parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// layout(int l, int t, int r, int b)</span></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就是根据规则获取了child的childLeft和childTop,然后启动child的layout函数。</p>
<p>这里看一下view的坐标系</p>
<img src="https://raw.githubusercontent.com/zrmomo/images/main/image/cc5c57e82f5346e0ad194f914edd0e5d%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp" alt="image.png" style="zoom: 50%;" />

<p>left和top坐标确定了view左上角的位置，right和bottom坐标确定了右下角的位置。</p>
<p>right - left 为view的宽(width)  bottom - top 为view的高(height)。</p>
<p>Layout流程就这些没啥好说的。</p>
<h3 id="Draw过程"><a href="#Draw过程" class="headerlink" title="Draw过程"></a>Draw过程</h3><p>再回到performTraversals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mView 是DecorView</span></span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br></pre></td></tr></table></figure>

<p>FrameLayout和ViewGroup都没有重写draw方法，所以我们看下View中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="meta">@NonNull</span> Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">privateFlags</span> <span class="operator">=</span> mPrivateFlags;</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas&#x27; layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view&#x27;s content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         *      7. If necessary, draw the default focus highlight</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="type">int</span> saveCount;</span><br><span class="line">				<span class="comment">// 绘制背景</span></span><br><span class="line">        drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">horizontalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">verticalEdges</span> <span class="operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAutofilledHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlay != <span class="literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7, draw the default focus highlight</span></span><br><span class="line">            drawDefaultFocusHighlight(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShowingLayoutBounds()) &#123;</span><br><span class="line">                debugDrawFocus(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we&#x27;re done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程用这张图片概括一下，循环的入口是draw方法。</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/webp-20231215160503207" alt="img"></p>
<h1 id="Android-View事件分发"><a href="#Android-View事件分发" class="headerlink" title="Android View事件分发"></a>Android View事件分发</h1><h2 id="分发的事件是什么"><a href="#分发的事件是什么" class="headerlink" title="分发的事件是什么"></a>分发的事件是什么</h2><p>我们对屏幕的点击，滑动，抬起等一系的动作都是由一个一个MotionEvent对象组成的。根据不同动作，主要有以下三种事件类型：<br>1.ACTION_DOWN：<strong>手指刚接触屏幕，按下去的那一瞬间产生该事件</strong><br>2.ACTION_MOVE：<strong>手指在屏幕上移动时候产生该事件</strong><br>3.ACTION_UP：<strong>手指从屏幕上松开的瞬间产生该事件</strong></p>
<p><strong>从ACTION_DOWN开始到ACTION_UP结束我们称为一个事件序列</strong></p>
<p>正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在MotionEvent上来讲无外乎下面两种。<br><strong>1.点击后抬起，也就是单击操作：ACTION_DOWN -&gt; ACTION_UP<br>2.点击后再风骚的滑动一段距离，再抬起：ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP</strong></p>
<h2 id="MotionEvent事件分发的三个方法"><a href="#MotionEvent事件分发的三个方法" class="headerlink" title="MotionEvent事件分发的三个方法"></a>MotionEvent事件分发的三个方法</h2><ul>
<li><p><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong><br>通过方法名我们不难猜测，它就是事件分发的重要方法。那么很明显，如果一个MotionEvent传递给了View，那么dispatchTouchEvent方法一定会被调用！<br>返回值：表示是否消费了当前事件。可能是View本身的onTouchEvent方法消费，也可能是子View的dispatchTouchEvent方法中消费。返回true表示事件被消费，本次的事件终止。返回false表示View以及子View均没有消费事件，将调用父View的onTouchEvent方法</p>
</li>
<li><p><strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong><br>事件拦截，当一个ViewGroup在接到MotionEvent事件序列时候，首先会调用此方法判断是否需要拦截。特别注意，这是ViewGroup特有的方法，View并没有拦截方法<br>返回值：是否拦截事件传递，返回true表示拦截了事件，那么事件将不再向下分发而是调用View本身的onTouchEvent方法。返回false表示不做拦截，事件将向下分发到子View的dispatchTouchEvent方法。</p>
</li>
<li><p><strong>public boolean onTouchEvent(MotionEvent ev)</strong><br>真正对MotionEvent进行处理或者说消费的方法。在dispatchTouchEvent进行调用。<br>返回值：返回true表示事件被消费，本次的事件终止。返回false表示事件没有被消费，将调用父View的onTouchEvent方法</p>
</li>
</ul>
<p>上面的三个方法可以用以下的伪代码来表示其之间的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//事件是否被消费</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev))&#123;<span class="comment">//调用onInterceptTouchEvent判断是否拦截事件</span></span><br><span class="line">        consume = onTouchEvent(ev);<span class="comment">//如果拦截则调用自身的onTouchEvent方法</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);<span class="comment">//不拦截调用子View的dispatchTouchEvent方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;<span class="comment">//返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件分发的具体流程"><a href="#事件分发的具体流程" class="headerlink" title="事件分发的具体流程"></a>事件分发的具体流程</h2><p>点击事件产生最先传递到当前的Activity，由Acivity的dispatchTouchEvent方法来对事件进行分发。那么很明显我们先看Activity的dispatchTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Activity：</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getWindow().superDispatchTouchEvent(ev)方法发现是Window类当中的一个抽象方法，Window的唯一实现类是PhoneWindow。那么去看PhoneWindow对应的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneWindow</span></span><br><span class="line">    <span class="comment">// This is the top-level view of the window, containing the window decor.</span></span><br><span class="line">    <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个DecorView就是Window的顶级View，我们通过setContentView设置的View是它的子View，</strong>到这里事件已经被传递到我们的顶级View中，一般是ViewGroup。</p>
<p>看看ViewGroup的dispatchTouchEvent方法实现，代码比较多先看下判断是否拦截事件的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">		   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> ev.getAction();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">actionMasked</span> <span class="operator">=</span> action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// 在开始新的触摸手势时，丢弃所有以前的状态。由于应用切换、ANR 或其他一些状态更改，框架可能已删除上一个手势的 up 或 cancel 事件。</span></span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里会执行 mFirstTouchTarget = null;  mFirstTouchTarget是用来承载处理事件的子View对象，这个对象非常重要，它决定了ViewGroup是否拦截事件</span></span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否拦截事件的标志位</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line">    	   <span class="comment">// 判断是否是ACTION_DOWN事件和mFirstTouchTarget是否为null，如果是ACTION_DOWN事件说明是一个新的事件或者mFirstTouchTarget不为null说明有处理事件的子View，会然后会判断子view是否调用了requestDisallowInterceptTouchEvent方法来禁止ViewGroup拦截，判断通过后会调用onInterceptTouchEvent方法来判断最终是否拦截</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                    <span class="comment">// 具体实现看下面的代码</span></span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果既不是ACTION_DOWN事件，mFirstTouchTarget==null，说明之前已经拦截ACTION_DOWN事件所以这里直接判定拦截，如果没拦截的话mFirstTouchTarget不会为null。</span></span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查触摸事件是否来自鼠标设备</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            <span class="comment">// 检查触摸事件的动作是否为按下（ACTION_DOWN）</span></span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            <span class="comment">// 检查是否按下了主要的鼠标按钮</span></span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            <span class="comment">// 调用isOnScrollbarThumb方法检查是否在滚动条拇指上</span></span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getXDispatchLocation(<span class="number">0</span>), ev.getYDispatchLocation(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="comment">// 如果上述条件都为真，表示需要拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上述条件有一个为假，表示不需要拦截该事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下上面的代码，通过判断actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN和 mFirstTouchTarget !&#x3D; null判断是否拦截，这里有一点要注意的是，根据逻辑 <strong>如果ViewGroup没有拦截ACTION_DOWN事件的话说明这组事件会有子view处理，所以mFirstTouchTarget 不会为null。否则的话mFirstTouchTarget 为null且不是ACTION_DOWN事件说明之前拦截了ACTION_DOWN事件，则后面的事件直接拦截。</strong></p>
<p><strong>mFirstTouchTarget 是否有值决定了ViewGroup是否拦截ACTION_DOWN以外的事件</strong></p>
<p>假设这里不拦截的话，看后续的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">        <span class="comment">//对子View进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> getAndVerifyPreorderedIndex(</span><br><span class="line">                    childrenCount, i, customOrder);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getAndVerifyPreorderedView(</span><br><span class="line">                    preorderedList, children, childIndex);</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childWithAccessibilityFocus = <span class="literal">null</span>;</span><br><span class="line">                i = childrenCount - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断1，View可见并且没有播放动画。2，点击事件的坐标落在View的范围内</span></span><br><span class="line">            <span class="comment">//如果上述两个条件有一项不满足则continue继续循环下一个View</span></span><br><span class="line">            <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="literal">null</span>)) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 走到这里说明找到了满足的子View了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里会判断mFirstTouchTarget，因为目前还未将事件传递给子view所以还是null 返回的也会是null</span></span><br><span class="line">            newTouchTarget = getTouchTarget(child);</span><br><span class="line">            <span class="comment">//如果有子View处理即newTouchTarget 不为null则跳出循环。</span></span><br><span class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">                newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resetCancelNextUpFlag(child);</span><br><span class="line">            <span class="comment">//dispatchTransformedTouchEvent第三个参数child这里不为null，实际调用的是child的dispatchTouchEvent方法，具体实现可以看下面。 重点方法</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                <span class="keyword">if</span> (preorderedList != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                            mLastTouchDownIndex = j;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mLastTouchDownIndex = childIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastTouchDownX = ev.getX();</span><br><span class="line">                mLastTouchDownY = ev.getY();</span><br><span class="line">                <span class="comment">//当child处理了点击事件，那么会设置mFirstTouchTarget 在addTouchTarget被赋值，具体实现看下面</span></span><br><span class="line">                newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//子View处理了事件，然后就跳出了for循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     ......</span><br><span class="line">         <span class="comment">// 如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false） </span></span><br><span class="line">         <span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">                handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="type">boolean</span> cancel,</span></span><br><span class="line"><span class="params">        View child, <span class="type">int</span> desiredPointerIdBits)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldAction</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true，子View为GroupView的话会重复上面的逻辑，不是的话会直接走View的dispatchTouchEvent方法。</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(<span class="meta">@NonNull</span> View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">        target.next = mFirstTouchTarget;</span><br><span class="line">     	<span class="comment">// 这里给mFirstTouchTarget赋值了，也就是上面说的是否处理了事件看mFirstTouchTarget是否为null</span></span><br><span class="line">        mFirstTouchTarget = target;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示ViewGroup进行事件传递的逻辑，在dispatchTransformedTouchEvent中会判断子View是否消费了事件，如果消费了会给mFirstTouchTarget赋值否则mFirstTouchTarget仍为null。</p>
<p>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）。会再次调用dispatchTransformedTouchEvent方法，且传入得child为null。</p>
<p>逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">           handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">           handled = child.dispatchTouchEvent(event);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>目前为止ViewGroup的事件处理逻辑分析完了。</p>
<p><strong>结论</strong>：</p>
<blockquote>
<p><strong>ViewGroup会遍历所有子View去寻找能够处理点击事件的子View（可见，没有播放动画，点击事件坐标落在子View内部）最终调用子View的dispatchTouchEvent方法处理事件</strong></p>
</blockquote>
<blockquote>
<p><strong>当子View处理了事件则mFirstTouchTarget 被赋值，并终止子View的遍历。</strong></p>
</blockquote>
<blockquote>
<p><strong>如果ViewGroup并没有子View或者子View处理了事件，但是子View的dispatchTouchEvent返回了false（一般是子View的onTouchEvent方法返回false）那么ViewGroup会去处理这个事件（本质调用View的dispatchTouchEvent去处理）</strong></p>
</blockquote>
<p>如果ViewGrop处理这个事件的话会调用View的dispatchTouchEvent。如果不是ViewGroup处理事件，而是普通的View处理事件的话会直接调用View的dispatchTouchEvent方法。</p>
<p>所以最终都会走到View的dispatchTouchEvent方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    	<span class="comment">//如果窗口没有被遮盖</span></span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            <span class="comment">//当前监听事件</span></span><br><span class="line">            <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">            <span class="comment">//需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件,如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</span></span><br><span class="line">            <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//result为false调用自己的onTouchEvent方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View会先判断是否设置了OnTouchListener，<strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong> <strong>且当前View的dispatchTouchEvent方法就会返回false。</strong><br>当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">viewFlags</span> <span class="operator">=</span> mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">//1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件</span></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    ... </span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">prepressed</span> <span class="operator">=</span> (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">focusTaken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                            setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> <span class="title class_">PerformClick</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    <span class="comment">//3.在ACTION_UP方法发生时会触发performClick()方法</span></span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的<strong>View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）</strong></p>
<p><strong>View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。</strong></p>
<p>加一个知识点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">            setClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">            setLongClickable(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>View的setOnClickListener会默认将View的clickable设置成true。<br>View的setOnLongClickListener同样会将View的longClickable设置成true。</strong></p>
<p><strong>如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。</strong>这里的View的dispatchTouchEvent就会返回false，也就是dispatchTransformedTouchEvent方法会返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里又调用了View的dispatchTouchEvent方法</span></span><br><span class="line">            handled = <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里调用了子View的dispatchTouchEvent方法,如果消耗了事件会返回true</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的<strong>dispatchTouchEvent是View嵌套调用的</strong>，所以最终的结果会由View层回调到Window层中，看一下原来的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># PhoneWindow</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值又会返回到Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<span class="comment">//事件分发并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//事件被消费</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);<span class="comment">//没有View可以处理，调用Activity onTouchEvent方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到此一个事件循环结束了循环</p>
<p>面试回答的时候为了逻辑清晰，可以定义一个只有一个ViewGroup和View的传递链</p>
<p>Activity - Window - GroupView - View</p>
<p>事件由Activity 开始传递，依次到Window 然后到了GroupView 再到View，事件传递主要的逻辑就是GroupView层和 View层，</p>
<p>首先事件会走到Activity 的dispatchTouchEvent方法，里面会调用Window的superDispatchTouchEvent方法去处理事件。</p>
<p>如果Window没有处理了事件会调用Activity的onTouchEvent方法去消费事件。再Window传递到ViewGroup和ViewGroup传递到View的过程中同样如此，会尝试调用自己的onTouchEvent方法去消费事件。</p>
<p>回单原来的逻辑，目前事件传递到了Window层，Window的superDispatchTouchEvent方法中会调用DecorView的事件分发方法。DecorView就是个FrameLayout，所以事件到了Viewgroup层。</p>
<p>Viewgroup的dispatchTouchEvent方法的逻辑，首先逻辑开始会判断要不要拦截当前事件，判断是否拦截会有两个判断条件。一个是当前的action事件是否为down事件，还有一个就是子View是否处理了事件的标志位。</p>
<p>这里如果是down事件或者标志位不等于null就会调用onInterceptTouchEvent方法判断是否拦截。这里调用onInterceptTouchEvent之前还会有一个标志位的判断，这个标志位是子View通过requestDisallowInterceptTouchEvent来通知父View的。</p>
<p>如果不是down事件且子View是否处理了事件的标志位为null说明之前的down事件被ViewGroup拦截了，所以后面move和up事件都会被拦截。</p>
<p>如果判断不拦截的话就会调用子View的dispatchTouchEvent方法，也就是View类中定义的逻辑。</p>
<p>这个方法首先会判断当前View是否设置了OnTouchListener监听，如果设置了监听且onTouch方法返回了true，那么onTouchEvent不会被调用。如果返回false的话会接着调用onTouchEvent方法。</p>
<p>这个方法会判断clickable和longClickable，只要有一个是true就会消费事件，然后会通过switch case判断事件的类型，再up case中会调用当前view设置的点击事件。</p>
<p>目前一整个事件传递从activity到view消费的这么一个逻辑，其实主要还是再Viewgroup和View传递的逻辑。之前说了View 消费的情况，我下面说一下View不消费的情况。</p>
<p>View不消费的话ViewGroup同样会走View类的dispatchTouchEvent方法的逻辑，然后调用onTouchEvent方法。如果onTouchEvent方法返回false的话事件会返回到Window层然后再返回到Activity层，也就是一开始说的逻辑，会调用activity的onTouchEvent方法。</p>
<h1 id="Android自定义View"><a href="#Android自定义View" class="headerlink" title="Android自定义View"></a>Android自定义View</h1><h2 id="自定义-View实现方式"><a href="#自定义-View实现方式" class="headerlink" title="自定义 View实现方式"></a>自定义 View实现方式</h2><p>总结下来有三种：</p>
<ul>
<li>继承某个控件，然后对它的一些功能进行修改，或者删除添加</li>
<li>将多个控件组合在一起形成一个新的View</li>
<li>继承 View &#x2F; ViewGroup 类，重写 <strong><code>onMeasure()</code><strong>、</strong><code>onLayout()</code><strong>、</strong><code>onDraw()</code></strong> 三大方法，从 0 到 1 创造一个新的控件。</li>
</ul>
<p>代码示例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaterialEdit</span>(context: Context,attrs:AttributeSet) :</span><br><span class="line">    AppCompatEditText(context,attrs) &#123; <span class="comment">// 定义一个名为 MaterialEdit 的类，继承自 AppCompatEditText</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一些常量和变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_SIZE = <span class="number">12.</span>dp  <span class="comment">// 文本大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TEXT_MARGIN = <span class="number">8.</span>dp <span class="comment">// 文本边距</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> HORIZONTAL_OFFSET = <span class="number">5.</span>dp <span class="comment">// 水平偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> VERTICAL_OFFSET = <span class="number">23.</span>dp <span class="comment">// 垂直偏移量  浮动标签距离view顶部的向下偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> EXTRA_VERTICAL_OFFSET = <span class="number">16.</span>dp <span class="comment">// 便签动画时的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG) <span class="comment">// 创建一个 Paint 对象，用于绘制文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> floatingLabelShown = <span class="literal">false</span> <span class="comment">// 一个标志，表示浮动标签是否正在显示</span></span><br><span class="line">    <span class="keyword">var</span> useFloatingLabel = <span class="literal">false</span> <span class="comment">// 一个标志，表示是否使用浮动标签</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field != value) &#123;</span><br><span class="line">                field = value</span><br><span class="line">                <span class="keyword">if</span> (field) &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop + TEXT_SIZE + TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setPadding(</span><br><span class="line">                        paddingLeft,</span><br><span class="line">                        (paddingTop - TEXT_SIZE - TEXT_MARGIN).toInt(),</span><br><span class="line">                        paddingRight,</span><br><span class="line">                        paddingBottom</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">            <span class="keyword">by</span> lazy &#123;</span><br><span class="line">                ObjectAnimator.ofFloat(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                    <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码块</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        paint.textSize = TEXT_SIZE <span class="comment">// 设置 Paint 的文本大小</span></span><br><span class="line">        <span class="comment">// 获取自定义属性 useFloatingLabel 的值  会触发 set 方法</span></span><br><span class="line">        <span class="keyword">val</span> typeArray = context.obtainStyledAttributes(attrs,R.styleable.MaterialEdit)</span><br><span class="line">        useFloatingLabel = typeArray.getBoolean(R.styleable.MaterialEdit_useFloatingLabel,<span class="literal">true</span>)</span><br><span class="line">        typeArray.recycle() <span class="comment">// 回收 typeArray</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 EditText 中的文本改变时，执行这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTextChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        text: <span class="type">CharSequence</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        start: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthBefore: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        lengthAfter: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮动标签正在显示，且文本变为空，那么隐藏浮动标签</span></span><br><span class="line">        <span class="keyword">if</span> (floatingLabelShown &amp;&amp; text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">false</span></span><br><span class="line">            animator.reverse() <span class="comment">// 执行动画的逆向操作，即隐藏浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果浮动标签没有显示，且文本不为空，那么显示浮动标签</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!floatingLabelShown &amp;&amp; !text.isNullOrEmpty()) &#123;</span><br><span class="line">            floatingLabelShown = <span class="literal">true</span></span><br><span class="line">            animator.start() <span class="comment">// 开始执行动画，即显示浮动标签</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个方法中绘制 EditText 的界面</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas) <span class="comment">// 调用父类的 onDraw 方法，绘制 EditText 的主体</span></span><br><span class="line">        paint.alpha = (floatingLabelFraction * <span class="number">0xff</span>).toInt() <span class="comment">// 根据动画的进度，设置 Paint 的透明度</span></span><br><span class="line">        <span class="comment">// 计算当前的垂直位置</span></span><br><span class="line">        <span class="keyword">val</span> currentVerticalValue =</span><br><span class="line">            VERTICAL_OFFSET + EXTRA_VERTICAL_OFFSET * (<span class="number">1</span> - floatingLabelFraction)</span><br><span class="line">        <span class="comment">// 在计算出的位置绘制提示文本</span></span><br><span class="line">        hint?.toString()?.let &#123;</span><br><span class="line">            canvas.drawText(</span><br><span class="line">                it,</span><br><span class="line">                HORIZONTAL_OFFSET,</span><br><span class="line">                currentVerticalValue,</span><br><span class="line">                paint</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Android-动画"><a href="#Android-动画" class="headerlink" title="Android 动画"></a>Android 动画</h1><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p><strong>帧动画（Frame Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br><span class="line">val frameAnimation = imageView.background as AnimationDrawable</span><br><span class="line">frameAnimation.start()</span><br></pre></td></tr></table></figure>

<p><strong>补间动画（Tween Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br><span class="line">val rotateAnimation = AnimationUtils.loadAnimation(context, R.anim.rotate)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p><strong>属性动画（Property Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">2000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure>

<p><strong>过渡动画（Transition Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sceneRoot: ViewGroup = findViewById(R.id.scene_root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> scene1: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene1, context)</span><br><span class="line"><span class="keyword">val</span> scene2: Scene = Scene.getSceneForLayout(sceneRoot, R.layout.scene2, context)</span><br><span class="line"></span><br><span class="line">TransitionManager.go(scene2, TransitionInflater.from(context).inflateTransition(R.transition.example_transition))</span><br></pre></td></tr></table></figure>

<p><strong>触摸反馈动画（Touch Feedback Animation）</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义触摸反馈动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ripple</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:color</span>=<span class="string">&quot;?android:attr/colorControlHighlight&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/mask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">&quot;@android:color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/button_normal&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ripple</span>&gt;</span></span><br><span class="line">button.background = ContextCompat.getDrawable(context, R.drawable.ripple)</span><br></pre></td></tr></table></figure>

<p><strong>物理动画（Physics-based Animation）</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> springAnimation = SpringAnimation(imageView, DynamicAnimation.ROTATION, <span class="number">0f</span>)</span><br><span class="line">springAnimation.spring.stiffness = SpringForce.STIFFNESS_LOW</span><br><span class="line">springAnimation.spring.dampingRatio = SpringForce.DAMPING_RATIO_HIGH_BOUNCY</span><br><span class="line">springAnimation.start()</span><br></pre></td></tr></table></figure>

<h2 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/drawable目录下创建一个XML文件，定义帧动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/frame3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">   imageView.setBackgroundResource(R.drawable.animation)</span><br><span class="line">   <span class="keyword">val</span> animationDrawable = imageView.background <span class="keyword">as</span> AnimationDrawable</span><br><span class="line">   animationDrawable.start()</span><br></pre></td></tr></table></figure>

<h2 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h2><p>资源文件定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在res/anim目录下创建一个XML文件，定义补间动画 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">&quot;360&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>xml定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.ani)</span><br><span class="line">imageView.startAnimation(rotateAnimation)</span><br></pre></td></tr></table></figure>

<p>补间动画的属性</p>
<p>补间动画（Tween Animation）在 Android 中主要包括四种类型：AlphaAnimation、ScaleAnimation、TranslateAnimation 和 RotateAnimation，它们分别对应透明度、缩放、位移和旋转四种动画效果。</p>
<p>以下是这四种补间动画的主要属性：</p>
<ol>
<li><strong>AlphaAnimation（透明度动画）</strong>：<ul>
<li>fromAlpha：动画开始时视图的透明度（0.0 - 1.0）</li>
<li>toAlpha：动画结束时视图的透明度（0.0 - 1.0）</li>
</ul>
</li>
<li><strong>ScaleAnimation（缩放动画）</strong>：<ul>
<li>fromXScale：动画开始时视图的X轴缩放比例</li>
<li>toXScale：动画结束时视图的X轴缩放比例</li>
<li>fromYScale：动画开始时视图的Y轴缩放比例</li>
<li>toYScale：动画结束时视图的Y轴缩放比例</li>
<li>pivotX：X轴的缩放中心点</li>
<li>pivotY：Y轴的缩放中心点</li>
</ul>
</li>
<li><strong>TranslateAnimation（位移动画）</strong>：<ul>
<li>fromXDelta：动画开始时视图在X轴的位置</li>
<li>toXDelta：动画结束时视图在X轴的位置</li>
<li>fromYDelta：动画开始时视图在Y轴的位置</li>
<li>toYDelta：动画结束时视图在Y轴的位置</li>
</ul>
</li>
<li><strong>RotateAnimation（旋转动画）</strong>：<ul>
<li>fromDegrees：动画开始时视图的旋转角度</li>
<li>toDegrees：动画结束时视图的旋转角度</li>
<li>pivotX：旋转的中心点X坐标</li>
<li>pivotY：旋转的中心点Y坐标</li>
</ul>
</li>
</ol>
<p>以上每种动画类型的属性都可以在 XML 中定义，也可以在代码中动态设置。除了这些特定的属性外，所有的补间动画还有一些共同的属性，例如：</p>
<ul>
<li>duration：动画的持续时间</li>
<li>fillAfter：动画结束后，视图是否保持动画结束时的状态</li>
<li>fillBefore：动画开始前，视图是否保持动画开始时的状态</li>
<li>repeatCount：动画的重复次数</li>
<li>repeatMode：动画的重复模式（重新开始或反向执行）</li>
<li>interpolator：动画的插值器（用于控制动画的速度变化）</li>
</ul>
<p>区域问题</p>
<p>补间动画虽然能对控件做动画 ，但是并没有改变控件内 部 的属性值 。也就是说只是做了动画，它的位置属性啥的都没有变。</p>
<h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><p>补问动画和逐帧动画统称为视图动画 ，从字面意思 中可以看 出，这两个动画只能对派生自 View 类的控件实例起作用； 而属性动画则不同，从名字 中可以看出它应该是作用于控件属性的 。<strong>正因为属性动画 能够只针对控件的某一个属性来做动画，所以造就了它能单独改变控件某一个属性的值 ，比如颜色 。</strong></p>
<p>属性动画分为ValueAnimator 和 ObjectAnimator 。</p>
<h3 id="ValueAnimator-："><a href="#ValueAnimator-：" class="headerlink" title="ValueAnimator ："></a><strong>ValueAnimator</strong> ：</h3><p>简单使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">   animator.setDuration(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 在这里监听</span></span><br><span class="line">   animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">       <span class="comment">// 可以在这里根据value值对View进行操作</span></span><br><span class="line">       <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">       loge(<span class="string">&quot;value: <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   animator.start()</span><br></pre></td></tr></table></figure>

<p>比如用来移动View</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">		<span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> value: <span class="built_in">Int</span> = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(value, value, value + imageView.width, value + imageView.height)</span><br><span class="line">        &#125;</span><br><span class="line">	    animator.addListener(<span class="keyword">object</span> : Animator.AnimatorListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationStart</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationStart&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationEnd</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationEnd&quot;</span>)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationCancel</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationCancel&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAnimationRepeat</span><span class="params">(animation: <span class="type">Animator</span>)</span></span> &#123;</span><br><span class="line">                loge(<span class="string">&quot;onAnimationRepeat&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">        animator.start()</span><br><span class="line">	    <span class="comment">//无限次重复的动画必须得在合适的时机cancel</span></span><br><span class="line">        animator.cancel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>View就会沿着从左上角到右下角的对角线进行移动。1秒钟完成动画，然后无限次的重复动画。</p>
<h3 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">animator.interpolator = AccelerateDecelerateInterpolator()</span><br></pre></td></tr></table></figure>

<p>Android SDK 提供了多种内置的插值器：</p>
<ol>
<li><code>LinearInterpolator</code>: 时间和动画进度之间是线性关系，也就是匀速运动。</li>
<li><code>AccelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐加快。</li>
<li><code>DecelerateInterpolator</code>: 随着时间的推移，动画的速度会逐渐减慢。</li>
<li><code>AccelerateDecelerateInterpolator</code>: 动画开始时速度逐渐加快，然后在结束时速度逐渐减慢。</li>
<li><code>AnticipateInterpolator</code>: 开始时，先向相反方向改变一段距离，然后再沿正常方向开始动画。</li>
<li><code>OvershootInterpolator</code>: 动画结束时，会超出目标值一些，然后再弹回来。</li>
<li><code>AnticipateOvershootInterpolator</code>: 开始时向相反方向改变，结束时超出目标值，然后再弹回。</li>
<li><code>BounceInterpolator</code>: 动画结束时，会像弹球一样多次弹跳。</li>
<li><code>CycleInterpolator</code>: 动画会循环指定的次数，每次循环都包括一个正向和一个反向的动画。</li>
<li><code>FastOutSlowInInterpolator</code>: 开始时快速，然后慢慢减速。</li>
</ol>
<h3 id="自定义插值器"><a href="#自定义插值器" class="headerlink" title="自定义插值器"></a>自定义插值器</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">100</span>, <span class="number">400</span>)</span><br><span class="line">    animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">        <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Float</span></span><br><span class="line">        loge(currentValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里currentValue的计算公式为，比如都到了全程的百分二十</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">currentValue = 100 + (400 -100)x 0.2</span><br></pre></td></tr></table></figure>

<p>这个0.2也就是进度值时插值器里的getinterpolatio方法返回的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getInterpolation</span><span class="params">(<span class="type">float</span> input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float</span>)(Math.cos((input + <span class="number">1</span>) * Math.PI) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>input 参数与任何我们设定的值没有关系，只与时间有关 ，随着时间的推移，动画的进度也自然地增加，input 参数就代表了当前动画的进度，而返回值则表示动画的当前数值进度。</p>
<p>Linearlnterpolator插值器中就直接返回了input</p>
<p>所以自定义插值器只需要实现TimeInterpolator 接口然后自定义getInterpolation方法的返回值就可以了。</p>
<h3 id="Evaluator估值器"><a href="#Evaluator估值器" class="headerlink" title="Evaluator估值器"></a>Evaluator估值器</h3><p>作用：</p>
<p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/1705668341835.jpg" alt="1705668341835"></p>
<p>我们通过监昕器拿到的是当前动画所对应的具体数值，而不是用小数表示的数值 。 那么必须有一个地方会根据当前的数值进度将其转换为对应的数值，这个地方就是 Evaluator 。Evaluator 用 于将从插值器返回的数值进度转换成对应的数值。</p>
<p>oflnt（）和ofFloat（）都是系统直接提供的函数 ，所以会有默认的插值器和 Evaluator 可供使用 。</p>
<p>以IntEvaluator为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">evaluate</span><span class="params">(<span class="type">float</span> fraction, Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startInt</span> <span class="operator">=</span> startValue;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(startInt + fraction * (endValue - startInt));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>(int)(startInt + fraction * (endValue - startInt))</code>就等价于上面的<code>currentValue = 100 + (400 -100)×进度值</code></p>
<p>自定义Evaluator</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReverseEvaluator</span> : <span class="type">android.animation.TypeEvaluator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evaluate</span><span class="params">(fraction: <span class="type">Float</span>, startValue: <span class="type">Int</span>, endValue: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (endValue - fraction * (endValue - startValue)).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">        <span class="keyword">val</span> animator: ValueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">400</span>)</span><br><span class="line">        animator.setDuration(<span class="number">1000</span>)</span><br><span class="line">        <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">        animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">        <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">        animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">        animator.setEvaluator(ReverseEvaluator())</span><br><span class="line">        animator.addUpdateListener &#123; animation -&gt;</span><br><span class="line">            <span class="keyword">val</span> currentValue = animation.animatedValue <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">            imageView.layout(imageView.left, currentValue, imageView.right, currentValue + imageView.height)</span><br><span class="line">            loge(currentValue)</span><br><span class="line">        &#125;</span><br><span class="line">        animator.start()</span><br></pre></td></tr></table></figure>

<p>最终实现了View从下到上也就是从终点到起点的运动。</p>
<h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h3><p><strong>ValueAnimator 有一个缺点 ，就是只能对动画中的数值进行计算 。</strong> 如果想对那个个控件执行操作，就需要监听 ValueAnimator 的动画过程，相比于补间动画要烦琐得多 。所以在 ValueAnimator 的基础上派生了 一个类 ObjectAnimator 。ObjectAnimator 是直接针对属性进行改变。 </p>
<p><strong>简单使用</strong>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imageView = findViewById&lt;ImageView&gt;(R.id.imageView)</span><br><span class="line">    <span class="keyword">val</span> animator = ObjectAnimator.ofFloat(imageView,<span class="string">&quot;alpha&quot;</span>,<span class="number">0f</span>,<span class="number">1f</span>)</span><br><span class="line">    <span class="comment">// 一次的动画时常为2000毫秒</span></span><br><span class="line">    animator.setDuration(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// 设置重复次数为无限次</span></span><br><span class="line">    animator.repeatCount = ValueAnimator.INFINITE</span><br><span class="line">    <span class="comment">// 设置重复模式为重新开始</span></span><br><span class="line">    animator.repeatMode = ValueAnimator.RESTART</span><br><span class="line">    animator.start()</span><br></pre></td></tr></table></figure>

<p>代码设置了imageView的透明度的从0到1的变化动画，ObjectAnimator 做动画，并不是根据控件XML 中的属性来改变的，而是通过指定属性所对应的 set 函数来改变的。View类中定义了alpha的set函数。</p>
<h3 id="ObjectAnimator动画原理"><a href="#ObjectAnimator动画原理" class="headerlink" title="ObjectAnimator动画原理"></a>ObjectAnimator动画原理</h3><p><img src="https://raw.githubusercontent.com/zrmomo/images/main/image/image-20240122162025356.png" alt="image-20240122162025356"></p>
<p>​		在 ObjectAnimator 的动画流程中，先通过插值器产生当前进度的百分比，然后再经过 Evaluator 生成对应百分比所对应的数字值 。 这两步与 ValueAnimator 的动画流程是完全一样的，唯一不同的是最后一步，在 ValueAnimator 中，需要通过添加监昕器来监昕当前的数值；而在 ObjectAnimator 中，则先根据属性值拼装成对应的 set 函数的名 字（ 比如这里的scaleY 的拼装方法就是将属性的第一个字母强制大写后，与 set 拼接，得到 setScaleY ），然后通过反射找到对应控件的setScaleY (float scale Y）函数，井将当前的数值作为setScaleY (floatscaleY）函数的参数传入 。</p>
<p>​		第一，拼接 set 函数的方法。<strong>首先强制将属性的第一个字母大写 ，然后与 set 拼接</strong>，就得到对应的 set 函数的名字。注意，只是强制将属性的第一个字母大写 ，后面的部分是保持不变的 。反过来， 如果我们的函数名为 setScalePointX（），那么在写属性时可以写成 scalePointX 或者 ScalePointX，<strong>即第一个字母大小写随意，但是后面的部分必须与set 函数后面部分的大小写保持一致 。找函数这一步是通过反射来实现的。</strong></p>
<p>​		第二，如何确定函数的参数类型？我们知道了如何找到对应的函数名，那么对应方法中的参数类型如何确定呢？我们在介绍 ValueAnimator 的时候说过，动画过程中产生的数值与构造时传入的值类型是一样的。由于 ObjectAnimator 与 ValueAnimator 在插值器和 Evaluator 这两步是完全一样的，而当前的动画数值是在 Evaluator 这一步产生的，所以 ObjectAnimator 的动画中产生的数值类型与构造时传入的值类型也是一样的。</p>
<p>​		第三，调用set 函数以后怎么办 ？从ObjectAnimator 的动画流程中可以看到，ObjectAnimator 只负责把动画过程中的数值传到对应属性的 s et 函数中就结束了。注意，传给set 函数以后就结束了！set 函数就相当于我们在ValueAnimator 中添加的监听器，set 函数中对控件的操作还是需要由我们自己来写的。</p>
<h3 id="自定义-ObjectAnimator-属性"><a href="#自定义-ObjectAnimator-属性" class="headerlink" title="自定义 ObjectAnimator 属性"></a>自定义 ObjectAnimator 属性</h3><p>在自定义View的时候，可以来自定义一个属性来实现动画的载体。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> floatingLabelFraction = <span class="number">0f</span> <span class="comment">// 一个浮点数，表示浮动标签动画的进度</span></span><br><span class="line">       <span class="keyword">set</span>(value) &#123;</span><br><span class="line">           field = value</span><br><span class="line">           invalidate() <span class="comment">// 每当动画进度改变时，请求重绘界面</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 创建一个 ObjectAnimator 对象，用于执行浮动标签的动画</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> animator: ObjectAnimator</span><br><span class="line">           <span class="keyword">by</span> lazy &#123;</span><br><span class="line">               ObjectAnimator.ofFloat(</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="string">&quot;floatingLabelFraction&quot;</span>,</span><br><span class="line">                   <span class="number">0f</span>, <span class="number">1f</span></span><br><span class="line">               )</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中floatingLabelFraction就是自定义的属性，然后再ofFloat方法中的target设置为this。</p>
<p>当且仅当动画只有一个过渡值时，系统才会调用对应属性的 get 函数来得到动画的初始值。如下面</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(<span class="keyword">this</span>, <span class="string">&quot;floatingLabelFraction&quot;</span>, <span class="number">1f</span> )</span><br></pre></td></tr></table></figure>

<p>当不存在 get函数时，则会取动画参数类型的默认值作为初始值；当无法取得动画参数类型的默认值时，则会直接崩渍。</p>
<h3 id="组合动画AnimatorSet"><a href="#组合动画AnimatorSet" class="headerlink" title="组合动画AnimatorSet"></a>组合动画AnimatorSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">translation</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);  <span class="comment">// 平移动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">rotate</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>);  <span class="comment">// 旋转动画 </span></span><br><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">alpha</span> <span class="operator">=</span> ObjectAnimator.ofFloat(mButton, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);  <span class="comment">// 透明度动画 // 创建组合动画的对象 </span></span><br><span class="line"><span class="type">AnimatorSet</span> <span class="variable">animSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimatorSet</span>();  <span class="comment">// 根据需求组合动画 </span></span><br><span class="line">animSet.play(translation).with(rotate).before(alpha);  </span><br><span class="line">animSet.setDuration(<span class="number">5000</span>);  <span class="comment">//启动动画 </span></span><br><span class="line">animSet.start()</span><br></pre></td></tr></table></figure>

<p>常用的组合方法</p>
<ul>
<li>AnimatorSet.play(Animator anim)   ：播放当前动画</li>
<li>AnimatorSet.after(long delay)   ：将现有动画延迟x毫秒后执行</li>
<li>AnimatorSet.with(Animator anim)   ：将现有动画和传入的动画同时执行</li>
<li>AnimatorSet.after(Animator anim)   ：将现有动画插入到传入的动画之后执行</li>
<li>AnimatorSet.before(Animator anim) ：  将现有动画插入到传入的动画之前执行</li>
</ul>
<h3 id="PropertyValuesHolder"><a href="#PropertyValuesHolder" class="headerlink" title="PropertyValuesHolder"></a>PropertyValuesHolder</h3><p>PropertyValuesHolder 类的含义就是 ，它其 中保存了动画过程中所需要操作的属性和对应的值。我们通过 ofFloat(Object target, String property Name, float. .. values）构造的动画 ，ofFloat()函数的内 部实现其实就是将传入的参数封装成 PropertyValuesHolder 实例来保存动画状态 的 。在封装成Prope向NaluesHolder实例以后，后期的各种操作也是以 PropertyValuesHolder 为主 的 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframeO</span> <span class="operator">=</span> Keyframe . ofFloat(Of , <span class="number">1</span>);</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframel</span> <span class="operator">=</span> Keyframe.ofFloat(O.lf , <span class="number">1.</span>lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframe9</span> <span class="operator">=</span> Keyframe .ofFloat(<span class="number">0</span> . <span class="number">9f</span> , l . lf) ;</span><br><span class="line"><span class="type">Keyframe</span> <span class="variable">scaleXframelO</span> <span class="operator">=</span> Keyframe . ofFloat(l , <span class="number">1</span>) ;</span><br><span class="line"><span class="type">PropertyValuesHolder</span> <span class="variable">frameHolder2</span> <span class="operator">=</span> PropertyValuesHolder . ofKeyframe (” ScaleX”,</span><br><span class="line">scaleXframeO , scaleXframel, scaleXframe9 , scaleXframelO) ;</span><br><span class="line"> <span class="type">Animator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofPropertyValuesHolder(mimage,frameHolderl,frameHolder2,frameHolder3);</span><br><span class="line">        animator.setDuration(lOOO);</span><br><span class="line">        animator.start();</span><br></pre></td></tr></table></figure>

<p>ObjectAnimator 中唯一一个能实现多动画同时播放的方法。</p>
<h3 id="ViewPropertyAnimator"><a href="#ViewPropertyAnimator" class="headerlink" title="ViewPropertyAnimator"></a>ViewPropertyAnimator</h3><p>为 View 的动画操作提供一种更加便捷的用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tvText.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> animator = tvText.animate()</span><br><span class="line">    animator.duration=<span class="number">1000</span></span><br><span class="line">    animator.translationX(<span class="number">100f</span>)<span class="comment">//点击一次会向右偏移，再点击没效果</span></span><br><span class="line">    animator.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>折叠屏适配</title>
    <url>/2024/03/26/%E6%8A%98%E5%8F%A0%E5%B1%8F%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h2 id="折叠屏适配"><a href="#折叠屏适配" class="headerlink" title="折叠屏适配"></a>折叠屏适配</h2><p>​		多形态屏幕切换适配的本质是： <strong>当应⽤运⾏时，屏幕的尺⼨、密度或⽐例发⽣了变化，应⽤能够继续在变化后的屏幕上正常显示和正常运⾏。</strong><a href="https://www.itgsa.com/documents/5242001394058240#TOC4">（摘自移动智能终端生态联盟）</a></p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>相关的单位</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>px</strong></th>
<th><strong>像素点  1080*1920的屏幕，就是宽1080个像素点和高1920个像素点。像素的大小是没有固定长度的，不同设备上一个单位像素色块的大小是不一样的。比如相同尺寸的屏幕所具有的像素点数量可能不同。</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>dp</strong></td>
<td><strong>布局的单位 ，最终会转化为像素点的数量。</strong></td>
</tr>
<tr>
<td align="center"><strong>sp</strong></td>
<td><strong>布局的单位用于控制字体的大小，可以随着系统调整的字体大小改变。</strong></td>
</tr>
<tr>
<td align="center"><strong>dpi</strong></td>
<td><strong>屏幕像素密度 每英寸多少个像素点 图片选取通过dpi来判断</strong></td>
</tr>
</tbody></table>
<h3 id="适配过程杂记"><a href="#适配过程杂记" class="headerlink" title="适配过程杂记"></a>适配过程杂记</h3><p>1.Application中添加属性android:resizeableActivity&#x3D;”true”，让app支持全屏展示。</p>
<p>2.activity添加android:configChanges&#x3D;”screenSize|smallestScreenSize|screenLayout|orientation|density”</p>
<p>解释：</p>
<ul>
<li><code>screenSize</code>: 屏幕尺寸更改，如旋转设备或切换窗口模式。如果指定此选项，则应用程序将继续运行而不会随之销毁和重新创建。</li>
<li><code>smallestScreenSize</code>: 屏幕尺寸的最小值更改，也会导致屏幕重新布局。如果指定此选项，则应用程序将继续运行而不会随之销毁和重新创建。</li>
<li><code>screenLayout</code>: 屏幕布局更改，比如从横向变为纵向。如果指定此选项，则应用程序将继续运行而不会随之销毁和重新创建。</li>
<li><code>orientation</code>: 设备方向更改，也是指从横向变为纵向或反之。如果指定此选项，则应用程序将继续运行而不会随之销毁和重新创建。</li>
<li><code>density</code>: 屏幕密度更改，如从低分辨率模拟器到高分辨率设备。如果指定此选项，则应用程序将继续运行而不会随之销毁和重新创建。</li>
</ul>
<ol start="3">
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>网络面试题</title>
    <url>/2024/03/08/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="三次握手是什么？"><a href="#三次握手是什么？" class="headerlink" title="三次握手是什么？"></a><strong>三次握手是什么？</strong></h4><p>​		三次握手是建立TCP连接的过程，具体步骤如下：</p>
<ol>
<li>客户端向服务器发送SYN（同步）请求，请求建立连接。</li>
<li>服务器接收到SYN请求后，回应一个ACK（确认）和自己的SYN，表示接受连接。</li>
<li>客户端接收到服务器的ACK和SYN后，回应一个ACK，表示连接建立成功。</li>
</ol>
<h4 id="三次握手变成两次了？有什么优点缺点？"><a href="#三次握手变成两次了？有什么优点缺点？" class="headerlink" title="三次握手变成两次了？有什么优点缺点？"></a><strong>三次握手变成两次了？有什么优点缺点？</strong></h4><p>​		三次握手变成两次握手是指在建立TCP连接时，客户端不再发送第三次握手的ACK确认，而是在服务器回应第二次握手的SYN时直接发送数据。</p>
<p>优点：</p>
<ul>
<li>减少连接建立的时延，提高连接速度。</li>
<li>减少网络流量，节省带宽。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不够安全，容易受到一些攻击，如SYN洪泛攻击。</li>
<li>不适用于所有场景，只适用于可靠的连接。</li>
</ul>
<h4 id="HTTPS为什么是安全的？"><a href="#HTTPS为什么是安全的？" class="headerlink" title="HTTPS为什么是安全的？"></a><strong>HTTPS为什么是安全的？</strong></h4><p>​		HTTPS（HTTP Secure）是安全的主要因素包括以下几点：</p>
<ol>
<li><strong>加密传输</strong>：HTTPS使用TLS（Transport Layer Security）协议对数据进行加密，使得数据在传输过程中不容易被窃取。</li>
<li><strong>身份验证</strong>：HTTPS使用数字证书来验证服务器的身份，确保用户连接到合法的服务器。</li>
<li><strong>数据完整性</strong>：HTTPS使用哈希函数来检测数据是否被篡改，以保证数据的完整性。</li>
<li><strong>保护隐私</strong>：HTTPS可以隐藏用户的浏览行为和敏感信息，增加隐私保护。</li>
</ol>
<h4 id="除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？"><a href="#除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？" class="headerlink" title="除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？"></a><strong>除了私钥公钥加解密，HTTP也行，那为什么还要HTTPS？</strong></h4><p>​		HTTP使用明文传输数据，容易受到中间人攻击，数据被窃取或篡改的风险很高。HTTPS通过加密传输数据，可以有效防止这些风险，提供更高的安全性和隐私保护。</p>
<h4 id="心跳包有了解吗？"><a href="#心跳包有了解吗？" class="headerlink" title="心跳包有了解吗？"></a><strong>心跳包有了解吗？</strong></h4><p>​		心跳包是一种用于保持TCP连接活跃的机制。它是定期发送一个小数据包到远程服务器，以防止连接由于不活动而被断开。心跳包通常用于保持长时间持续的连接，如WebSocket连接，以确保连接不会在空闲时被关闭。</p>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p><a href="https://juejin.cn/post/6977144949833728008">https://juejin.cn/post/6977144949833728008</a></p>
<h4 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h4><ol>
<li><p>建立连接</p>
</li>
<li><p><strong>客户端发送HTTPS请求</strong>：客户端向服务器发送一个HTTPS请求，请求建立一个安全连接。</p>
</li>
<li><p><strong>服务器发送证书</strong>：服务器响应该请求并发送其SSL证书，该证书包含服务器的公钥以及证书颁发机构（CA）的签名。</p>
</li>
<li><p>非对称加密阶段</p>
</li>
<li><p><strong>验证证书</strong>：客户端验证服务器的证书是否由可信的CA签名，以及证书中的公钥是否属于服务器。</p>
</li>
<li><p><strong>生成会话密钥</strong>：客户端生成一个随机的会话密钥，用于后续的对称加密通信。</p>
</li>
<li><p><strong>加密会话密钥</strong>：客户端使用服务器的公钥加密会话密钥，然后将加密后的会话密钥发送给服务器。</p>
</li>
<li><p><strong>解密会话密钥</strong>：服务器收到加密的会话密钥后，使用自己的私钥解密它，获取会话密钥。</p>
</li>
<li><p>对称加密阶段</p>
</li>
<li><p><strong>加密通信</strong>：双方现在都有了相同的会话密钥。客户端和服务器使用这个会话密钥对其通信内容进行对称加密。</p>
</li>
<li><p><strong>传输加密数据</strong>：加密后的数据通过互联网安全传输。</p>
</li>
<li><p><strong>解密通信</strong>：接收方使用相同的会话密钥对数据进行解密，还原成原始数据。</p>
</li>
<li><p>保持会话</p>
</li>
<li><p><strong>会话维持</strong>：在同一个会话中，客户端和服务器将继续使用这个会话密钥进行对称加密和解密通信。</p>
</li>
<li><p><strong>会话结束</strong>：一旦会话结束，会话密钥将被丢弃，以后的通信将需要重新建立连接并生成新的会话密钥。</p>
</li>
</ol>
<p>加解密技术</p>
<ul>
<li><strong>非对称加密</strong>：在建立会话密钥阶段使用，用于安全地交换会话密钥。它使用一对公钥和私钥，其中公钥可以公开，私钥保持私有。</li>
<li><strong>对称加密</strong>：在加密实际通信数据阶段使用，因为它相比非对称加密有更高的效率。双方使用相同的密钥进行加密和解密。</li>
</ul>
<h4 id="TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制"></a>TCP 重传、滑动窗口、流量控制、拥塞控制</h4><p><strong>TCP重传</strong></p>
<ul>
<li><strong>目的</strong>：确保数据可靠传输。当TCP检测到丢包时（通过超时或接收到重复的ACK），它会重新发送丢失的数据包。</li>
<li><strong>实现</strong>：每个TCP段都有一个序列号和确认应答（ACK）。发送方在发送数据后启动一个定时器，如果在定时器超时前没有收到对应的ACK，那么这个数据段将被重传。</li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li><strong>目的</strong>：实现流量控制，同时允许发送方在停顿等待ACK之前发送多个数据包，从而提高通信效率。</li>
<li><strong>实现</strong>：滑动窗口是发送方和接收方各自维护的一个窗口。窗口大小是动态调整的，它限制了在需要接收ACK之前可以发送的最大数据量。当ACK被接收，窗口就会”滑动”，允许发送更多的数据。</li>
</ul>
<p><strong>流量控制</strong></p>
<ul>
<li><strong>目的</strong>：防止发送方过快地发送数据，使得接收方来不及处理，避免数据溢出。</li>
<li><strong>实现</strong>：通过调整发送方的窗口大小来实现。接收方在ACK中指示自己的接收窗口大小，告诉发送方自己还能接收多少数据，从而控制发送方的数据发送速率。</li>
</ul>
<p><strong>拥塞控制</strong></p>
<ul>
<li><strong>目的</strong>：防止过多的数据注入到网络中，造成网络拥塞。</li>
<li>实现：TCP使用几种算法（如慢启动、拥塞避免、快速重传和快速恢复）来动态调整发送窗口的大小，以响应网络的拥塞情况。<ul>
<li><strong>慢启动</strong>：连接开始时小心地增加网络流量。</li>
<li><strong>拥塞避免</strong>：避免网络达到其承载能力。</li>
<li><strong>快速重传</strong>：在接收到三个重复的ACK时立即重传丢失的包，不等待超时。</li>
<li><strong>快速恢复</strong>：在检测到丢包时，减少但不是减到初始状态的窗口大小，快速恢复到拥塞避免状态。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>​		动态代理模式是通过动态生成代理类的代理模式，它其实就是将目标类的类加载器和相应的接口传进去代理器(InvocationHandler)，通过代理器生成了一份新的”备份“——代理类，这个动态生成的代理类里实现了接口中的所有方法，然后在 InvocationHandler.invoke() 中通过反射机制，调用目标类对象的方法。</p>
<p>​		理论上动态代理是为了通过自动生成代理对象在运行时控制要代理的对象的访问，JDK动态代理主要涉及两个类：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code>，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// proxy: 代理对象，即动态生成的代理类的实例</span></span><br><span class="line">    	<span class="comment">// method: 正在被调用的方法</span></span><br><span class="line">    	<span class="comment">// args: 调用方法时传递的参数</span></span><br><span class="line"></span><br><span class="line">    	before();  <span class="comment">// 调用目标方法前的处理，例如日志记录、权限检查等</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 调用目标对象（target）的方法（method），并传递参数（args）</span></span><br><span class="line">    	<span class="comment">// target 是实际对象，代理对象是通过它来间接访问目标对象的方法</span></span><br><span class="line">    	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">    	after();  <span class="comment">// 调用目标方法后的处理，例如日志记录、资源释放等</span></span><br><span class="line"></span><br><span class="line">    	<span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名</span></span><br><span class="line">        <span class="comment">// System.getProperties().setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">        <span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        <span class="comment">// ProxyUtils.generateClassFile(userServiceImpl.getClass(), &quot;UserServiceProxy&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1. 创建被代理的对象，UserService接口的实现类</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> userServiceImpl.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService，</span></span><br><span class="line">        Class[] interfaces = userServiceImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用</span></span><br><span class="line">        <span class="comment">//     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userServiceImpl);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		   5.根据上面提供的信息，创建代理对象 在这个过程中，</span></span><br><span class="line"><span class="comment">               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码</span></span><br><span class="line"><span class="comment">               b.然后根据相应的字节码转换成对应的class，</span></span><br><span class="line"><span class="comment">               c.然后调用newInstance()创建代理实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);</span><br><span class="line">        <span class="comment">// 调用代理的方法</span></span><br><span class="line">        proxy.select();</span><br><span class="line">        proxy.update();</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code> 是两个核心类，它们的作用如下：</p>
<ol>
<li><code>java.lang.reflect.Proxy</code></li>
</ol>
<p><code>Proxy</code> 类是动态代理类的超类，它提供了用于创建动态代理类和实例的静态方法。主要方法包括：</p>
<ul>
<li><code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>: 这是创建动态代理实例最常用的方法。它需要三个参数：类加载器（用于加载代理类）、接口数组（代理类需要实现的接口列表）、调用处理器（用于处理方法调用的对象）。这个方法返回一个实现了指定接口的代理实例。</li>
</ul>
<ol start="2">
<li><code>java.lang.reflect.InvocationHandler</code></li>
</ol>
<p><code>InvocationHandler</code> 是一个接口，它定义了一个方法 <code>invoke(Object proxy, Method method, Object[] args)</code>。在使用动态代理时，你需要实现这个接口，并提供 <code>invoke</code> 方法的实现，这个方法会在代理实例上的方法被调用时执行。</p>
<ul>
<li><code>invoke(Object proxy, Method method, Object[] args)</code>: 这个方法有三个参数：<code>proxy</code> 是动态代理实例本身，<code>method</code> 是被调用的方法，<code>args</code> 是调用方法时传递的参数。在这个方法的实现中，你可以定义在方法调用前后要执行的逻辑，比如日志记录、权限检查等。你还可以使用 <code>method.invoke(target, args)</code> 来调用目标对象的实际方法。</li>
</ul>
<p>总的来说，<code>Proxy</code> 类用于创建动态代理实例，而 <code>InvocationHandler</code> 接口用于定义代理实例上方法调用的处理逻辑。通过这两个类的配合使用，可以在运行时动态地创建代理对象并处理其方法调用，而无需手动编写代理类的代码。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>​		观察者模式用于实现对象之间的一对多依赖关系，其中一个对象（主题或被观察者）状态的改变会通知并影响多个其他对象（观察者)。</p>
<p>​		在Android开发中，观察者模式也经常被广泛应用，尤其在处理用户界面和数据的更新方面。以下是Android中常见的观察者模式的应用场景：</p>
<ol>
<li><strong>LiveData和ViewModel：</strong> Android架构组件中的LiveData和ViewModel是观察者模式的经典应用。LiveData允许数据对象通知观察者（通常是UI界面）数据发生了变化，而ViewModel用于管理UI相关的数据。这使得数据的变化可以自动通知UI进行更新，而无需手动操作。</li>
<li><strong>BroadcastReceiver：</strong> BroadcastReceiver用于在Android应用程序内部或与其他应用程序之间进行通信。它可以用于观察和响应系统事件，例如网络连接更改、短信到达等。当事件发生时，BroadcastReceiver会接收通知并执行相应的操作。</li>
<li><strong>ContentObserver：</strong> ContentObserver是Android的API，用于观察内容提供者（如联系人、日历、短信等）中的数据变化。应用程序可以注册ContentObserver来监听数据变化，以便在数据发生变化时采取适当的行动。</li>
<li><strong>OnClickListener和其他监听器：</strong> Android中的许多UI元素，如按钮，文本框，滑动控件等，都可以通过添加监听器来观察用户的交互动作。当用户执行相应的操作时，监听器会通知应用程序执行相应的逻辑。</li>
</ol>
<p>实际代码演示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observable</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> observers = mutableListOf&lt;Observer&lt;T&gt;&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.add(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        observers.remove(observer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">notifyObservers</span><span class="params">(<span class="keyword">data</span>: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        observers.forEach &#123; it.onUpdate(<span class="keyword">data</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> userObservable = Observable&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userObserver = <span class="keyword">object</span> : Observer&lt;User&gt; &#123;	</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(<span class="keyword">data</span>: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;User data updated: <span class="subst">$&#123;data.name&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userObservable.addObserver(userObserver)</span><br><span class="line">    userObservable.notifyObservers(User(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>))  <span class="comment">// 输出: User data updated: Alice</span></span><br><span class="line">    userObservable.removeObserver(userObserver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="观察者模式和回调的异同"><a href="#观察者模式和回调的异同" class="headerlink" title="观察者模式和回调的异同"></a>观察者模式和回调的异同</h4><p><strong>观察者模式</strong>：</p>
<ul>
<li>是一种设计模式，用于在对象之间建立一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>
</ul>
<p><strong>回调</strong>：</p>
<ul>
<li>是一种编程技术，允许一个函数（回调函数）作为参数传递给另一个函数，在适当的时候由该函数执行。</li>
<li>回调强调的是单个事件的响应，即一个特定事件发生时执行特定的函数。</li>
</ul>
<p><strong>总结</strong>：</p>
<ol>
<li>观察者模式通常用于实现一对多的通信，而回调通常用于一对一的通信。</li>
<li>观察者模式的观察者通常是事先注册到被观察对象中的，而回调函数是在调用时传递给另一个函数的。</li>
</ol>
<h4 id="观察者模式-多个订阅方，怎么通知到一半怎么中止后面的观察者？"><a href="#观察者模式-多个订阅方，怎么通知到一半怎么中止后面的观察者？" class="headerlink" title="观察者模式  多个订阅方，怎么通知到一半怎么中止后面的观察者？"></a>观察者模式  多个订阅方，怎么通知到一半怎么中止后面的观察者？</h4><p>​		在通知过程中加入一些逻辑来判断是否继续通知后续的观察者。通知是一个遍历队列的过程，可以添加终止逻辑。</p>
<h4 id="讲一讲责任链模式"><a href="#讲一讲责任链模式" class="headerlink" title="讲一讲责任链模式"></a>讲一讲责任链模式</h4><p>​		责任链是属于行为型模式，在这种模式中，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p>​		责任链模式是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。</p>
<p>代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折扣处理器接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DiscountHandler</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nextHandler: DiscountHandler? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VIP 会员折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.isVip) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.9</span>, <span class="string">&quot;VIP Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 购买金额折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AmountDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.amount &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.95</span>, <span class="string">&quot;Amount Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 购买数量折扣处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuantityDiscountHandler</span> : <span class="type">DiscountHandler</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleDiscount</span><span class="params">(request: <span class="type">DiscountRequest</span>)</span></span>: DiscountResponse &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (request.quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            DiscountResponse(request.amount * <span class="number">0.97</span>, <span class="string">&quot;Quantity Discount Applied&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextHandler?.handleDiscount(request) ?: DiscountResponse(request.amount, <span class="string">&quot;No Discount Applied&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折扣请求</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">DiscountRequest</span>(<span class="keyword">val</span> isVip: <span class="built_in">Boolean</span>, <span class="keyword">val</span> amount: <span class="built_in">Double</span>, <span class="keyword">val</span> quantity: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 折扣响应</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">DiscountResponse</span>(<span class="keyword">val</span> finalAmount: <span class="built_in">Double</span>, <span class="keyword">val</span> message: String)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> vipHandler = VipDiscountHandler()</span><br><span class="line">    <span class="keyword">val</span> amountHandler = AmountDiscountHandler()</span><br><span class="line">    <span class="keyword">val</span> quantityHandler = QuantityDiscountHandler()</span><br><span class="line"></span><br><span class="line">    vipHandler.nextHandler = amountHandler</span><br><span class="line">    amountHandler.nextHandler = quantityHandler</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> request = DiscountRequest(isVip = <span class="literal">true</span>, amount = <span class="number">600.0</span>, quantity = <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">val</span> response = vipHandler.handleDiscount(request)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Final Amount: <span class="subst">$&#123;response.finalAmount&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Message: <span class="subst">$&#123;response.message&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		定义了一个抽象的 <code>DiscountHandler</code> 类，它有一个 <code>handleDiscount</code> 方法用于处理折扣请求，以及一个 <code>nextHandler</code> 属性用于指向链中的下一个处理器。<code>VipDiscountHandler</code>、<code>AmountDiscountHandler</code> 和 <code>QuantityDiscountHandler</code> 是具体的折扣处理器，它们分别处理 VIP 会员折扣、购买金额折扣和购买数量折扣。</p>
<h4 id="责任链模式和策略模式有什么区别"><a href="#责任链模式和策略模式有什么区别" class="headerlink" title="责任链模式和策略模式有什么区别"></a>责任链模式和策略模式有什么区别</h4><p>​		<strong>责任链模式</strong>关注的是请求的发送和处理。它将请求的发送者和接收者解耦，并允许多个对象处理同一个请求，或者说，一个请求可以被一个处理序列处理。处理者通常包含对其后继者的引用，如果一个对象不能处理该请求，它会将相同的请求传递给下一个接收者。</p>
<p>​		<strong>策略模式</strong>使得算法可以独立于使用它的客户而变化。也就是说，它实现了某个操作的策略的切换。在策略模式中，客户知道它正在使用的策略对象。</p>
<h4 id="单例模式的几种创建方式"><a href="#单例模式的几种创建方式" class="headerlink" title="单例模式的几种创建方式"></a>单例模式的几种创建方式</h4><p>懒汉式（线程不安全）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonLazy? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonLazy &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = SingletonLazy()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>懒汉式（线程安全，同步方法）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazySynchronized</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonLazySynchronized? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonLazySynchronized &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = SingletonLazySynchronized()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>双重检查锁定（Double-Check Locking）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonDoubleCheck</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDoubleCheck? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: SingletonDoubleCheck &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                        instance = SingletonDoubleCheck()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>饿汉式（静态初始化）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonEager = SingletonEager()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>静态内部类（Static Nested Class）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonDirectLazy</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonDirectLazy <span class="keyword">by</span> lazy &#123; SingletonDirectLazy() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>枚举（Enum）</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.object</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">xxx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		反编译后的Java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">var0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="装饰者模式和代理模式的区别"><a href="#装饰者模式和代理模式的区别" class="headerlink" title="装饰者模式和代理模式的区别"></a>装饰者模式和代理模式的区别</h4><p>装饰者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> basicCar = BasicCar()</span><br><span class="line">    <span class="keyword">val</span> sportsCar = SportsCarDecorator(basicCar)</span><br><span class="line">    <span class="keyword">val</span> luxuryCar = LuxuryCarDecorator(sportsCar)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Basic Car:&quot;</span>)</span><br><span class="line">    basicCar.assemble()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;\nSports Car:&quot;</span>)</span><br><span class="line">    sportsCar.assemble()</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;\nLuxury Sports Car:&quot;</span>)</span><br><span class="line">    luxuryCar.assemble()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component Interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">assemble</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicCar</span> : <span class="type">Car</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">assemble</span><span class="params">()</span></span> &#123;</span><br><span class="line">        print(<span class="string">&quot;Basic Car&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorator</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">CarDecorator</span>(<span class="keyword">private</span> <span class="keyword">val</span> car: Car) : Car &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">assemble</span><span class="params">()</span></span> &#123;</span><br><span class="line">        car.assemble()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsCarDecorator</span>(car: Car) : CarDecorator(car) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">assemble</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.assemble()</span><br><span class="line">        print(<span class="string">&quot; + Sports Features&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another Concrete Decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LuxuryCarDecorator</span>(car: Car) : CarDecorator(car) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">assemble</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.assemble()</span><br><span class="line">        print(<span class="string">&quot; + Luxury Features&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代理</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> realImage = RealImage(<span class="string">&quot;photo.jpg&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> proxyImage = ProxyImage(realImage)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;Calling display on the proxy image:&quot;</span>)</span><br><span class="line">    proxyImage.display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject Interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Real Subject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span>(<span class="keyword">private</span> <span class="keyword">val</span> fileName: String) : Image &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        loadFromDisk(fileName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Displaying <span class="variable">$fileName</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadFromDisk</span><span class="params">(fileName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Loading <span class="variable">$fileName</span> from disk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyImage</span>(<span class="keyword">private</span> <span class="keyword">val</span> realImage: RealImage) : Image &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Proxy Image: Performing some checks before displaying the real image&quot;</span>)</span><br><span class="line">        realImage.display()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>装饰者模式：</strong></p>
<ul>
<li><strong>目的</strong>：主要用于动态地给一个对象添加一些额外的职责或功能，而不改变其结构。</li>
<li><strong>实现</strong>：装饰者和被装饰的对象通常实现相同的接口或继承相同的父类，装饰者持有被装饰对象的引用，并在其基础上添加新的功能。</li>
<li><strong>透明性</strong>：使用装饰者模式时，客户端不需要知道对象是否被装饰，因为装饰者和被装饰对象有相同的接口。</li>
<li><strong>可扩展性</strong>：可以通过添加新的装饰者类来轻松扩展功能，而不需要修改现有的代码。</li>
</ul>
<p><strong>代理模式：</strong></p>
<ul>
<li><strong>目的</strong>：主要用于控制对一个对象的访问，可以用于延迟初始化、访问控制、日志记录、监控等。</li>
<li><strong>实现</strong>：代理对象和真实对象通常实现相同的接口，但代理对象包含对真实对象的引用，并且在访问真实对象之前或之后执行一些额外的操作。</li>
<li><strong>透明性</strong>：使用代理模式时，客户端通常知道对象被代理了，因为代理对象可能提供与真实对象不同的行为。</li>
<li><strong>控制性</strong>：代理模式主要用于控制对真实对象的访问，可以在不改变真实对象代码的情况下增加额外的功能。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>装饰者模式主要用于增加对象的功能，代理模式主要用于控制对对象的访问。</li>
<li>装饰者模式强调动态添加功能，代理模式强调在访问对象前后添加控制逻辑。</li>
<li>装饰者模式中，装饰者和被装饰对象有相同的接口，而代理模式中，代理对象和真实对象有相同的接口。</li>
</ul>
]]></content>
  </entry>
</search>
